[
    {
        "question_id": "1873_A",
        "code_list": [
            "def main():\n    t = int(input())\n    for _ in range(t):\n        s = input().strip()\n        # Check if the string is already 'abc'\n        if s == 'abc':\n            print('YES')\n        else:\n            # Count the number of swaps needed to make 'abc'\n            swaps = 0\n            for i in range(3):\n                if s[i] != 'a':\n                    swaps += 1\n                if s[i] != 'b' and i > 0:\n                    swaps += 1\n                if s[i] != 'c' and i > 1:\n                    swaps += 1\n            # If the total number of swaps is 2 or less, it's possible\n            if swaps <= 2:\n                print('YES')\n            else:\n                print('NO')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1873_B",
        "code_list": [
            "def max_product_after_increment(t):\n    def calculate_max_product(a):\n        n = len(a)\n        original_product = 1\n        zero_count = 0\n        min_digit = float('inf')\n        \n        for digit in a:\n            if digit == 0:\n                zero_count += 1\n            elif digit != 9:\n                min_digit = min(min_digit, digit)\n            original_product *= digit\n        \n        # If there are no zeros and the minimum digit is 9, incrementing any digit won't help\n        if zero_count == 0 and min_digit == 9:\n            return original_product\n        \n        # If there are zeros, we can increase the product by changing a zero to 1\n        if zero_count > 0:\n            return original_product * (zero_count + 1)\n        \n        # If there are no zeros, we should check if increasing the smallest non-nine digit helps\n        if min_digit != 9:\n            return original_product * (min_digit + 1)\n        \n        # If none of the above conditions are met, we just return the original product\n        return original_product\n    \n    results = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        results.append(calculate_max_product(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    max_product_after_increment(int(input().strip()))"
        ]
    },
    {
        "question_id": "1873_D",
        "code_list": [
            "def min_operations_to_remove_black_cells(t):\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        s = input()\n        operations = 0\n        i = 0\n        while i < n:\n            if s[i] == 'B':\n                start = i\n                while i < n and s[i] == 'B':\n                    i += 1\n                end = i - 1\n                segments = (end - start + k - 1) // k\n                operations += segments\n                i = end + 1\n            else:\n                i += 1\n        results.append(operations)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    t = int(input())\n    min_operations_to_remove_black_cells(t)"
        ]
    },
    {
        "question_id": "1883_B",
        "code_list": [
            "def can_form_palindrome(s, k):\n    char_count = [0] * 26\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n    \n    odd_counts = sum(count % 2 for count in char_count)\n    \n    # If more than 1 character has an odd count, we cannot form a palindrome\n    if odd_counts > 1:\n        return \"NO\"\n    \n    # Check if removing k characters can make the string form a palindrome\n    remaining_length = len(s) - k\n    if remaining_length % 2 == 0 and odd_counts == 0:\n        return \"YES\"\n    elif remaining_length % 2 == 1 and odd_counts <= 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n, k = map(int, data[index:index+2])\n        index += 2\n        s = data[index]\n        index += 1\n        \n        result = can_form_palindrome(s, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1883_C",
        "code_list": [
            "def min_operations_to_divisible_by_k(t):\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        product_mod_k = 1\n        operations = 0\n        \n        # Calculate initial product modulo k\n        for num in arr:\n            product_mod_k = (product_mod_k * (num % k)) % k\n        \n        # If product is already divisible by k, no operations needed\n        if product_mod_k == 0:\n            print(0)\n            continue\n        \n        # Count how many numbers are already contributing to making the product divisible by k\n        count = 0\n        for num in arr:\n            if num % k == 0:\n                count += 1\n        \n        # If there are enough numbers that are already divisible by k, no additional operations needed\n        if count >= k - 1:\n            print(0)\n            continue\n        \n        # Calculate the required operations\n        for i in range(n):\n            if arr[i] % k != 0:\n                arr[i] += 1\n                product_mod_k = (product_mod_k * (arr[i] % k)) % k\n                operations += 1\n                if product_mod_k == 0:\n                    break\n        \n        print(operations)\n\nif __name__ == \"__main__\":\n    t = int(input())\n    min_operations_to_divisible_by_k(t)"
        ]
    },
    {
        "question_id": "1899_A",
        "code_list": [
            "def determine_winner(n):\n    # Calculate the remainder when n is divided by 6\n    remainder = n % 6\n    \n    # Determine the winner based on the remainder\n    if remainder == 0 or remainder == 2 or remainder == 4:\n        return \"First\"\n    else:\n        return \"Second\"\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        print(determine_winner(n))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_B",
        "code_list": [
            "from typing import List\n\ndef max_weight_difference(n: int, weights: List[int]) -> int:\n    # Calculate prefix sums for quick weight calculation\n    prefix_sums = [0]\n    for weight in weights:\n        prefix_sums.append(prefix_sums[-1] + weight)\n    \n    max_diff = 0\n    \n    # Iterate over all possible values of k\n    for k in range(1, n + 1):\n        if n % k != 0:\n            continue\n        \n        min_weight = float('inf')\n        max_weight = float('-inf')\n        \n        # Calculate the weight of each truck\n        for i in range(k, n + 1, k):\n            truck_weight = prefix_sums[i] - prefix_sums[i - k]\n            min_weight = min(min_weight, truck_weight)\n            max_weight = max(max_weight, truck_weight)\n        \n        # Update the maximum difference\n        max_diff = max(max_diff, max_weight - min_weight)\n    \n    return max_diff\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    num_cases = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(num_cases):\n        n = int(data[index])\n        index += 1\n        weights = list(map(int, data[index:index + n]))\n        index += n\n        result = max_weight_difference(n, weights)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_C",
        "code_list": [
            "def max_alternating_subarray_sum(n, arr):\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Iterate through the array\n    for i in range(n):\n        if (i % 2 == 0 and arr[i] % 2 != 0) or (i % 2 != 0 and arr[i] % 2 == 0):\n            current_sum += arr[i]\n            max_sum = max(max_sum, current_sum)\n        else:\n            current_sum = arr[i] if (i % 2 == 0 and arr[i] % 2 != 0) or (i % 2 != 0 and arr[i] % 2 == 0) else 0\n    \n    return max_sum\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = max_alternating_subarray_sum(n, arr)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_D",
        "code_list": [
            "from collections import Counter\n\ndef count_equal_combinations(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Initialize the result counter\n    result = 0\n    \n    # Iterate through the unique elements in the array\n    for value in freq:\n        # If the frequency is more than 1, we can form pairs with itself\n        if freq[value] > 1:\n            result += freq[value] * (freq[value] - 1) // 2\n    \n    return result\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        print(count_equal_combinations(n, a))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "2727",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        count = 0\n        for detail in details:\n            age = int(detail[11:13])\n            if age > 60:\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "2728",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        score = 0\n        while nums:\n            max_val = 0\n            next_row = []\n            for row in nums:\n                if row:\n                    max_val = max(max_val, row.pop())\n                    if row:\n                        next_row.append(row)\n            score += max_val\n            nums = next_row\n        return score"
        ]
    },
    {
        "question_id": "2730",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        prefix_or, suffix_or = 0, 0\n        for num in nums:\n            suffix_or |= num\n        \n        max_or = 0\n        current_or = 0\n        for i, num in enumerate(nums):\n            # Calculate the or result if we apply the operation on nums[i]\n            current_or = prefix_or | (num << k) | suffix_or ^ num\n            max_or = max(max_or, current_or)\n            # Update prefix or\n            prefix_or |= num\n        \n        return max_or"
        ]
    },
    {
        "question_id": "2754",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        # Remove zeros as they do not contribute to the product\n        nums = [num for num in nums if num != 0]\n        \n        # If there are no positive numbers and at most one negative number, return 0\n        if len(nums) == 0:\n            return 0\n        \n        # Separate positive and negative numbers\n        pos_nums = [num for num in nums if num > 0]\n        neg_nums = [num for num in nums if num < 0]\n        \n        # Sort negative numbers to potentially remove the smallest (most negative) number\n        neg_nums.sort()\n        \n        # If there's an odd number of negative numbers, remove the smallest one\n        if len(neg_nums) % 2 == 1:\n            neg_nums.pop(0)\n        \n        # Calculate the product of all positive and remaining negative numbers\n        strength = 1\n        for num in pos_nums + neg_nums:\n            strength *= num\n        \n        return strength"
        ]
    },
    {
        "question_id": "2755",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        dp = [float('inf')] * (len(s) + 1)\n        dp[-1] = 0\n        \n        for i in range(len(s) - 1, -1, -1):\n            dp[i] = dp[i + 1] + 1\n            for word in dictionary:\n                if s.startswith(word, i):\n                    dp[i] = min(dp[i], dp[i + len(word)])\n        \n        return dp[0]"
        ]
    },
    {
        "question_id": "2756",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        # Sort the prices to find the two cheapest chocolates\n        sorted_prices = sorted(prices)\n        # Check if the sum of the two cheapest chocolates is within budget\n        if sorted_prices[0] + sorted_prices[1] <= money:\n            # Calculate the remaining money after purchase\n            return money - (sorted_prices[0] + sorted_prices[1])\n        else:\n            # Return the original money if it's not possible to buy two chocolates\n            return money"
        ]
    },
    {
        "question_id": "2757",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def digit_sum(n, tight, remaining):\n            if len(n) == 0:\n                return 1 if remaining == 0 else 0\n            if tight == 0 and remaining < 0:\n                return 0\n            res = 0\n            upper_bound = int(n[0]) if tight else 9\n            for d in range(upper_bound + 1):\n                new_tight = tight and d == upper_bound\n                res += digit_sum(n[1:], new_tight, remaining - d)\n            return res % MOD\n        \n        # Convert num1 and num2 to lists of digits\n        num1_digits = tuple(map(int, num1))\n        num2_digits = tuple(map(int, num2))\n        \n        # Calculate the count of numbers less than or equal to num2 with digit sums within the range\n        count_le_num2 = digit_sum(str(num2_digits), True, max_sum) - digit_sum(str(num2_digits), True, min_sum - 1)\n        \n        # Calculate the count of numbers less than or equal to num1 with digit sums within the range\n        count_le_num1 = digit_sum(str(num1_digits), True, max_sum) - digit_sum(str(num1_digits), True, min_sum - 1)\n        \n        # The result is the difference between these counts\n        return (count_le_num2 - count_le_num1) % MOD"
        ]
    },
    {
        "question_id": "2777",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        def count_distinct(arr):\n            return len(set(arr))\n        \n        n = len(nums)\n        result = []\n        for i in range(n):\n            prefix_distinct = count_distinct(nums[:i+1])\n            suffix_distinct = count_distinct(nums[i+1:])\n            result.append(prefix_distinct - suffix_distinct)\n        return result"
        ]
    },
    {
        "question_id": "2779",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        nums = [0] * n\n        answer = []\n        count = 0\n        \n        for index, color in queries:\n            if index > 0 and nums[index - 1] == color and nums[index - 1] != 0:\n                count -= 1\n            if index < n - 1 and nums[index + 1] == color and nums[index + 1] != 0:\n                count -= 1\n            \n            if nums[index] != 0:\n                if index > 0 and nums[index - 1] == nums[index]:\n                    count -= 1\n                if index < n - 1 and nums[index + 1] == nums[index]:\n                    count -= 1\n            \n            nums[index] = color\n            \n            if index > 0 and nums[index - 1] == color and nums[index - 1] != 0:\n                count += 1\n            if index < n - 1 and nums[index + 1] == color and nums[index + 1] != 0:\n                count += 1\n            \n            answer.append(count)\n        \n        return answer"
        ]
    },
    {
        "question_id": "2784",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        nums.sort()\n        prefix_sum = 0\n        total_power = 0\n        \n        for num in nums:\n            # Calculate the power of the current number as a single group\n            total_power = (total_power + (num ** 2) * (prefix_sum + num)) % MOD\n            # Update the prefix sum to include the current number\n            prefix_sum = (prefix_sum * 2 + num) % MOD\n        \n        return total_power"
        ]
    },
    {
        "question_id": "2785",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        idx1, idxn = nums.index(1), nums.index(n)\n        moves = 0\n        \n        # If 1 is to the right of n, we need to move 1 to the front and n to the end\n        if idx1 > idxn:\n            moves += idx1 + (n - 1 - idxn)\n        else:\n            # Otherwise, we just need to move n to the end\n            moves += idxn - idx1 - 1\n        \n        return moves"
        ]
    },
    {
        "question_id": "2786",
        "code_list": [
            "class Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        n = len(s)\n        max_len = 1\n        start = 0\n        last_occurrence = {}\n        \n        for end in range(n):\n            if s[end] in last_occurrence and s[end] == s[end - 1]:\n                start = max(start, last_occurrence[s[end]] + 1)\n            \n            last_occurrence[s[end]] = end\n            \n            max_len = max(max_len, end - start + 1)\n        \n        return max_len"
        ]
    },
    {
        "question_id": "2791",
        "code_list": [
            "class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        # Initialize the list to keep track of who has received the ball\n        received_ball = [False] * n\n        # Start with the first friend\n        current_friend = 0\n        # Number of steps to move in each turn\n        steps = 1\n        \n        while not received_ball[current_friend]:\n            received_ball[current_friend] = True\n            # Calculate the next friend to receive the ball\n            current_friend = (current_friend + steps * k) % n\n            # Increment the number of steps for the next turn\n            steps += 1\n        \n        # Collect all friends who did not receive the ball\n        losers = [i + 1 for i, received in enumerate(received_ball) if not received]\n        return losers"
        ]
    },
    {
        "question_id": "2792",
        "code_list": [
            "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        # The key observation is that the XOR operation is its own inverse.\n        # This means that if we start with any initial value (0 or 1),\n        # the derived array can always be generated from some original array.\n        # We just need to check if the XOR of the entire derived array is 0.\n        # If it is 0, then there exists a valid original array; otherwise, it doesn't.\n        return reduce(lambda x, y: x ^ y, derived) == 0"
        ]
    },
    {
        "question_id": "2800",
        "code_list": [
            "class Solution:\n    def minLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            if char == 'B' and stack and stack[-1] == 'A':\n                stack.pop()\n            elif char == 'D' and stack and stack[-1] == 'C':\n                stack.pop()\n            else:\n                stack.append(char)\n        return len(stack)"
        ]
    },
    {
        "question_id": "2802",
        "code_list": [
            "from typing import List\n\ndef can_partition(s: str, target: int) -> bool:\n    if s == \"0\":\n        return target == 0\n    \n    n = len(s)\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for i in range(1, n + 1):\n        num_str = s[:i]\n        num = int(num_str)\n        if num > target:\n            break\n        if dp[num]:\n            for j in range(i, n + 1):\n                next_num_str = s[i:j]\n                next_num = int(next_num_str)\n                if dp[num + next_num]:\n                    dp[num + next_num] = True\n                    if num + next_num == target:\n                        return True\n    return dp[target]\n\nclass Solution:\n    def punishmentNumber(self, n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            square = i * i\n            square_str = str(square)\n            if can_partition(square_str, i):\n                total += square\n        return total"
        ]
    },
    {
        "question_id": "2808",
        "code_list": [
            "from typing import List\nimport functools\n\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        @functools.lru_cache(None)\n        def dp(index, remaining):\n            if remaining <= 0:\n                return 0\n            if index == len(cost):\n                return float('inf')\n            # Option 1: Use the paid painter to paint the current wall\n            paid = cost[index] + dp(index + 1, remaining - time[index] - 1)\n            # Option 2: Skip the current wall (use the free painter)\n            skip = dp(index + 1, remaining)\n            return min(paid, skip)\n        \n        return dp(0, len(cost))"
        ]
    },
    {
        "question_id": "2810",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minCost(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        # Initialize the result with the cost of buying all chocolates without any operations\n        res = sum(nums)\n        # Initialize the cost of performing k operations\n        op_cost = 0\n        \n        # Iterate through the number of operations from 1 to n-1\n        for k in range(1, n):\n            # Update the cost of performing k operations\n            op_cost += x\n            # Calculate the cost of buying chocolates after k operations\n            current_cost = op_cost\n            for i in range(n):\n                # Find the minimum cost of buying the i-th type of chocolate after k operations\n                current_cost += min(nums[(i + j) % n] for j in range(k))\n            # Update the result with the minimum cost found\n            res = min(res, current_cost)\n        \n        return res"
        ]
    },
    {
        "question_id": "2811",
        "code_list": [
            "class Solution:\n    def minimumSum(self, n: int, k: int) -> int:\n        result = []\n        i = 1\n        while len(result) < n:\n            if all(i + x != k for x in result):\n                result.append(i)\n            i += 1\n        return sum(result)"
        ]
    },
    {
        "question_id": "2812",
        "code_list": [
            "class Solution:\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        return num + 2 * t"
        ]
    },
    {
        "question_id": "2816",
        "code_list": [
            "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        result = list(s)\n        for i in range(n // 2):\n            if s[i] != s[n - i - 1]:\n                # Choose the lexicographically smaller character\n                result[i] = result[n - i - 1] = min(s[i], s[n - i - 1])\n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2817",
        "code_list": [
            "class Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        \n        # Iterate through the string to find the minimum cost\n        for i in range(1, n):\n            if s[i] != s[i-1]:\n                # Calculate the cost of inverting up to index i-1\n                cost += min(i, n - i)\n        \n        return cost"
        ]
    },
    {
        "question_id": "2819",
        "code_list": [
            "class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        i = len(num) - 1\n        while i >= 0 and num[i] == '0':\n            i -= 1\n        return num[:i+1]"
        ]
    },
    {
        "question_id": "2824",
        "code_list": [
            "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated_str = str(n) + str(2 * n) + str(3 * n)\n        return len(concatenated_str) == 9 and set(concatenated_str) == {'1', '2', '3', '4', '5', '6', '7', '8', '9'}"
        ]
    },
    {
        "question_id": "2825",
        "code_list": [
            "class Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        # Use a set to store unique characters in the string\n        unique_chars = set(s)\n        # The length of the set is the minimized length of the string\n        return len(unique_chars)"
        ]
    },
    {
        "question_id": "2827",
        "code_list": [
            "from math import gcd\nfrom typing import List\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums) == 1:\n            return True\n        \n        max_num = max(nums)\n        sieve = [True] * (max_num + 1)\n        primes = []\n        \n        for i in range(2, int(max_num**0.5) + 1):\n            if sieve[i]:\n                for j in range(i*i, max_num + 1, i):\n                    sieve[j] = False\n        \n        for i in range(2, max_num + 1):\n            if sieve[i] and max_num % i == 0:\n                primes.append(i)\n        \n        parent = {i: i for i in nums}\n        rank = {i: 0 for i in nums}\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n        \n        for num in nums:\n            factors = set()\n            for prime in primes:\n                if prime > num:\n                    break\n                while num % prime == 0:\n                    factors.add(prime)\n                    num //= prime\n            if num > 1:\n                factors.add(num)\n            for factor in factors:\n                union(num, factor)\n        \n        return len(set(find(num) for num in nums)) == 1"
        ]
    },
    {
        "question_id": "2828",
        "code_list": [
            "class Solution:\n    def smallestString(self, s: str) -> str:\n        n = len(s)\n        i = 0\n        # Skip all leading 'a's\n        while i < n and s[i] == 'a':\n            i += 1\n        \n        # If the whole string is 'a's, change the last 'a' to 'z'\n        if i == n:\n            return s[:-1] + 'z'\n        \n        # Find the end of the substring where we don't want to change 'a' to 'z'\n        j = i\n        while j < n and s[j] != 'a':\n            j += 1\n        \n        # Change all characters in the found substring to their previous character\n        result = list(s)\n        for k in range(i, j):\n            result[k] = chr(ord(result[k]) - 1)\n        \n        # Append the rest of the string\n        result.extend(s[j:])\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2831",
        "code_list": [
            "from math import gcd\nfrom typing import List\n\nclass Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            first_digit = int(str(nums[i])[0])\n            for j in range(i + 1, len(nums)):\n                last_digit = nums[j] % 10\n                if gcd(first_digit, last_digit) == 1:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2832",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        max_length = 0\n        count_map = defaultdict(int)\n        left = 0\n        \n        for right in range(len(nums)):\n            count_map[nums[right]] += 1\n            current_max_count = max(count_map.values())\n            \n            while (right - left + 1) - current_max_count > k:\n                count_map[nums[left]] -= 1\n                left += 1\n            \n            max_length = max(max_length, current_max_count)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2833",
        "code_list": [
            "from collections import defaultdict\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # Sort queries to process them in order\n        query_map = {q: i for i, q in enumerate(queries)}\n        queries.sort()\n        \n        # Sort logs by time\n        logs.sort(key=lambda log: log[1])\n        \n        result = [0] * len(queries)\n        active_servers = SortedList()\n        server_status = defaultdict(int)\n        \n        log_index = 0\n        for query_time in queries:\n            # Add all logs that fall within the current query time range\n            while log_index < len(logs) and logs[log_index][1] <= query_time:\n                server_id, time = logs[log_index]\n                if server_id not in server_status:\n                    active_servers.add(server_id)\n                server_status[server_id] += 1\n                log_index += 1\n            \n            # Remove all logs that fall out of the current query time range\n            while active_servers and active_servers[0] in server_status and server_status[active_servers[0]] > 0 and logs[log_index-1][1] > query_time + x:\n                server_status[active_servers[0]] -= 1\n                if server_status[active_servers[0]] == 0:\n                    active_servers.remove(active_servers[0])\n            \n            # Calculate the number of inactive servers for the current query\n            result[query_map[query_time]] = n - len(active_servers)\n        \n        return result"
        ]
    },
    {
        "question_id": "2834",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        occupied_positions = set(nums)\n        for start, end in zip(moveFrom, moveTo):\n            while start in occupied_positions:\n                occupied_positions.remove(start)\n                start += 1\n            while end in occupied_positions:\n                end -= 1\n            occupied_positions.add(end)\n        return sorted(list(occupied_positions))"
        ]
    },
    {
        "question_id": "2837",
        "code_list": [
            "class Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        for ops in range(61):\n            target = num1 - ops * num2\n            if target < 0:\n                continue\n            count_set_bits = bin(target).count('1')\n            if count_set_bits <= ops and ops <= target and ops <= 60:\n                return ops\n        return -1"
        ]
    },
    {
        "question_id": "2839",
        "code_list": [
            "from typing import List\nimport bisect\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        # Sort queries by x_i in descending order and store their original indices\n        sorted_queries = sorted(enumerate(queries), key=lambda x: -x[1][0])\n        nums1, nums2 = zip(*sorted(zip(nums1, nums2)))\n        nums1, nums2 = list(nums1), list(nums2)\n        \n        # Initialize result array with -1\n        result = [-1] * len(sorted_queries)\n        max_sum = 0\n        max_j = -1\n        \n        # Process each query\n        for i, (x, y) in sorted_queries:\n            while max_j + 1 < len(nums1) and nums1[max_j + 1] >= x:\n                j = max_j + 1\n                # Find the rightmost position where nums2 is greater than or equal to nums2[j]\n                k = bisect.bisect_left(nums2[:j+1], nums2[j])\n                if k > 0:\n                    k -= 1\n                max_sum = max(max_sum, nums1[j] + nums2[k])\n                max_j += 1\n            \n            # Binary search to find the largest j such that nums1[j] >= x and nums2[j] >= y\n            j = bisect.bisect_left(nums1, x)\n            k = bisect.bisect_left(nums2[:j+1], y)\n            if k > 0:\n                k -= 1\n            if nums1[j] >= x and nums2[k] >= y:\n                result[i] = max_sum if max_sum > nums1[j] + nums2[k] else nums1[j] + nums2[k]\n            elif k > 0 and nums1[j] >= x and nums2[k-1] >= y:\n                result[i] = max_sum if max_sum > nums1[j] + nums2[k-1] else nums1[j] + nums2[k-1]\n        \n        return result"
        ]
    },
    {
        "question_id": "2844",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n = len(nums)\n        return sum(num ** 2 for i, num in enumerate(nums, start=1) if n % i == 0)"
        ]
    },
    {
        "question_id": "2845",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        nums.sort()\n        min_partition_value = float('inf')\n        for i in range(1, len(nums)):\n            min_partition_value = min(min_partition_value, nums[i] - nums[i - 1])\n        return min_partition_value"
        ]
    },
    {
        "question_id": "2847",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        word_set = set()\n        count = 0\n        for word in words:\n            if word[::-1] in word_set:\n                count += 1\n            else:\n                word_set.add(word)\n        return count"
        ]
    },
    {
        "question_id": "2848",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(index, mask):\n            if index == len(nums):\n                return 1\n            count = 0\n            for i in range(len(nums)):\n                if mask & (1 << i) == 0 and (nums[i] % nums[index] == 0 or nums[index] % nums[i] == 0):\n                    count += dfs(index + 1, mask | (1 << i))\n            return count % MOD\n        \n        return dfs(0, 0)"
        ]
    },
    {
        "question_id": "2849",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        from collections import deque\n        \n        def imbalance_count(subarr):\n            sarr = sorted(subarr)\n            count = 0\n            for i in range(len(sarr) - 1):\n                if sarr[i + 1] - sarr[i] > 1:\n                    count += 1\n            return count\n        \n        total_imbalance = 0\n        for start in range(len(nums)):\n            for end in range(start, len(nums)):\n                total_imbalance += imbalance_count(nums[start:end+1])\n        return total_imbalance"
        ]
    },
    {
        "question_id": "2850",
        "code_list": [
            "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        # If x and y are equal, we can use all of them without restrictions\n        if x == y:\n            return 2 * (x + y + z)\n        \n        # If x > y, we can use y \"AA\" and y-1 \"BB\" pairs plus all \"AB\" and one \"AA\"\n        elif x > y:\n            return 2 * (y + y + z + min(y, x - 1))\n        \n        # If y > x, we can use x \"BB\" and x-1 \"AA\" pairs plus all \"AB\" and one \"BB\"\n        else:\n            return 2 * (x + x + z + min(x, y - 1))"
        ]
    },
    {
        "question_id": "2854",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def minimizeConcatenatedLength(self, words: List[str]) -> int:\n        @lru_cache(None)\n        def dp(i, start_char, end_char):\n            if i == len(words):\n                return 0\n            # Option 1: Join with current word without modification\n            opt1 = len(words[i]) + dp(i + 1, words[i][0], words[i][-1])\n            # Option 2: Join with current word modifying the start character\n            if words[i][0] == end_char:\n                opt2 = len(words[i]) - 1 + dp(i + 1, words[i][1], words[i][-1])\n            else:\n                opt2 = len(words[i]) + dp(i + 1, words[i][0], words[i][-1])\n            # Option 3: Join with current word modifying the end character\n            if words[i][-1] == start_char:\n                opt3 = len(words[i]) - 1 + dp(i + 1, words[i][0], words[i][:-1])\n            else:\n                opt3 = len(words[i]) + dp(i + 1, words[i][0], words[i][-1])\n            # Option 4: Join with current word modifying both characters\n            if words[i][0] == end_char and words[i][-1] == start_char:\n                opt4 = len(words[i]) - 2 + dp(i + 1, words[i][1], words[i][:-1])\n            elif words[i][0] == end_char:\n                opt4 = len(words[i]) - 1 + dp(i + 1, words[i][1], words[i][:-1])\n            elif words[i][-1] == start_char:\n                opt4 = len(words[i]) - 1 + dp(i + 1, words[i][0], words[i][:-1])\n            else:\n                opt4 = len(words[i]) + dp(i + 1, words[i][0], words[i][-1])\n            return min(opt1, opt2, opt3, opt4)\n        \n        return len(words[0]) + dp(1, words[0][0], words[0][-1])"
        ]
    },
    {
        "question_id": "2855",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [-1] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            if dp[i] == -1:\n                continue\n            for j in range(i + 1, n):\n                if -target <= nums[j] - nums[i] <= target:\n                    dp[j] = max(dp[j], dp[i] + 1)\n        \n        return dp[n - 1]"
        ]
    },
    {
        "question_id": "2856",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        from collections import Counter\n        \n        # Calculate the number of distinct elements in the entire array\n        total_distinct = len(set(nums))\n        \n        # Initialize variables for the sliding window approach\n        n = len(nums)\n        left = 0\n        current_distinct = 0\n        count = Counter()\n        result = 0\n        \n        # Use a sliding window to find all complete subarrays\n        for right in range(n):\n            count[nums[right]] += 1\n            current_distinct = len(count)\n            \n            # If the current window is not complete, move the left pointer to the right\n            while current_distinct == total_distinct:\n                count[nums[left]] -= 1\n                if count[nums[left]] == 0:\n                    del count[nums[left]]\n                    current_distinct -= 1\n                left += 1\n            \n            # The number of complete subarrays ending at 'right' is (right - left + 1)\n            result += (right - left + 1)\n        \n        return result"
        ]
    },
    {
        "question_id": "2857",
        "code_list": [
            "class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        distance = 0\n        while mainTank >= 5:\n            # Use 5 liters of fuel\n            mainTank -= 5\n            distance += 50\n            # Transfer 1 liter of fuel from additional tank to main tank if possible\n            if additionalTank > 0:\n                mainTank += 1\n                additionalTank -= 1\n        # Add the distance covered by the remaining fuel in the main tank\n        distance += mainTank * 10\n        return distance"
        ]
    },
    {
        "question_id": "2866",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        max_length = 0\n        start_index = -1\n        \n        for i in range(len(nums)):\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                if start_index == -1:\n                    start_index = i\n                current_length = 1\n                while i + 1 < len(nums) and nums[i + 1] <= threshold and (nums[i] % 2 != nums[i + 1] % 2):\n                    current_length += 1\n                    i += 1\n                max_length = max(max_length, current_length)\n                if nums[i + 1] % 2 == 0:\n                    start_index = i + 1\n                else:\n                    start_index = -1\n            else:\n                start_index = -1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2867",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        last_one_index = -1\n        count = 0\n        \n        for i, num in enumerate(nums):\n            if num == 1:\n                if last_one_index == -1:\n                    last_one_index = i\n                else:\n                    count = (count + (i - last_one_index)) % MOD\n                    last_one_index = i\n        \n        return count + 1 if last_one_index != -1 else 0"
        ]
    },
    {
        "question_id": "2868",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        left = 0\n        result = 0\n        max_deque = deque()\n        min_deque = deque()\n        \n        for right in range(len(nums)):\n            # Maintain max_deque\n            while max_deque and nums[right] > nums[max_deque[-1]]:\n                max_deque.pop()\n            max_deque.append(right)\n            \n            # Maintain min_deque\n            while min_deque and nums[right] < nums[min_deque[-1]]:\n                min_deque.pop()\n            min_deque.append(right)\n            \n            # Check if the current window is valid\n            while nums[max_deque[0]] - nums[min_deque[0]] > 2:\n                if max_deque[0] == left:\n                    max_deque.popleft()\n                if min_deque[0] == left:\n                    min_deque.popleft()\n                left += 1\n            \n            # Add the number of valid subarrays ending at 'right'\n            result += right - left + 1\n        \n        return result"
        ]
    },
    {
        "question_id": "2869",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        dp1, dp2 = [1] * n, [1] * n\n        \n        for i in range(1, n):\n            if nums1[i] >= nums1[i-1]:\n                dp1[i] = max(dp1[i], dp1[i-1] + 1)\n            if nums1[i] >= nums2[i-1]:\n                dp1[i] = max(dp1[i], dp2[i-1] + 1)\n            \n            if nums2[i] >= nums2[i-1]:\n                dp2[i] = max(dp2[i], dp2[i-1] + 1)\n            if nums2[i] >= nums1[i-1]:\n                dp2[i] = max(dp2[i], dp1[i-1] + 1)\n        \n        return max(max(dp1), max(dp2))"
        ]
    },
    {
        "question_id": "2870",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        max_length = -1\n        n = len(nums)\n        i = 0\n        \n        while i < n:\n            # Check for alternating subarray starting at index i\n            for j in range(i + 1, n):\n                if (j - i) % 2 == 0 and nums[j] != nums[j - 1] + 1:\n                    break\n                if (j - i) % 2 == 1 and nums[j] != nums[j - 1] - 1:\n                    break\n                if j == n - 1:\n                    max_length = max(max_length, j - i + 1)\n            i += 1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2872",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n - 2, -1, -1):\n            if nums[i] <= nums[i + 1]:\n                nums[i + 1] += nums[i]\n        return max(nums)"
        ]
    },
    {
        "question_id": "2873",
        "code_list": [
            "from math import sqrt\n\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(sqrt(num)) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        prime_pairs = []\n        for x in range(2, n // 2 + 1):\n            y = n - x\n            if is_prime(x) and is_prime(y):\n                prime_pairs.append([x, y])\n        \n        return sorted(prime_pairs)"
        ]
    },
    {
        "question_id": "2876",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        return sum(1 for hour in hours if hour >= target)"
        ]
    },
    {
        "question_id": "2877",
        "code_list": [
            "from itertools import permutations\n\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        def merge(x, y):\n            # Find the longest common suffix of x and the longest common prefix of y\n            for i in range(len(x), -1, -1):\n                if x.endswith(y[:i]):\n                    return x + y[i:]\n            return x + y\n        \n        # Generate all possible concatenations of a, b, and c\n        candidates = [merge(merge(a, b), c), merge(merge(a, c), b), merge(merge(b, a), c), merge(merge(b, c), a), merge(merge(c, a), b), merge(merge(c, b), a)]\n        \n        # Sort candidates based on length and lexicographical order\n        candidates.sort(key=lambda x: (len(x), x))\n        \n        return candidates[0]"
        ]
    },
    {
        "question_id": "2878",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        operations = [0] * (n + 1)\n        \n        for i in range(n):\n            operations[i + 1] = operations[i] + nums[i]\n            if i >= k - 1:\n                operations[i + 1] -= operations[i + 1 - k]\n            \n            if operations[i + 1] < 0 or (nums[i] > 0 and operations[i + 1] - operations[i] > nums[i]):\n                return False\n        \n        return True"
        ]
    },
    {
        "question_id": "2879",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def minimumChanges(self, s: str, k: int) -> int:\n        n = len(s)\n        \n        @lru_cache(None)\n        def is_semi_palindrome(sub):\n            length = len(sub)\n            for d in range(1, length // 2 + 1):\n                if length % d != 0:\n                    continue\n                palindrome = True\n                for i in range(d):\n                    if sub[i] != sub[length - d + i]:\n                        palindrome = False\n                        break\n                if palindrome:\n                    return True\n            return False\n        \n        @lru_cache(None)\n        def dp(i, k):\n            if k == 1:\n                return sum(is_semi_palindrome(s[j:]) for j in range(i, n))\n            if i == n:\n                return float('inf')\n            min_changes = float('inf')\n            for j in range(i, n):\n                if is_semi_palindrome(s[i:j+1]):\n                    min_changes = min(min_changes, dp(j+1, k-1))\n            return min_changes\n        \n        return dp(0, k)"
        ]
    },
    {
        "question_id": "2881",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            # Split the current word by the separator\n            splits = word.split(separator)\n            # Extend the result list with non-empty splits\n            result.extend([split for split in splits if split])\n        return result"
        ]
    },
    {
        "question_id": "2882",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(target, max_num):\n            if target == 0:\n                return 1\n            if target < 0 or max_num == 0:\n                return 0\n            \n            # Include max_num in the sum\n            include = dp(target - max_num**x, max_num - 1)\n            # Exclude max_num from the sum\n            exclude = dp(target, max_num - 1)\n            \n            return (include + exclude) % MOD\n        \n        return dp(n, int(n**(1/x)))"
        ]
    },
    {
        "question_id": "2883",
        "code_list": [
            "from math import log\n\nclass Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        # Precompute powers of 5 that fit within 15 bits (since s.length <= 15)\n        powers_of_5 = {bin(5**i)[2:].zfill(15) for i in range(16)}\n        \n        n = len(s)\n        dp = [-1] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if s[j:i] in powers_of_5 and s[j] != '0':\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "2884",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        max_length = 0\n        last_forbidden_end = -1\n        \n        for i in range(len(word)):\n            for length in range(1, 11):  # forbidden[i] length <= 10\n                if i + length > len(word):\n                    break\n                substring = word[i:i+length]\n                if substring in forbidden:\n                    last_forbidden_end = max(last_forbidden_end, i + length - 1)\n                    break\n            \n            max_length = max(max_length, i - last_forbidden_end)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2886",
        "code_list": [
            "class Solution:\n    def finalString(self, s: str) -> str:\n        result = []\n        for char in s:\n            if char == 'i':\n                result.reverse()\n            else:\n                result.append(char)\n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2887",
        "code_list": [
            "class Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = 'aeiouAEIOU'\n        vowel_chars = [char for char in s if char in vowels]\n        vowel_chars.sort(key=lambda x: ord(x))\n        \n        result = []\n        vowel_index = 0\n        \n        for char in s:\n            if char in vowels:\n                result.append(vowel_chars[vowel_index])\n                vowel_index += 1\n            else:\n                result.append(char)\n                \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2888",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        total_count = Counter(nums)\n        dominant_element = max(total_count, key=total_count.get)\n        left_count = 0\n        \n        for i, num in enumerate(nums):\n            left_count += 1 if num == dominant_element else 0\n            right_count = total_count[dominant_element] - left_count\n            \n            if left_count * 2 > i + 1 and right_count * 2 > len(nums) - i - 1:\n                return i\n        \n        return -1"
        ]
    },
    {
        "question_id": "2891",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        max_beauty = 0\n        left = 0\n        for right in range(len(nums)):\n            while nums[right] - nums[left] > 2 * k:\n                left += 1\n            max_beauty = max(max_beauty, right - left + 1)\n        return max_beauty"
        ]
    },
    {
        "question_id": "2892",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        max_num = max(nums)\n        if len(nums) != max_num + 1 or nums.count(max_num) != 2:\n            return False\n        \n        expected_base = set(range(1, max_num))\n        actual_set = set(nums[:max_num])\n        \n        return expected_base == actual_set"
        ]
    },
    {
        "question_id": "2893",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp_even = [0] * n\n        dp_odd = [0] * n\n        \n        if nums[0] % 2 == 0:\n            dp_even[0] = nums[0]\n        else:\n            dp_odd[0] = nums[0]\n        \n        for i in range(1, n):\n            if nums[i] % 2 == 0:\n                dp_even[i] = max(dp_even[i-1] + nums[i], dp_odd[i-1] + nums[i] - x)\n                dp_odd[i] = dp_odd[i-1]\n            else:\n                dp_odd[i] = max(dp_odd[i-1] + nums[i], dp_even[i-1] + nums[i] - x)\n                dp_even[i] = dp_even[i-1]\n        \n        return max(dp_even[-1], dp_odd[-1])"
        ]
    },
    {
        "question_id": "2902",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_sum = -1\n        num_map = {}\n        \n        for num in nums:\n            max_digit = max(int(digit) for digit in str(num))\n            if max_digit in num_map:\n                # Calculate the sum of the current number and the number stored in num_map[max_digit]\n                potential_sum = num + num_map[max_digit]\n                # Update max_sum if the potential_sum is greater than the current max_sum\n                max_sum = max(max_sum, potential_sum)\n                # Update num_map[max_digit] to the larger of the current number and the number already stored\n                num_map[max_digit] = max(num, num_map[max_digit])\n            else:\n                # Initialize num_map[max_digit] with the current number\n                num_map[max_digit] = num\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "2915",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        prefix_count = defaultdict(int)\n        prefix_count[0] = 1\n        count = 0\n        current_count = 0\n        \n        for num in nums:\n            if num % modulo == k:\n                current_count += 1\n            current_count %= modulo\n            complement = (current_count - k + modulo) % modulo\n            count += prefix_count[complement]\n            prefix_count[current_count] += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "2916",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        n = len(nums)\n        # If the array has less than or equal to 2 elements, it can always be split as required\n        if n <= 2:\n            return True\n        \n        # Check if there exists any pair of adjacent elements whose sum is >= m\n        for i in range(n - 1):\n            if nums[i] + nums[i + 1] >= m:\n                return True\n        \n        # If no such pair exists, return False\n        return False"
        ]
    },
    {
        "question_id": "2917",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] < target:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2919",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort()\n        total, count = 0, 0\n        \n        for limit in usageLimits:\n            total += limit\n            if total >= count + 1:\n                count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "2920",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        index_map = defaultdict(list)\n        \n        # Map each value to its indices\n        for i, num in enumerate(nums):\n            index_map[num].append(i)\n        \n        max_distance = 0\n        \n        # Calculate the maximum distance between occurrences of each value\n        for indices in index_map.values():\n            max_distance_here = 0\n            for i in range(len(indices)):\n                max_distance_here = max(max_distance_here, (indices[(i + 1) % len(indices)] - indices[i]) // 2)\n            max_distance = max(max_distance, max_distance_here)\n        \n        return max_distance"
        ]
    },
    {
        "question_id": "2921",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(length, is_limit, is_num, prev_digit):\n            if length == 0:\n                return int(is_num)\n            res = 0\n            if not is_num:\n                res = dp(length - 1, False, False, None)\n            low_digit = 1 if not is_num else int(low[-length])\n            high_digit = int(high[-length]) if is_limit else 9\n            for digit in range(low_digit, high_digit + 1):\n                if prev_digit is None or abs(prev_digit - digit) == 1:\n                    res += dp(length - 1, is_limit and digit == high_digit, True, digit)\n            return res % MOD\n        \n        def count_numbers(n):\n            return dp(len(n), True, False, None)\n        \n        # Count stepping numbers up to high and low-1, then subtract\n        return (count_numbers(high) - count_numbers(low[:-1]) + int(low[0] == '1' and low[-1] == '0')) % MOD"
        ]
    },
    {
        "question_id": "2952",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        n = len(nums1)\n        total_increase = sum(nums2)\n        total_initial = sum(nums1)\n        \n        # Calculate the initial sum after all increments\n        initial_sum = total_initial + total_increase\n        \n        # If the initial sum is already less than or equal to x, return 0\n        if initial_sum <= x:\n            return 0\n        \n        # Sort nums2 and nums1 based on nums2 values\n        sorted_indices = sorted(range(n), key=lambda i: nums2[i])\n        nums1_sorted = [nums1[i] for i in sorted_indices]\n        nums2_sorted = [nums2[i] for i in sorted_indices]\n        \n        @lru_cache(None)\n        def dp(index, remaining):\n            if remaining < 0:\n                return float('inf')\n            if index == n:\n                return 0\n            # Option 1: Do nothing with current index\n            option1 = dp(index + 1, remaining)\n            # Option 2: Zero out the current index\n            option2 = 1 + dp(index + 1, remaining - nums2_sorted[index] - nums1_sorted[index])\n            return min(option1, option2)\n        \n        result = dp(0, x - total_initial)\n        return result if result != float('inf') else -1"
        ]
    },
    {
        "question_id": "2953",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        count = 0\n        n = len(coordinates)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (coordinates[i][0] ^ coordinates[j][0]) + (coordinates[i][1] ^ coordinates[j][1]) == k:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2954",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        max_sum = 0\n        current_sum = 0\n        count_map = defaultdict(int)\n        \n        # Initialize the first window\n        for i in range(k):\n            current_sum += nums[i]\n            count_map[nums[i]] += 1\n        \n        # Check if the first window is valid\n        if len(count_map) >= m:\n            max_sum = current_sum\n        \n        # Slide the window across the array\n        for i in range(k, len(nums)):\n            current_sum += nums[i] - nums[i - k]  # Add new element and remove old element\n            count_map[nums[i]] += 1\n            count_map[nums[i - k]] -= 1\n            \n            # Remove elements from count_map if their count becomes zero\n            if count_map[nums[i - k]] == 0:\n                del count_map[nums[i - k]]\n            \n            # Check if the current window is valid\n            if len(count_map) >= m:\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "2955",
        "code_list": [
            "class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        roundedAmount = round(purchaseAmount / 10) * 10\n        return 100 - roundedAmount"
        ]
    },
    {
        "question_id": "2977",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        acronym = ''.join(word[0] for word in words)\n        return acronym == s"
        ]
    },
    {
        "question_id": "2979",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        # Sort offers based on the starting index\n        offers.sort(key=lambda x: x[0])\n        \n        # Initialize a DP array where dp[i] represents the maximum gold earned up to house i\n        dp = [0] * (n + 1)\n        \n        # Dictionary to store the latest offer ending at each house\n        offer_dict = {}\n        for start, end, gold in offers:\n            if end + 1 not in offer_dict:\n                offer_dict[end + 1] = []\n            offer_dict[end + 1].append((start, end, gold))\n        \n        # Iterate through each house\n        for i in range(1, n + 1):\n            # Copy the previous day's maximum gold\n            dp[i] = dp[i - 1]\n            \n            # Check if there are any offers ending at this house\n            if i in offer_dict:\n                for start, end, gold in offer_dict[i]:\n                    # Update the maximum gold by considering the current offer\n                    dp[i] = max(dp[i], dp[start] + gold)\n        \n        # The answer is the maximum gold earned up to the last house\n        return dp[n]"
        ]
    },
    {
        "question_id": "2998",
        "code_list": [
            "class Solution:\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        count = 0\n        for num in range(low, high + 1):\n            num_str = str(num)\n            if len(num_str) % 2 != 0:\n                continue\n            mid = len(num_str) // 2\n            first_half_sum = sum(int(digit) for digit in num_str[:mid])\n            second_half_sum = sum(int(digit) for digit in num_str[mid:])\n            if first_half_sum == second_half_sum:\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "2999",
        "code_list": [
            "class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        # Check if the characters at even indices are the same in both strings\n        # and the characters at odd indices are the same in both strings\n        return sorted(s1[::2]) == sorted(s2[::2]) and sorted(s1[1::2]) == sorted(s2[1::2])"
        ]
    },
    {
        "question_id": "3000",
        "code_list": [
            "from sortedcontainers import SortedList\n\nclass Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        sl = SortedList()\n        min_diff = float('inf')\n        \n        for i in range(len(nums)):\n            if i >= x:\n                sl.add(nums[i - x])\n                pos = sl.bisect_left(nums[i])\n                if pos < len(sl):\n                    min_diff = min(min_diff, abs(nums[i] - sl[pos]))\n                if pos > 0:\n                    min_diff = min(min_diff, abs(nums[i] - sl[pos - 1]))\n            if i == x - 1:\n                sl.add(nums[i])\n        \n        return min_diff"
        ]
    },
    {
        "question_id": "3017",
        "code_list": [
            "from math import log10\n\nclass Solution:\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        def count_beautiful_numbers(n, k):\n            count = 0\n            for num in range(1, n + 1):\n                if num % k == 0:\n                    even_count, odd_count = 0, 0\n                    for digit in str(num):\n                        if int(digit) % 2 == 0:\n                            even_count += 1\n                        else:\n                            odd_count += 1\n                    if even_count == odd_count:\n                        count += 1\n            return count\n        \n        # Adjusting the range to include the boundaries\n        low_digits = len(str(low))\n        high_digits = len(str(high))\n        \n        total_beautiful = 0\n        for digits in range(low_digits, high_digits + 1):\n            total_beautiful += count_beautiful_numbers(10**digits - 1, k)\n        \n        # Subtracting the count for numbers less than 'low'\n        for i in range(1, low):\n            if i % k == 0:\n                even_count, odd_count = 0, 0\n                for digit in str(i):\n                    if int(digit) % 2 == 0:\n                        even_count += 1\n                    else:\n                        odd_count += 1\n                if even_count == odd_count:\n                    total_beautiful -= 1\n        \n        return total_beautiful"
        ]
    },
    {
        "question_id": "3018",
        "code_list": [
            "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        i, j = 0, 0\n        while i < len(str1) and j < len(str2):\n            # Calculate the next character of str2[j] in the cycle\n            next_char = chr((ord(str2[j]) - ord('a') + 1) % 26 + ord('a'))\n            # Check if current character of str1 matches str2[j] or its next character in the cycle\n            if str1[i] == str2[j] or str1[i] == next_char:\n                j += 1\n            i += 1\n        return j == len(str2)"
        ]
    },
    {
        "question_id": "3019",
        "code_list": [
            "class Solution:\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        # Count the number of '_' which can be used to maximize the distance\n        underscore_count = moves.count('_')\n        # Calculate the net movement towards left or right\n        net_movement = moves.count('R') - moves.count('L')\n        # The furthest distance is the sum of net movement and underscores\n        return abs(net_movement) + underscore_count"
        ]
    },
    {
        "question_id": "3024",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        if s == t:\n            # If s is already equal to t, we need to check if k is even (since each operation changes the string)\n            return pow(2, k, MOD) - 1 if k % 2 == 0 else 1\n        \n        # Find all rotations of s that match t\n        rotations = [s[i:] + s[:i] for i in range(n)]\n        if t not in rotations:\n            return 0\n        \n        # Count frequency of each rotation\n        rotation_counts = Counter(rotations)\n        t_count = rotation_counts[t]\n        \n        # Calculate the number of ways to reach t in exactly k operations\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for _ in range(k):\n            new_dp = [0] * (k + 1)\n            for j in range(k + 1):\n                if j >= 1:\n                    new_dp[j] += dp[j - 1] * (n - 1)\n                    new_dp[j] %= MOD\n                if j >= t_count:\n                    new_dp[j] += dp[j - t_count] * t_count\n                    new_dp[j] %= MOD\n            dp = new_dp\n        \n        return dp[k]"
        ]
    },
    {
        "question_id": "3025",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        # Convert target to binary representation to check if it's possible to form the target\n        target_bin = bin(target)[2:]\n        target_len = len(target_bin)\n        \n        # Initialize a counter to keep track of the number of operations needed\n        operations = 0\n        \n        # Count the frequency of each power of 2 in nums\n        freq = [0] * 31\n        for num in nums:\n            freq[num.bit_length() - 1] += 1\n        \n        # Iterate over each bit position in the target's binary representation\n        for i in range(target_len):\n            if target_bin[target_len - 1 - i] == '1':\n                # Find the smallest power of 2 that can be used to form the current bit\n                j = i\n                while j < 31 and freq[j] == 0:\n                    j += 1\n                if j >= 31:\n                    # If no suitable power of 2 is found, return -1\n                    return -1\n                else:\n                    # Use the found power of 2 and decrement its count\n                    freq[j] -= 1\n                    # If the current bit is set and the higher bits are not set, we need to split\n                    while j > i and freq[j-1] > 0:\n                        freq[j-1] -= 1\n                        freq[j] += 2\n                        operations += 1\n        return operations"
        ]
    },
    {
        "question_id": "3031",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        n, m = len(grid), len(grid[0])\n        total_product = 1\n        mod = 12345\n        \n        # Calculate the product of all elements in grid\n        for i in range(n):\n            for j in range(m):\n                total_product *= grid[i][j]\n                total_product %= mod\n        \n        result = [[0] * m for _ in range(n)]\n        \n        # Calculate each element in the product matrix\n        for i in range(n):\n            for j in range(m):\n                left_product = 1\n                for k in range(j):\n                    left_product *= grid[i][k]\n                    left_product %= mod\n                \n                right_product = 1\n                for k in range(j + 1, m):\n                    right_product *= grid[i][k]\n                    right_product %= mod\n                \n                result[i][j] = (total_product // left_product) * right_product\n                result[i][j] %= mod\n        \n        return result"
        ]
    },
    {
        "question_id": "3032",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n        n = len(receiver)\n        memo = defaultdict(int)\n        \n        def dfs(x, depth):\n            if depth == 0:\n                return x\n            if (x, depth) in memo:\n                return memo[(x, depth)]\n            next_x = receiver[x]\n            result = dfs(next_x, depth - 1)\n            memo[(x, depth)] = result + x\n            return result + x\n        \n        max_value = 0\n        for i in range(n):\n            max_value = max(max_value, dfs(i, k))\n        \n        return max_value"
        ]
    },
    {
        "question_id": "3033",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        n = len(s1)\n        diff_indices = [i for i in range(n) if s1[i] != s2[i]]\n        m = len(diff_indices)\n        \n        if m % 2 != 0:\n            return -1\n        \n        dp = [[float('inf')] * (m // 2 + 1) for _ in range(m + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, m + 1):\n            for j in range(min(i // 2 + 1, m // 2 + 1)):\n                if i > 1:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                if i > 2 and j > 0:\n                    flip_cost = x if i % 2 == 1 else 1\n                    dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + flip_cost)\n        \n        return dp[m][m // 2] if dp[m][m // 2] != float('inf') else -1"
        ]
    },
    {
        "question_id": "3034",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        covered_points = set()\n        for start, end in nums:\n            for point in range(start, end + 1):\n                covered_points.add(point)\n        return len(covered_points)"
        ]
    },
    {
        "question_id": "3044",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        collected = set()\n        operations = 0\n        \n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] <= k:\n                collected.add(nums[i])\n            if len(collected) == k:\n                return len(nums) - i\n            operations += 1\n            \n        return operations"
        ]
    },
    {
        "question_id": "3045",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        # Find the index where the array is broken\n        break_index = -1\n        for i in range(1, n):\n            if nums[i] < nums[i - 1]:\n                if break_index != -1:\n                    return -1  # More than one break point found, not possible to sort\n                break_index = i\n        \n        if break_index == -1:\n            return 0  # Array is already sorted\n        \n        # Check if the array can be sorted by right shifts\n        for i in range(break_index, n - 1):\n            if nums[i] > nums[i + 1]:\n                return -1\n        \n        # Calculate the number of right shifts needed\n        return n - break_index"
        ]
    },
    {
        "question_id": "3046",
        "code_list": [
            "class Solution:\n    def minimumOperations(self, num: str) -> int:\n        n = len(num)\n        # Reverse the string for easier iteration from the end\n        num = num[::-1]\n        min_ops = float('inf')\n        \n        # Check for ending with '00', '25', '50', '75'\n        for i in range(n):\n            if num[i] == '0':\n                min_ops = min(min_ops, n - i - 2)\n                if i + 1 < n and num[i + 1] == '0':\n                    min_ops = min(min_ops, n - i - 3)\n            elif num[i] == '5':\n                min_ops = min(min_ops, n - i - 1)\n                if i + 1 < n and (num[i + 1] == '2' or num[i + 1] == '7'):\n                    min_ops = min(min_ops, n - i - 2)\n        \n        # If no valid combination found, return n (all digits need to be deleted)\n        return min_ops if min_ops != float('inf') else n"
        ]
    },
    {
        "question_id": "3047",
        "code_list": [
            "from math import sqrt\nfrom collections import defaultdict\n\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        def is_perfect_square(n):\n            return int(sqrt(n)) ** 2 == n\n        \n        factor_counts = defaultdict(int)\n        for num in nums:\n            factors = []\n            for i in range(2, int(sqrt(num)) + 1):\n                while num % i == 0:\n                    factors.append(i)\n                    num //= i\n            if num > 1:\n                factors.append(num)\n            factor_counts[tuple(sorted(factors))] += num\n        \n        max_sum = 0\n        for value in factor_counts.values():\n            if is_perfect_square(value):\n                max_sum = max(max_sum, value)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3055",
        "code_list": [
            "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        ones = s.count('1')\n        zeros = s.count('0')\n        # Place all but one '1' at the beginning, followed by all '0's, and end with one '1'\n        return '1' * (ones - 1) + '0' * zeros + '1'"
        ]
    },
    {
        "question_id": "3080",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        min_score = all_num = nums[0]\n        for num in nums:\n            all_num &= num\n            min_score |= (all_num ^ num)\n        \n        if min_score == 0:\n            return len(nums) - nums.count(0)\n        else:\n            return 1"
        ]
    },
    {
        "question_id": "3081",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_count = 1\n        current_count = 1\n        \n        for i in range(1, n):\n            if nums[i] == nums[i - 1]:\n                current_count += 1\n                max_count = max(max_count, current_count)\n            else:\n                current_count = 1\n        \n        return n - (max_count + 1) // 2 * 2"
        ]
    },
    {
        "question_id": "3091",
        "code_list": [
            "from typing import List\nfrom collections import Counter\nfrom functools import lru_cache\n\nclass Solution:\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        mod = 10**9 + 7\n        cnt = Counter(nums)\n        keys = sorted(cnt.keys())\n        \n        @lru_cache(None)\n        def dp(index, target):\n            if target < 0:\n                return 0\n            if index == len(keys):\n                return int(target == 0)\n            res = dp(index + 1, target)\n            for i in range(1, cnt[keys[index]] + 1):\n                res += dp(index + 1, target - i * keys[index])\n                res %= mod\n            return res\n        \n        return (dp(0, r) - dp(0, l - 1) + mod) % mod"
        ]
    },
    {
        "question_id": "3093",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)"
        ]
    },
    {
        "question_id": "3094",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        operations = 0\n        \n        for freq in count.values():\n            if freq == 1:\n                return -1\n            operations += (freq + 2) // 3\n        \n        return operations"
        ]
    },
    {
        "question_id": "3104",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countWays(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        ways = 0\n        \n        # Case 1: Selecting no student\n        if nums[0] > 0:\n            ways += 1\n        \n        # Case 2: Selecting some or all students\n        for i in range(n - 1):\n            if nums[i] < i + 1 < nums[i + 1]:\n                ways += 1\n        \n        # Case 3: Selecting all students\n        if n > nums[-1]:\n            ways += 1\n        \n        return ways"
        ]
    },
    {
        "question_id": "3106",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        dp = [0] + [-1] * target\n        \n        for num in nums:\n            for j in range(target, num - 1, -1):\n                if dp[j - num] != -1:\n                    dp[j] = max(dp[j], dp[j - num] + 1)\n        \n        return dp[target]"
        ]
    },
    {
        "question_id": "3114",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        left = [0] * n\n        right = [0] * n\n        \n        stack = []\n        # Calculate left boundary\n        for i in range(n):\n            while stack and maxHeights[stack[-1]] >= maxHeights[i]:\n                stack.pop()\n            left[i] = (i - stack[-1] - 1) * maxHeights[i] if stack else i * maxHeights[i]\n            if stack:\n                left[i] += left[stack[-1]]\n            stack.append(i)\n        \n        stack = []\n        # Calculate right boundary\n        for i in range(n - 1, -1, -1):\n            while stack and maxHeights[stack[-1]] >= maxHeights[i]:\n                stack.pop()\n            right[i] = (stack[-1] - i - 1) * maxHeights[i] if stack else (n - i - 1) * maxHeights[i]\n            if stack:\n                right[i] += right[stack[-1]]\n            stack.append(i)\n        \n        # Calculate the maximum sum of heights\n        return max(left[i] + right[i] - maxHeights[i] for i in range(n))"
        ]
    },
    {
        "question_id": "3141",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)\n        prefix_sum = {0: -1}\n        current_sum = 0\n        min_length = float('inf')\n        n = len(nums)\n        \n        for i, num in enumerate(nums * 2):\n            current_sum += num\n            if (current_sum - target) % total_sum in prefix_sum:\n                min_length = min(min_length, (i - prefix_sum[(current_sum - target) % total_sum]) % (n * 2))\n            prefix_sum[current_sum % total_sum] = i\n        \n        if total_sum == 0 or target % total_sum == 0 and (target // total_sum) * n < min_length:\n            return (target // total_sum) * n\n        \n        return min_length if min_length != float('inf') else -1"
        ]
    },
    {
        "question_id": "3150",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        n = len(s)\n        min_len = float('inf')\n        result = \"\"\n        left = 0\n        \n        for right in range(n):\n            if s[right] == '1':\n                k -= 1\n            \n            while k == 0:\n                if right - left + 1 < min_len or (right - left + 1 == min_len and s[left:right+1] < result):\n                    min_len = right - left + 1\n                    result = s[left:right+1]\n                \n                if s[left] == '1':\n                    k += 1\n                left += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3151",
        "code_list": [
            "from heapq import heapify, heappop, heappush\n\nclass Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        # Sort processor times in ascending order\n        processorTime.sort()\n        # Sort tasks in descending order to always assign the longest task to the earliest available processor\n        tasks.sort(reverse=True)\n        \n        # Create a min-heap for tasks\n        task_heap = tasks\n        heapify(task_heap)\n        \n        # Assign tasks to processors\n        for i in range(len(processorTime)):\n            for _ in range(4):\n                # Get the next task with the longest processing time\n                task_time = heappop(task_heap)\n                # Calculate the completion time for this task on the current processor\n                processorTime[i] += task_time\n        \n        # Return the maximum completion time among all processors\n        return max(processorTime)"
        ]
    },
    {
        "question_id": "3153",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Count the frequency of each bit position across all numbers\n        bit_counts = [0] * 30\n        for num in nums:\n            for bit in range(30):\n                if num & (1 << bit):\n                    bit_counts[bit] += 1\n        \n        # Construct the k largest possible numbers based on the bit counts\n        result_nums = []\n        for _ in range(k):\n            current_num = 0\n            for bit in range(30):\n                if bit_counts[bit]:\n                    current_num |= (1 << bit)\n                    bit_counts[bit] -= 1\n            result_nums.append(current_num)\n        \n        # Calculate the sum of squares of the k largest numbers\n        return sum(x ** 2 for x in result_nums) % MOD"
        ]
    },
    {
        "question_id": "3154",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        max_value = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    current_value = (nums[i] - nums[j]) * nums[k]\n                    max_value = max(max_value, current_value)\n        return max_value if max_value > 0 else 0"
        ]
    },
    {
        "question_id": "3163",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        total_sum = 0\n        \n        for i in range(n):\n            distinct_values = set()\n            for j in range(i, n):\n                distinct_values.add(nums[j])\n                total_sum += len(distinct_values) ** 2\n        \n        return total_sum"
        ]
    },
    {
        "question_id": "3164",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def lastVisitedIntegers(self, words: List[str]) -> List[int]:\n        result = []\n        nums = []\n        prev_count = 0\n        \n        for word in words:\n            if word != \"prev\":\n                nums.append(int(word))\n                prev_count = 0\n            else:\n                prev_count += 1\n                if len(nums) < prev_count:\n                    result.append(-1)\n                else:\n                    result.append(nums[-prev_count])\n        \n        return result"
        ]
    },
    {
        "question_id": "3166",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        values = list(count.values())\n        n = len(nums)\n        \n        def is_valid(k):\n            total_groups = 0\n            for v in values:\n                q, r = divmod(v, k)\n                if r > 0:\n                    if r > (k - 1 - q):\n                        return False\n                    total_groups += r\n            return True\n        \n        for k in range(min(values), 0, -1):\n            if is_valid(k):\n                return sum(v // (k + 1) + (v % (k + 1) != 0) for v in values)"
        ]
    },
    {
        "question_id": "3171",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        zeros1, total1 = nums1.count(0), sum(nums1)\n        zeros2, total2 = nums2.count(0), sum(nums2)\n        \n        # Calculate the required sums to balance the arrays\n        required_sum1 = total1 + zeros1\n        required_sum2 = total2 + zeros2\n        \n        # Check if it's possible to make the sums equal\n        if (total1 + zeros1 > total2 + zeros2 and zeros1 == 0) or (total2 + zeros2 > total1 + zeros1 and zeros2 == 0):\n            return -1\n        \n        # Return the maximum of the required sums\n        return max(required_sum1, required_sum2)"
        ]
    },
    {
        "question_id": "3172",
        "code_list": [
            "class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        num1 = sum(i for i in range(1, n + 1) if i % m != 0)\n        num2 = sum(i for i in range(1, n + 1) if i % m == 0)\n        return num1 - num2"
        ]
    },
    {
        "question_id": "3174",
        "code_list": [
            "class Solution:\n    def minChanges(self, s: str) -> int:\n        changes = 0\n        n = len(s)\n        for i in range(0, n, 2):\n            if s[i] != s[i + 1]:\n                changes += 1\n        return changes"
        ]
    },
    {
        "question_id": "3176",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        left_min = [0] * n\n        right_min = [0] * n\n        \n        # Fill left_min array\n        left_min[0] = nums[0]\n        for i in range(1, n):\n            left_min[i] = min(left_min[i-1], nums[i])\n        \n        # Fill right_min array\n        right_min[n-1] = nums[n-1]\n        for i in range(n-2, -1, -1):\n            right_min[i] = min(right_min[i+1], nums[i])\n        \n        min_sum = float('inf')\n        \n        for j in range(1, n-1):\n            if left_min[j-1] < nums[j] > right_min[j+1]:\n                min_sum = min(min_sum, left_min[j-1] + nums[j] + right_min[j+1])\n        \n        return min_sum if min_sum != float('inf') else -1"
        ]
    },
    {
        "question_id": "3183",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        bit_count = [0] * 31\n        \n        for num in nums:\n            for i in range(31):\n                if num & (1 << i):\n                    bit_count[i] += 1\n        \n        result = 0\n        for i in range(31):\n            if bit_count[i] >= k:\n                result |= (1 << i)\n        \n        return result"
        ]
    },
    {
        "question_id": "3184",
        "code_list": [
            "from typing import List\nimport bisect\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [nums[0]]\n        min_dp = [nums[0]]\n        for i in range(1, n):\n            if nums[i] + min_dp[i // 2] >= nums[i]:\n                dp.append(nums[i] + min_dp[i // 2])\n            else:\n                dp.append(nums[i])\n            min_dp.append(min(dp))\n        return max(dp)"
        ]
    },
    {
        "question_id": "3188",
        "code_list": [
            "class Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        strongest_team = -1\n        for i in range(len(grid)):\n            if sum(grid[i]) == len(grid) - 1:\n                if strongest_team != -1:\n                    return -1  # More than one team can be a champion\n                strongest_team = i\n        return strongest_team"
        ]
    },
    {
        "question_id": "3190",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        max1, max2 = max(nums1), max(nums2)\n        if nums1[-1] == max1 and nums2[-1] == max2:\n            return 0\n        \n        def check_swap(i):\n            temp1, temp2 = nums1[:], nums2[:]\n            temp1[i], temp2[i] = temp2[i], temp1[i]\n            if temp1[-1] == max1 and temp2[-1] == max2:\n                return True\n            return False\n        \n        def count_swaps():\n            swaps = 0\n            for i in range(n):\n                if nums1[i] > max1 or nums2[i] > max2:\n                    return float('inf')\n                if nums1[i] != max1 and nums2[i] != max2:\n                    if check_swap(i):\n                        swaps += 1\n                    else:\n                        return float('inf')\n            return swaps\n        \n        min_swaps = count_swaps()\n        if min_swaps == float('inf'):\n            return -1\n        return min_swaps"
        ]
    },
    {
        "question_id": "3192",
        "code_list": [
            "class Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Convert a and b to binary strings with leading zeros to match the length 2^n\n        a_bin = bin(a)[2:].zfill(n)\n        b_bin = bin(b)[2:].zfill(n)\n        \n        max_product = 0\n        \n        # Iterate over all possible values of x from 0 to 2^n - 1\n        for x in range(2**n):\n            x_bin = bin(x)[2:].zfill(n)\n            \n            # Calculate the XOR values\n            a_xor_x = int(a_bin, 2) ^ int(x_bin, 2)\n            b_xor_x = int(b_bin, 2) ^ int(x_bin, 2)\n            \n            # Calculate the product and update max_product if this is the maximum found so far\n            product = (a_xor_x * b_xor_x) % MOD\n            max_product = max(max_product, product)\n        \n        return max_product"
        ]
    },
    {
        "question_id": "3193",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        max_xor = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if abs(nums[i] - nums[j]) <= min(nums[i], nums[j]):\n                    max_xor = max(max_xor, nums[i] ^ nums[j])\n        return max_xor"
        ]
    },
    {
        "question_id": "3194",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        result_indices = []\n        for index, word in enumerate(words):\n            if x in word:\n                result_indices.append(index)\n        return result_indices"
        ]
    },
    {
        "question_id": "3195",
        "code_list": [
            "class Solution:\n    def minimumSteps(self, s: str) -> int:\n        steps = 0\n        zero_count = 0\n        \n        for i in range(len(s)):\n            if s[i] == '0':\n                zero_count += 1\n            else:\n                steps += i - zero_count\n        \n        return steps"
        ]
    },
    {
        "question_id": "3196",
        "code_list": [
            "from typing import List\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        sl = SortedList()\n        max_freq = 0\n        \n        for right in range(n):\n            sl.add(nums[right])\n            while sl[-1] - sl[0] > k:\n                sl.remove(nums[left])\n                left += 1\n            max_freq = max(max_freq, right - left + 1)\n        \n        return max_freq"
        ]
    },
    {
        "question_id": "3199",
        "code_list": [
            "from itertools import product\n\nclass Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        return sum(1 for distribution in product(range(limit + 1), repeat=3) if sum(distribution) == n)"
        ]
    },
    {
        "question_id": "3200",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def stringCount(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(length, has_le, has_e, has_t):\n            if length == n:\n                return 1 if has_le and has_e and has_t else 0\n            count = 0\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                if char == 'l' and not has_le:\n                    count += dp(length + 1, True, has_e, has_t)\n                elif char == 'e' and not has_e:\n                    count += dp(length + 1, has_le, True, has_t)\n                elif char == 't' and not has_t:\n                    count += dp(length + 1, has_le, has_e, True)\n                else:\n                    count += dp(length + 1, has_le, has_e, has_t)\n            return count % MOD\n        \n        return dp(0, False, False, False)"
        ]
    },
    {
        "question_id": "3203",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        def check_palindrome(s1, s2):\n            return all(s1[i] == s2[~i] for i in range(len(s1) // 2))\n        \n        def transform_query(query):\n            a, b, c, d = query\n            return (a, b, len(s) - d - 1, len(s) - c - 1)\n        \n        results = []\n        for query in queries:\n            transformed_query = transform_query(query)\n            a, b, c, d = transformed_query\n            \n            # Check if the two halves can form a palindrome\n            left_half = s[:b+1]\n            right_half = s[d:]\n            if check_palindrome(left_half, right_half):\n                results.append(True)\n            else:\n                results.append(False)\n        \n        return results"
        ]
    },
    {
        "question_id": "3206",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        set_nums1 = set(nums1)\n        set_nums2 = set(nums2)\n        \n        count_in_nums2 = sum(1 for num in nums1 if num in set_nums2)\n        count_in_nums1 = sum(1 for num in nums2 if num in set_nums1)\n        \n        return [count_in_nums2, count_in_nums1]"
        ]
    },
    {
        "question_id": "3207",
        "code_list": [
            "class Solution:\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        # Find the common prefix length of the three strings\n        min_length = min(len(s1), len(s2), len(s3))\n        common_prefix_length = 0\n        \n        for i in range(min_length):\n            if s1[i] == s2[i] == s3[i]:\n                common_prefix_length += 1\n            else:\n                break\n        \n        # If there is no common prefix, it's impossible to make the strings equal\n        if common_prefix_length == 0:\n            return -1\n        \n        # Calculate the total number of deletions needed\n        total_deletions = (len(s1) - common_prefix_length) + (len(s2) - common_prefix_length) + (len(s3) - common_prefix_length)\n        \n        return total_deletions"
        ]
    },
    {
        "question_id": "3209",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            # Option 1: Buy the current fruit\n            dp[i] = min(dp[i], dp[i - 1] + prices[i - 1])\n            # Option 2: Skip the current fruit and buy the next i fruits\n            for j in range(i + 1, min(n + 1, i + i + 1)):\n                dp[j] = min(dp[j], dp[i - 1] + prices[i - 1])\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "3210",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        vowels = set('aeiou')\n        prefix_sum = 0\n        count = 0\n        seen = defaultdict(int)\n        seen[0] = 1\n        \n        for i, char in enumerate(s):\n            prefix_sum += 1 if char in vowels else -1\n            if prefix_sum % 2 != 0:\n                continue\n            \n            # Check if the current prefix sum is valid for the condition (prefix_sum * (prefix_sum // 2)) % k == 0\n            if prefix_sum % k == 0:\n                count += seen[prefix_sum // 2]\n            \n            seen[prefix_sum // 2] += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3211",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findMaximumLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [1] * n  # dp[i] represents the max length of non-decreasing subarray ending at i\n        \n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] <= nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"
        ]
    },
    {
        "question_id": "3212",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        last_occurrence = {}\n        for i, num in enumerate(nums):\n            last_occurrence[num] = i\n        \n        partitions = 1\n        start, end = 0, 0\n        for i, num in enumerate(nums):\n            end = max(end, last_occurrence[num])\n            if i == end:\n                partitions *= 2\n                partitions %= (10**9 + 7)\n        \n        return partitions - 1"
        ]
    },
    {
        "question_id": "3213",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        max_num = max(nums)\n        n = len(nums)\n        left = 0\n        count = 0\n        result = 0\n        \n        for right in range(n):\n            if nums[right] == max_num:\n                count += 1\n            \n            while count >= k:\n                if nums[left] == max_num:\n                    count -= 1\n                left += 1\n            \n            result += left\n        \n        return result"
        ]
    },
    {
        "question_id": "3219",
        "code_list": [
            "from typing import List\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        n = len(nums)\n        sorted_nums = sorted(zip(nums, range(n)))\n        groups = []\n        start = 0\n        \n        for i in range(1, n):\n            if sorted_nums[i][0] - sorted_nums[start][0] > limit:\n                groups.append(sorted_nums[start:i])\n                start = i\n        \n        groups.append(sorted_nums[start:])\n        \n        result = [0] * n\n        for group in groups:\n            indices = [i[1] for i in group]\n            values = [i[0] for i in group]\n            values.sort()\n            \n            for idx, val in zip(indices, values):\n                result[idx] = val\n        \n        return result"
        ]
    },
    {
        "question_id": "3220",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        tested_count = 0\n        for i in range(len(batteryPercentages)):\n            if batteryPercentages[i] > 0:\n                tested_count += 1\n                for j in range(i + 1, len(batteryPercentages)):\n                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1)\n        return tested_count"
        ]
    },
    {
        "question_id": "3221",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        peaks = []\n        for i in range(1, len(mountain) - 1):\n            if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\n                peaks.append(i)\n        return peaks"
        ]
    },
    {
        "question_id": "3223",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        def is_valid(sub):\n            counter = Counter(sub)\n            for char, freq in counter.items():\n                if freq % k != 0 or (ord(char) - ord('a') > 2 and ord(char) - ord('a') < 23):\n                    return False\n            return True\n        \n        n = len(word)\n        result = 0\n        i = 0\n        while i < n:\n            j = i\n            while j < n and abs(ord(word[j]) - ord(word[j-1])) <= 2:\n                j += 1\n            sub = word[i:j]\n            if is_valid(sub):\n                result += 1\n            i = j\n        return result"
        ]
    },
    {
        "question_id": "3224",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Calculate gaps between consecutive sick children\n        gaps = []\n        for i in range(1, len(sick)):\n            gaps.append(sick[i] - sick[i - 1] - 1)\n        gaps.append(sick[0])\n        gaps.append(n - 1 - sick[-1])\n        \n        # Calculate the product of combinations for each gap\n        total_sequences = 1\n        for gap in gaps:\n            if gap > 1:\n                total_sequences *= pow(2, gap - 1, MOD)\n                total_sequences %= MOD\n        \n        return total_sequences"
        ]
    },
    {
        "question_id": "3225",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        freq_map = defaultdict(int)\n        left = 0\n        max_length = 0\n        \n        for right in range(len(nums)):\n            freq_map[nums[right]] += 1\n            \n            while freq_map[nums[right]] > k:\n                freq_map[nums[left]] -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3226",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        arr = []\n        while nums:\n            bob_move = nums.pop(0)\n            alice_move = nums.pop(0)\n            arr.append(bob_move)\n            arr.append(alice_move)\n        return arr"
        ]
    },
    {
        "question_id": "3227",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        # Flatten the grid into a single list\n        flat_grid = [num for row in grid for num in row]\n        \n        # Count the occurrences of each number\n        count = Counter(flat_grid)\n        \n        # Find the repeated number (appears twice)\n        repeated = [num for num, freq in count.items() if freq == 2][0]\n        \n        # Find the missing number (appears only once)\n        n = len(grid)\n        all_numbers = set(range(1, n*n + 1))\n        present_numbers = set(flat_grid)\n        missing = list(all_numbers - present_numbers)[0]\n        \n        return [repeated, missing]"
        ]
    },
    {
        "question_id": "3228",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        half_n = n // 2\n        \n        count1, count2 = Counter(nums1), Counter(nums2)\n        common_elements = (count1 & count2).elements()\n        \n        unique_to_nums1 = set(nums1) - set(nums2)\n        unique_to_nums2 = set(nums2) - set(nums1)\n        \n        unique_count1 = min(len(unique_to_nums1), half_n - sum(1 for _ in common_elements))\n        unique_count2 = min(len(unique_to_nums2), half_n - unique_count1)\n        \n        return unique_count1 + unique_count2 + min(half_n, sum(1 for _ in common_elements))"
        ]
    },
    {
        "question_id": "3229",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort()\n        median = nums[n // 2]\n        \n        def is_palindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        def get_closest_palindrome(num):\n            lower, upper = num, num\n            while True:\n                if is_palindrome(lower):\n                    return lower\n                if is_palindrome(upper):\n                    return upper\n                lower -= 1\n                upper += 1\n        \n        closest_palindrome = get_closest_palindrome(median)\n        cost = sum(abs(num - closest_palindrome) for num in nums)\n        \n        # Check if there's another palindrome closer to the median\n        next_palindrome = get_closest_palindrome(closest_palindrome + 1)\n        next_cost = sum(abs(num - next_palindrome) for num in nums)\n        \n        return min(cost, next_cost)"
        ]
    },
    {
        "question_id": "3230",
        "code_list": [
            "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        operations = 0\n        i = 0\n        while i < len(word) - 1:\n            if abs(ord(word[i]) - ord(word[i + 1])) <= 1:\n                operations += 1\n                i += 2\n            else:\n                i += 1\n        return operations"
        ]
    },
    {
        "question_id": "3231",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        added_coins = 0\n        max_reachable = 0\n        \n        coins.sort()\n        i = 0\n        \n        while max_reachable < target:\n            while i < len(coins) and coins[i] <= max_reachable + 1:\n                max_reachable += coins[i]\n                i += 1\n            \n            if max_reachable >= target:\n                break\n            \n            # If the next coin is greater than max_reachable + 1, we need to add a coin equal to max_reachable + 1\n            added_coins += 1\n            max_reachable += max_reachable + 1\n        \n        return added_coins"
        ]
    },
    {
        "question_id": "3233",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n        def count_partitions(s, k):\n            partitions = 0\n            start = 0\n            char_count = Counter()\n            for end in range(len(s)):\n                char_count[s[end]] += 1\n                while len(char_count) > k:\n                    char_count[s[start]] -= 1\n                    if char_count[s[start]] == 0:\n                        del char_count[s[start]]\n                    start += 1\n                if end - start + 1 == len(s) or len(char_count) < k:\n                    partitions += 1\n            return partitions\n        \n        original_partitions = count_partitions(s, k)\n        max_partitions = original_partitions\n        for i in range(len(s)):\n            for new_char in set('abcdefghijklmnopqrstuvwxyz') - {s[i]}:\n                new_s = s[:i] + new_char + s[i+1:]\n                max_partitions = max(max_partitions, count_partitions(new_s, k))\n        \n        return max_partitions"
        ]
    },
    {
        "question_id": "3234",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        good_indices = []\n        for i, (a, b, c, m) in enumerate(variables):\n            result = pow(pow(a, b, 10), c, m)\n            if result == target:\n                good_indices.append(i)\n        return good_indices"
        ]
    },
    {
        "question_id": "3235",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        # Create a graph to store the minimum cost to transform one character to another\n        graph = defaultdict(dict)\n        for o, c, co in zip(original, changed, cost):\n            if c not in graph[o]:\n                graph[o][c] = co\n            else:\n                graph[o][c] = min(graph[o][c], co)\n        \n        # Floyd-Warshall algorithm to find the shortest path between all pairs of characters\n        for k in graph:\n            for i in graph:\n                for j in graph:\n                    if i in graph[k] and j in graph[k] and (j not in graph[i] or graph[i][j] > graph[i][k] + graph[k][j]):\n                        graph[i][j] = graph[i][k] + graph[k][j]\n        \n        # Calculate the total cost to transform source to target\n        total_cost = 0\n        for s, t in zip(source, target):\n            if t not in graph[s]:\n                return -1\n            total_cost += graph[s][t]\n        \n        return total_cost"
        ]
    },
    {
        "question_id": "3236",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 1\n        \n        # Find the longest sequential prefix\n        longest_prefix_sum = nums[0]\n        current_streak = True\n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1:\n                longest_prefix_sum += nums[i]\n            else:\n                current_streak = False\n                break\n        \n        # If the entire array is sequential, just check the last element\n        if current_streak:\n            return longest_prefix_sum + 1\n        \n        # Check for the smallest missing integer starting from the sum of the longest sequential prefix\n        target = longest_prefix_sum\n        seen = set(nums)\n        while target in seen:\n            target += 1\n        \n        return target"
        ]
    },
    {
        "question_id": "3239",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:\n        queue = deque([(x, 0)])\n        visited = set([x])\n        \n        while queue:\n            current, steps = queue.popleft()\n            \n            if current == y:\n                return steps\n            \n            # Divide by 11 if possible\n            if current % 11 == 0 and current // 11 not in visited:\n                visited.add(current // 11)\n                queue.append((current // 11, steps + 1))\n            \n            # Divide by 5 if possible\n            if current % 5 == 0 and current // 5 not in visited:\n                visited.add(current // 5)\n                queue.append((current // 5, steps + 1))\n            \n            # Decrement by 1\n            if current - 1 not in visited:\n                visited.add(current - 1)\n                queue.append((current - 1, steps + 1))\n            \n            # Increment by 1\n            if current + 1 not in visited:\n                visited.add(current + 1)\n                queue.append((current + 1, steps + 1))\n        \n        return -1  # This line should theoretically never be reached with valid inputs"
        ]
    },
    {
        "question_id": "3240",
        "code_list": [
            "class Solution:\n    def findMaximumNumber(self, k: int, x: int) -> int:\n        def count_set_bits_in_range(n, x):\n            count = 0\n            for i in range(x - 1, n + 1, x):\n                count += (n // (1 << i)) + 1\n            return count\n        \n        low, high = 1, k\n        while low < high:\n            mid = (low + high + 1) // 2\n            if count_set_bits_in_range(mid, x) > k:\n                high = mid - 1\n            else:\n                low = mid\n        return low"
        ]
    },
    {
        "question_id": "3242",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        freq_counter = Counter(nums)\n        max_freq = max(freq_counter.values())\n        return sum(count for count in freq_counter.values() if count == max_freq)"
        ]
    },
    {
        "question_id": "3243",
        "code_list": [
            "from math import log10\n\nclass Solution:\n    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:\n        def count_numbers(n, k):\n            if n < len(s):\n                return 0\n            prefix = str(n)[:len(str(n)) - len(s)]\n            suffix = str(n)[-len(s):]\n            if suffix != s:\n                return 0\n            count = 0\n            for i in range(len(prefix)):\n                if prefix[i] == '0':\n                    continue\n                if int(prefix[i]) > k:\n                    break\n                if int(prefix[i]) < k:\n                    count += (k + 1) * (10 ** (len(prefix) - i - 1))\n                else:\n                    count += (n // (10 ** (len(prefix) - i)) % 10 - int(prefix[i])) * (10 ** (len(prefix) - i - 1))\n                    break\n            else:\n                count += 1\n            return count\n        \n        start_str = str(start)\n        finish_str = str(finish)\n        start_suffix = start_str[-len(s):]\n        finish_prefix = finish_str[:-len(s)]\n        \n        if start_suffix != s:\n            start = int(start_str[:-len(s)] + s)\n        else:\n            start = start\n        \n        if finish_prefix != '':\n            finish = int(finish_str[:-len(s)] + s)\n        else:\n            finish = finish + 1\n        \n        return count_numbers(finish, limit) - count_numbers(start, limit)"
        ]
    },
    {
        "question_id": "3244",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        min_val = min(nums)\n        count_min = nums.count(min_val)\n        \n        for num in nums:\n            if num % min_val != 0:\n                return 1\n        \n        return max(1, count_min - 1)"
        ]
    },
    {
        "question_id": "3245",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        a_indices = []\n        b_indices = []\n        \n        # Find all occurrences of 'a' in s\n        for i in range(len(s) - len(a) + 1):\n            if s[i:i+len(a)] == a:\n                a_indices.append(i)\n        \n        # Find all occurrences of 'b' in s\n        for i in range(len(s) - len(b) + 1):\n            if s[i:i+len(b)] == b:\n                b_indices.append(i)\n        \n        beautiful_indices = []\n        \n        # Check each occurrence of 'a' to see if there's a matching 'b' within the range\n        for i in a_indices:\n            for j in b_indices:\n                if abs(j - i) <= k:\n                    beautiful_indices.append(i)\n                    break\n        \n        return sorted(set(beautiful_indices))"
        ]
    },
    {
        "question_id": "3246",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        # Check if there are at least two even numbers in the list\n        return sum(1 for num in nums if num % 2 == 0) >= 2"
        ]
    },
    {
        "question_id": "3249",
        "code_list": [
            "from functools import reduce\nfrom operator import xor\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        target_xor = k\n        current_xor = reduce(xor, nums, 0)\n        diff_xor = current_xor ^ target_xor\n        \n        # Count the number of set bits in diff_xor, which represents the minimum operations needed\n        return bin(diff_xor).count('1')"
        ]
    },
    {
        "question_id": "3251",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n        max_area = 0\n        max_diagonal_squared = 0\n        \n        for length, width in dimensions:\n            diagonal_squared = length ** 2 + width ** 2\n            area = length * width\n            \n            if diagonal_squared > max_diagonal_squared or (diagonal_squared == max_diagonal_squared and area > max_area):\n                max_diagonal_squared = diagonal_squared\n                max_area = area\n        \n        return max_area"
        ]
    },
    {
        "question_id": "3252",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        n = len(nums)\n        left, right = 0, n - 1\n        \n        # Find the longest prefix that is strictly increasing\n        while left < n - 1 and nums[left] < nums[left + 1]:\n            left += 1\n        \n        # If the whole array is already strictly increasing\n        if left == n - 1:\n            return (n * (n + 1)) // 2\n        \n        # Find the longest suffix that is strictly increasing\n        while right > 0 and nums[right - 1] < nums[right]:\n            right -= 1\n        \n        count = 0\n        \n        # Case 1: Removing the entire array makes it strictly increasing\n        count += 1\n        \n        # Case 2: Removing a subarray starting from the beginning\n        for i in range(left + 1):\n            j = bisect_right(nums, nums[i], right, n)\n            if j == n or nums[j] > nums[i]:\n                count += (n - j + 1)\n        \n        # Case 3: Removing a subarray ending at the end\n        for j in range(right, n):\n            i = bisect_left(nums, nums[j], 0, left + 1)\n            if i == left + 1 or nums[i - 1] < nums[j]:\n                count += (i)\n        \n        # Case 4: Removing a subarray that starts from the beginning and ends at the end\n        for i in range(left + 1):\n            j = bisect_right(nums, nums[i], right, n)\n            if j == n or nums[j] > nums[i]:\n                k = bisect_left(nums, nums[j], 0, i)\n                if k == i or nums[k - 1] < nums[j]:\n                    count += (n - j + 1) - (i - k)\n        \n        return count"
        ]
    },
    {
        "question_id": "3261",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        # Precompute the prefix OR values\n        prefix_or = [0] * (n + 1)\n        for i in range(n):\n            prefix_or[i + 1] = prefix_or[i] | nums[i]\n        \n        # Function to check if we can reduce the OR value to target using at most k operations\n        def can_reduce_to_target(target: int) -> bool:\n            operations_needed = 0\n            for i in range(n):\n                current_or = prefix_or[i + 1]\n                if current_or & target == target:\n                    continue\n                # Find the rightmost position where we can perform an operation to reduce the OR value\n                j = i\n                while j < n and (prefix_or[j + 1] & target != target):\n                    j += 1\n                if j == n:\n                    return False\n                operations_needed += j - i\n                i = j - 1\n            return operations_needed <= k\n        \n        # Binary search to find the minimum possible OR value\n        low, high = 0, (1 << 30) - 1\n        while low < high:\n            mid = (low + high) // 2\n            if can_reduce_to_target(mid):\n                high = mid\n            else:\n                low = mid + 1\n        \n        return low"
        ]
    },
    {
        "question_id": "3262",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        for i in range(len(nums) - 2):\n            if nums[i] < nums[i + 1] + nums[i + 2]:\n                return nums[i] + nums[i + 1] + nums[i + 2]\n        return -1"
        ]
    },
    {
        "question_id": "3263",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        # The cost of the first subarray is always the first element of nums\n        first_cost = nums[0]\n        # Initialize the minimum cost with the sum of the first two elements\n        min_cost = first_cost + nums[1]\n        # Find the minimum element among the last n-2 elements (excluding the first two)\n        for i in range(2, len(nums) - 1):\n            min_cost = min(min_cost, nums[i])\n        # Return the sum of the first element and the minimum of the last two elements\n        return first_cost + min_cost"
        ]
    },
    {
        "question_id": "3265",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        prefix_sum = [0]\n        min_prefix_sum = [0]\n        dp = defaultdict(lambda: float('inf'))\n        max_sum = float('-inf')\n        \n        for i, num in enumerate(nums):\n            prefix_sum.append(prefix_sum[-1] + num)\n            min_prefix_sum.append(min(min_prefix_sum[-1], prefix_sum[-1]))\n            \n            # Check for subarrays ending at current index with absolute difference k\n            for prev_num in [num - k, num + k]:\n                if prev_num in dp:\n                    start_index = dp[prev_num]\n                    current_sum = prefix_sum[i + 1] - min_prefix_sum[start_index]\n                    max_sum = max(max_sum, current_sum)\n                    \n            # Update the earliest occurrence of the current number\n            dp[num] = i + 1\n        \n        return max_sum if max_sum != float('-inf') else 0"
        ]
    },
    {
        "question_id": "3267",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maximumLength(self, s: str) -> int:\n        # Dictionary to store the count of each special substring length\n        count = defaultdict(list)\n        \n        # Iterate through the string to find all special substrings\n        i = 0\n        while i < len(s):\n            j = i + 1\n            while j < len(s) and s[j] == s[i]:\n                j += 1\n            length = j - i\n            while length > 0:\n                count[s[i]].append(length)\n                length -= 1\n            i = j\n        \n        max_length = -1\n        # Check each character's special substrings\n        for char, lengths in count.items():\n            # Sort the lengths in descending order\n            lengths.sort(reverse=True)\n            # Check if the top three lengths occur at least thrice\n            if len(lengths) >= 3 and lengths[0] == lengths[1] == lengths[2]:\n                max_length = max(max_length, lengths[0])\n            elif len(lengths) >= 4 and lengths[0] == lengths[1] == lengths[2] == lengths[3]:\n                max_length = max(max_length, lengths[0])\n            elif len(lengths) >= 5 and lengths[0] == lengths[1] == lengths[2] == lengths[3] == lengths[4]:\n                max_length = max(max_length, lengths[0])\n            elif len(lengths) >= 6 and lengths[0] == lengths[1] == lengths[2] == lengths[3] == lengths[4] == lengths[5]:\n                max_length = max(max_length, lengths[0])\n            elif len(lengths) >= 7 and lengths[0] == lengths[1] == lengths[2] == lengths[3] == lengths[4] == lengths[5] == lengths[6]:\n                max_length = max(max_length, lengths[0])\n            elif len(lengths) >= 8 and lengths[0] == lengths[1] == lengths[2] == lengths[3] == lengths[4] == lengths[5] == lengths[6] == lengths[7]:\n                max_length = max(max_length, lengths[0])\n            elif len(lengths) >= 9 and lengths[0] == lengths[1] == lengths[2] == lengths[3] == lengths[4] == lengths[5] == lengths[6] == lengths[7] == lengths[8]:\n                max_length = max(max_length, lengths[0])\n            elif len(lengths) >= 10 and lengths[0] == lengths[1] == lengths[2] == lengths[3] == lengths[4] == lengths[5] == lengths[6] == lengths[7] == lengths[8] == lengths[9]:\n                max_length = max(max_length, lengths[0])\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3269",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        m = len(pattern)\n        \n        for i in range(n - m):\n            matches = True\n            for j in range(m):\n                if pattern[j] == 1 and nums[i + j + 1] <= nums[i + j]:\n                    matches = False\n                    break\n                elif pattern[j] == 0 and nums[i + j + 1] != nums[i + j]:\n                    matches = False\n                    break\n                elif pattern[j] == -1 and nums[i + j + 1] >= nums[i + j]:\n                    matches = False\n                    break\n            if matches:\n                count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3279",
        "code_list": [
            "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        # If both n and m are even or both are odd, Alice cannot guarantee a win\n        if (n % 2 == m % 2):\n            return 0\n        \n        # Calculate the number of valid pairs\n        # For each odd x in [1, n], there are (m // 2 + 1) choices for y\n        # For each even x in [1, n], there are (m // 2) choices for y\n        # Similarly, for each odd y in [1, m], there are (n // 2 + 1) choices for x\n        # For each even y in [1, m], there are (n // 2) choices for x\n        odd_n = n // 2\n        even_n = n - odd_n\n        odd_m = m // 2\n        even_m = m - odd_m\n        \n        result = (odd_n * (even_m + odd_m) + even_n * odd_m)\n        return result"
        ]
    },
    {
        "question_id": "3291",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        n = len(nums)\n        for i in range(n - 1):\n            while i < n - 1 and nums[i] > nums[i + 1]:\n                # Find the next element with the same number of set bits as nums[i]\n                j = i + 1\n                while j < n and self.count_set_bits(nums[j]) != self.count_set_bits(nums[i]):\n                    j += 1\n                if j == n:\n                    return False\n                nums[i], nums[j] = nums[j], nums[i]\n                i = j - 1\n            i += 1\n        return True\n    \n    def count_set_bits(self, num: int) -> int:\n        count = 0\n        while num:\n            count += num & 1\n            num >>= 1\n        return count"
        ]
    },
    {
        "question_id": "3292",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n, m = len(nums), len(changeIndices)\n        marked = [False] * n\n        earliest = [float('inf')] * n\n        \n        for s in range(m):\n            idx = changeIndices[s] - 1\n            if marked[idx]:\n                continue\n            marked[idx] = True\n            earliest[idx] = min(earliest[idx], s + 1)\n        \n        if not all(marked):\n            return -1\n        \n        def can_mark_all_in_t(t):\n            remaining_time = t\n            for i in range(n):\n                if nums[i] > 0:\n                    required_time = nums[i] + earliest[i] - 1\n                    if required_time > t:\n                        return False\n                    remaining_time -= required_time\n            return remaining_time >= 0\n        \n        left, right = 1, m\n        while left < right:\n            mid = (left + right) // 2\n            if can_mark_all_in_t(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"
        ]
    },
    {
        "question_id": "3297",
        "code_list": [
            "class Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        length = len(word)\n        time = 1\n        while True:\n            # Remove the first k characters\n            word = word[k:]\n            # Check if the remaining word matches the original word starting from some point\n            for i in range(length - len(word) + 1):\n                if word == word[i:]:\n                    return time\n            time += 1"
        ]
    },
    {
        "question_id": "3298",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSelectedElements(self, nums: List[int]) -> int:\n        nums.sort()\n        dp = {}\n        \n        def dfs(index, prev):\n            if index == len(nums):\n                return 0\n            if (index, prev) in dp:\n                return dp[(index, prev)]\n            \n            # Option 1: Skip current element\n            skip = dfs(index + 1, prev)\n            \n            # Option 2: Include current element\n            include = 0\n            if prev is None or prev + 1 == nums[index]:\n                include = 1 + dfs(index + 1, nums[index])\n            elif prev + 2 == nums[index]:\n                include = 1 + dfs(index + 1, nums[index] - 1)\n            \n            dp[(index, prev)] = max(skip, include)\n            return dp[(index, prev)]\n        \n        return dfs(0, None)"
        ]
    },
    {
        "question_id": "3299",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        num_counts = Counter(nums)\n        max_length = 1\n        \n        for num in num_counts:\n            if num == 1:\n                # Special case for 1, as 1^k will always be 1\n                length = 2 * num_counts[1] - (num_counts[1] % 2)\n                max_length = max(max_length, length)\n                continue\n            \n            current_length = 0\n            while num_counts[num] >= 2 and num_counts[num**2]:\n                num_counts[num] -= 2\n                num_counts[num**2] -= 1\n                current_length += 2\n            \n            if num_counts[num] >= 1:\n                current_length += 1\n            max_length = max(max_length, current_length)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3308",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def lastNonEmptyString(self, s: str) -> str:\n        char_count = Counter(s)\n        max_count = max(char_count.values())\n        result = []\n        \n        for char in reversed(s):\n            if char_count[char] == max_count:\n                result.append(char)\n                char_count[char] -= 1\n        \n        return ''.join(reversed(result))"
        ]
    },
    {
        "question_id": "3309",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        def isPrefixAndSuffix(str1: str, str2: str) -> bool:\n            return str2.startswith(str1) and str2.endswith(str1)\n        \n        count = 0\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if isPrefixAndSuffix(words[i], words[j]):\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3311",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        position = 0\n        boundary_count = 0\n        \n        for num in nums:\n            position += num\n            if position == 0:\n                boundary_count += 1\n        \n        return boundary_count"
        ]
    },
    {
        "question_id": "3312",
        "code_list": [
            "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        count = 0\n        prev_char = s[0].lower()\n        for char in s[1:]:\n            current_char = char.lower()\n            if current_char != prev_char:\n                count += 1\n                prev_char = current_char\n        return count"
        ]
    },
    {
        "question_id": "3317",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:\n        # Count the frequency of each character in all words\n        char_count = Counter()\n        for word in words:\n            char_count.update(word)\n        \n        # Calculate the total number of pairs of characters\n        pairs = sum(count // 2 for count in char_count.values())\n        \n        # Sort the lengths of the words\n        lengths = sorted(len(word) for word in words)\n        \n        # Try to form as many palindromes as possible\n        result = 0\n        for length in lengths:\n            # A palindrome of length `n` needs `n // 2` pairs of characters\n            if pairs >= length // 2:\n                pairs -= length // 2\n                result += 1\n            else:\n                break\n        \n        return result"
        ]
    },
    {
        "question_id": "3320",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        \n        target_score = nums[0] + nums[1]\n        operations_count = 0\n        \n        i = 0\n        while i < len(nums) - 1:\n            if nums[i] + nums[i + 1] == target_score:\n                operations_count += 1\n                i += 2\n            else:\n                break\n        \n        return operations_count"
        ]
    },
    {
        "question_id": "3324",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        from collections import Counter\n        \n        # Count the occurrences of each element in the array\n        count = Counter(nums)\n        \n        # Check if any element appears more than twice\n        for val in count.values():\n            if val > 2:\n                return False\n        \n        # If no element appears more than twice, it's possible to split the array\n        return True"
        ]
    },
    {
        "question_id": "3329",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        def get_prefixes(num):\n            prefixes = set()\n            num_str = str(num)\n            for i in range(1, len(num_str) + 1):\n                prefixes.add(int(num_str[:i]))\n            return prefixes\n        \n        max_length = 0\n        prefixes_arr1 = {num: get_prefixes(num) for num in arr1}\n        prefixes_arr2 = {num: get_prefixes(num) for num in arr2}\n        \n        for num1 in prefixes_arr1:\n            for num2 in prefixes_arr2:\n                common_prefixes = prefixes_arr1[num1].intersection(prefixes_arr2[num2])\n                if common_prefixes:\n                    max_length = max(max_length, max(common_prefixes).bit_length())\n        \n        return max_length - 1 if max_length else 0"
        ]
    },
    {
        "question_id": "3331",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        count = 0\n        while min(nums) < k:\n            nums.remove(min(nums))\n            count += 1\n        return count"
        ]
    },
    {
        "question_id": "3347",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        arr1, arr2 = [nums[0]], [nums[1]]\n        for i in range(2, len(nums)):\n            if arr1[-1] > arr2[-1]:\n                arr1.append(nums[i])\n            else:\n                arr2.append(nums[i])\n        return arr1 + arr2"
        ]
    },
    {
        "question_id": "abc301_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n\n    taka_wins = S.count('T')\n    aoki_wins = S.count('A')\n\n    if taka_wins > aoki_wins:\n        print('T')\n    elif aoki_wins > taka_wins:\n        print('A')\n    else:\n        # Check who reached the number of wins first\n        taka_first = S.rfind('T') < S.find('A')\n        if taka_first:\n            print('T')\n        else:\n            print('A')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_sequence(A):\n        N = len(A)\n        i = 0\n        \n        while True:\n            for i in range(N - 1):\n                if abs(A[i] - A[i + 1]) == 1:\n                    continue\n                else:\n                    break\n            else:\n                return A\n            \n            if A[i] < A[i + 1]:\n                insert_values = list(range(A[i] + 1, A[i + 1]))\n            else:\n                insert_values = list(range(A[i] - 1, A[i + 1], -1))\n            \n            A = A[:i + 1] + insert_values + A[i + 1:]\n            N += len(insert_values)\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    result = process_sequence(A)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_c",
        "code_list": [
            "def can_win_game(S, T):\n    # Count the frequency of each character in both strings\n    freq_S = [0] * 26\n    freq_T = [0] * 26\n    \n    for char in S:\n        if char != '@':\n            freq_S[ord(char) - ord('a')] += 1\n    \n    for char in T:\n        if char != '@':\n            freq_T[ord(char) - ord('a')] += 1\n    \n    # Check if we can make the remaining '@'s match the required characters\n    for i in range(26):\n        if freq_S[i] < freq_T[i]:\n            return \"No\"\n    \n    # Check if we can make the remaining '@'s match the required characters in reverse\n    for i in range(25, -1, -1):\n        if freq_S[i] > freq_T[i]:\n            return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    T = input().strip()\n    print(can_win_game(S, T))"
        ]
    },
    {
        "question_id": "abc301_d",
        "code_list": [
            "def main():\n    import re\n    \n    def find_max_value(S, N):\n        max_value = -1\n        for i in range(2 ** S.count('?')):\n            binary_str = bin(i)[2:].zfill(S.count('?'))\n            temp_str = S\n            for j, char in enumerate(binary_str):\n                temp_str = temp_str[:j] + char + temp_str[j+1:]\n            value = int(temp_str, 2)\n            if value <= N:\n                max_value = max(max_value, value)\n        return max_value\n    \n    S = input().strip()\n    N = int(input())\n    \n    print(find_max_value(S, N))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_e",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start, goal, candies):\n    H, W = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[False] * W for _ in range(H)]\n    queue = deque([(start, 0)])\n    max_candies = -1\n    \n    while queue:\n        (x, y), candies_visited = queue.popleft()\n        \n        if (x, y) == goal:\n            max_candies = max(max_candies, candies_visited)\n            continue\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and grid[nx][ny] != '#':\n                visited[nx][ny] = True\n                if grid[nx][ny] == 'o':\n                    queue.append(((nx, ny), candies_visited + 1))\n                else:\n                    queue.append(((nx, ny), candies_visited))\n    \n    return max_candies\n\ndef main():\n    H, W, T = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    start = None\n    goal = None\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n    \n    max_candies = bfs(grid, start, goal, [])\n    \n    if max_candies > T:\n        max_candies = -1\n    \n    print(max_candies)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_f",
        "code_list": [
            "def count_valid_strings(S):\n    MOD = 998244353\n    n = len(S)\n    \n    # Count the number of '?' in the string\n    q = S.count('?')\n    \n    # Initialize the DP table\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    # Count the number of valid strings for each position\n    for i in range(n):\n        if S[i] == '?':\n            dp[i + 1] = (dp[i] * 52) % MOD\n        elif S[i].isupper():\n            dp[i + 1] = dp[i]\n        else:  # S[i] is a lowercase letter\n            dp[i + 1] = dp[i]\n            if i > 0 and S[i - 1].isupper() and S[i] != S[i - 1]:\n                dp[i + 1] -= dp[i - 1]\n                dp[i + 1] %= MOD\n    \n    # Calculate the total number of valid strings\n    total_valid = dp[n]\n    \n    # Subtract the invalid strings containing DDoS-type subsequences\n    for j in range(q):\n        total_valid -= dp[n - 4 + j] * 26\n        total_valid %= MOD\n    \n    return (total_valid + MOD) % MOD\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(count_valid_strings(S))"
        ]
    },
    {
        "question_id": "abc302_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    attacks = (A + B - 1) // B\n    print(attacks)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_b",
        "code_list": [
            "def find_sequence(H, W, grid):\n    directions = [\n        (0, 1), (1, 1), (1, 0), (1, -1),\n        (0, -1), (-1, -1), (-1, 0), (-1, 1)\n    ]\n    \n    def check_sequence(r, c, direction):\n        for i in range(5):\n            nr, nc = r + direction[0] * i, c + direction[1] * i\n            if not (0 <= nr < H and 0 <= nc < W):\n                return False\n            if grid[nr][nc] != 'snukes'[i]:\n                return False\n        return True\n    \n    for r in range(H):\n        for c in range(W):\n            if grid[r][c] == 's':\n                for direction in directions:\n                    if check_sequence(r, c, direction):\n                        return [(r + direction[0] * i, c + direction[1] * i) for i in range(5)]\n    \n    return []\n\ndef main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    result = find_sequence(H, W, grid)\n    for r, c in result:\n        print(r + 1, c + 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_c",
        "code_list": [
            "def can_rearrange_strings(N, M, strings):\n    from collections import Counter\n    \n    # Count the frequency of each character in each position across all strings\n    char_counts = [Counter(s[i] for s in strings) for i in range(M)]\n    \n    # Check if the frequency of each character in each position is consistent\n    for i in range(M - 1):\n        for j in range(i + 1, M):\n            if len(char_counts[i]) != len(char_counts[j]):\n                return \"No\"\n            for char in char_counts[i]:\n                if char not in char_counts[j] or char_counts[i][char] != char_counts[j][char]:\n                    return \"No\"\n    \n    # If all checks pass, it's possible to rearrange the strings as required\n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    strings = [input().strip() for _ in range(N)]\n    print(can_rearrange_strings(N, M, strings))"
        ]
    },
    {
        "question_id": "abc302_d",
        "code_list": [
            "def find_max_sum(N, M, D, A, B):\n    # Sort the lists to facilitate binary search\n    A.sort()\n    B.sort()\n    \n    max_sum = -1\n    \n    # Iterate through each element in A\n    for a in A:\n        # Find the largest element in B that satisfies the condition\n        left, right = 0, M - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if a + B[mid] <= D:\n                max_sum = max(max_sum, a + B[mid])\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return max_sum\n\nif __name__ == \"__main__\":\n    N, M, D = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    result = find_max_sum(N, M, D, A, B)\n    print(result)"
        ]
    },
    {
        "question_id": "abc302_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    queries = []\n    for i in range(2, len(data), 3):\n        if data[i] == '1':\n            queries.append((data[i], int(data[i+1]), int(data[i+2])))\n        else:\n            queries.append((data[i], int(data[i+1])))\n    \n    # Initialize sets to keep track of connected components\n    parent = list(range(n + 1))\n    size = [1] * (n + 1)\n    component_count = n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if size[rootX] < size[rootY]:\n                rootX, rootY = rootY, rootX\n            parent[rootY] = rootX\n            size[rootX] += size[rootY]\n            nonlocal component_count\n            component_count -= 1\n    \n    def count_isolated_vertices():\n        return component_count - sum(size[root] == 1 for root in range(1, n + 1))\n    \n    results = []\n    for query_type, vertex in queries:\n        if query_type == '1':\n            union(vertex, vertex + 1)\n        else:\n            isolated_count = count_isolated_vertices()\n            for i in range(1, n + 1):\n                if find(i) == find(vertex):\n                    parent[i] = i\n                    size[i] = 1\n            results.append(isolated_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_f",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    sets = []\n    for _ in range(N):\n        A_i = int(input())\n        sets.append(set(map(int, input().split())))\n    \n    # Initialize the union-find structure\n    parent = list(range(M + 1))\n    size = [1] * (M + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if size[rootX] < size[rootY]:\n                rootX, rootY = rootY, rootX\n            parent[rootY] = rootX\n            size[rootX] += size[rootY]\n    \n    # Union all sets that have at least one common element\n    for i in range(N):\n        for j in range(i + 1, N):\n            if len(sets[i].intersection(sets[j])) > 0:\n                union(min(sets[i]), min(sets[j]))\n                union(max(sets[i]), max(sets[j]))\n    \n    # Check if 1 and M are connected\n    root1 = find(1)\n    rootM = find(M)\n    if root1 == rootM:\n        print(0)\n    else:\n        # Find the minimum number of operations\n        min_operations = float('inf')\n        for i in range(N):\n            for num in sets[i]:\n                if num == 1 or num == M:\n                    root = find(num)\n                    if root == root1 or root == rootM:\n                        min_operations = min(min_operations, len(sets[i]) - 1)\n        \n        if min_operations == float('inf'):\n            print(-1)\n        else:\n            print(min_operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc303_a",
        "code_list": [
            "def are_similar_strings(S: str, T: str) -> bool:\n    for char_s, char_t in zip(S, T):\n        if char_s != char_t and (char_s not in 'lo' or char_t not in 'lo1'):\n            return False\n    return True\n\ndef main():\n    N = int(input().strip())\n    S = input().strip()\n    T = input().strip()\n    \n    if are_similar_strings(S, T):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc303_b",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    N, M = map(int, input().split())\n    photos = [list(map(int, input().split())) for _ in range(M)]\n    \n    # Create a list of all possible pairs\n    all_pairs = list(combinations(range(1, N+1), 2))\n    \n    # Check which pairs are not adjacent in any photo\n    bad_mood_pairs = set()\n    for photo in photos:\n        for i in range(N - 1):\n            if photo[i] > photo[i + 1]:\n                photo[i], photo[i + 1] = photo[i + 1], photo[i]\n            if (photo[i], photo[i + 1]) not in bad_mood_pairs:\n                bad_mood_pairs.add((photo[i + 1], photo[i]))\n    \n    # Count the number of pairs that are not in bad_mood_pairs\n    total_pairs = len(all_pairs)\n    good_mood_pairs = len(bad_mood_pairs)\n    bad_mood_count = total_pairs - good_mood_pairs\n    \n    print(bad_mood_count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc303_c",
        "code_list": [
            "def can_complete_moves(N, M, H, K, S, items):\n    # Initialize current position and health\n    x, y = 0, 0\n    health = H\n    \n    # Process each move\n    for i in range(N):\n        # Determine the next position based on the move direction\n        if S[i] == 'R':\n            x += 1\n        elif S[i] == 'L':\n            x -= 1\n        elif S[i] == 'U':\n            y += 1\n        elif S[i] == 'D':\n            y -= 1\n        \n        # Decrease health by 1 for each move\n        health -= 1\n        \n        # Check if health becomes negative\n        if health <= 0:\n            return \"No\"\n        \n        # Check if the new position contains an item and health is less than K\n        for item in items:\n            if item[0] == x and item[1] == y and health < K:\n                health = K\n                break\n    \n    # If all moves are completed without health becoming non-positive\n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N, M, H, K = map(int, input().split())\n    S = input()\n    items = [tuple(map(int, input().split())) for _ in range(M)]\n    \n    result = can_complete_moves(N, M, H, K, S, items)\n    print(result)"
        ]
    },
    {
        "question_id": "abc303_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    X, Y, Z = map(int, data[:3])\n    S = data[3]\n    \n    ans = 0\n    caps_on = False\n    \n    for char in S:\n        if char.isupper() != caps_on:\n            if caps_on:\n                ans += Z + X\n            else:\n                ans += Z + Y\n            caps_on = not caps_on\n        elif caps_on:\n            ans += X\n        else:\n            ans += Y\n    \n    print(ans)"
        ]
    },
    {
        "question_id": "abc303_e",
        "code_list": [
            "def find_initial_stars(N, edges):\n    # Build the adjacency list for the tree\n    adj_list = {i: [] for i in range(1, N + 1)}\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Initialize the result list to store the levels of the stars\n    levels = []\n\n    # Function to perform DFS and determine the level of the star\n    def dfs(node, parent, level):\n        children = []\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                children.append(dfs(neighbor, node, level + 1))\n        if len(children) == 1:\n            return children[0] + 1\n        else:\n            levels.append(level)\n            return 1\n\n    # Start DFS from any leaf node\n    for node in adj_list:\n        if len(adj_list[node]) == 1:\n            dfs(node, None, 0)\n            break\n\n    # Sort the levels and remove duplicates\n    levels.sort()\n    levels = list(set(levels))\n\n    # Print the sorted levels\n    print(\" \".join(map(str, levels)))\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    edges = [tuple(map(int, input().strip().split())) for _ in range(N - 1)]\n    find_initial_stars(N, edges)"
        ]
    },
    {
        "question_id": "abc304_a",
        "code_list": [
            "def find_youngest_and_seating_order(N, people):\n    # Create a dictionary to store the age of each person\n    age_dict = {}\n    for i in range(N):\n        name, age = people[i]\n        age_dict[name] = int(age)\n    \n    # Find the youngest person\n    youngest_person = min(age_dict, key=age_dict.get)\n    \n    # Initialize the current person as the youngest person\n    current_person = youngest_person\n    \n    # Print the names in the clockwise order\n    for _ in range(N):\n        print(current_person)\n        # Move to the next person in a circular manner\n        current_person = people[(people.index((current_person, age_dict[current_person])) + 1) % N][0]\n\ndef main():\n    N = int(input())\n    people = []\n    for _ in range(N):\n        name, age = input().split()\n        people.append((name, age))\n    \n    find_youngest_and_seating_order(N, people)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_b",
        "code_list": [
            "def main():\n    N = int(input())\n    if N <= 10**3 - 1:\n        print(N)\n    elif N <= 10**4 - 1:\n        print(N // 10)\n    elif N <= 10**5 - 1:\n        print(N // 100)\n    elif N <= 10**6 - 1:\n        print(N // 1000)\n    elif N <= 10**7 - 1:\n        print(N // 10000)\n    elif N <= 10**8 - 1:\n        print(N // 100000)\n    else:\n        print(N // 1000000)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_c",
        "code_list": [
            "import math\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef is_infected(N, D, positions):\n    infected = [False] * N\n    infected[0] = True  # Person 1 is initially infected\n    \n    queue = [0]\n    \n    while queue:\n        current = queue.pop(0)\n        \n        for i in range(N):\n            if not infected[i]:\n                dist = euclidean_distance(positions[current], positions[i])\n                if dist <= D:\n                    infected[i] = True\n                    queue.append(i)\n    \n    result = []\n    for i in range(N):\n        if infected[i]:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n    \n    return result\n\ndef main():\n    N, D = map(int, input().split())\n    positions = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    results = is_infected(N, D, positions)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_d",
        "code_list": [
            "def main():\n    # Read input\n    W, H = map(int, input().split())\n    N = int(input())\n    strawberries = [tuple(map(int, input().split())) for _ in range(N)]\n    A = int(input())\n    vertical_lines = sorted(set(map(int, input().split())))\n    B = int(input())\n    horizontal_lines = sorted(set(map(int, input().split())))\n\n    # Calculate the minimum and maximum number of strawberries\n    min_strawberries = float('inf')\n    max_strawberries = 0\n\n    # Iterate over all possible sub-rectangles\n    for i in range(len(vertical_lines) + 1):\n        for j in range(len(horizontal_lines) + 1):\n            for k in range(i + 1, len(vertical_lines) + 1):\n                for l in range(j + 1, len(horizontal_lines) + 1):\n                    # Calculate the number of strawberries in the current sub-rectangle\n                    count = sum(1 for px, py in strawberries if vertical_lines[i] < px < vertical_lines[k] and horizontal_lines[j] < py < horizontal_lines[l])\n                    min_strawberries = min(min_strawberries, count)\n                    max_strawberries = max(max_strawberries, count)\n\n    # Output the result\n    print(min_strawberries, max_strawberries)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_e",
        "code_list": [
            "from collections import defaultdict\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    rootX = find(x)\n    rootY = find(y)\n    if rootX != rootY:\n        parent[rootX] = rootY\n\ndef is_good():\n    for x, y in bad_pairs:\n        if find(x) == find(y):\n            return False\n    return True\n\ndef add_edge(u, v):\n    union(u, v)\n    if is_good():\n        return \"Yes\"\n    else:\n        return \"No\"\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    K = int(input())\n    bad_pairs = [tuple(map(int, input().split())) for _ in range(K)]\n    Q = int(input())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    # Initialize parent array for union-find\n    parent = list(range(N + 1))\n\n    # Add existing edges to the union-find structure\n    for u, v in edges:\n        union(u, v)\n\n    # Process each query\n    for p, q in queries:\n        print(add_edge(p, q))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_a",
        "code_list": [
            "def main():\n    N = int(input())\n    # Calculate the nearest water station\n    if N % 5 <= 2:\n        nearest_station = (N // 5) * 5 + 5\n    else:\n        nearest_station = (N // 5 + 1) * 5\n    print(nearest_station)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_b",
        "code_list": [
            "def main():\n    # Define the distances between adjacent points\n    distances = {\n        ('A', 'B'): 3,\n        ('B', 'C'): 1,\n        ('C', 'D'): 4,\n        ('D', 'E'): 1,\n        ('E', 'F'): 5,\n        ('F', 'G'): 9\n    }\n    \n    # Function to calculate the distance between two points\n    def calculate_distance(p, q):\n        if p > q:\n            p, q = q, p\n        \n        total_distance = 0\n        for i in range(ord(p), ord(q)):\n            key = (chr(i), chr(i + 1))\n            if key in distances:\n                total_distance += distances[key]\n            else:\n                key = (chr(i + 1), chr(i))\n                if key in distances:\n                    total_distance += distances[key]\n        \n        return total_distance\n    \n    # Read input\n    p, q = input().strip().split()\n    \n    # Calculate and print the distance\n    print(calculate_distance(p, q))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_c",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    # Find the top-left and bottom-right corners of the rectangle\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                a, b, c, d = i, i, j, j\n                break\n    \n    # Expand the rectangle to find the smallest possible rectangle containing all '#'s\n    while True:\n        found = False\n        for i in range(a - 1, -1, -1):\n            if all(grid[i][j] == '#' for j in range(c, d + 1)):\n                a = i\n                found = True\n                break\n        if not found:\n            break\n    \n    while True:\n        found = False\n        for i in range(b + 1, H):\n            if all(grid[i][j] == '#' for j in range(c, d + 1)):\n                b = i\n                found = True\n                break\n        if not found:\n            break\n    \n    while True:\n        found = False\n        for j in range(c - 1, -1, -1):\n            if all(grid[i][j] == '#' for i in range(a, b + 1)):\n                c = j\n                found = True\n                break\n        if not found:\n            break\n    \n    while True:\n        found = False\n        for j in range(d + 1, W):\n            if all(grid[i][j] == '#' for i in range(a, b + 1)):\n                d = j\n                found = True\n                break\n        if not found:\n            break\n    \n    # Find the square that became empty after Snuke ate the cookie\n    for i in range(a, b + 1):\n        for j in range(c, d + 1):\n            if grid[i][j] == '.':\n                print(i + 1, j + 1)\n                return\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    a = data[1:2 * n + 1]\n    q = data[2 * n + 1]\n    queries = [(data[i], data[i + 1]) for i in range(2 * n + 2, 2 * n + 2 + q)]\n\n    # Initialize segment tree\n    seg_tree_size = 4 * len(a)\n    seg_tree = [0] * seg_tree_size\n\n    def build_segment_tree(node, start, end):\n        if start == end:\n            return\n        mid = (start + end) // 2\n        build_segment_tree(2 * node, start, mid)\n        build_segment_tree(2 * node + 1, mid + 1, end)\n\n    def update_segment_tree(node, start, end, index, value):\n        if start == end:\n            seg_tree[node] += value\n            return\n        mid = (start + end) // 2\n        if start <= index <= mid:\n            update_segment_tree(2 * node, start, mid, index, value)\n        else:\n            update_segment_tree(2 * node + 1, mid + 1, end, index, value)\n        seg_tree[node] = seg_tree[2 * node] + seg_tree[2 * node + 1]\n\n    def query_segment_tree(node, start, end, left, right):\n        if left > end or right < start:\n            return 0\n        if left <= start and end <= right:\n            return seg_tree[node]\n        mid = (start + end) // 2\n        return query_segment_tree(2 * node, start, mid, left, right) + query_segment_tree(2 * node + 1, mid + 1, end, left, right)\n\n    build_segment_tree(1, 0, len(a) - 1)\n\n    for l, r in queries:\n        result = query_segment_tree(1, 0, len(a) - 1, l, r)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_e",
        "code_list": [
            "from collections import deque\n\ndef bfs(graph, start, stamina):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    distances = [-1] * (n + 1)\n    distances[start] = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                distances[neighbor] = distances[current] + 1\n                queue.append(neighbor)\n    \n    return [i for i in range(1, n + 1) if distances[i] <= stamina]\n\ndef find_guarded_vertices(n, m, k, edges, positions, stamina):\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    guarded_vertices = set()\n    for p, h in zip(positions, stamina):\n        guarded_vertices.update(bfs(graph, p, h))\n    \n    return sorted(guarded_vertices)\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    positions = [int(input()) for _ in range(k)]\n    stamina = [int(input()) for _ in range(k)]\n    \n    guarded_vertices = find_guarded_vertices(n, m, k, edges, positions, stamina)\n    \n    print(len(guarded_vertices))\n    print(' '.join(map(str, guarded_vertices)))"
        ]
    },
    {
        "question_id": "abc306_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    result = ''.join([char * 2 for char in S])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc306_b",
        "code_list": [
            "def main():\n    # Read the input sequence\n    sequence = list(map(int, input().split()))\n    \n    # Calculate the result using bitwise operations for efficiency\n    result = 0\n    for i, bit in enumerate(sequence):\n        result |= bit << i\n    \n    # Print the result\n    print(result)"
        ]
    },
    {
        "question_id": "abc306_c",
        "code_list": [
            "def find_middle_occurrence(n, arr):\n    # Dictionary to store the middle occurrence index of each number\n    middle_indices = {}\n    \n    # Iterate through the array to find the middle occurrence index for each number\n    for i, num in enumerate(arr):\n        if num in middle_indices:\n            middle_indices[num].append(i)\n        else:\n            middle_indices[num] = [i]\n    \n    # Extract the middle indices and sort them based on the middle occurrence index\n    sorted_indices = sorted(middle_indices.values(), key=lambda x: x[1])\n    \n    # Extract the numbers corresponding to the sorted middle indices\n    result = [arr.index(sorted_indices[i][1]) + 1 for i in range(n)]\n    \n    return result\n\ndef main():\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    result = find_middle_occurrence(n, arr)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc306_d",
        "code_list": [
            "def max_tastiness(N, courses):\n    # Initialize variables to keep track of the maximum sum of tastiness\n    max_sum = 0\n    current_sum = 0\n    healthy_sum = 0\n    healthy_index = -1\n    \n    for i, (X, Y) in enumerate(courses):\n        if X == 0:\n            # Antidotal course\n            if current_sum < 0:\n                # If current_sum is negative, we can reset it to 0 and add the antidotal course's tastiness\n                current_sum = Y\n                healthy_sum += Y\n                healthy_index = i\n            else:\n                # Otherwise, add the antidotal course's tastiness to the current_sum\n                current_sum += Y\n        else:\n            # Poisonous course\n            if current_sum > 0:\n                # If current_sum is positive, we can skip the poisonous course without dying\n                continue\n            elif current_sum == 0 and healthy_index != -1:\n                # If current_sum is 0 and we have an antidotal course before, we can use it to survive\n                current_sum = healthy_sum + Y\n                healthy_index = i\n            else:\n                # If we can't survive, break the loop\n                break\n    \n    return max(max_sum, current_sum)\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    courses = []\n    for _ in range(N):\n        X, Y = map(int, input().strip().split())\n        courses.append((X, Y))\n    \n    print(max_tastiness(N, courses))"
        ]
    },
    {
        "question_id": "abc306_e",
        "code_list": [
            "import heapq\n\ndef main():\n    # Read input\n    N, K, Q = map(int, input().split())\n    A = [0] * N\n    \n    # Function to update the sequence and calculate f(A)\n    def update_and_calculate_f(A, X, Y):\n        A[X-1] = Y\n        # Use a min heap to keep track of the smallest elements\n        min_heap = []\n        for i in range(N):\n            if A[i] > 0:\n                heapq.heappush(min_heap, -A[i])\n            if len(min_heap) > K:\n                heapq.heappop(min_heap)\n        return -sum(min_heap)\n    \n    # Process updates\n    for _ in range(Q):\n        X, Y = map(int, input().split())\n        result = update_and_calculate_f(A, X, Y)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc307_a",
        "code_list": [
            "def main():\n    N = int(input())\n    steps = list(map(int, input().split()))\n    \n    weekly_steps = []\n    for i in range(0, len(steps), 7):\n        weekly_steps.append(sum(steps[i:i+7]))\n    \n    print(*weekly_steps)"
        ]
    },
    {
        "question_id": "abc307_b",
        "code_list": [
            "def is_palindrome(s):\n    return s == s[::-1]\n\ndef find_palindrome_pair(strings):\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_palindrome(strings[i] + strings[j]):\n                return True\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    strings = data[1:n+1]\n    \n    if find_palindrome_pair(strings):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc307_c",
        "code_list": [
            "def main():\n    from itertools import product\n\n    def parse_sheet(sheet):\n        return [list(row) for row in sheet]\n\n    def find_all_black_squares(sheet):\n        black_squares = []\n        for i, row in enumerate(sheet):\n            for j, cell in enumerate(row):\n                if cell == '#':\n                    black_squares.append((i, j))\n        return black_squares\n\n    def check_paste_and_cut(A, B, X):\n        H_A, W_A = len(A), len(A[0])\n        H_B, W_B = len(B), len(B[0])\n        H_X, W_X = len(X), len(X[0])\n\n        # Find all black squares in A and B\n        black_squares_A = find_all_black_squares(A)\n        black_squares_B = find_all_black_squares(B)\n        all_black_squares = set(black_squares_A + black_squares_B)\n\n        # Check if all black squares can fit into X\n        for (x_start, y_start) in product(range(H_X - H_A + 1), range(W_X - W_A + 1)):\n            for (x_end, y_end) in product(range(H_X - H_B + 1), range(W_X - W_B + 1)):\n                if x_start + H_A > x_end or y_start + W_A > y_end:\n                    continue\n                # Create a copy of sheet C\n                C = [['.' for _ in range(W_X)] for _ in range(H_X)]\n                # Paste A and B onto C\n                for i in range(H_A):\n                    for j in range(W_A):\n                        C[x_start + i][y_start + j] = A[i][j]\n                for i in range(H_B):\n                    for j in range(W_B):\n                        C[x_end + i][y_end + j] = B[i][j]\n                # Check if all black squares are covered\n                if all((x, y) in all_black_squares for x in range(x_start, x_start + H_A) for y in range(y_start, y_start + W_A)):\n                    if all((x, y) in all_black_squares for x in range(x_end, x_end + H_B) for y in range(y_end, y_end + W_B)):\n                        # Check if the cut-out sheet matches X\n                        for i in range(H_X):\n                            for j in range(W_X):\n                                if C[i][j] != X[i][j]:\n                                    break\n                            else:\n                                continue\n                            break\n                        else:\n                            print(\"Yes\")\n                            return\n        print(\"No\")\n\n    # Read input\n    H_A, W_A = map(int, input().split())\n    A = [input() for _ in range(H_A)]\n    H_B, W_B = map(int, input().split())\n    B = [input() for _ in range(H_B)]\n    H_X, W_X = map(int, input().split())\n    X = [input() for _ in range(H_X)]\n\n    # Parse sheets\n    A = parse_sheet(A)\n    B = parse_sheet(B)\n    X = parse_sheet(X)\n\n    # Check if the goal can be achieved\n    check_paste_and_cut(A, B, X)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc307_d",
        "code_list": [
            "def remove_substrings(s):\n    stack = []\n    result = list(s)\n    \n    for i, char in enumerate(result):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start_index = stack.pop()\n                # Remove the substring between ( and )\n                del result[start_index+1:i]\n    \n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input()\n    print(remove_substrings(S))"
        ]
    },
    {
        "question_id": "abc307_e",
        "code_list": [
            "from math import pow\n\ndef mod_pow(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef count_ways(N, M):\n    mod = 998244353\n    if N == 1:\n        return M\n    elif N == 2:\n        return M * (M - 1)\n    else:\n        dp = [0] * (N + 1)\n        dp[1], dp[2] = M, M * (M - 1)\n        for i in range(3, N + 1):\n            dp[i] = (dp[i - 1] * (M - 1) + dp[i - 2] * (M - 1)) % mod\n        return dp[N]\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    print(count_ways(N, M))"
        ]
    },
    {
        "question_id": "abc308_a",
        "code_list": [
            "def main():\n    # Read input as a list of integers\n    S = list(map(int, input().split()))\n    \n    # Check if the sequence is monotonically non-decreasing\n    if any(S[i] < S[i - 1] for i in range(1, 8)):\n        print(\"No\")\n        return\n    \n    # Check if all elements are between 100 and 675, inclusive\n    if not all(100 <= S_i <= 675 for S_i in S):\n        print(\"No\")\n        return\n    \n    # Check if all elements are multiples of 25\n    if not all(S_i % 25 == 0 for S_i in S):\n        print(\"No\")\n        return\n    \n    # If all conditions are satisfied\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_b",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    colors = [input() for _ in range(N)]\n    prices = {input(): int(input()) for _ in range(M)}\n    default_price = int(input())\n    \n    total_price = sum(prices.get(color, default_price) for color in colors)\n    print(total_price)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    people = []\n    \n    for i in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        index += 2\n        success_rate = A / (A + B)\n        people.append((success_rate, -i, i + 1))\n    \n    people.sort(reverse=True)\n    \n    for _, _, person_id in people:\n        print(person_id, end=' ')\n    print()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_d",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    def is_valid(i, j):\n        return 0 <= i < H and 0 <= j < W\n    \n    def dfs(i, j, path):\n        if i == H - 1 and j == W - 1:\n            return True\n        \n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if is_valid(ni, nj) and grid[ni][nj] == path[(len(path) - 1) % 5 + 1]:\n                if dfs(ni, nj, path + grid[ni][nj]):\n                    return True\n        return False\n    \n    if grid[0][0] == 's' and dfs(0, 0, 's'):\n        print('Yes')\n    else:\n        print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    S = input()\n\n    def mex(arr):\n        seen = set(arr)\n        i = 0\n        while i in seen:\n            i += 1\n        return i\n\n    count = defaultdict(int)\n    result = 0\n\n    for i in range(N):\n        if S[i] == 'M':\n            continue\n        for j in range(i + 1, N):\n            if S[j] == 'M':\n                continue\n            for k in range(j + 1, N):\n                if S[k] == 'M':\n                    continue\n                if S[i] == 'E' and S[j] == 'X' and S[k] == 'X':\n                    result += mex([A[i], A[j], A[k]])\n                elif S[i] == 'X' and S[j] == 'E' and S[k] == 'X':\n                    result += mex([A[i], A[j], A[k]])\n                elif S[i] == 'X' and S[j] == 'X' and S[k] == 'E':\n                    result += mex([A[i], A[j], A[k]])\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_f",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, m = data[0], data[1]\n    prices = data[2:2 + n]\n    discounts = []\n    for i in range(m):\n        l, d = data[2 + n + i * 2], data[2 + n + i * 2 + 1]\n        discounts.append((l, d))\n\n    # Sort discounts based on the lower limit L in descending order\n    discounts.sort(reverse=True)\n\n    total_cost = 0\n    used_coupons = [False] * m\n\n    for i in range(n):\n        price = prices[i]\n        # Try to find a suitable coupon for the current item\n        for j in range(m):\n            if not used_coupons[j] and discounts[j][0] <= price:\n                total_cost += price - discounts[j][1]\n                used_coupons[j] = True\n                break\n        if not used_coupons[j]:\n            total_cost += price\n\n    print(total_cost)"
        ]
    },
    {
        "question_id": "abc309_a",
        "code_list": [
            "def main():\n    # Read input values for A and B\n    A, B = map(int, input().split())\n    \n    # Define the positions of numbers 1 through 9 on a 3x3 board\n    positions = {\n        1: (0, 0), 2: (0, 1), 3: (0, 2),\n        4: (1, 0), 5: (1, 1), 6: (1, 2),\n        7: (2, 0), 8: (2, 1), 9: (2, 2)\n    }\n    \n    # Get the positions of A and B\n    pos_A = positions[A]\n    pos_B = positions[B]\n    \n    # Check if A and B are adjacent horizontally\n    if pos_A[1] == pos_B[1] and abs(pos_A[0] - pos_B[0]) == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_b",
        "code_list": [
            "def shift_outer_squares(N, grid):\n    # Extract the outer squares into a list\n    outer_squares = []\n    for i in range(N):\n        outer_squares.append(grid[i][0])\n        outer_squares.append(grid[N-1][i])\n        if i != N-1:\n            outer_squares.append(grid[N-1-i][N-1])\n        if i != 0:\n            outer_squares.append(grid[0][N-1-i])\n    \n    # Shift the outer squares clockwise by one\n    shifted_squares = [outer_squares[-1]] + outer_squares[:-1]\n    \n    # Place the shifted outer squares back into the grid\n    k = 0\n    for i in range(N):\n        grid[i][0] = shifted_squares[k]\n        k += 1\n        grid[N-1][i] = shifted_squares[k]\n        k += 1\n        if i != N-1:\n            grid[N-1-i][N-1] = shifted_squares[k]\n            k += 1\n        if i != 0:\n            grid[0][N-1-i] = shifted_squares[k]\n            k += 1\n    \n    # Return the modified grid\n    return grid\n\ndef main():\n    N = int(input().strip())\n    grid = []\n    for _ in range(N):\n        row = list(map(int, input().strip()))\n        grid.append(row)\n    \n    shifted_grid = shift_outer_squares(N, grid)\n    \n    for row in shifted_grid:\n        print(''.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    start = 2\n    end = 2 + 2 * N\n    \n    a = [0] * N\n    b = [0] * N\n    \n    for i in range(N):\n        a[i] = int(data[start])\n        b[i] = int(data[start + 1])\n        start += 2\n    \n    day = 0\n    total_pills = 0\n    for i in range(N):\n        if day < a[i]:\n            total_pills += b[i]\n            if total_pills <= K:\n                print(day + 1)\n                return\n            else:\n                day = a[i]\n        else:\n            total_pills -= b[i - 1]\n            total_pills += b[i]\n            if total_pills <= K:\n                print(day + 1)\n                return\n            else:\n                day += 1\n    \n    # If we reach here, it means we need to check beyond the last prescription day\n    while True:\n        day += 1\n        total_pills -= b[day % N - 1]\n        total_pills += b[day % N]\n        if total_pills <= K:\n            print(day)\n            return\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_d",
        "code_list": [
            "import sys\nfrom collections import deque\n\ndef bfs(graph, start, end):\n    queue = deque([(start, 1)])\n    visited = {start}\n    \n    while queue:\n        current, distance = queue.popleft()\n        if current == end:\n            return distance\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, distance + 1))\n    return float('inf')\n\ndef find_max_path_length(N1, N2, M, edges):\n    # Build the graph\n    graph = {i: [] for i in range(1, N1 + N2 + 1)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Find the shortest path without any additional edge\n    shortest_path = bfs(graph, 1, N1 + N2)\n    \n    # Check potential candidates for the additional edge\n    candidates = []\n    for u in range(1, N1 + 1):\n        for v in range(N1 + 1, N1 + N2 + 1):\n            if (u, v) not in edges and (v, u) not in edges:\n                candidates.append((u, v))\n    \n    max_path_length = shortest_path\n    for u, v in candidates:\n        # Create a temporary graph with the additional edge\n        temp_graph = graph.copy()\n        temp_graph[u].append(v)\n        temp_graph[v].append(u)\n        \n        # Calculate the new shortest path\n        new_path_length = bfs(temp_graph, 1, N1 + N2)\n        max_path_length = max(max_path_length, new_path_length)\n    \n    return max_path_length\n\ndef main():\n    N1, N2, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    print(find_max_path_length(N1, N2, M, edges))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_e",
        "code_list": [
            "def find_parent(i, parent_map):\n    if parent_map[i] == -1:\n        return i\n    return find_parent(parent_map[i], parent_map)\n\ndef union(i, j, parent_map):\n    pi = find_parent(i, parent_map)\n    pj = find_parent(j, parent_map)\n    if pi != pj:\n        parent_map[pj] = pi\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    m = int(data[1])\n    parent_map = [-1] * (n + 1)\n    for i in range(2, n + 1):\n        parent_map[i] = int(data[i - 1])\n\n    start_indices = [2 + i * 2 for i in range(m)]\n    end_indices = [start_indices[i] + 1 for i in range(m)]\n\n    covered = set()\n    for i in range(m):\n        x = int(data[start_indices[i]])\n        y = int(data[end_indices[i]])\n        current = x\n        while current <= n and y > 0:\n            if current not in covered:\n                covered.add(current)\n                for j in range(parent_map[current], -1, -1):\n                    union(current, j, parent_map)\n            current += 1\n            y -= 1\n\n    print(len(covered))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_a",
        "code_list": [
            "def main():\n    N, P, Q = map(int, input().split())\n    dishes = list(map(int, input().split()))\n    \n    # Calculate the cost without using the coupon\n    cost_without_coupon = P\n    \n    # Calculate the cost with the coupon if any dish is cheaper than the difference between P and Q\n    min_dish_price = min(dishes)\n    cost_with_coupon = Q + min_dish_price if min_dish_price < P - Q else float('inf')\n    \n    # The minimum total amount of money to pay\n    print(min(cost_without_coupon, cost_with_coupon))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    products = []\n    for _ in range(N):\n        P, C = map(int, input().split())\n        functions = set(map(int, input().split()))\n        products.append((P, functions))\n    \n    # Check if there is a product that is strictly superior to another\n    for i in range(N):\n        for j in range(i + 1, N):\n            if products[i][0] >= products[j][0]:\n                if products[j][1].issuperset(products[i][1]):\n                    if products[i][0] > products[j][0] or len(products[j][1] - products[i][1]) > 0:\n                        print(\"Yes\")\n                        return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_c",
        "code_list": [
            "from collections import defaultdict\n\ndef reverse_string(s):\n    return s[::-1]\n\ndef count_unique_sticks(N, sticks):\n    unique_sticks = defaultdict(int)\n    \n    for stick in sticks:\n        # Check both the original and reversed string\n        unique_sticks[stick] += 1\n        unique_sticks[reverse_string(stick)] += 1\n    \n    # The number of unique sticks is the number of keys in the dictionary divided by 2\n    # because each unique stick appears twice (once in its original form and once in its reversed form)\n    return len(unique_sticks) // 2\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    sticks = []\n    for _ in range(N):\n        sticks.append(input().strip())\n    \n    print(count_unique_sticks(N, sticks))"
        ]
    },
    {
        "question_id": "abc310_d",
        "code_list": [
            "from itertools import combinations\n\ndef count_ways(N, T, M, pairs):\n    # Create a graph to represent the incompatibilities\n    graph = {i: [] for i in range(1, N + 1)}\n    for a, b in pairs:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, visited, team):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor in team:\n                return False\n            if not dfs(neighbor, visited, team):\n                return False\n        team.add(node)\n        return True\n\n    def valid_teams(teams):\n        for team in teams:\n            if len(team) < 1:\n                return False\n        return True\n\n    def count_divisions(remaining_players, current_team, teams):\n        if not remaining_players:\n            if valid_teams(teams):\n                return 1\n            return 0\n        count = 0\n        for player in remaining_players:\n            new_teams = [set(t) for t in teams]\n            if all(player not in team for team in new_teams):\n                new_teams.append({player})\n                count += count_divisions(remaining_players - set([player]), current_team + 1, new_teams)\n        return count\n\n    total_ways = 0\n    for division in combinations(range(1, N + 1), T):\n        remaining_players = set(range(1, N + 1)) - set(division)\n        if not remaining_players:\n            continue\n        visited = set()\n        valid = True\n        for player in division:\n            if player in visited:\n                continue\n            if not dfs(player, visited, set()):\n                valid = False\n                break\n        if valid and count_divisions(remaining_players, 1, [visited]) > 0:\n            total_ways += 1\n\n    return total_ways\n\nif __name__ == \"__main__\":\n    N, T, M = map(int, input().split())\n    pairs = [tuple(map(int, input().split())) for _ in range(M)]\n    print(count_ways(N, T, M, pairs))"
        ]
    },
    {
        "question_id": "abc310_e",
        "code_list": [
            "def nand(a, b):\n    return 1 if a == 1 and b == 1 else 0\n\ndef calculate_nand_sequence(S):\n    N = len(S)\n    result = 0\n    \n    # Initialize the dp array to store intermediate results\n    dp = [int(S[0])] * N\n    \n    for j in range(1, N):\n        current_value = int(S[j])\n        for i in range(j, -1, -1):\n            if i == j:\n                dp[i] = current_value\n            else:\n                dp[i] = nand(dp[i], current_value)\n            result += dp[i]\n    \n    return result\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    print(calculate_nand_sequence(S))"
        ]
    },
    {
        "question_id": "abc310_f",
        "code_list": [
            "from functools import lru_cache\nfrom math import gcd\n\ndef modular_inverse(a, mod):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return g, y - (b // a) * x, x\n    \n    g, x, _ = extended_gcd(a, mod)\n    if g != 1:\n        raise Exception('Modular inverse does not exist')\n    else:\n        return x % mod\n\ndef solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    @lru_cache(None)\n    def dp(index, target):\n        if index == N:\n            return int(target == 0)\n        result = 0\n        for roll in range(1, A[index] + 1):\n            result += dp(index + 1, target - roll)\n            result %= 998244353\n        return result\n    \n    total_ways = dp(0, 10)\n    total_possible_outcomes = 1\n    for a in A:\n        total_possible_outcomes *= a\n        total_possible_outcomes %= 998244353\n    \n    numerator = total_ways\n    denominator = total_possible_outcomes\n    \n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n    \n    inverse_denominator = modular_inverse(denominator, 998244353)\n    \n    result = (numerator * inverse_denominator) % 998244353\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()"
        ]
    },
    {
        "question_id": "abc311_a",
        "code_list": [
            "def main():\n    # Read input\n    N = int(input())\n    S = input()\n\n    # Initialize counters for each character\n    count_A = 0\n    count_B = 0\n    count_C = 0\n\n    # Iterate through the string\n    for i, char in enumerate(S):\n        if char == 'A':\n            count_A += 1\n        elif char == 'B':\n            count_B += 1\n        elif char == 'C':\n            count_C += 1\n\n        # Check if all characters have appeared at least once\n        if count_A > 0 and count_B > 0 and count_C > 0:\n            break\n\n    # Print the index (1-based) where the condition is satisfied\n    print(i + 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc311_b",
        "code_list": [
            "def find_max_consecutive_free_days(N, D, schedules):\n    max_days = 0\n    for start_day in range(D):\n        for end_day in range(start_day, D + 1):\n            if all(schedule[start_day:end_day].replace('o', '') == '' for schedule in schedules):\n                max_days = max(max_days, end_day - start_day)\n    return max_days\n\nif __name__ == \"__main__\":\n    N, D = map(int, input().split())\n    schedules = [input() for _ in range(N)]\n    print(find_max_consecutive_free_days(N, D, schedules))"
        ]
    },
    {
        "question_id": "abc311_c",
        "code_list": [
            "def find_cycle(n, edges):\n    # Initialize the graph\n    graph = [[] for _ in range(n)]\n    for i, edge in enumerate(edges):\n        graph[i].append(edge - 1)\n\n    # Function to perform DFS and detect cycles\n    def dfs(node, path, visited, cycle):\n        if node in path:\n            return True\n        if node in cycle:\n            return False\n        cycle.add(node)\n        for neighbor in graph[node]:\n            if dfs(neighbor, path + [node], visited | {node}, cycle):\n                return True\n        cycle.remove(node)\n        return False\n\n    # Find the cycle\n    for start_node in range(n):\n        if dfs(start_node, [], set(), set()):\n            break\n\n    # Reconstruct the cycle\n    cycle = []\n    while start_node != cycle[-1]:\n        cycle.append(start_node)\n        start_node = edges[start_node] - 1\n    cycle.append(start_node)\n\n    # Output the cycle\n    print(len(cycle))\n    print(' '.join(map(str, cycle)))\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = list(map(int, input().split()))\n    find_cycle(n, edges)"
        ]
    },
    {
        "question_id": "abc311_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start):\n    n, m = len(grid), len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    count = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        count += 1\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 < nx < n - 1 and 0 < ny < m - 1 and grid[nx][ny] == '.' and not visited[nx][ny]:\n                visited[nx][ny] = True\n                queue.append((nx, ny))\n                \n    return count\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    \n    start = (1, 1)\n    print(bfs(grid, start))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc311_e",
        "code_list": [
            "def count_holeless_squares(H, W, N, holes):\n    # Initialize a 2D array to keep track of the number of holes in each subgrid\n    hole_counts = [[0] * (W + 1) for _ in range(H + 1)]\n    \n    # Update the hole counts based on the given holed squares\n    for a, b in holes:\n        hole_counts[a][b] += 1\n        for i in range(a, H + 1):\n            for j in range(b, W + 1):\n                hole_counts[i][j] += hole_counts[i - a][j - b]\n    \n    # Calculate the number of holeless squares\n    holeless_count = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if hole_counts[i][j] == 0:\n                holeless_count += min(i, j)\n    \n    return holeless_count\n\ndef main():\n    H, W, N = map(int, input().split())\n    holes = [tuple(map(int, input().split())) for _ in range(N)]\n    print(count_holeless_squares(H, W, N, holes))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S in [\"ACE\", \"BDF\", \"CEG\", \"DFA\", \"EGB\", \"FAC\", \"GBD\"]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_b",
        "code_list": [
            "def find_tak_code_regions(N, M, grid):\n    def check_region(i, j):\n        # Check the top-left 3x3 region\n        for x in range(3):\n            for y in range(3):\n                if grid[i+x][j+y] != '#':\n                    return False\n        \n        # Check the adjacent cells\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if dx == 0 and dy == 0:\n                    continue\n                for x in range(3):\n                    for y in range(3):\n                        nx, ny = i + x + dx, j + y + dy\n                        if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '#':\n                            return False\n        return True\n    \n    tak_code_regions = []\n    for i in range(N - 8):\n        for j in range(M - 8):\n            if check_region(i, j):\n                tak_code_regions.append((i + 1, j + 1))\n    \n    return tak_code_regions\n\ndef main():\n    N, M = map(int, input().split())\n    grid = [input().strip() for _ in range(N)]\n    tak_code_regions = find_tak_code_regions(N, M, grid)\n    for i, j in tak_code_regions:\n        print(i, j)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_c",
        "code_list": [
            "def main():\n    import bisect\n\n    N, M = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    B = sorted(map(int, input().split()))\n\n    # Find the minimum X that satisfies the condition\n    left, right = 1, 10**9 + 1\n    while left < right:\n        mid = (left + right) // 2\n        if sum(a >= mid for a in A) >= sum(b <= mid for b in B):\n            right = mid\n        else:\n            left = mid + 1\n\n    print(left)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_d",
        "code_list": [
            "from collections import Counter\n\ndef count_parenthesis_strings(S):\n    MOD = 998244353\n    n = len(S)\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: empty string\n    \n    for i in range(n):\n        if S[i] == '(':\n            dp[i + 1] += dp[i]\n            dp[i + 1] %= MOD\n        elif S[i] == ')':\n            dp[i + 1] += dp[i]\n            dp[i + 1] %= MOD\n        else:  # S[i] == '?'\n            dp[i + 1] += dp[i] * 2\n            dp[i + 1] %= MOD\n    \n    def check_parenthesis(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            elif c == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    def dfs(index, balance):\n        if index == n:\n            return int(balance == 0)\n        \n        if S[index] == '(' or S[index] == ')':\n            return dfs(index + 1, balance + (1 if S[index] == '(' else -1))\n        else:\n            return (dfs(index + 1, balance + 1) + dfs(index + 1, balance - 1)) % MOD\n    \n    return dfs(0, 0) * dp[n] % MOD\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(count_parenthesis_strings(S))"
        ]
    },
    {
        "question_id": "abc312_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    cuboids = []\n    for _ in range(N):\n        x1, y1, z1, x2, y2, z2 = map(int, input().split())\n        cuboids.append(((x1, y1, z1), (x2, y2, z2)))\n\n    # Create a graph where each node represents a cuboid and edges represent shared faces\n    graph = defaultdict(list)\n    for i in range(N):\n        for j in range(i + 1, N):\n            xi1, yi1, zi1, xi2, yi2, zi2 = cuboids[i]\n            xj1, yj1, zj1, xj2, yj2, zj2 = cuboids[j]\n\n            # Check if they share a face\n            if (xi1 <= xj1 < xi2 or xj1 <= xi1 < xj2) and (yi1 <= yj1 < yi2 or yj1 <= yi1 < yj2) and (zi1 <= zj1 < zi2 or zj1 <= zi1 < zj2):\n                graph[i].append(j)\n                graph[j].append(i)\n\n    # Print the number of neighbors for each cuboid\n    for i in range(N):\n        print(len(graph[i]))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_f",
        "code_list": [
            "import heapq\n\ndef main():\n    N, M = map(int, input().split())\n    items = []\n    for _ in range(N):\n        T, X = map(int, input().split())\n        items.append((X, T))\n    \n    # Sort items based on their happiness in descending order\n    items.sort(reverse=True)\n    \n    # Priority queue to keep track of can openers and their usage limit\n    can_openers = []\n    happiness = 0\n    \n    for X, T in items:\n        if T == 2:  # Can opener\n            heapq.heappush(can_openers, (-X, T))\n        elif T == 1:  # Regular can\n            if can_openers and M > 0:\n                _, X_opener = heapq.heappop(can_openers)\n                happiness += X + X_opener\n                M -= 1\n            else:\n                happiness += X\n        else:  # Pull-tab can\n            happiness += X\n    \n    print(happiness)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc313_a",
        "code_list": [
            "def main():\n    N = int(input())\n    abilities = list(map(int, input().split()))\n    \n    max_ability = max(abilities)\n    current_ability = abilities[0]\n    \n    # Calculate the minimum non-negative integer x\n    x = max_ability - current_ability\n    \n    print(x)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc313_b",
        "code_list": [
            "def find_strongest_programmer(N, M, relations):\n    # Initialize the graph to represent the superiority relations\n    graph = {i: set() for i in range(1, N + 1)}\n    \n    # Populate the graph with the given relations\n    for A, B in relations:\n        graph[A].add(B)\n    \n    # Function to check if a person is the strongest\n    def is_strongest(person):\n        for other in range(1, N + 1):\n            if other != person and (person not in graph[other] and other not in graph[person]):\n                return False\n        return True\n    \n    # Check each person to see if they could be the strongest\n    strongest = None\n    for person in range(1, N + 1):\n        if is_strongest(person):\n            if strongest is not None:\n                # More than one person is the strongest, return -1\n                return -1\n            strongest = person\n    \n    return strongest\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    relations = [tuple(map(int, input().split())) for _ in range(M)]\n    print(find_strongest_programmer(N, M, relations))"
        ]
    },
    {
        "question_id": "abc313_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def min_operations_to_balance_sequence(N, A):\n        total_sum = sum(A)\n        target_value = total_sum // N\n        remainder = total_sum % N\n        \n        # Calculate the number of elements that need to be adjusted\n        elements_above_target = sum(1 for x in A if x > target_value)\n        \n        # The minimum number of operations required is the sum of the differences\n        # between each element above the target value and the target value itself,\n        # plus the sum of the differences between each element below the target value\n        # and the target value minus one, but only up to the remainder.\n        operations = 0\n        for x in A:\n            if x > target_value:\n                operations += x - target_value\n            elif x < target_value:\n                operations += max(0, target_value - 1 - x)\n        \n        # Adjust the operations count based on the remainder\n        operations -= remainder * (target_value + 1 - target_value)\n        \n        return operations\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    print(min_operations_to_balance_sequence(N, A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_a",
        "code_list": [
            "import math\n\ndef main():\n    N = int(input().strip())\n    pi_str = str(math.pi)\n    decimal_part = pi_str.split('.')[1][:N]\n    result = f\"3.{decimal_part}\"\n    if len(decimal_part) < N:\n        result += '0' * (N - len(decimal_part))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_int():\n        return int(sys.stdin.readline().strip())\n    \n    def read_line():\n        return sys.stdin.readline().strip().split()\n    \n    N = read_int()\n    bets = []\n    for _ in range(N):\n        C_i = read_int()\n        A_i = list(map(int, read_line()))\n        bets.append((A_i, C_i))\n    \n    X = int(read_line()[0])\n    \n    # Find all people who bet on X\n    betters = [i + 1 for i, (outcomes, _) in enumerate(bets) if X in outcomes]\n    \n    # If no one bet on X, print 0 and return\n    if not betters:\n        print(0)\n        return\n    \n    # Find the minimum number of bets among those who bet on X\n    min_bets = min(bets[i - 1][1] for i in betters)\n    \n    # Filter out those who do not have the minimum number of bets\n    winners = [i for i in betters if bets[i - 1][1] == min_bets]\n    \n    # Print the result\n    print(len(winners))\n    print(' '.join(map(str, winners)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    S = input()\n    C = list(map(int, input().split()))\n    \n    # Initialize the positions of each color\n    color_positions = [[] for _ in range(M)]\n    for i in range(N):\n        color_positions[C[i] - 1].append(i)\n    \n    # Perform right circular shifts for each color\n    for color in range(M):\n        positions = color_positions[color]\n        k = len(positions)\n        if k > 1:\n            shifted_positions = [positions[(i + 1) % k] for i in range(k)]\n            for i, pos in enumerate(shifted_positions):\n                S = S[:pos] + S[positions[i]:pos] + S[:positions[i]] + S[pos+1:]\n    \n    # Print the final string\n    print(S)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    S = data[1]\n    Q = int(data[2])\n\n    # Initialize a list to store the operations\n    operations = []\n    start_index = 3\n    for _ in range(Q):\n        t = int(data[start_index])\n        x = int(data[start_index + 1]) - 1\n        c = data[start_index + 2]\n        operations.append((t, x, c))\n        start_index += 3\n\n    # Process the operations\n    for t, x, c in operations:\n        if t == 1:\n            S = S[:x] + c + S[x+1:]\n        elif t == 2:\n            S = S.lower()\n        elif t == 3:\n            S = S.upper()\n\n    print(S)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_e",
        "code_list": [
            "import numpy as np\nfrom scipy.optimize import linprog\n\ndef main():\n    # Read input\n    N, M = map(int, input().split())\n    wheels = []\n    for _ in range(N):\n        C, P = map(int, input().split())\n        S = list(map(int, input().split()))\n        wheels.append((C, P, S))\n    \n    # Define the linear programming problem\n    A_eq = []\n    b_eq = [M]\n    bounds = [(0, None)] * N\n    \n    # Objective function coefficients (negative because we want to minimize the negative of the expected cost)\n    c = [-C for _, C, _ in wheels]\n    \n    # Constraints for each wheel\n    for i, (_, P, S) in enumerate(wheels):\n        row = [0] * N\n        row[i] = 1\n        A_eq.append(row)\n        for j in range(P):\n            A_eq.append([1 if k == i else 0 for k in range(N)])\n            b_eq.append(S[j])\n    \n    # Solve the linear programming problem\n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    # The expected cost is the negative of the objective value\n    expected_cost = -res.fun\n    print(f\"{expected_cost:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_f",
        "code_list": [
            "from collections import defaultdict\nfrom math import gcd\n\ndef modinv(a, m=998244353):\n    return pow(a, m - 2, m)\n\ndef main():\n    n = int(input())\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Initialize the parent and size arrays\n    parent = [-1] * (n + 1)\n    size = [1] * (n + 1)\n    \n    # Function to find the root of a node\n    def find(x):\n        if parent[x] == -1:\n            return x\n        parent[x] = find(parent[x])\n        return parent[x]\n    \n    # Function to union two nodes\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n    \n    # Process the edges in reverse order\n    for u, v in reversed(edges):\n        union(u, v)\n    \n    # Calculate the expected values\n    expected_values = [0] * (n + 1)\n    for i in range(1, n + 1):\n        root = find(i)\n        expected_values[root] += 1\n    \n    # Adjust the expected values based on the sizes of the components\n    for i in range(1, n + 1):\n        root = find(i)\n        expected_values[root] -= size[root] - 1\n    \n    # Print the results modulo 998244353\n    for i in range(1, n + 1):\n        root = find(i)\n        expected_values[root] = (expected_values[root] * modinv(size[root])) % 998244353\n    \n    print(*expected_values[1:])"
        ]
    },
    {
        "question_id": "abc315_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = ''.join([char for char in S if char not in 'aeiou'])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_b",
        "code_list": [
            "def main():\n    M = int(input())\n    days_in_months = list(map(int, input().split()))\n    \n    total_days = sum(days_in_months)\n    middle_day = (total_days + 1) // 2\n    \n    current_day = 1\n    current_month = 1\n    \n    for month_days in days_in_months:\n        if current_day + month_days >= middle_day:\n            break\n        current_day += month_days\n        current_month += 1\n    \n    print(current_month, middle_day - current_day)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    ice_creams = []\n    for _ in range(N):\n        F, S = map(int, input().split())\n        ice_creams.append((F, S))\n    \n    # Sort by deliciousness in descending order\n    ice_creams.sort(key=lambda x: x[1], reverse=True)\n    \n    max_satisfaction = 0\n    # Dictionary to store the maximum deliciousness of each flavor\n    max_deliciousness = defaultdict(lambda: 0)\n    \n    for F, S in ice_creams:\n        # Check if there's another cup with the same flavor\n        if max_deliciousness[F] > 0:\n            # Calculate satisfaction if they have the same flavor\n            satisfaction_same_flavor = max_deliciousness[F] + S / 2\n            max_satisfaction = max(max_satisfaction, satisfaction_same_flavor)\n        \n        # Update the maximum deliciousness for this flavor\n        max_deliciousness[F] = max(max_deliciousness[F], S)\n    \n    # Find the highest deliciousness for different flavors\n    for F, S in ice_creams:\n        if max_deliciousness[F] != S:\n            satisfaction_different_flavor = S + max_deliciousness[F]\n            max_satisfaction = max(max_satisfaction, satisfaction_different_flavor)\n    \n    print(int(max_satisfaction))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_d",
        "code_list": [
            "def main():\n    # Read input\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    while True:\n        # Check rows\n        marked_rows = set()\n        for i in range(H):\n            if len(set(grid[i])) > 1:\n                continue\n            if grid[i].count(grid[i][0]) >= 2:\n                marked_rows.add(i)\n        \n        # Check columns\n        marked_cols = set()\n        for j in range(W):\n            col = ''.join(grid[i][j] for i in range(H))\n            if len(set(col)) > 1:\n                continue\n            if col.count(col[0]) >= 2:\n                marked_cols.add(j)\n        \n        # Marked cookies found, remove them\n        if marked_rows or marked_cols:\n            for i in range(H):\n                for j in range(W):\n                    if (i in marked_rows) or (j in marked_cols):\n                        grid[i] = grid[i][:j] + '.' + grid[i][j+1:]\n            continue\n        \n        # No more marked cookies, break the loop\n        break\n    \n    # Count remaining cookies\n    remaining_cookies = sum(row.count('.') == 0 for row in grid)\n    print(remaining_cookies)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_e",
        "code_list": [
            "from collections import deque, defaultdict\n\ndef find_reading_order(N, graph):\n    indegree = [0] * (N + 1)\n    for i in range(1, N + 1):\n        for p in graph[i]:\n            indegree[p] += 1\n    \n    queue = deque()\n    for i in range(1, N + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\ndef main():\n    N = int(input())\n    graph = defaultdict(list)\n    \n    for i in range(1, N + 1):\n        C, *P = map(int, input().split())\n        graph[i+1].extend(P)\n    \n    reading_order = find_reading_order(N, graph)\n    for book in reading_order[:-1]:  # Exclude book 1\n        print(book, end=' ')\n    print()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_f",
        "code_list": [
            "import math\nfrom itertools import combinations\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef min_race_distance(N, checkpoints):\n    min_distance = float('inf')\n    for C in range(1, N-1):  # C is the number of checkpoints to skip\n        distances = [euclidean_distance(checkpoints[i], checkpoints[i+1]) for i in range(N-1)]\n        for comb in combinations(range(1, N-1), C):\n            distances_skipped = list(distances)\n            for index in sorted(comb, reverse=True):\n                del distances_skipped[index]\n            total_distance = sum(distances_skipped) + 2 ** (C - 1)\n            min_distance = min(min_distance, total_distance)\n    return min_distance\n\ndef main():\n    N = int(input())\n    checkpoints = [tuple(map(int, input().split())) for _ in range(N)]\n    result = min_race_distance(N, checkpoints)\n    print(f\"{result:.15f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc318_a",
        "code_list": [
            "def main():\n    N, M, P = map(int, input().split())\n    count = 0\n    for day in range(M, N + 1, P):\n        if day <= N:\n            count += 1\n    print(count)"
        ]
    },
    {
        "question_id": "abc318_b",
        "code_list": [
            "def main():\n    import sys\n    from itertools import product\n    \n    def intersect(a1, b1, c1, d1, a2, b2, c2, d2):\n        # Check if two rectangles intersect\n        return max(a1, a2) < min(b1, b2) and max(c1, c2) < min(d1, d2)\n    \n    n = int(input())\n    intervals = [tuple(map(int, line.split())) for _ in range(n)]\n    \n    # Generate all possible intersections\n    intersections = set()\n    for (a1, b1, c1, d1), (a2, b2, c2, d2) in product(intervals, repeat=2):\n        if intersect(a1, b1, c1, d1, a2, b2, c2, d2):\n            intersections.add((max(a1, a2), min(b1, b2), max(c1, c2), min(d1, d2)))\n    \n    # Calculate the total area covered by the intersections\n    total_area = sum((b - a) * (d - c) for a, b, c, d in intersections)\n    \n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc318_c",
        "code_list": [
            "def min_cost(N, D, P, F):\n    # Calculate the total cost if no one-day passes are bought\n    total_fare = sum(F)\n    \n    # Calculate the number of one-day passes needed\n    passes_needed = (N + D - 1) // D\n    \n    # Calculate the cost with the optimal number of one-day passes\n    total_cost = passes_needed * P + sum(sorted(F)[:N - passes_needed * D])\n    \n    return total_cost\n\ndef main():\n    N, D, P = map(int, input().split())\n    F = list(map(int, input().split()))\n    print(min_cost(N, D, P, F))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc318_d",
        "code_list": [
            "import itertools\n\ndef max_weighted_edges(N, weights):\n    # Generate all possible combinations of edges\n    edge_combinations = list(itertools.combinations(range(N), 2))\n    \n    # Calculate the total weight for each combination of edges\n    max_weight = 0\n    for combination in itertools.combinations(edge_combinations, N//2):\n        current_weight = sum(weights[i][j] for i, j in combination)\n        if len(set([i for i, _ in combination] + [j for _, j in combination])) == N:\n            max_weight = max(max_weight, current_weight)\n    \n    return max_weight\n\nif __name__ == \"__main__\":\n    N = int(input())\n    weights = []\n    for _ in range(N):\n        row = list(map(int, input().split()))\n        weights.append(row)\n    \n    print(max_weighted_edges(N, weights))"
        ]
    },
    {
        "question_id": "abc318_e",
        "code_list": [
            "from collections import defaultdict\n\ndef count_triples():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Dictionary to store the indices of each element\n    index_map = defaultdict(list)\n    for i, num in enumerate(arr):\n        index_map[num].append(i)\n    \n    # Calculate the number of valid triples\n    count = 0\n    for num, indices in index_map.items():\n        if len(indices) >= 2:\n            for i in range(len(indices) - 2):\n                for j in range(i + 1, len(indices) - 1):\n                    if arr[indices[i]] != arr[indices[j]]:\n                        count += indices[-1] - indices[j]\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    count_triples()"
        ]
    },
    {
        "question_id": "abc319_b",
        "code_list": [
            "def main():\n    N = int(input().strip())\n    result = ['-'] * (N + 1)\n    \n    for i in range(1, 10):\n        for j in range(1, N // i + 1):\n            index = j * i - 1\n            if index <= N and N % (i * j) == 0:\n                if result[index] == '-':\n                    result[index] = str(i)\n                else:\n                    result[index] = min(result[index], str(i))\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc319_c",
        "code_list": [
            "from itertools import permutations\n\ndef calculate_probability(grid):\n    count_valid = 0\n    total_permutations = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\n    \n    # Generate all possible permutations of the grid\n    for perm in permutations(range(9)):\n        valid = True\n        \n        # Check horizontal lines\n        for i in range(3):\n            if perm[i*3] == perm[i*3+1] and perm[i*3+1] != perm[i*3+2]:\n                valid = False\n                break\n        \n        # Check vertical lines\n        for j in range(3):\n            if perm[j] == perm[3+j] and perm[3+j] != perm[6+j]:\n                valid = False\n                break\n        \n        # Check diagonal lines\n        if perm[0] == perm[4] and perm[4] != perm[8]:\n            valid = False\n        if perm[2] == perm[4] and perm[4] != perm[6]:\n            valid = False\n        \n        if valid:\n            count_valid += 1\n    \n    return count_valid / total_permutations\n\ndef main():\n    grid = []\n    for _ in range(3):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    probability = calculate_probability(grid)\n    print(f\"{probability:.16f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc319_d",
        "code_list": [
            "def min_window_width(N, M, lengths):\n    # Initialize binary search bounds\n    low, high = max(lengths), sum(lengths) + M - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        lines, current_width = 1, 0\n        \n        for length in lengths:\n            if current_width + length > mid:\n                lines += 1\n                current_width = length\n            else:\n                current_width += length + 1\n        \n        if lines > M:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    lengths = list(map(int, input().split()))\n    print(min_window_width(N, M, lengths))"
        ]
    },
    {
        "question_id": "abc319_e",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef process_queries(N, X, Y, P, T, Q, queries):\n    # Calculate the LCM of all P_i values\n    lcm_value = reduce(lcm, P)\n    \n    # Initialize the result list\n    results = []\n    \n    for q in queries:\n        # Calculate the earliest arrival time at bus stop 1\n        time_to_stop_1 = max(q + X - (q + X) % lcm_value, q + X)\n        \n        # Calculate the earliest arrival time at bus stop N\n        time_to_stop_N = time_to_stop_1 + sum(T[i] for i in range(N-1))\n        \n        # Add walking time from bus stop N to Aoki's house\n        final_time = time_to_stop_N + Y\n        \n        results.append(final_time)\n    \n    return results\n\ndef main():\n    N, X, Y = map(int, input().split())\n    P = [int(input()) for _ in range(N-1)]\n    T = [int(input()) for _ in range(N-1)]\n    Q = int(input())\n    queries = [int(input()) for _ in range(Q)]\n    \n    results = process_queries(N, X, Y, P, T, Q, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc320_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    A, B = map(int, input().split())\n    result = pow(A, B) + pow(B, A)\n    print(result)"
        ]
    },
    {
        "question_id": "abc320_b",
        "code_list": [
            "def expand_around_center(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1\n\ndef longest_palindromic_substring(s):\n    if len(s) < 2:\n        return len(s)\n    \n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(s, i, i)\n        len2 = expand_around_center(s, i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return end - start + 1\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(longest_palindromic_substring(s))"
        ]
    },
    {
        "question_id": "abc320_c",
        "code_list": [
            "def find_min_time(M, S):\n    # Check if all strings are the same\n    if len(set(S)) == 1:\n        return 0\n    \n    # Find the unique characters in each string\n    unique_chars = [set(s) for s in S]\n    \n    # Check if there is any common character among all strings\n    common_chars = set.intersection(*unique_chars)\n    \n    if not common_chars:\n        return -1\n    \n    # Calculate the minimum time to align all reels to a common character\n    min_time = float('inf')\n    for char in common_chars:\n        times = [s.index(char) for s in S]\n        min_time = min(min_time, max(times))\n    \n    return min_time + M\n\ndef main():\n    M = int(input())\n    S = [input().strip() for _ in range(3)]\n    result = find_min_time(M, S)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc320_d",
        "code_list": [
            "from collections import defaultdict\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    # Initialize dictionaries to store the relative positions\n    relative_positions = defaultdict(list)\n    for i in range(M):\n        A = int(data[2 * i + 2]) - 1\n        B = int(data[2 * i + 3]) - 1\n        X = int(data[2 * i + 4])\n        Y = int(data[2 * i + 5])\n        relative_positions[A].append((B, X, Y))\n        relative_positions[B].append((A, -X, -Y))\n    \n    # Initialize coordinates with None\n    coordinates = [None] * N\n    \n    # Function to update coordinates based on relative position\n    def update_coordinates(person, x, y):\n        if coordinates[person] is None:\n            coordinates[person] = (x, y)\n        else:\n            cx, cy = coordinates[person]\n            if (cx + x, cy + y) != (cx, cy):\n                coordinates[person] = (cx + x, cy + y)\n    \n    # Start with person 1 at the origin\n    update_coordinates(0, 0, 0)\n    \n    # Process all relative positions\n    for person in range(N):\n        if coordinates[person] is None:\n            continue\n        for other_person, dx, dy in relative_positions[person]:\n            if coordinates[other_person] is None:\n                update_coordinates(other_person, dx, dy)\n            elif coordinates[other_person] != (coordinates[person][0] + dx, coordinates[person][1] + dy):\n                print(\"undecidable\")\n                return\n    \n    # Print the coordinates\n    for coord in coordinates:\n        if coord is None:\n            print(\"undecidable\")\n        else:\n            print(coord[0], coord[1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc320_e",
        "code_list": [
            "from collections import deque\n\ndef main():\n    N, M = map(int, input().split())\n    events = [list(map(int, input().split())) for _ in range(M)]\n    \n    # Initialize the deque with positions of people in the row\n    people_in_row = deque(range(1, N + 1))\n    noodles_received = [0] * N\n    \n    current_time = 0\n    \n    for T, W, S in events:\n        while people_in_row and current_time >= people_in_row[0]:\n            # Person at the front leaves the row\n            person_leaving = people_in_row.popleft()\n            # Person returns to the row after S time units\n            people_in_row.append(person_leaving)\n            current_time += S\n        \n        if people_in_row:\n            # Front person receives noodles\n            noodles_received[people_in_row[0] - 1] += W\n        \n        current_time = max(current_time, T)\n        current_time += W\n    \n    for i in range(N):\n        print(noodles_received[i])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc321_a",
        "code_list": [
            "def is_321_like_number(N):\n    digits = [int(d) for d in str(N)]\n    for i in range(len(digits) - 1):\n        if digits[i] <= digits[i + 1]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    if is_321_like_number(N):\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        ]
    },
    {
        "question_id": "abc321_b",
        "code_list": [
            "def main():\n    N, X = map(int, input().split())\n    scores = list(map(int, input().split()))\n    \n    # Sort the scores\n    scores.sort()\n    \n    # Calculate the current sum without the highest and lowest scores\n    current_sum = sum(scores[1:-1])\n    \n    # Calculate the minimum score needed in the last round\n    min_score_needed = X - current_sum\n    \n    # Check if the minimum score needed is valid\n    if min_score_needed < 0:\n        print(-1)\n    elif min_score_needed > 100:\n        print(100)\n    else:\n        print(min_score_needed)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc321_c",
        "code_list": [
            "def generate_321_like_numbers(k):\n    numbers = []\n    # Generate all possible combinations of digits in descending order\n    for i in range(1, 10):\n        for j in range(i + 1, 10):\n            for l in range(j + 1, 10):\n                for m in range(l + 1, 10):\n                    for n in range(m + 1, 10):\n                        numbers.append(int(f\"{i}{j}{l}{m}{n}\"))\n    # Sort the generated numbers\n    numbers.sort()\n    return numbers[k - 1]\n\ndef main():\n    k = int(input())\n    result = generate_321_like_numbers(k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc321_d",
        "code_list": [
            "def calculate_total_price(N, M, P, A, B):\n    # Sort the arrays A and B\n    A.sort()\n    B.sort()\n    \n    # Initialize the result variable\n    total_price = 0\n    \n    # Iterate through each main dish\n    for i in range(N):\n        # For each main dish, find the number of side dishes that make the sum less than or equal to P\n        count = 0\n        for j in range(M):\n            if A[i] + B[j] <= P:\n                count += 1\n            else:\n                break\n        \n        # Add the contribution of this main dish to the total price\n        total_price += count * A[i]\n    \n    # Add the contribution of each side dish when paired with the cheapest main dish\n    total_price += (M - count) * min(A)\n    \n    return total_price\n\nif __name__ == \"__main__\":\n    N, M, P = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(calculate_total_price(N, M, P, A, B))"
        ]
    },
    {
        "question_id": "abc321_e",
        "code_list": [
            "def count_vertices_distance(N, X, K):\n    if K == 0:\n        return 1 if X == 1 else 0\n    \n    # Calculate the distance from X to the root (1)\n    distance = 0\n    while X != 1:\n        X = X // 2\n        distance += 1\n    \n    if distance > K:\n        return 0\n    \n    remaining_distance = K - distance\n    result = 0\n    \n    # Traverse upwards from the current node\n    current_node = X\n    while remaining_distance >= 0:\n        if remaining_distance == 0:\n            result += 1\n        current_node = current_node * 2\n        remaining_distance -= 1\n    \n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        X = int(data[index + 1])\n        K = int(data[index + 2])\n        index += 3\n        \n        results.append(count_vertices_distance(N, X, K))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    \n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            print(i + 1)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    S = input().strip()\n    T = input().strip()\n\n    # Check if S is a prefix of T\n    is_prefix = T.startswith(S)\n    # Check if S is a suffix of T\n    is_suffix = T.endswith(S)\n\n    # Determine the result based on the conditions\n    if is_prefix and is_suffix:\n        print(0)\n    elif is_prefix and not is_suffix:\n        print(1)\n    elif not is_prefix and is_suffix:\n        print(2)\n    else:\n        print(3)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Initialize the result list\n    result = [0] * N\n\n    # Iterate from the last day to the first day\n    for i in range(N - 2, -1, -1):\n        # Find the next day with fireworks\n        next_firework_day = min([day for day in A if day > i], default=i)\n        # Calculate the difference\n        result[i] = next_firework_day - i\n\n    # Print the result\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_d",
        "code_list": [
            "import copy\n\ndef rotate(polyomino):\n    \"\"\"Rotate a polyomino 90 degrees clockwise.\"\"\"\n    return [''.join(row) for row in zip(*reversed(polyomino))]\n\ndef flip(polyomino):\n    \"\"\"Flip a polyomino vertically.\"\"\"\n    return [row[::-1] for row in polyomino]\n\ndef place_polyomino(grid, polyomino, pos):\n    \"\"\"Place a polyomino on the grid starting at position pos.\"\"\"\n    for dy in range(4):\n        for dx in range(4):\n            if polyomino[dy][dx] == '#':\n                if pos[0] + dy >= 4 or pos[1] + dx >= 4:\n                    return False\n                if grid[pos[0] + dy][pos[1] + dx] != '.':\n                    return False\n                grid[pos[0] + dy][pos[1] + dx] = '#'\n    return True\n\ndef remove_polyomino(grid, polyomino, pos):\n    \"\"\"Remove a polyomino from the grid starting at position pos.\"\"\"\n    for dy in range(4):\n        for dx in range(4):\n            if polyomino[dy][dx] == '#':\n                grid[pos[0] + dy][pos[1] + dx] = '.'\n\ndef check_solution(grid, polyominoes):\n    \"\"\"Check if the grid is completely covered by non-overlapping polyominoes.\"\"\"\n    for row in grid:\n        if '#' in row:\n            return False\n    return True\n\ndef solve(grid, polyominoes, index=0):\n    \"\"\"Recursively try to place polyominoes on the grid.\"\"\"\n    if index == len(polyominoes):\n        return check_solution(grid, polyominoes)\n    \n    for i in range(4):\n        for j in range(4):\n            for polyomino in polyominoes[index]:\n                new_grid = copy.deepcopy(grid)\n                if place_polyomino(new_grid, polyomino, (i, j)):\n                    if solve(new_grid, polyominoes, index + 1):\n                        return True\n                remove_polyomino(new_grid, polyomino, (i, j))\n                for _ in range(3):\n                    polyomino = rotate(polyomino)\n                    if place_polyomino(new_grid, polyomino, (i, j)):\n                        if solve(new_grid, polyominoes, index + 1):\n                            return True\n                    remove_polyomino(new_grid, polyomino, (i, j))\n                    polyomino = flip(polyomino)\n                    if place_polyomino(new_grid, polyomino, (i, j)):\n                        if solve(new_grid, polyominoes, index + 1):\n                            return True\n                    remove_polyomino(new_grid, polyomino, (i, j))\n                    polyomino = rotate(polyomino)\n                    if place_polyomino(new_grid, polyomino, (i, j)):\n                        if solve(new_grid, polyominoes, index + 1):\n                            return True\n                    remove_polyomino(new_grid, polyomino, (i, j))\n    return False\n\ndef main():\n    polyominoes = []\n    for i in range(3):\n        polyomino = []\n        for j in range(4):\n            row = input().strip()\n            polyomino.append(row)\n        polyominoes.append(polyomino)\n    \n    grid = [['.' for _ in range(4)] for _ in range(4)]\n    if solve(grid, polyominoes):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_e",
        "code_list": [
            "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, k, p = int(data[0]), int(data[1]), int(data[2])\n    costs = []\n    effects = [[] for _ in range(k)]\n    \n    start = 3\n    for i in range(n):\n        c = int(data[start])\n        start += 1\n        for j in range(k):\n            a = int(data[start])\n            start += 1\n            effects[j].append(a)\n        costs.append(c)\n    \n    # Calculate the total effect needed for each parameter\n    target = [p] * k\n    dp = [[float('inf')] * (p + 1) for _ in range(1 << k)]\n    dp[0][0] = 0\n    \n    for mask in range(1 << k):\n        for j in range(k):\n            if mask & (1 << j):\n                for prev_mask in range(mask):\n                    if (prev_mask & (1 << j)) == 0:\n                        new_mask = mask ^ (1 << j)\n                        dp[mask][j] = min(dp[mask][j], dp[new_mask][j] + costs[i])\n                        for i in range(k):\n                            dp[mask][j] += effects[i][j]\n    \n    result = min(dp[(1 << k) - 1])\n    print(result if result != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    for i in range(2, 17, 2):\n        if S[i-1] != '0':\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_b",
        "code_list": [
            "def main():\n    N = int(input())\n    wins = [0] * N\n    \n    for i in range(N):\n        S_i = input()\n        for j in range(N):\n            if S_i[j] == 'o':\n                wins[i] += 1\n    \n    ranked_players = sorted(range(N), key=lambda k: (-wins[k], k))\n    \n    for player in ranked_players:\n        print(player + 1, end=' ')\n    print()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Process each player\n    for i in range(N):\n        # Read the solved status for the current player\n        S = input()\n        \n        # Calculate the current score of the player\n        current_score = sum(A[j] for j in range(M) if S[j] == 'o') + i\n        \n        # Initialize the number of additional problems needed\n        additional_problems_needed = 0\n        \n        # Calculate the minimum number of additional problems needed\n        for j in range(M):\n            if S[j] == 'x':\n                # Calculate the score increase by solving the j-th problem\n                score_increase = A[j]\n                \n                # Calculate the new score after solving the j-th problem\n                new_score = current_score + score_increase + additional_problems_needed\n                \n                # Check if the new score exceeds all other players' current scores\n                if new_score > max(current_score + sum(A[k] for k in range(M) if S[k] == 'x') + (i + 1 - count_x(S)) * 100 for count_x in [lambda s: s.count('x')]):\n                    break\n                \n                # Increment the number of additional problems needed\n                additional_problems_needed += 1\n        \n        # Print the result for the current player\n        print(additional_problems_needed)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    index = 1\n    sizes = []\n    counts = []\n\n    for _ in range(n):\n        sizes.append(int(data[index]))\n        counts.append(int(data[index + 1]))\n        index += 2\n\n    min_slimes = sum(counts)\n\n    for size in sizes:\n        count = counts[sizes.index(size)]\n        while count >= 2:\n            count -= 2\n            min_slimes -= 1\n            if count >= 2:\n                min_slimes += 1\n\n    print(min_slimes)"
        ]
    },
    {
        "question_id": "abc323_e",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\ndef modinv(a, m=998244353):\n    return pow(a, m - 2, m)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(N, X, Ts):\n    total_time = sum(Ts)\n    prob = [0] * N\n    dp = [0] * (total_time + 1)\n    dp[0] = 1\n    \n    for t in Ts:\n        new_dp = [0] * (total_time + 1)\n        for i in range(total_time + 1):\n            if i + t <= total_time:\n                new_dp[i + t] += dp[i]\n            new_dp[i] += dp[i]\n        dp = new_dp\n    \n    for i in range(total_time + 1):\n        if i > X:\n            break\n        prob[i % len(Ts)] += dp[i]\n    \n    numerator = 0\n    denominator = 0\n    for i in range(N):\n        numerator += prob[i * total_time // N] * Ts[i]\n        denominator += Ts[i]\n    \n    numerator %= 998244353\n    denominator %= 998244353\n    lcm_den = reduce(lcm, [denominator] * N)\n    numerator *= modinv(denominator, 998244353)\n    numerator %= 998244353\n    result = numerator * modinv(lcm_den, 998244353) % 998244353\n    return result\n\nif __name__ == \"__main__\":\n    N, X = map(int, input().split())\n    Ts = list(map(int, input().split()))\n    print(solve(N, X, Ts))"
        ]
    },
    {
        "question_id": "abc324_a",
        "code_list": [
            "def main():\n    # Read the number of integers N\n    N = int(input())\n    \n    # Read the list of integers A_1, A_2, ..., A_N\n    A = list(map(int, input().split()))\n    \n    # Check if all elements in the list are equal\n    if len(set(A)) == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_b",
        "code_list": [
            "import math\n\ndef main():\n    N = int(input())\n    # Check if N is divisible by 2 and then by 3 until it can't be divided anymore\n    while N % 2 == 0:\n        N //= 2\n    while N % 3 == 0:\n        N //= 3\n    \n    # If after division, N is 1, it means N was only composed of factors 2 and 3\n    if N == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_c",
        "code_list": [
            "def is_valid(s, t):\n    if len(s) > len(t) + 1:\n        return False\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        else:\n            j += 1\n    return i == len(s)\n\ndef find_possible_strings(n, t_prime, strings):\n    possible_indices = []\n    for i, s in enumerate(strings):\n        if len(s) == len(t_prime) and s == t_prime or \\\n           (len(s) == len(t_prime) + 1 and is_valid(s, t_prime)) or \\\n           (len(s) == len(t_prime) - 1 and is_valid(t_prime, s)) or \\\n           (len(s) == len(t_prime) and sum(c1 != c2 for c1, c2 in zip(s, t_prime)) == 1):\n            possible_indices.append(i + 1)\n    return possible_indices\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[1])\n    t_prime = data[2]\n    strings = data[3:]\n    \n    possible_indices = find_possible_strings(n, t_prime, strings)\n    print(len(possible_indices))\n    print(' '.join(map(str, possible_indices)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_d",
        "code_list": [
            "import itertools\nimport math\n\ndef is_square(num):\n    return int(math.isqrt(num)) ** 2 == num\n\ndef count_square_numbers(N, S):\n    count = 0\n    for perm in itertools.permutations(S):\n        num = int(''.join(perm))\n        if num > 0 and is_square(num):\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    print(count_square_numbers(N, S))"
        ]
    },
    {
        "question_id": "abc324_e",
        "code_list": [
            "from collections import defaultdict\n\ndef find_subsequence_pairs(N, T, strings):\n    def is_subsequence(s, t):\n        t_index = 0\n        for char in s:\n            if t_index < len(t) and char == t[t_index]:\n                t_index += 1\n            if t_index == len(t):\n                return True\n        return False\n\n    count = 0\n    for i in range(N):\n        for j in range(i, N):\n            if is_subsequence(strings[i] + strings[j], T):\n                count += 1\n    return count\n\ndef main():\n    N, T = input().split()\n    N = int(N)\n    strings = [input().strip() for _ in range(N)]\n    print(find_subsequence_pairs(N, T, strings))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_f",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef dijkstra_with_beauty(graph, start, end):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    beauty_cost_ratio = [float('-inf')] * n\n    beauty_cost_ratio[start] = 0\n    pq = [(0, 0, start)]  # (cost, beauty, node)\n\n    while pq:\n        cost, beauty, node = heapq.heappop(pq)\n        if node == end:\n            return beauty / cost\n        for neighbor, b, c in graph[node]:\n            new_cost = cost + c\n            new_beauty = beauty + b\n            new_ratio = new_beauty / new_cost\n            if new_ratio > beauty_cost_ratio[neighbor]:\n                beauty_cost_ratio[neighbor] = new_ratio\n                dist[neighbor] = new_cost\n                heapq.heappush(pq, (new_cost, new_beauty, neighbor))\n    return -1\n\ndef main():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v, b, c = map(int, input().split())\n        graph[u-1].append((v-1, b, c))\n\n    print(dijkstra_with_beauty(graph, 0, n-1))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_a",
        "code_list": [
            "def main():\n    S, T = input().split()\n    print(f\"{S} san\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    start_times = []\n    end_times = []\n    weights = []\n    \n    for i in range(1, n * 3 + 1, 3):\n        start_times.append(int(data[i]))\n        end_times.append(int(data[i + 1]))\n        weights.append(int(data[i + 2]))\n    \n    max_employees = 0\n    \n    for start in range(9, 18):\n        end = start + 1\n        current_weight = 0\n        \n        for i in range(n):\n            if start_times[i] <= start and end_times[i] >= end:\n                current_weight += weights[i]\n        \n        max_employees = max(max_employees, current_weight)\n    \n    print(max_employees)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_c",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    def merge_sensors(i, j):\n        stack = [(i, j)]\n        while stack:\n            x, y = stack.pop()\n            if grid[x][y] == '.':\n                continue\n            grid[x][y] = '.'\n            for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '#':\n                    stack.append((nx, ny))\n    \n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                merge_sensors(i, j)\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_d",
        "code_list": [
            "import heapq\n\ndef max_printable_products(N, intervals):\n    events = []\n    for i, (T, D) in enumerate(intervals):\n        events.append((T, i, 'enter'))\n        events.append((T + D - 1, i, 'leave'))\n    \n    events.sort()\n    charge_time = 0\n    printed = set()\n    max_printed = 0\n    \n    for time, i, event in events:\n        if event == 'enter':\n            if charge_time <= time:\n                printed.add(i)\n                max_printed = max(max_printed, len(printed))\n                charge_time = time + 1\n            else:\n                heapq.heappush(events, (charge_time, i, 'enter'))\n                printed.add(i)\n                max_printed = max(max_printed, len(printed))\n                charge_time = time + 1\n        elif event == 'leave':\n            printed.remove(i)\n            charge_time = min(charge_time, time + 1)\n    \n    return max_printed\n\nif __name__ == \"__main__\":\n    N = int(input())\n    intervals = [tuple(map(int, input().split())) for _ in range(N)]\n    print(max_printable_products(N, intervals))"
        ]
    },
    {
        "question_id": "abc325_e",
        "code_list": [
            "import sys\nfrom heapq import heappop, heappush\n\ndef dijkstra(N, A, B, C, D):\n    # Initialize distances with infinity\n    dist = [[float('inf')] * N for _ in range(N)]\n    # Distance from city 1 to itself is 0\n    dist[0][0] = 0\n    \n    # Priority queue to store (time, current_city, last_transport)\n    pq = [(0, 0, 'car')]\n    \n    while pq:\n        time, current_city, last_transport = heappop(pq)\n        \n        if time > dist[current_city][last_transport == 'car']:\n            continue\n        \n        # Calculate the next possible times using both car and train\n        for next_city in range(N):\n            if D[current_city][next_city] == float('inf'):\n                continue\n            \n            # If we are currently in a car and can switch to train\n            if last_transport == 'car':\n                new_time_car = time + D[current_city][next_city] * A\n                new_time_train = time + D[current_city][next_city] * B + C\n                if new_time_car < dist[next_city][True]:\n                    dist[next_city][True] = new_time_car\n                    heappush(pq, (new_time_car, next_city, True))\n                if new_time_train < dist[next_city][False]:\n                    dist[next_city][False] = new_time_train\n                    heappush(pq, (new_time_train, next_city, False))\n            \n            # If we are currently on a train and can switch to car\n            elif last_transport == 'train':\n                new_time_car = time + D[current_city][next_city] * A\n                if new_time_car < dist[next_city][True]:\n                    dist[next_city][True] = new_time_car\n                    heappush(pq, (new_time_car, next_city, True))\n    \n    # Return the minimum time to reach city N\n    return min(dist[N-1])\n\ndef main():\n    # Read input\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    C = int(data[3])\n    \n    D = []\n    for i in range(N):\n        row = list(map(int, data[4 + i * N : 4 + (i + 1) * N]))\n        D.append(row)\n    \n    # Calculate and print the result\n    print(dijkstra(N, A, B, C, D))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_f",
        "code_list": [
            "import sys\nfrom typing import List\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    d_start = 1\n    d_end = d_start + n\n    d = list(map(int, data[d_start:d_end]))\n    \n    l_start = d_end\n    l_end = l_start + 2\n    l = [int(data[i]) for i in range(l_start, l_end)]\n    \n    c_start = l_end\n    c_end = c_start + 2\n    c = [int(data[i]) for i in range(c_start, c_end)]\n    \n    k_start = c_end\n    k_end = k_start + 2\n    k = [int(data[i]) for i in range(k_start, k_end)]\n    \n    dp = [float('inf')] * (max(d) + 1)\n    dp[0] = 0\n    \n    for i in range(1, max(d) + 1):\n        for j in range(2):\n            if i >= l[j] and k[j] > 0:\n                dp[i] = min(dp[i], dp[i - l[j]] + c[j])\n                k[j] -= 1\n    \n    result = float('inf')\n    for i in d:\n        result = min(result, dp[i])\n    \n    if result == float('inf'):\n        print(-1)\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_a",
        "code_list": [
            "def main():\n    X, Y = map(int, input().split())\n    if abs(X - Y) <= 2:\n        print(\"Yes\")\n    elif (X < Y and Y - X <= 3) or (X > Y and X - Y <= 3):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_b",
        "code_list": [
            "def find_next_326_like_number(N):\n    for num in range(N, 1000):\n        hundreds = num // 100\n        tens = (num // 10) % 10\n        ones = num % 10\n        if hundreds * tens == ones:\n            return num\n\nif __name__ == \"__main__\":\n    N = int(input())\n    print(find_next_326_like_number(N))"
        ]
    },
    {
        "question_id": "abc326_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Sort the coordinates\n    A.sort()\n\n    # Initialize variables\n    max_gifts = 0\n    left = 0\n\n    # Iterate through the sorted coordinates\n    for right in range(N):\n        # Check if the current interval [A[left], A[right] + M) contains valid gifts\n        while A[right] - A[left] >= M:\n            left += 1\n        # Update the maximum number of gifts\n        max_gifts = max(max_gifts, right - left + 1)\n\n    # Print the result\n    print(max_gifts)"
        ]
    },
    {
        "question_id": "abc326_d",
        "code_list": [
            "from itertools import permutations\n\ndef solve(N, R, C):\n    # Generate all possible permutations for the rows and columns\n    row_perms = list(permutations('ABC' * (N // 3 + 1), N))\n    col_perms = list(permutations('ABC' * (N // 3 + 1), N))\n\n    # Filter permutations based on the required conditions\n    valid_rows = [perm for perm in row_perms if all(perm[i] == ch for i, ch in enumerate(R))]\n    valid_cols = [perm for perm in col_perms if all(perm[i] == ch for i, ch in enumerate(C))]\n\n    # Check for a valid solution\n    for row_perm in valid_rows:\n        for col_perm in valid_cols:\n            grid = [['.' for _ in range(N)] for _ in range(N)]\n            used = set()\n\n            # Place characters according to row and column permutations\n            for i in range(N):\n                for j in range(N):\n                    if (i, j) not in used:\n                        grid[i][j] = row_perm[i]\n                        grid[j][i] = col_perm[j]\n                        used.add((i, j))\n\n            # Verify the solution\n            if all(grid[i].count(ch) == 1 for ch in 'ABC') and all(grid[j].count(ch) == 1 for ch in 'ABC'):\n                return ['Yes'] + [\"\".join(row) for row in grid]\n\n    return ['No']\n\ndef main():\n    N = int(input().strip())\n    R = input().strip()\n    C = input().strip()\n    result = solve(N, R, C)\n    print(result[0])\n    if result[0] == 'Yes':\n        for row in result[1:]:\n            print(row)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_e",
        "code_list": [
            "def modular_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef expected_salary(N, A):\n    mod = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 0\n    for i in range(1, N + 1):\n        dp[i] = sum(A[j] * (i - j) * modular_inverse(i, mod) % mod for j in range(i)) % mod\n    return sum(dp) % mod\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(expected_salary(N, A))"
        ]
    },
    {
        "question_id": "abc327_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    \n    for i in range(N - 1):\n        if (S[i] == 'a' and S[i + 1] == 'b') or (S[i] == 'b' and S[i + 1] == 'a'):\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc327_b",
        "code_list": [
            "import math\n\ndef main():\n    B = int(input())\n    for A in range(1, int(math.log2(B)) + 2):\n        if A ** A == B:\n            print(A)\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc327_c",
        "code_list": [
            "def check_sudoku(grid):\n    # Check rows\n    for row in grid:\n        if sorted(row) != list(range(1, 10)):\n            return \"No\"\n    \n    # Check columns\n    for col in range(9):\n        if sorted([grid[row][col] for row in range(9)]) != list(range(1, 10)):\n            return \"No\"\n    \n    # Check 3x3 subgrids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if sorted(subgrid) != list(range(1, 10)):\n                return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    grid = []\n    for _ in range(9):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    print(check_sudoku(grid))"
        ]
    },
    {
        "question_id": "abc327_d",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Create a dictionary to store the parity of differences\n    diff_parity = {}\n    \n    # Iterate through the pairs (A_i, B_i)\n    for i in range(M):\n        diff = abs(A[i] - B[i])\n        if diff % 2 == 0:\n            if diff not in diff_parity or diff_parity[diff] == 0:\n                diff_parity[diff] = 1\n            else:\n                print(\"No\")\n                return\n        else:\n            if diff not in diff_parity or diff_parity[diff] == 1:\n                diff_parity[diff] = 0\n            else:\n                print(\"No\")\n                return\n    \n    # If no conflict is found, print \"Yes\"\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc327_e",
        "code_list": [
            "import heapq\nfrom math import sqrt\n\ndef calculate_rating(performance):\n    k = len(performance)\n    numerator = sum((0.9)**(k-i) * performance[i] for i in range(k))\n    denominator = sum((0.9)**(k-i) for i in range(k))\n    return numerator / denominator - 1200 / sqrt(k)\n\ndef max_rating(contests):\n    n = len(contests)\n    max_heap = []\n    \n    # Initialize the heap with the first element\n    heapq.heappush(max_heap, (-contests[0], 0))\n    \n    current_max_rating = -calculate_rating([-contests[0]])\n    \n    for i in range(1, n):\n        while max_heap and -max_heap[0][1] < i - 50:\n            heapq.heappop(max_heap)\n        \n        new_performance = -contests[i]\n        new_rating = -calculate_rating([new_performance] + [-performance for performance, _ in max_heap])\n        \n        if new_rating > current_max_rating:\n            current_max_rating = new_rating\n            heapq.heappush(max_heap, (-new_performance, i))\n    \n    return current_max_rating\n\ndef main():\n    n = int(input().strip())\n    performances = list(map(int, input().strip().split()))\n    print(f\"{max_rating(performances):.15f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc328_a",
        "code_list": [
            "def main():\n    # Read input values\n    N, X = map(int, input().split())\n    scores = list(map(int, input().split()))\n    \n    # Calculate the total score for problems with a score of X or less\n    total_score = sum(score for score in scores if score <= X)\n    \n    # Print the result\n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc328_b",
        "code_list": [
            "def main():\n    N = int(input())\n    days_in_month = list(map(int, input().split()))\n\n    count = 0\n    for i, days in enumerate(days_in_month, start=1):\n        for j in range(1, days + 1):\n            str_i = str(i)\n            str_j = str(j)\n            if len(set(str_i)) == 1 or (len(str_i) > 1 and str_i[0] == str_j[0]):\n                count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc328_c",
        "code_list": [
            "def count_consecutive_duplicates(s, queries):\n    n = len(s)\n    prefix_sum = [0] * (n + 1)\n    \n    # Calculate prefix sum array where prefix_sum[i] stores the number of consecutive duplicates up to index i-1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            prefix_sum[i + 1] = prefix_sum[i] + 1\n        else:\n            prefix_sum[i + 1] = prefix_sum[i]\n    \n    # Process each query\n    for l, r in queries:\n        result = prefix_sum[r] - prefix_sum[l]\n        print(result)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    s = data[2]\n    queries = []\n    \n    # Parse queries\n    for i in range(3, 3 + 2 * q, 2):\n        queries.append((int(data[i]), int(data[i + 1])))\n    \n    count_consecutive_duplicates(s, queries)"
        ]
    },
    {
        "question_id": "abc328_d",
        "code_list": [
            "def remove_ABC(S):\n    while 'ABC' in S:\n        S = S.replace('ABC', '', 1)\n    return S\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(remove_ABC(S))"
        ]
    },
    {
        "question_id": "abc328_e",
        "code_list": [
            "from typing import List, Tuple\nimport heapq\n\ndef find(parent: List[int], x: int) -> int:\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent: List[int], x: int, y: int):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        parent[rootX] = rootY\n\ndef kruskal(n: int, edges: List[Tuple[int, int, int]], k: int) -> int:\n    parent = list(range(n))\n    edges.sort(key=lambda x: x[2])\n    total_weight = 0\n    for u, v, w in edges:\n        if find(parent, u) != find(parent, v):\n            union(parent, u, v)\n            total_weight += w\n    return total_weight % k\n\ndef main():\n    n, m, k = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        edges.append((u - 1, v - 1, w))\n    \n    min_cost = kruskal(n, edges, k)\n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    for i in range(len(S)):\n        print(S[i], end=' ')\n    print()  # Print a newline at the end\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    numbers = list(map(int, data[1:n+1]))\n    max_num = max(numbers)\n    \n    # Filter out the max number and find the maximum of the remaining numbers\n    second_max = max(num for num in numbers if num != max_num)\n    \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_c",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    \n    count = 0\n    current_char = S[0]\n    current_length = 1\n    \n    for i in range(1, N):\n        if S[i] == current_char:\n            current_length += 1\n        else:\n            count += (current_length * (current_length + 1)) // 2\n            current_char = S[i]\n            current_length = 1\n    \n    count += (current_length * (current_length + 1)) // 2\n    \n    print(count)"
        ]
    },
    {
        "question_id": "abc329_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    votes = list(map(int, input().split()))\n    \n    # Initialize counters for each candidate\n    candidate_counts = defaultdict(int)\n    max_count = 0\n    winner = 0\n    \n    for i, vote in enumerate(votes):\n        candidate_counts[vote] += 1\n        \n        # Update the maximum count if necessary\n        if candidate_counts[vote] > max_count:\n            max_count = candidate_counts[vote]\n            winner = vote\n        elif candidate_counts[vote] == max_count:\n            winner = min(winner, vote)\n        \n        print(winner)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_e",
        "code_list": [
            "def can_match_s(n, m, s, t):\n    # Check if each character in T matches the corresponding character in S at intervals of M\n    for i in range(m):\n        if all(s[j * m + i] == t[i] for j in range((n - 1) // m + 1)):\n            continue\n        else:\n            return \"No\"\n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    s = input().strip()\n    t = input().strip()\n    print(can_match_s(n, m, s, t))"
        ]
    },
    {
        "question_id": "abc329_f",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    # Read input\n    N, Q = map(int, input().split())\n    C = list(map(int, input().split()))\n    \n    # Initialize data structures\n    box_contents = defaultdict(set)\n    for i, color in enumerate(C):\n        box_contents[color].add(i + 1)\n    \n    # Process queries\n    for _ in range(Q):\n        a, b = map(int, input().split())\n        # Move all balls from box a to box b\n        if a in box_contents:\n            for box in box_contents[a]:\n                box_contents[b].add(box)\n            del box_contents[a]\n        \n        # Print the number of different colors in box b\n        print(len(box_contents[b]))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_a",
        "code_list": [
            "def main():\n    # Read input\n    N, L = map(int, input().split())\n    scores = list(map(int, input().split()))\n    \n    # Count the number of people who passed\n    passed_count = sum(1 for score in scores if score >= L)\n    \n    # Output the result\n    print(passed_count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_b",
        "code_list": [
            "def main():\n    # Read input\n    N, L, R = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Find X_i for each i\n    Xi = []\n    for ai in A:\n        if ai <= (L + R) // 2:\n            Xi.append(R)\n        else:\n            Xi.append(L)\n\n    # Print results\n    print(*Xi)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_c",
        "code_list": [
            "import math\n\ndef main():\n    D = int(input())\n    min_diff = float('inf')\n    \n    # Iterate over possible values of x\n    for x in range(int(math.sqrt(D)) + 1):\n        # Calculate the remaining value after subtracting x^2 from D\n        remaining = D - x * x\n        # Check if the remaining value is a perfect square\n        y = int(math.sqrt(remaining))\n        if y * y == remaining:\n            min_diff = 0\n            break\n        else:\n            # Calculate the difference between remaining and y^2\n            diff = abs(remaining - y * y)\n            min_diff = min(min_diff, diff)\n    \n    print(min_diff)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_d",
        "code_list": [
            "from collections import Counter\n\ndef count_triples(N, grid):\n    # Count the number of 'o's in each row and column\n    row_counts = [Counter(row) for row in grid]\n    col_counts = [Counter(col) for col in zip(*grid)]\n    \n    # Calculate the number of valid triples\n    result = 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'o':\n                # Count pairs in the same row but different columns\n                same_row_pairs = (row_counts[i]['o'] - 1) * (N - 1 - col_counts[j]['o'])\n                # Count pairs in the same column but different rows\n                same_col_pairs = (col_counts[j]['o'] - 1) * (N - 1 - row_counts[i]['o'])\n                result += same_row_pairs + same_col_pairs\n    \n    return result // 2  # Each triple is counted twice\n\ndef main():\n    N = int(input().strip())\n    grid = [input().strip() for _ in range(N)]\n    print(count_triples(N, grid))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_e",
        "code_list": [
            "from typing import List\n\ndef mex_of_sequence(sequence: List[int]) -> int:\n    seen = set(sequence)\n    for i in range(len(sequence)):\n        if i not in seen:\n            return i\n    return len(sequence)\n\ndef main():\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Initialize the set with the current sequence\n    seen = set(A)\n    \n    for _ in range(Q):\n        i, x = map(int, input().split())\n        i -= 1  # Adjust index to be zero-based\n        A[i] = x\n        \n        # Update the seen set\n        seen.discard(A[i])\n        seen.add(x)\n        \n        # Find the mex\n        mex = mex_of_sequence(A)\n        print(mex)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_a",
        "code_list": [
            "def main():\n    M, D = map(int, input().split())\n    y, m, d = map(int, input().split())\n    \n    # Calculate the total number of days from the start of the year to the given day\n    total_days = (y - 1) * M * D + (m - 1) * D + d\n    \n    # Calculate the next day\n    next_day = total_days % (M * D)\n    \n    # If next_day is 0, it means we have completed a full cycle of the year\n    if next_day == 0:\n        next_day = M * D\n        m += 1\n        if m > M:\n            m = 1\n            y += 1\n    \n    # Extract the new month and day\n    new_d = next_day % D\n    new_m = (next_day // D) + 1\n    \n    # Print the result\n    print(y, new_m, new_d)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_b",
        "code_list": [
            "import sys\n\ndef main():\n    N, S, M, L = map(int, sys.stdin.readline().split())\n    min_cost = float('inf')\n    \n    for i in range(N // 6 + 1):\n        for j in range(N // 8 + 1):\n            for k in range(N // 12 + 1):\n                if 6 * i + 8 * j + 12 * k >= N:\n                    min_cost = min(min_cost, i * S + j * M + k * L)\n    \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    suffix_sum = [0] * (n + 1)\n    count = [0] * (max(a) + 1)\n    \n    # Calculate suffix sums and counts\n    for i in range(n - 1, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + a[i]\n        count[a[i]] += 1\n    \n    # Calculate the result for each index\n    result = []\n    for i in range(n):\n        result.append(suffix_sum[i + 1] - (a[i] * count[a[i]]))\n    \n    # Print the results\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_d",
        "code_list": [
            "def count_black_squares(N, queries):\n    # Precompute the prefix sum for each row and column\n    prefix_sum = [[0] * (N + 1) for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            prefix_sum[i][j + 1] = prefix_sum[i][j] + (1 if P[i][j] == 'B' else 0)\n    \n    def query(A, B, C, D):\n        # Calculate the effective indices within the repeating pattern\n        i_start = A % N\n        j_start = B % N\n        i_end = C % N\n        j_end = D % N\n        \n        # If the end indices are less than the start indices, they are out of bounds\n        if i_end < i_start or j_end < j_start:\n            return 0\n        \n        # Calculate the number of black squares using the prefix sums\n        total_black = (prefix_sum[i_end][j_end + 1] - prefix_sum[i_end][j_start]) - (prefix_sum[i_start][j_end + 1] - prefix_sum[i_start][j_start])\n        \n        # Add the black squares in the remaining rows if any\n        if i_end >= i_start:\n            total_black += (D // N - B // N) * (prefix_sum[i_end][j_end + 1] - prefix_sum[i_end][j_start])\n        \n        return total_black\n    \n    # Process each query\n    results = [query(*query) for query in queries]\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    P = [data[i:i+N] for i in range(2, 2+N)]\n    queries = [(int(data[i*4+2]), int(data[i*4+3]), int(data[i*4+4]), int(data[i*4+5])) for i in range(Q)]\n    \n    results = count_black_squares(N, queries)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc331_e",
        "code_list": [
            "def find_most_expensive_set_meal():\n    # Read input\n    N, M, L = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    forbidden_pairs = [tuple(map(int, input().split())) for _ in range(L)]\n    \n    # Find the maximum price of a main dish and a side dish that are not forbidden\n    max_price = 0\n    for i in range(N):\n        for j in range(M):\n            if (i + 1, j + 1) not in forbidden_pairs:\n                max_price = max(max_price, a[i] + b[j])\n    \n    # Output the result\n    print(max_price)\n\nif __name__ == \"__main__\":\n    find_most_expensive_set_meal()"
        ]
    },
    {
        "question_id": "abc332_a",
        "code_list": [
            "def calculate_total_cost():\n    # Read input\n    N, S, K = map(int, input().split())\n    total_price = 0\n    \n    # Calculate the total price of the products\n    for _ in range(N):\n        P, Q = map(int, input().split())\n        total_price += P * Q\n    \n    # Calculate the final amount to pay\n    if total_price >= S:\n        shipping_fee = 0\n    else:\n        shipping_fee = K\n    \n    total_amount = total_price + shipping_fee\n    print(total_amount)\n\nif __name__ == \"__main__\":\n    calculate_total_cost()"
        ]
    },
    {
        "question_id": "abc332_b",
        "code_list": [
            "def main():\n    K, G, M = map(int, input().split())\n    glass = 0\n    mug = 0\n    \n    for _ in range(K):\n        if glass == G:\n            glass = 0\n        elif mug == M:\n            mug = 0\n            glass += M\n        else:\n            if M - mug <= G - glass:\n                glass += M - mug\n                mug = 0\n            else:\n                glass = G\n                mug -= (G - glass)\n    \n    print(glass, mug)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc332_c",
        "code_list": [
            "def min_tshirts_to_buy(N, M, S):\n    # Initialize variables to track the number of logo T-shirts needed and the last day a logo T-shirt was used\n    logo_needed = 0\n    last_logo_day = -1\n    \n    for i in range(N):\n        if S[i] == '1':\n            # If going out for a meal, check if a logo T-shirt is needed\n            if last_logo_day < i:\n                logo_needed += 1\n                last_logo_day = i\n        elif S[i] == '2':\n            # If attending a competitive programming event, a logo T-shirt is definitely needed\n            logo_needed += 1\n            last_logo_day = i\n    \n    # Calculate the minimum number of logo T-shirts to buy\n    return max(logo_needed - M, 0)\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    S = input().strip()\n    print(min_tshirts_to_buy(N, M, S))"
        ]
    },
    {
        "question_id": "abc332_d",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(H)]\n    B = [list(map(int, input().split())) for _ in range(H)]\n\n    # Check if the grids are identical\n    if A == B:\n        print(0)\n        return\n\n    # Function to count the number of swaps needed to sort a row or column\n    def count_swaps(arr):\n        sorted_arr = sorted(arr)\n        swaps = 0\n        for i in range(len(arr)):\n            if arr[i] != sorted_arr[i]:\n                target_index = arr.index(sorted_arr[i])\n                while target_index != i:\n                    arr[i], arr[target_index] = arr[target_index], arr[i]\n                    swaps += 1\n                    target_index = arr.index(sorted_arr[i])\n        return swaps\n\n    # Count swaps for rows and columns separately\n    row_swaps = 0\n    col_swaps = 0\n    for i in range(H):\n        if A[i] != B[i]:\n            row_swaps += count_swaps(A[i])\n            A[i] = B[i]\n\n    for j in range(W):\n        col = [A[i][j] for i in range(H)]\n        if col != [B[i][j] for i in range(H)]:\n            col_swaps += count_swaps(col)\n            for i in range(H):\n                A[i][j] = B[i][j]\n\n    # Verify if the grids are now identical\n    if A == B:\n        print(row_swaps + col_swaps)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc333_a",
        "code_list": [
            "def main():\n    N = int(input().strip())\n    result = str(N) * N\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc333_b",
        "code_list": [
            "def main():\n    # Define the coordinates of the vertices of the pentagon\n    coordinates = {'A': (0, 1), 'B': (0.5 * (1 + 5**0.5), 0), 'C': (1, -1), 'D': (0.5 * (1 - 5**0.5), 0), 'E': (-0.5, 1)}\n    \n    # Read the input\n    S1, S2 = input().split()\n    T1, T2 = input().split()\n    \n    # Calculate the distance between S1 and S2\n    distance_S1_S2 = ((coordinates[S1][0] - coordinates[S2][0])**2 + (coordinates[S1][1] - coordinates[S2][1])**2)**0.5\n    \n    # Calculate the distance between T1 and T2\n    distance_T1_T2 = ((coordinates[T1][0] - coordinates[T2][0])**2 + (coordinates[T1][1] - coordinates[T2][1])**2)**0.5\n    \n    # Check if the distances are equal\n    if distance_S1_S2 == distance_T1_T2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc333_c",
        "code_list": [
            "def main():\n    def generate_repunits(n):\n        return [int('1' * i) for i in range(1, n + 1)]\n\n    def sum_of_three_repunits(repunits):\n        sums = set()\n        for i in range(len(repunits)):\n            for j in range(i, len(repunits)):\n                for k in range(j, len(repunits)):\n                    sums.add(repunits[i] + repunits[j] + repunits[k])\n        return sorted(sums)\n\n    N = int(input())\n    repunits = generate_repunits(100)  # Generate enough repunits to cover the constraints\n    result = sum_of_three_repunits(repunits)[N - 1]\n    print(result)"
        ]
    },
    {
        "question_id": "abc333_d",
        "code_list": [
            "def dfs(node, parent, graph):\n    depth = 0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            depth = max(depth, dfs(neighbor, node, graph))\n    return depth + 1\n\ndef min_operations_to_delete_vertex_1(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Find the deepest leaf node from vertex 1\n    deepest_leaf_depth = dfs(1, -1, graph)\n    \n    # Calculate the minimum number of operations\n    # If the deepest leaf node is directly connected to vertex 1, we need one less operation\n    return deepest_leaf_depth - 1\n\nif __name__ == \"__main__\":\n    N = int(input())\n    edges = []\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    result = min_operations_to_delete_vertex_1(N, edges)\n    print(result)"
        ]
    },
    {
        "question_id": "abc333_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    events = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    # Initialize variables\n    potion_count = defaultdict(int)\n    max_potions = 0\n    min_max_potions = float('inf')\n    actions = []\n    current_potions = 0\n    \n    # Process events\n    for i, (t, x) in enumerate(events):\n        if t == 1:  # Find potion\n            potion_count[x] += 1\n            current_potions += 1\n            max_potions = max(max_potions, current_potions)\n            actions.append(1)\n        else:  # Encounter monster\n            if x in potion_count and potion_count[x] > 0:\n                potion_count[x] -= 1\n                current_potions -= 1\n                actions.append(0)\n            else:\n                actions.append(0)\n                if current_potions + potion_count[x] < i + 1:\n                    min_max_potions = -1\n                    break\n                else:\n                    min_max_potions = min(min_max_potions, max_potions)\n                    max_potions = max(max_potions, current_potions)\n                    current_potions += potion_count[x]\n                    potion_count[x] = 0\n    \n    if min_max_potions == float('inf'):\n        min_max_potions = -1\n    \n    # Print results\n    if min_max_potions == -1:\n        print(-1)\n    else:\n        print(min_max_potions)\n        print(*actions)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc334_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    B, G = map(int, input().split())\n    if B > G:\n        print(\"Bat\")\n    else:\n        print(\"Glove\")"
        ]
    },
    {
        "question_id": "abc334_b",
        "code_list": [
            "def main():\n    A, M, L, R = map(int, input().split())\n    if L > R:\n        L, R = R, L\n    \n    # Adjust A to be within the range [L, R]\n    if A < L:\n        A += (-(A - L) // M + 1) * M\n    elif A > R:\n        A -= (A - R) // M * M\n    \n    # Calculate the number of Christmas trees\n    if A == L or A == R:\n        result = (R - A) // M + 1\n    else:\n        result = (R - A) // M + 1 + (A - L) // M + 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc334_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:K+2]))\n    \n    # Initialize the list of available colors\n    colors = [i for i in range(1, N + 1) if i not in A]\n    \n    # Sort the available colors\n    colors.sort()\n    \n    # Calculate the minimum weirdness\n    weirdness = 0\n    i, j = 0, len(colors) - 1\n    \n    while i <= j:\n        weirdness += abs(colors[i] - colors[j])\n        i += 1\n        j -= 1\n    \n    print(weirdness)"
        ]
    },
    {
        "question_id": "abc334_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    reindeer_needed = []\n    for _ in range(n):\n        reindeer_needed.append(int(data[index]))\n        index += 1\n    \n    queries = []\n    for _ in range(q):\n        queries.append(int(data[index]))\n        index += 1\n    \n    # Sort the reindeer needed in descending order\n    reindeer_needed.sort(reverse=True)\n    \n    total_reindeer = 0\n    result = [0] * q\n    \n    for i, query in enumerate(queries):\n        while reindeer_needed and total_reindeer + reindeer_needed[-1] <= query:\n            total_reindeer += reindeer_needed.pop()\n        \n        if total_reindeer > query:\n            total_reindeer -= reindeer_needed.pop()\n        \n        result[i] = len(reindeer_needed)\n    \n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc334_e",
        "code_list": [
            "from collections import defaultdict\nfrom math import comb\nfrom typing import List, Tuple\n\ndef count_green_components(grid: List[str]) -> int:\n    def dfs(x: int, y: int) -> None:\n        if 0 <= x < h and 0 <= y < w and grid[x][y] == '#':\n            grid[x] = grid[x][:y] + '.' + grid[x][y+1:]\n            for dx, dy in directions:\n                dfs(x + dx, y + dy)\n\n    h, w = len(grid), len(grid[0])\n    components = 0\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '#':\n                components += 1\n                dfs(i, j)\n    return components\n\ndef main():\n    h, w = map(int, input().split())\n    grid = [input() for _ in range(h)]\n    \n    total_red_cells = sum(row.count('.') for row in grid)\n    total_green_components = count_green_components(grid)\n    \n    mod = 998244353\n    \n    def expected_value(red_cell: Tuple[int, int]) -> int:\n        x, y = red_cell\n        if grid[x][y] == '#':\n            return 0\n        \n        grid[x] = grid[x][:y] + '#' + grid[x][y+1:]\n        new_green_components = count_green_components(grid)\n        grid[x] = grid[x][:y] + '.' + grid[x][y+1:]\n        \n        return (new_green_components - total_green_components) % mod\n    \n    result = 0\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '.':\n                result += expected_value((i, j))\n                result %= mod\n    \n    print(result // total_red_cells)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc335_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    S = S[:-4] + '2024'\n    print(S)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc335_b",
        "code_list": [
            "def generate_triples(N):\n    for x in range(N + 1):\n        for y in range(x + 1):\n            for z in range(y + 1):\n                if x + y + z <= N:\n                    print(f\"{x} {y} {z}\")\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    generate_triples(N)"
        ]
    },
    {
        "question_id": "abc335_c",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    \n    # Initialize positions\n    positions = [(i, 0) for i in range(1, N + 1)]\n    \n    # Process queries\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            # Move the head\n            direction = query[1]\n            if direction == 'R':\n                positions[0] = (positions[0][0] + 1, positions[0][1])\n            elif direction == 'L':\n                positions[0] = (positions[0][0] - 1, positions[0][1])\n            elif direction == 'U':\n                positions[0] = (positions[0][0], positions[0][1] + 1)\n            elif direction == 'D':\n                positions[0] = (positions[0][0], positions[0][1] - 1)\n            \n            # Move other parts\n            for i in range(1, N):\n                positions[i] = positions[i - 1]\n        else:\n            # Query position of part p\n            p = query[1]\n            print(positions[p - 1][0], positions[p - 1][1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc335_d",
        "code_list": [
            "def main():\n    N = int(input())\n    # Initialize the grid with zeros\n    grid = [[0] * N for _ in range(N)]\n    \n    # Place Takahashi at the center\n    center = (N // 2, N // 2)\n    grid[center[0]][center[1]] = 'T'\n    \n    # Function to get the next position based on the current position and the previous part's position\n    def get_next_position(current, prev):\n        x, y = current\n        px, py = prev\n        dx, dy = x - px, y - py\n        \n        # Determine the direction to move based on the previous part's position\n        if dx == 1 and dy == 0:  # Moving right\n            return (x, y + 1), (x, y - 1)\n        elif dx == -1 and dy == 0:  # Moving left\n            return (x, y - 1), (x, y + 1)\n        elif dx == 0 and dy == 1:  # Moving down\n            return (x + 1, y), (x - 1, y)\n        elif dx == 0 and dy == -1:  # Moving up\n            return (x - 1, y), (x + 1, y)\n    \n    # Start from the top-left corner and place the first part\n    current = (0, 0)\n    prev = None\n    \n    for x in range(1, N**2):\n        if prev is not None:\n            current, prev = get_next_position(current, prev)\n        \n        # Place the current part in the grid\n        grid[current[0]][current[1]] = x\n        \n        # If we reach the center, break the loop as Takahashi is already placed there\n        if current == center:\n            break\n    \n    # Convert the grid to the required output format\n    output = []\n    for row in grid:\n        output.append(' '.join(str(part) if part != 'T' else 'T' for part in row))\n    \n    # Print the output\n    print('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_a",
        "code_list": [
            "def main():\n    N = int(input().strip())\n    dragon_string = 'L' + 'o' * N + 'n' + 'g'\n    print(dragon_string)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_b",
        "code_list": [
            "def main():\n    N = int(input())\n    ctz = 0\n    while N % 2 == 0 and N > 0:\n        ctz += 1\n        N //= 2\n    print(ctz)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_c",
        "code_list": [
            "def main():\n    N = int(input())\n    result = \"\"\n    \n    while N > 0:\n        # Determine the current digit based on the position\n        if N <= 5 * (10 ** 11):\n            digit = (N - 1) % 5\n        else:\n            digit = 4\n        \n        # Append the digit to the result string\n        result += str(digit * 2)\n        \n        # Update N for the next iteration\n        N -= digit * 2 * (10 ** ((len(result) - 1) // 2))\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_d",
        "code_list": [
            "def max_pyramid_sequence_size(N, A):\n    # Count the frequency of each number in the sequence\n    freq = [0] * (max(A) + 1)\n    for num in A:\n        freq[num] += 1\n    \n    # Calculate the maximum possible pyramid sequence size\n    max_size = 0\n    left = 1\n    right = len(freq) - 1\n    while left <= right:\n        if freq[left] > 0:\n            max_size += min(freq[left], right - left + 1)\n            left += 1\n        if freq[right] > 0:\n            max_size += min(freq[right], right - left + 1)\n            right -= 1\n    \n    return max_size\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(max_pyramid_sequence_size(N, A))"
        ]
    },
    {
        "question_id": "abc337_a",
        "code_list": [
            "def main():\n    N = int(input())\n    takahashi_score = 0\n    aoki_score = 0\n    \n    for _ in range(N):\n        X, Y = map(int, input().split())\n        takahashi_score += X\n        aoki_score += Y\n    \n    if takahashi_score > aoki_score:\n        print(\"Takahashi\")\n    elif takahashi_score < aoki_score:\n        print(\"Aoki\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc337_b",
        "code_list": [
            "def is_extended_abc_string(s):\n    count_a = s.count('A')\n    count_b = s.count('B')\n    count_c = s.count('C')\n    \n    # Check if the counts of A, B, and C can form an Extended ABC string\n    if count_a > 0 and count_b > 0 and count_c > 0:\n        # Check if the string can be divided into parts of A, B, and C\n        if len(s) % (count_a + count_b + count_c) == 0:\n            return 'Yes'\n    return 'No'\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(is_extended_abc_string(s))"
        ]
    },
    {
        "question_id": "abc337_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_front_people(arrangement):\n        n = len(arrangement)\n        front_people = []\n        for i in range(n):\n            if arrangement[i] == -1:\n                front_people.append(i + 1)\n        return front_people\n    \n    def arrange_people(front_people, arrangement):\n        arranged_order = []\n        while front_people:\n            current_person = front_people.pop(0)\n            arranged_order.append(current_person)\n            next_person_index = arrangement[current_person - 1]\n            if next_person_index != -1:\n                front_people.remove(next_person_index)\n                front_people.append(next_person_index)\n        return arranged_order\n    \n    n = int(input())\n    arrangement = list(map(int, input().split()))\n    \n    front_people = find_front_people(arrangement)\n    arranged_order = arrange_people(front_people, arrangement)\n    \n    print(\" \".join(map(str, arranged_order)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc337_d",
        "code_list": [
            "def min_operations_to_fill(grid, H, W, K):\n    def count_empty_rows():\n        empty_rows = [0] * H\n        for j in range(W):\n            for i in range(H):\n                if grid[i][j] == '.':\n                    empty_rows[i] += 1\n        return empty_rows\n\n    def count_empty_cols():\n        empty_cols = [0] * W\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == '.':\n                    empty_cols[j] += 1\n        return empty_cols\n\n    def check_row(i, start, end):\n        return all(grid[i][j] == 'o' for j in range(start, end))\n\n    def check_col(j, start, end):\n        return all(grid[i][j] == 'o' for i in range(start, end))\n\n    empty_rows = count_empty_rows()\n    empty_cols = count_empty_cols()\n\n    # Check for horizontal sequences\n    for i in range(H):\n        for j in range(W - K + 1):\n            if check_row(i, j, j + K):\n                return 0\n\n    # Check for vertical sequences\n    for j in range(W):\n        for i in range(H - K + 1):\n            if check_col(j, i, i + K):\n                return 0\n\n    # Calculate minimum operations needed\n    min_ops = float('inf')\n    for i in range(H):\n        for j in range(W - K + 1):\n            ops = sum(empty_rows[i]) + sum(empty_cols[j:j + K])\n            min_ops = min(min_ops, ops)\n\n    for j in range(W):\n        for i in range(H - K + 1):\n            ops = sum(empty_rows[i:i + K]) + sum(empty_cols[j])\n            min_ops = min(min_ops, ops)\n\n    return -1 if min_ops == float('inf') else min_ops\n\ndef main():\n    H, W, K = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    result = min_operations_to_fill(grid, H, W, K)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc337_e",
        "code_list": [
            "import sys\n\ndef main():\n    # Read the number of bottles\n    N = int(input())\n    \n    # Calculate the minimum number of friends needed\n    M = N.bit_length()\n    \n    # Print the number of friends to call\n    print(M)\n    \n    # Distribute the bottles among the friends\n    for i in range(M):\n        # For each friend, determine which bottles to give\n        bottles = []\n        for j in range(N):\n            if (j >> i) & 1:\n                bottles.append(j + 1)\n        \n        # Print the number of bottles and the bottles themselves\n        print(len(bottles), *bottles)\n    \n    # Read the response from the judge\n    S = input().strip()\n    \n    # Determine the spoiled bottle based on the responses\n    spoiled_bottle = 0\n    for i in range(M):\n        if S[i] == '1':\n            spoiled_bottle |= 1 << i\n    \n    # Print the number of the spoiled juice bottle\n    print(spoiled_bottle)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S[0].isupper() and S[1:].islower():\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_b",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    S = input().strip()\n    char_count = Counter(S)\n    max_count = max(char_count.values())\n    max_chars = [char for char, count in char_count.items() if count == max_count]\n    print(min(max_chars))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_c",
        "code_list": [
            "def max_servings(N, Q, A, B):\n    min_A = float('inf')\n    min_B = float('inf')\n    \n    # Find the minimum requirements for making one serving of each dish\n    for i in range(N):\n        if A[i] > 0:\n            min_A = min(min_A, Q[i] // A[i])\n        if B[i] > 0:\n            min_B = min(min_B, Q[i] // B[i])\n    \n    # The maximum number of servings is the minimum of the two calculated above\n    return min(min_A, min_B)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    Q = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    print(max_servings(N, Q, A, B))"
        ]
    },
    {
        "question_id": "abc338_d",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    X = list(map(int, input().split()))\n    \n    # Calculate the initial length of the tour without closing any bridge\n    length = sum(X[i] - X[i-1] for i in range(1, M))\n    \n    # Calculate the minimum possible length after closing each bridge\n    min_length = length\n    for i in range(N):\n        if i < M-1:\n            min_length = min(min_length, length + X[i+1] - X[i])\n        else:\n            min_length = min(min_length, length + X[0] - X[M-1])\n    \n    # Adjust the length based on the circular nature of the archipelago\n    for i in range(M-1):\n        if X[i+1] < X[i]:\n            min_length = min(min_length, length + N - (X[i] - X[i+1]))\n        else:\n            min_length = min(min_length, length + X[i+1] - X[i])\n    \n    print(min_length)"
        ]
    },
    {
        "question_id": "abc338_e",
        "code_list": [
            "def is_intersecting(N, chords):\n    # Convert the problem into a simpler form by mapping points to a linear range\n    # We can use the fact that points are on a circle and map them to a linear range\n    # For simplicity, we will use the relative positions of the points\n    # We need to check if any two chords cross each other\n    \n    # Sort the chords based on the starting point of the first endpoint\n    chords.sort(key=lambda x: x[0])\n    \n    # Initialize a list to keep track of the endpoints\n    endpoints = []\n    \n    for A, B in chords:\n        # Append the endpoints in a way that helps us determine intersections\n        endpoints.append((A, 'start'))\n        endpoints.append((B, 'end'))\n    \n    # Sort the endpoints by their position on the circle\n    endpoints.sort(key=lambda x: x[0])\n    \n    # Initialize counters for open chords\n    open_chords = 0\n    \n    # Iterate through the sorted endpoints\n    for _, endpoint_type in endpoints:\n        if endpoint_type == 'start':\n            open_chords += 1\n        else:\n            open_chords -= 1\n        \n        # If at any point we have more than one open chord, there must be an intersection\n        if open_chords > 1:\n            return True\n    \n    return False\n\ndef main():\n    N = int(input().strip())\n    chords = []\n    for _ in range(N):\n        A, B = map(int, input().strip().split())\n        chords.append((A, B))\n    \n    if is_intersecting(N, chords):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_f",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    def read_int():\n        return int(input())\n    def read_ints():\n        return map(int, input().split())\n\n    N, M = read_ints()\n    edges = defaultdict(list)\n    for _ in range(M):\n        U, V, W = read_ints()\n        edges[U].append((V, W))\n\n    # Initialize the DP table\n    dp = [[float('inf')] * (1 << N) for _ in range(N)]\n    for i in range(N):\n        dp[i][1 << i] = 0\n\n    # Fill the DP table\n    for mask in range(1 << N):\n        for u in range(N):\n            if mask & (1 << u):\n                for v, w in edges[u]:\n                    new_mask = mask | (1 << v)\n                    if new_mask != mask:\n                        dp[v][new_mask] = min(dp[v][new_mask], dp[u][mask] + w)\n\n    # Check if all vertices are visited\n    final_mask = (1 << N) - 1\n    result = min(dp[u][final_mask] for u in range(N))\n    if result == float('inf'):\n        print(\"No\")\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    last_dot_index = S.rfind('.')\n    print(S[last_dot_index+1:] if last_dot_index != -1 else S)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_b",
        "code_list": [
            "def main():\n    H, W, N = map(int, input().split())\n    grid = [['.' for _ in range(W)] for _ in range(H)]\n    x, y = 0, 0\n    dx, dy = -1, 0  # Initial direction: up\n    \n    for _ in range(N):\n        if grid[x][y] == '.':\n            grid[x][y] = '#'\n            dx, dy = dy, -dx  # Rotate 90 degrees clockwise\n        else:\n            grid[x][y] = '.'\n            dx, dy = -dy, dx  # Rotate 90 degrees counterclockwise\n        \n        x, y = (x + dx) % H, (y + dy) % W\n    \n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    passengers = 0\n    \n    for i in range(1, 2 * n + 1, 2):\n        passengers += int(data[i])\n    \n    print(max(passengers, 0))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(start1, start2, grid):\n    N = len(grid)\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = set([start1])\n    queue = deque([(start1, start2, 0)])\n    \n    while queue:\n        (x1, y1), (x2, y2), steps = queue.popleft()\n        \n        for dx, dy in directions:\n            new_x1, new_y1 = x1 + dx, y1 + dy\n            new_x2, new_y2 = x2 + dx, y2 + dy\n            \n            if 0 <= new_x1 < N and 0 <= new_y1 < N and grid[new_x1][new_y1] != '#':\n                if 0 <= new_x2 < N and 0 <= new_y2 < N and grid[new_x2][new_y2] != '#':\n                    if (new_x1, new_y1) == (new_x2, new_y2):\n                        return steps + 1\n                    if (new_x1, new_y1) not in visited:\n                        visited.add((new_x1, new_y1))\n                        queue.append(((new_x1, new_y1), (new_x2, new_y2), steps + 1))\n    \n    return -1\n\ndef main():\n    N = int(input().strip())\n    grid = [input().strip() for _ in range(N)]\n    \n    players = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'P':\n                players.append((i, j))\n    \n    result = bfs(players[0], players[1], grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_a",
        "code_list": [
            "def main():\n    # Read input from stdin\n    A, B, D = map(int, input().split())\n    \n    # Initialize the current term as the first term\n    current_term = A\n    \n    # Print the terms of the arithmetic sequence\n    while current_term <= B:\n        print(current_term, end=' ')\n        current_term += D\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_b",
        "code_list": [
            "def main():\n    Q = int(input())\n    A = []\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            A.append(query[1])\n        elif query[0] == 2:\n            print(A[-query[1]])"
        ]
    },
    {
        "question_id": "abc340_c",
        "code_list": [
            "def main():\n    import math\n    \n    def calculate_payment(N):\n        payment = 0\n        while N >= 2:\n            # Find the largest power of 2 less than or equal to N\n            k = int(math.log2(N))\n            # Calculate the number of 1s added in this step\n            ones_added = (N - 2**k) + 1\n            # Update N to the sum of the two new numbers added\n            N = 2**k + (N - 2**k + 1)\n            # Add the cost of the operation to the total payment\n            payment += 2 * 2**k - ones_added\n        return payment\n    \n    N = int(input())\n    print(calculate_payment(N))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_d",
        "code_list": [
            "def min_time_to_clear_stages(N, stages):\n    # Initialize the dp array where dp[i] represents the minimum time to reach stage i\n    dp = [float('inf')] * (N + 1)\n    dp[1] = 0  # No time needed to reach stage 1 initially\n    \n    for i in range(1, N):\n        dp[i + 1] = min(dp[i + 1], dp[i] + stages[i][0])  # Option 1: Clear stage i directly\n        if stages[i][1] <= i:  # Check if we can jump to stage X_i from stage i\n            dp[min(i + 1, N)] = min(dp[min(i + 1, N)], dp[i] + stages[i][1])\n    \n    return dp[N]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    stages = []\n    for _ in range(N - 1):\n        A, B, X = map(int, input().split())\n        stages.append((A, B, X))\n    \n    print(min_time_to_clear_stages(N, stages))"
        ]
    },
    {
        "question_id": "abc340_e",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Initialize the count array to keep track of net changes\n    count = [0] * N\n\n    # Process each operation\n    for b in B:\n        # Take out all balls from box b\n        balls_taken = A[b]\n        A[b] = 0\n\n        # Distribute balls back into boxes\n        c = 0\n        while balls_taken > 0:\n            index = (b + c) % N\n            count[index] += 1\n            balls_taken -= 1\n            c += 1\n\n    # Update the final number of balls in each box\n    for i in range(N):\n        A[i] += count[i]\n\n    # Output the result\n    print(*A)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_a",
        "code_list": [
            "def main():\n    N = int(input())\n    result = '1' * (N + 1) + '0' * N\n    print(result[::2])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_b",
        "code_list": [
            "def max_currency(N, A, S, T):\n    # Initialize the total currency of the last country\n    total_currency = A[N-1]\n    \n    # Iterate from the second last country to the first country\n    for i in range(N-2, -1, -1):\n        # Calculate the minimum amount needed to perform the operation\n        min_needed = max(S[i] - A[i], 0)\n        \n        # If there's enough currency to perform the operation\n        if total_currency >= min_needed:\n            # Gain the currency from the next country\n            total_currency += T[i]\n            # Update the current country's currency\n            A[i] += min_needed\n        else:\n            # Otherwise, break the loop as we cannot perform further operations\n            break\n    \n    return total_currency\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    S = [0] + list(map(int, input().split()))\n    T = list(map(int, input().split()))\n    \n    print(max_currency(N, A, S, T))"
        ]
    },
    {
        "question_id": "abc341_c",
        "code_list": [
            "def main():\n    H, W, N = map(int, input().split())\n    T = input()\n    S = [input() for _ in range(H)]\n    \n    directions = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}\n    possible_positions = set()\n    \n    # Initial position can be any non-sea cell on the perimeter\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] == '.' and (i == 0 or i == H-1 or j == 0 or j == W-1):\n                possible_positions.add((i, j))\n    \n    # Update possible positions based on the moves\n    x, y = 0, 0\n    for move in T:\n        dx, dy = directions[move]\n        new_x, new_y = x + dx, y + dy\n        \n        # Check if the new position is within bounds and not sea\n        if 0 <= new_x < H and 0 <= new_y < W and S[new_x][new_y] == '.':\n            possible_positions = {(new_x, new_y) if (new_x, new_y) in pos else pos for pos in possible_positions}\n            x, y = new_x, new_y\n    \n    print(len(possible_positions))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_d",
        "code_list": [
            "def lcm(a, b):\n    from math import gcd\n    return a * b // gcd(a, b)\n\ndef count_numbers(n, m, x):\n    count = 0\n    # Count numbers <= x divisible by n but not by m\n    count += (x // n) - (x // lcm(n, m))\n    # Count numbers <= x divisible by m but not by n\n    count += (x // m) - (x // lcm(n, m))\n    return count\n\ndef find_kth_number(n, m, k):\n    low, high = 1, 10**15\n    while low < high:\n        mid = (low + high) // 2\n        if count_numbers(n, m, mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    print(find_kth_number(n, m, k))"
        ]
    },
    {
        "question_id": "abc341_e",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    S = input()\n    \n    # Initialize variables\n    flipped = [False] * N  # Track which positions have been flipped\n    result = []  # Store results for type 2 queries\n    \n    # Process queries\n    for _ in range(Q):\n        query_type, L, R = map(int, input().split())\n        \n        if query_type == 1:\n            # Flip characters from L to R\n            for i in range(L - 1, R):\n                flipped[i] = not flipped[i]\n        else:\n            # Check if the substring from L to R is a good string\n            is_good = True\n            prev_char = None\n            for i in range(L - 1, R):\n                char = S[i] if not flipped[i] else '1' if S[i] == '0' else '0'\n                if prev_char is not None and char == prev_char:\n                    is_good = False\n                    break\n                prev_char = char\n            \n            result.append('Yes' if is_good else 'No')\n    \n    # Output results for type 2 queries\n    for res in result:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_f",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    weights = list(map(int, input().split()))\n    pieces = list(map(int, input().split()))\n\n    # Build adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    # Priority queue to store (weight, vertex, pieces)\n    pq = []\n    for i, (w, p) in enumerate(zip(weights, pieces)):\n        if p > 0:\n            heapq.heappush(pq, (-w, i, p))\n\n    total_operations = 0\n\n    while pq:\n        w, x, p = heapq.heappop(pq)\n        w = -w\n        if p == 0:\n            continue\n\n        # Find all adjacent vertices with weight less than w\n        adjacent_vertices = [y for y in adj_list[x] if weights[y] < w]\n        for y in adjacent_vertices:\n            if pieces[y] < 10**9:\n                pieces[y] += 1\n                heapq.heappush(pq, (-weights[y], y, pieces[y]))\n                pieces[y] -= 1\n\n        pieces[x] -= 1\n        total_operations += 1\n\n    print(total_operations)"
        ]
    },
    {
        "question_id": "abc342_a",
        "code_list": [
            "def find_unique_char_index(S):\n    # Count occurrences of the first character\n    count_first_char = S.count(S[0])\n    \n    # If the count of the first character is equal to the length of the string minus one,\n    # then the unique character is the last one\n    if count_first_char == len(S) - 1:\n        return len(S) - 1\n    \n    # Otherwise, the unique character is the first one\n    else:\n        return 0\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(find_unique_char_index(S))"
        ]
    },
    {
        "question_id": "abc342_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_query(N, positions, A, B):\n        return positions[A - 1]\n    \n    N = int(input())\n    positions = list(map(int, input().split()))\n    Q = int(input())\n    \n    for _ in range(Q):\n        A, B = map(int, input().split())\n        result = process_query(N, positions, A, B)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc342_c",
        "code_list": [
            "def main():\n    import sys\n    \n    # Read input\n    N = int(input().strip())\n    S = input().strip()\n    Q = int(input().strip())\n    \n    # Initialize a dictionary to store replacements\n    replacements = {}\n    \n    # Process each replacement operation\n    for _ in range(Q):\n        c, d = input().strip().split()\n        replacements[c] = d\n    \n    # Apply all replacements to the string\n    for c, d in replacements.items():\n        S = S.replace(c, d)\n    \n    # Print the final string\n    print(S)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc342_d",
        "code_list": [
            "import math\nfrom collections import Counter\n\ndef is_square(n):\n    return int(math.isqrt(n)) ** 2 == n\n\ndef count_square_pairs(N, A):\n    # Count the frequency of each number in A\n    freq = Counter(A)\n    \n    # Initialize the result counter\n    result = 0\n    \n    # Iterate through all unique numbers in A\n    for num in freq:\n        if is_square(num):\n            # If the number itself is a square, we need to count pairs (i, j) where A_i = A_j = num\n            result += freq[num] * (freq[num] - 1) // 2\n    \n    # Check for pairs (i, j) where A_i * A_j is a square\n    for i in range(N):\n        for j in range(i + 1, N):\n            product = A[i] * A[j]\n            if is_square(product):\n                result += 1\n    \n    return result\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(count_square_pairs(N, A))"
        ]
    },
    {
        "question_id": "abc342_e",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef process_trains(N, M, trains):\n    # Build the graph\n    graph = defaultdict(list)\n    for l, d, k, c, A, B in trains:\n        for t in range(l, l + k * d, d):\n            graph[A].append((B, c))\n            graph[B].append((A, 0))  # Reverse edge with 0 cost for bidirectional travel\n    \n    # Calculate the latest arrival time for each station\n    latest_arrival = [-float('inf')] * N\n    for i in range(1, N):\n        latest_arrival[i] = dijkstra(N, graph, i)[-1]\n    \n    return latest_arrival\n\ndef main():\n    N, M = map(int, input().split())\n    trains = []\n    for _ in range(M):\n        l, d, k, c, A, B = map(int, input().split())\n        trains.append((l, d, k, c, A, B))\n    \n    latest_arrival = process_trains(N, M, trains)\n    \n    for i in range(1, N):\n        if latest_arrival[i] == -float('inf'):\n            print(\"Unreachable\")\n        else:\n            print(latest_arrival[i])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    sum_ab = A + B\n    # Possible values excluding the sum of A and B\n    possible_values = [i for i in range(10) if i != sum_ab]\n    print(possible_values[0])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_input():\n        return sys.stdin.read().strip().split('\\n')\n    \n    def process_adjacency_matrix(adj_matrix):\n        n = len(adj_matrix)\n        result = []\n        for i in range(n):\n            connected_vertices = [j + 1 for j in range(n) if adj_matrix[i][j] == 1]\n            result.append(sorted(connected_vertices))\n        return result\n    \n    def print_result(result):\n        for line in result:\n            print(' '.join(map(str, line)))\n    \n    # Read input\n    input_data = read_input()\n    \n    # Extract adjacency matrix\n    n = int(input_data[0])\n    adj_matrix = [list(map(int, line.split())) for line in input_data[1:]]\n    \n    # Process and print result\n    result = process_adjacency_matrix(adj_matrix)\n    print_result(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_c",
        "code_list": [
            "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef find_max_palindromic_cube(N):\n    # Start from the cube root of N and go downwards\n    for x in range(int(N ** (1/3)), 0, -1):\n        cube = x ** 3\n        if cube > N:\n            continue\n        if is_palindrome(cube):\n            return cube\n    return 1\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(find_max_palindromic_cube(N))"
        ]
    },
    {
        "question_id": "abc343_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, T = map(int, input().split())\n    score_changes = defaultdict(list)\n    \n    for _ in range(T):\n        A, B = map(int, input().split())\n        score_changes[A].append(B)\n    \n    time_points = sorted(score_changes.keys())\n    score_counts = [0] * (T + 1)\n    score_set = set()\n    \n    for t in range(1, T + 1):\n        current_time = time_points[t - 1]\n        score_counts[t] = len(score_set)\n        \n        for score_change in score_changes[current_time]:\n            score_set.add(score_change)\n        \n        if t < T:\n            next_time = time_points[t]\n            for _ in range(next_time - current_time - 1):\n                score_set.add(0)\n        \n        if t > 1:\n            score_set.discard(score_changes[time_points[t - 2]][-1])\n    \n    for i in range(1, T + 1):\n        print(score_counts[i])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_e",
        "code_list": [
            "def main():\n    V1, V2, V3 = map(int, input().split())\n    \n    # Check if the given V1, V2, V3 can form a valid configuration\n    if V1 + 3 * V2 + 7 * V3 != 3 * 7**3:\n        print(\"No\")\n        return\n    \n    # Calculate the total volume covered by the cubes\n    total_volume = V1 + 3 * V2 + 7 * V3\n    \n    # Check if the configuration is possible within the constraints\n    if total_volume > 3 * 100**3 or V3 > 7**3:\n        print(\"No\")\n        return\n    \n    # Determine the positions of the cubes\n    a1, b1, c1 = 0, 0, 0\n    a2, b2, c2 = 0, 7, 0\n    a3, b3, c3 = 7, 0, 0\n    \n    # Verify the configuration\n    if V1 == 7**3 and V2 == 2 * 7**2 and V3 == 7**3:\n        print(\"Yes\")\n        print(a1, b1, c1, a2, b2, c2, a3, b3, c3)\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    T = input().strip()\n    N = int(input().strip())\n    \n    # Initialize the cost array\n    cost = [float('inf')] * (len(T) + 1)\n    cost[0] = 0\n    \n    # Process each bag\n    for _ in range(N):\n        A, *strings = input().strip().split()\n        A = int(A)\n        \n        # Update the cost array based on the current bag\n        new_cost = [float('inf')] * (len(T) + 1)\n        for j in range(len(T) + 1):\n            if cost[j] != float('inf'):\n                for s in strings:\n                    if T.startswith(s, j):\n                        new_cost[j + len(s)] = min(new_cost[j + len(s)], cost[j])\n                    new_cost[j] = min(new_cost[j], cost[j] + 1)\n        \n        cost = new_cost\n    \n    # Output the result\n    print(cost[len(T)] if cost[len(T)] != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    start = S.find('|')\n    end = S.rfind('|')\n    result = S[:start] + S[end+1:]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_c",
        "code_list": [
            "def main():\n    import sys\n    from itertools import product\n    \n    def read_int():\n        return int(sys.stdin.readline())\n    \n    def read_line():\n        return list(map(int, sys.stdin.readline().split()))\n    \n    N = read_int()\n    A = read_line()\n    M = read_int()\n    B = read_line()\n    L = read_int()\n    C = read_line()\n    Q = read_int()\n    X = read_line()\n    \n    # Generate all possible sums of elements from A, B, and C\n    possible_sums = set(a + b + c for a, b, c in product(A, B, C))\n    \n    # Check each X_i\n    for x in X:\n        if x in possible_sums:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_b",
        "code_list": [
            "def main():\n    # Read input until 0 is encountered\n    numbers = []\n    while True:\n        try:\n            num = int(input())\n            if num == 0:\n                break\n            numbers.append(num)\n        except EOFError:\n            break\n    \n    # Print the numbers in reverse order\n    for num in reversed(numbers):\n        print(num)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    # Read input\n    N = int(input())\n    A = list(map(int, input().split()))\n    Q = int(input())\n    \n    # Initialize data structures\n    positions = {x: i for i, x in enumerate(A)}\n    next_positions = defaultdict(lambda: -1)\n    prev_positions = defaultdict(lambda: -1)\n    \n    # Process queries\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            x, y = query[1], query[2]\n            pos_x = positions[x]\n            pos_y = positions[y]\n            del positions[x]\n            del positions[y]\n            A[pos_x] = y\n            positions[y] = pos_x\n            next_positions[pos_x] = pos_y\n            prev_positions[pos_y] = pos_x\n            next_positions[pos_y] = pos_x + 1\n            prev_positions[pos_x + 1] = pos_y\n        elif query[0] == 2:\n            x = query[1]\n            pos_x = positions[x]\n            del positions[x]\n            next_pos = next_positions[pos_x]\n            prev_positions[next_pos] = prev_positions[pos_x]\n            next_positions[prev_positions[pos_x]] = next_pos\n    \n    # Output the result\n    print(' '.join(map(str, A)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc345_d",
        "code_list": [
            "def can_cover_grid(N, H, W, tiles):\n    # Check if any tile cannot fit into the grid\n    for A, B in tiles:\n        if A > H and B > W:\n            return \"No\"\n    \n    # Generate all possible tile placements\n    def generate_placements(A, B):\n        return [(A, B), (B, A)]\n    \n    # Try placing tiles recursively\n    def try_place(tiles, placed, row, col):\n        if row == H:\n            return True\n        \n        for A, B in generate_placements(*tiles[0]):\n            if A + row <= H and B + col <= W:\n                for placement in generate_placements(A, B):\n                    if all((i + row < H and j + col < W and (i + row, j + col) not in placed) for i in range(A) for j in range(B)):\n                        for i in range(A):\n                            for j in range(B):\n                                placed.add((i + row, j + col))\n                        if try_place(tiles[1:], placed, row, col + B):\n                            return True\n                        for i in range(A):\n                            for j in range(B):\n                                placed.remove((i + row, j + col))\n        \n        if col == W:\n            return try_place(tiles, placed, row + 1, 0)\n        else:\n            return try_place(tiles, placed, row, col + 1)\n    \n    return \"Yes\" if try_place(tiles, set(), 0, 0) else \"No\"\n\nif __name__ == \"__main__\":\n    N, H, W = map(int, input().split())\n    tiles = [tuple(map(int, input().split())) for _ in range(N)]\n    print(can_cover_grid(N, H, W, tiles))"
        ]
    },
    {
        "question_id": "abc345_b",
        "code_list": [
            "def main():\n    X = int(input())\n    result = (X + 9) // 10\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_d",
        "code_list": [
            "def min_cost_to_make_good_string(N, S, costs):\n    # Initialize variables to keep track of the minimum cost\n    min_cost = float('inf')\n    \n    # Iterate through the string to find the optimal position to flip\n    for i in range(1, N):\n        # Calculate the cost of making the string good by flipping at position i\n        current_cost = 0\n        for j in range(i):\n            if S[j] != S[i]:\n                current_cost += costs[j]\n        for j in range(i + 1, N):\n            if S[j] != S[i]:\n                current_cost += costs[j]\n        \n        # Update the minimum cost found so far\n        min_cost = min(min_cost, current_cost)\n    \n    return min_cost\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    costs = list(map(int, input().strip().split()))\n    print(min_cost_to_make_good_string(N, S, costs))"
        ]
    },
    {
        "question_id": "abc346_b",
        "code_list": [
            "def main():\n    # Read input values for W and B\n    W, B = map(int, input().split())\n    \n    # The repeating pattern of the string S\n    pattern = \"wbwbwwbwbwbw\"\n    \n    # Calculate the number of times the pattern needs to repeat to cover at least W and B\n    # Since the pattern length is 12, we need to consider multiples of 12\n    def find_substring(W, B):\n        # Iterate over possible multiples of the pattern length\n        for i in range(1, 101):\n            # Calculate the number of 'w' and 'b' in the repeated pattern\n            count_w = pattern.count('w') * i\n            count_b = pattern.count('b') * i\n            \n            # Check if the current multiple can accommodate W and B\n            if count_w >= W and count_b >= B:\n                # Calculate the required starting position in the pattern\n                start_pos_w = (W - 1) % pattern.count('w')\n                start_pos_b = (B - 1) % pattern.count('b')\n                \n                # Check if the required positions exist in the pattern\n                if 'w' * W in pattern * i and 'b' * B in pattern * i:\n                    return True\n        return False\n    \n    # Check if there exists a substring with W 'w' and B 'b'\n    result = find_substring(W, B)\n    \n    # Print the result\n    print(\"Yes\" if result else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_e",
        "code_list": [
            "def main():\n    # Read input\n    H, W, M = map(int, input().split())\n    operations = [list(map(int, input().split())) for _ in range(M)]\n    \n    # Initialize sets to keep track of rows and columns that have been painted\n    painted_rows = set()\n    painted_cols = set()\n    \n    # Process each operation\n    for T, A, X in operations:\n        if T == 1:\n            painted_rows.add(A - 1)\n            # Paint all cells in the A-th row with color X\n            for col in range(W):\n                if (A - 1, col) not in painted_cols:\n                    print(X, end=' ')\n                    painted_cols.add((A - 1, col))\n        elif T == 2:\n            painted_cols.add(A - 1)\n            # Paint all cells in the A-th column with color X\n            for row in range(H):\n                if (row, A - 1) not in painted_rows:\n                    print(X, end=' ')\n                    painted_rows.add((row, A - 1))\n    \n    # Determine the unique colors present\n    unique_colors = sorted(set([X for _, X in operations]))\n    \n    # Output the number of unique colors\n    print(len(unique_colors))\n    \n    # Output the count of cells for each unique color\n    for color in unique_colors:\n        count = sum(1 for op in operations if op[2] == color)\n        print(color, count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_a",
        "code_list": [
            "def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    for i in range(N - 1):\n        B_i = A[i] * A[i + 1]\n        print(B_i, end=' ' if i < N - 2 else '\\n')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_c",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Create a set of all numbers from 1 to K\n    all_numbers = set(range(1, K + 1))\n\n    # Remove numbers present in A from the set\n    missing_numbers = all_numbers - set(A)\n\n    # Calculate the sum of missing numbers\n    result = sum(missing_numbers)\n\n    # Print the result\n    print(result)"
        ]
    },
    {
        "question_id": "abc347_c",
        "code_list": [
            "def main():\n    N, A, B = map(int, input().split())\n    D = list(map(int, input().split()))\n    \n    # Calculate the difference between consecutive days\n    diff = [D[i] - D[i-1] for i in range(1, N)]\n    \n    # Check if all differences are multiples of (A + B)\n    if all(d % (A + B) == 0 for d in diff):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc347_a",
        "code_list": [
            "def main():\n    # Read input values\n    N, K = map(int, input().split())\n    \n    # Read the sequence A\n    A = list(map(int, input().split()))\n    \n    # Extract multiples of K and divide them by K\n    quotients = [a // K for a in A if a % K == 0]\n    \n    # Print the quotients in ascending order\n    print(\" \".join(map(str, sorted(quotients))))"
        ]
    },
    {
        "question_id": "abc347_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    x_start = 2\n    \n    # Initialize the sequence A and the set S\n    A = [0] * N\n    S = set()\n    \n    # Process each query\n    for i in range(Q):\n        x = int(data[x_start + i])\n        if x in S:\n            S.remove(x)\n        else:\n            S.add(x)\n        \n        # Update the sequence A based on the current size of S\n        for j in S:\n            A[j - 1] += len(S)\n    \n    # Print the final sequence A\n    print(\" \".join(map(str, A)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc347_b",
        "code_list": [
            "def count_unique_substrings(s):\n    n = len(s)\n    unique_substrings = set()\n    \n    # Generate all possible substrings\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            unique_substrings.add(s[i:j])\n    \n    # Return the number of unique substrings\n    return len(unique_substrings)\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(count_unique_substrings(s))"
        ]
    },
    {
        "question_id": "abc348_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    bean_map = defaultdict(list)\n    \n    for _ in range(N):\n        A, C = map(int, input().split())\n        bean_map[C].append(A)\n    \n    max_min_deliciousness = 0\n    \n    for colors in bean_map.values():\n        colors.sort(reverse=True)\n        max_min_deliciousness = max(max_min_deliciousness, colors[-1])\n    \n    print(max_min_deliciousness)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_b",
        "code_list": [
            "import math\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef find_farthest_points(points):\n    n = len(points)\n    result = []\n    \n    for i in range(n):\n        max_distance = 0\n        farthest_point_id = -1\n        \n        for j in range(n):\n            if i != j:\n                distance = euclidean_distance(points[i], points[j])\n                if distance > max_distance:\n                    max_distance = distance\n                    farthest_point_id = j + 1  # IDs start from 1\n                elif distance == max_distance:\n                    farthest_point_id = min(farthest_point_id, j + 1)\n        \n        result.append(farthest_point_id)\n    \n    return result\n\ndef main():\n    n = int(input())\n    points = []\n    \n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    \n    farthest_points = find_farthest_points(points)\n    \n    for point_id in farthest_points:\n        print(point_id)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_a",
        "code_list": [
            "def main():\n    N = int(input())\n    result = ''.join(['o' if (i + 1) % 3 != 0 else 'x' for i in range(N)])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start, end, medicines):\n    h, w = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[[False for _ in range(h * w + 1)] for _ in range(w)] for _ in range(h)]\n    queue = deque([(start[0], start[1], 0)])\n    visited[start[0]][start[1]][0] = True\n    \n    while queue:\n        x, y, energy = queue.popleft()\n        \n        if (x, y) == end:\n            return True\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < h and 0 <= ny < w and grid[nx][ny] != '#':\n                nenergy = energy\n                \n                if grid[nx][ny] == 'S' or grid[nx][ny] == 'T':\n                    continue\n                elif grid[nx][ny] == '.':\n                    nenergy -= 1\n                elif grid[nx][ny] == 'E':\n                    nenergy = int(grid[nx][ny][1:])\n                \n                if nenergy >= 0 and not visited[nx][ny][nenergy]:\n                    visited[nx][ny][nenergy] = True\n                    queue.append((nx, ny, nenergy))\n    \n    return False\n\ndef main():\n    h, w = map(int, input().split())\n    grid = [input() for _ in range(h)]\n    n = int(input())\n    medicines = [tuple(map(int, input().split())) + (grid[r-1][c-1],) for r, c in (map(int, input().split()) for _ in range(n))]\n    \n    start = next((i, j) for i in range(h) for j in range(w) if grid[i][j] == 'S')\n    end = next((i, j) for i in range(h) for j in range(w) if grid[i][j] == 'T')\n    \n    for r, c, e in medicines:\n        grid[r-1] = grid[r-1][:c-1] + 'E' + grid[r-1][c:]\n    \n    if bfs(grid, start, end, medicines):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, depth, c, g):\n    global total_depth\n    total_depth += depth\n    for neighbor in g[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, c, g)\n\ndef calculate_f(v, c, g, n):\n    global total_depth\n    total_depth = 0\n    dfs(v, -1, 0, c, g)\n    return sum(c[i] * (total_depth - 2 * depth) for i, depth in enumerate(g[v]))\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    c = []\n    start_index = 1\n    \n    for i in range(1, n):\n        edges.append((int(data[start_index]), int(data[start_index + 1])))\n        start_index += 2\n    \n    start_index += 1\n    c = list(map(int, data[start_index:start_index + n]))\n    \n    g = defaultdict(list)\n    for u, v in edges:\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    \n    min_f = float('inf')\n    for v in range(n):\n        min_f = min(min_f, calculate_f(v, c, g, n))\n    \n    print(min_f)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc349_c",
        "code_list": [
            "def is_airport_code(S: str, T: str) -> bool:\n    # Check if T can be formed by taking a subsequence of length 3 from S and converting it to uppercase\n    for i in range(len(S) - 2):\n        if S[i:i+3].upper() == T:\n            return True\n    \n    # Check if T can be formed by taking a subsequence of length 2 from S, converting it to uppercase, and appending 'X'\n    for i in range(len(S) - 1):\n        if S[i:i+2].upper() + 'X' == T:\n            return True\n    \n    return False\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    T = input().strip()\n    print(\"Yes\" if is_airport_code(S, T) else \"No\")"
        ]
    },
    {
        "question_id": "abc349_a",
        "code_list": [
            "def calculate_final_score(N, A):\n    # Calculate the total change in scores for all pairs except the last person\n    total_change = sum(A)\n    # The final score of person N is the negative of the total change\n    final_score_N = -total_change\n    return final_score_N\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(calculate_final_score(N, A))"
        ]
    },
    {
        "question_id": "abc349_b",
        "code_list": [
            "from collections import Counter\n\ndef is_good_string(S):\n    # Count the frequency of each character in the string\n    freq = Counter(S)\n    \n    # Count how many characters have the same frequency\n    freq_of_freq = Counter(freq.values())\n    \n    # Check the conditions for a good string\n    for count in freq_of_freq.values():\n        if count != 0 and count != 2:\n            return False\n    \n    # Check if there's more than one unique frequency with exactly one occurrence\n    if len([count for count in freq_of_freq.values() if count == 1]) > 1:\n        return False\n    \n    return True\n\ndef main():\n    S = input().strip()\n    print(\"Yes\" if is_good_string(S) else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc349_d",
        "code_list": [
            "def find_good_sequences(L, R):\n    def find_min_power_of_two(n):\n        power = 0\n        while n > 0:\n            n >>= 1\n            power += 1\n        return power - 1\n    \n    def find_good_sequence(L, R):\n        power = find_min_power_of_two(R - L)\n        start = L & ((1 << power) - 1)\n        end = start + (1 << power)\n        if end <= R:\n            return (start, end)\n        else:\n            return (L, R)\n    \n    result = []\n    while L < R:\n        seq = find_good_sequence(L, R)\n        result.append(seq)\n        L, R = seq[1], seq[1]\n    \n    return result\n\ndef main():\n    L, R = map(int, input().split())\n    sequences = find_good_sequences(L, R)\n    print(len(sequences))\n    for seq in sequences:\n        print(seq[0], seq[1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc349_e",
        "code_list": [
            "def main():\n    # Read the grid\n    grid = []\n    for _ in range(3):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to check if a player can force a win\n    def can_force_win(grid, player):\n        # Check rows, columns, and diagonals for a forced win\n        for i in range(3):\n            if grid[i][0] == grid[i][1] == player and grid[i][2] == 0:\n                return True\n            if grid[0][i] == grid[1][i] == player and grid[2][i] == 0:\n                return True\n        if grid[0][0] == grid[1][1] == player and grid[2][2] == 0:\n            return True\n        if grid[0][2] == grid[1][1] == player and grid[2][0] == 0:\n            return True\n        if grid[2][0] == grid[1][1] == player and grid[0][2] == 0:\n            return True\n        if grid[2][2] == grid[1][1] == player and grid[0][0] == 0:\n            return True\n        \n        return False\n    \n    # Function to simulate the game and determine the winner\n    def simulate_game(grid):\n        # Initialize scores\n        takahashi_score = 0\n        aoki_score = 0\n        \n        # Player turn order\n        current_player = 'T'\n        \n        while True:\n            # Find the best move for the current player\n            best_move = None\n            best_score = -float('inf')\n            \n            for i in range(3):\n                for j in range(3):\n                    if grid[i][j] == 0:\n                        new_grid = [row[:] for row in grid]\n                        new_grid[i][j] = 1 if current_player == 'T' else 2\n                        score = sum(new_grid[i][j] for i in range(3) for j in range(3) if new_grid[i][j] == 1) - sum(new_grid[i][j] for i in range(3) for j in range(3) if new_grid[i][j] == 2)\n                        if score > best_score:\n                            best_score = score\n                            best_move = (i, j)\n            \n            # Apply the best move\n            i, j = best_move\n            grid[i][j] = 1 if current_player == 'T' else 2\n            \n            # Update scores\n            if current_player == 'T':\n                takahashi_score += grid[i][j]\n            else:\n                aoki_score += grid[i][j]\n            \n            # Check for a win condition\n            if can_force_win(grid, 1):\n                return 'Takahashi'\n            if can_force_win(grid, 2):\n                return 'Aoki'\n            \n            # Check if all cells are filled\n            if all(grid[i][j] != 0 for i in range(3) for j in range(3)):\n                return 'Takahashi' if takahashi_score > aoki_score else 'Aoki'\n            \n            # Switch players\n            current_player = 'A' if current_player == 'T' else 'T'\n\n    # Determine the winner\n    winner = simulate_game(grid)\n    print(winner)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    # Check if the string matches the pattern ABC followed by two digits within the valid range\n    if S[:3] == \"ABC\" and 1 <= int(S[3:]) <= 348 and int(S[3:]) != 316:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_e",
        "code_list": [
            "import math\n\ndef expected_cost(N, A, X, Y):\n    # Initialize memoization table\n    memo = {}\n    \n    def dp(n):\n        if n == 0:\n            return 0\n        if n < A:\n            return float('inf')\n        if (n, A, X, Y) in memo:\n            return memo[(n, A, X, Y)]\n        \n        # Cost of dividing by A\n        cost_divide = X + dp(math.floor(n / A))\n        \n        # Cost of rolling the die\n        cost_roll = Y + min(dp(math.floor(n / i)) for i in range(1, 7))\n        \n        # Take the minimum of both costs\n        result = min(cost_divide, cost_roll)\n        memo[(n, A, X, Y)] = result\n        return result\n    \n    return dp(N)\n\nif __name__ == \"__main__\":\n    N, A, X, Y = map(int, input().split())\n    print(expected_cost(N, A, X, Y))"
        ]
    },
    {
        "question_id": "abc350_b",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    treatments = list(map(int, input().split()))\n    \n    # Initialize the count of teeth\n    teeth_count = N\n    \n    # Process each treatment\n    for treatment in treatments:\n        if teeth_count > 0:\n            # If there is a tooth in the hole, remove it\n            if teeth_count >= treatment:\n                teeth_count -= 1\n            else:\n                # If the hole is empty, do nothing\n                continue\n        else:\n            # If there are no teeth left, do nothing\n            continue\n    \n    # Output the result\n    print(teeth_count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def swap_elements(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n    \n    def find_index(arr, value):\n        return arr.index(value)\n    \n    def transform_permutation(N, perm):\n        operations = []\n        for i in range(N):\n            if perm[i] != i + 1:\n                target_index = find_index(perm, i + 1)\n                swap_elements(perm, i, target_index)\n                operations.append((i + 1, target_index + 1))\n        return operations\n    \n    # Read input\n    N = int(input().strip())\n    perm = list(map(int, input().strip().split()))\n    \n    # Transform the permutation\n    operations = transform_permutation(N, perm)\n    \n    # Output the result\n    print(len(operations))\n    for op in operations:\n        print(op[0], op[1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    # Read input\n    N, M = map(int, input().split())\n    friendships = defaultdict(set)\n    \n    for _ in range(M):\n        A, B = map(int, input().split())\n        friendships[A].add(B)\n        friendships[B].add(A)\n    \n    # Initialize counts\n    count = 0\n    \n    # Iterate over all users\n    for user in range(1, N + 1):\n        for friend in friendships[user]:\n            for potential_friend in friendships[friend]:\n                if potential_friend != user and potential_friend not in friendships[user]:\n                    count += 1\n    \n    # Each friendship triplet is counted twice, so divide by 2\n    result = count // 2\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_a",
        "code_list": [
            "def main():\n    # Read input\n    takahashi_scores = list(map(int, input().split()))\n    aoki_scores = list(map(int, input().split()))\n\n    # Calculate the current scores\n    takahashi_total = sum(takahashi_scores)\n    aoki_total = sum(aoki_scores)\n\n    # Determine the minimum runs needed for Aoki to win\n    min_runs_needed = 1 if takahashi_total - aoki_total < 0 else takahashi_total - aoki_total + 1\n\n    # Output the result\n    print(min_runs_needed)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_b",
        "code_list": [
            "def find_mismatched_cell(N, grid_A, grid_B):\n    for i in range(N):\n        for j in range(N):\n            if grid_A[i][j] != grid_B[i][j]:\n                return i + 1, j + 1\n\ndef main():\n    N = int(input())\n    grid_A = [input() for _ in range(N)]\n    input()  # Skip the empty line between grid A and grid B\n    grid_B = [input() for _ in range(N)]\n    \n    i, j = find_mismatched_cell(N, grid_A, grid_B)\n    print(i, j)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_e",
        "code_list": [
            "from collections import defaultdict\n\ndef bfs(start, end, points):\n    queue = [(start[0], start[1], 0)]\n    visited = set()\n    while queue:\n        x, y, dist = queue.pop(0)\n        if (x, y) == (end[0], end[1]):\n            return dist\n        for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= 1e8 and 0 <= ny <= 1e8 and (nx, ny) in points and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, dist + 1))\n    return float('inf')\n\ndef main():\n    N = int(input())\n    points = []\n    for _ in range(N):\n        X, Y = map(int, input().split())\n        points.append((X, Y))\n\n    dist_sum = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = bfs(points[i], points[j], set(points))\n            if dist != float('inf'):\n                dist_sum += dist\n\n    print(dist_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_f",
        "code_list": [
            "def main():\n    import sys\n    \n    def calculate_expression(N, A):\n        prefix_sum = [0] * (N + 1)\n        for i in range(N):\n            prefix_sum[i + 1] = prefix_sum[i] + A[i]\n        \n        result = 0\n        for i in range(N):\n            left = i + 1\n            right = N\n            while left < right:\n                mid = (left + right) // 2\n                if A[mid] - A[i] > 0:\n                    right = mid\n                else:\n                    left = mid + 1\n            \n            for j in range(left, N):\n                result += max(A[j] - A[i], 0)\n        \n        return result\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    print(calculate_expression(N, A))"
        ]
    },
    {
        "question_id": "abc351_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_operations(N, A):\n        sequence = []\n        for i in range(N):\n            sequence.append(2 ** A[i])\n            while len(sequence) > 1 and sequence[-1] == sequence[-2]:\n                sequence.pop()\n                sequence.pop()\n                if len(sequence) > 1:\n                    sequence.append(sequence[-1] + sequence[-2])\n        \n        return len(sequence)\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    print(process_operations(N, A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start):\n    H, W = len(grid), len(grid[0])\n    visited = [[False] * W for _ in range(H)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    count = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        count += 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and grid[nx][ny] != '#':\n                visited[nx][ny] = True\n                queue.append((nx, ny))\n    \n    return count\n\ndef main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    max_degree_of_freedom = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] != '#':\n                max_degree_of_freedom = max(max_degree_of_freedom, bfs(grid, (i, j)))\n    \n    print(max_degree_of_freedom)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef kruskal(n, edges):\n    mst_edges = []\n    for u, v, w in edges:\n        heappush(mst_edges, (w, u, v))\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    mst_weight = 0\n    while mst_edges:\n        w, u, v = heappop(mst_edges)\n        if find(parent, u) != find(parent, v):\n            union(parent, rank, u, v)\n            mst_weight += w\n    return mst_weight\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, m = int(data[0]), int(data[1])\n    edges = []\n    start_index = 2\n    \n    for _ in range(m):\n        k, c = int(data[start_index]), int(data[start_index + 1])\n        start_index += 2\n        for i in range(start_index, start_index + k - 1):\n            u, v = int(data[i]), int(data[i + 1])\n            edges.append((u, v, c))\n        start_index += k - 1\n    \n    # Check connectivity\n    parent = list(range(n + 1))\n    for u, v, _ in edges:\n        union(parent, [0] * (n + 1), u, v)\n    \n    # Find the root of the first vertex\n    root = find(parent, 1)\n    \n    # Check if all vertices have the same root\n    for i in range(2, n + 1):\n        if find(parent, i) != root:\n            print(-1)\n            return\n    \n    # Calculate MST weight\n    mst_weight = kruskal(n, edges)\n    print(mst_weight)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_a",
        "code_list": [
            "def main():\n    N, X, Y, Z = map(int, input().split())\n    if X < Y:  # Traveling from X to Y using an inbound train\n        stops = [i for i in range(X + 1, Y + 1)]\n    else:  # Traveling from X to Y using an outbound train\n        stops = [i for i in range(X - 1, Y - 1, -1)]\n    if Z in stops:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_c",
        "code_list": [
            "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    ai = [0] * n\n    bi = [0] * n\n    \n    start = 1\n    for i in range(n):\n        ai[i] = int(data[start])\n        bi[i] = int(data[start + 1])\n        start += 2\n    \n    # Find the maximum height by sorting based on the difference between head and shoulder heights\n    max_height = 0\n    current_height = 0\n    for i in sorted(range(n), key=lambda x: bi[x] - ai[x], reverse=True):\n        current_height += ai[i]\n        max_height = max(max_height, current_height + bi[i])\n    \n    print(max_height)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_b",
        "code_list": [
            "def find_correctly_typed_positions(S, T):\n    # Initialize variables\n    S_len = len(S)\n    T_len = len(T)\n    correct_positions = []\n    S_index = 0\n    \n    # Iterate through T to find correctly typed positions\n    for i in range(T_len):\n        if S_index < S_len and S[S_index] == T[i]:\n            correct_positions.append(i + 1)\n            S_index += 1\n        elif S_index > 0:\n            S_index -= 1\n    \n    return correct_positions\n\ndef main():\n    S = input().strip()\n    T = input().strip()\n    correct_positions = find_correctly_typed_positions(S, T)\n    print(\" \".join(map(str, correct_positions)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_d",
        "code_list": [
            "def find_min_gap(N, K, P):\n    # Create a dictionary to store the positions of each number in the permutation\n    pos = {num: idx for idx, num in enumerate(P)}\n    \n    # Initialize variables to track the minimum gap\n    min_gap = N\n    \n    # Iterate through each possible starting position for the subsequence\n    for start in range(N - K + 1):\n        # Calculate the expected end position based on the starting position and length K\n        expected_end = start + K - 1\n        \n        # Check if the subsequence from start to expected_end forms a consecutive sequence\n        if all(pos[start + i] == start + i for i in range(K)):\n            min_gap = min(min_gap, expected_end - start)\n    \n    return min_gap\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    P = list(map(int, input().split()))\n    print(find_min_gap(N, K, P))"
        ]
    },
    {
        "question_id": "abc353_c",
        "code_list": [
            "def f(x, y):\n    return (x + y) % 100000000\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = (prefix_sum[i - 1] + A[i - 1]) % 100000000\n    \n    result = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            result += f(A[i - 1], A[j - 1])\n            result %= 100000000\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_b",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Initialize variables\n    empty_seats = K\n    starts = 0\n\n    # Process each group\n    for group_size in A:\n        if empty_seats < group_size:\n            # Start the attraction\n            starts += 1\n            empty_seats = K\n        else:\n            # Guide the group\n            empty_seats -= group_size\n            if empty_seats == 0:\n                # Start the attraction\n                starts += 1\n                empty_seats = K\n\n    print(starts)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_a",
        "code_list": [
            "def main():\n    # Read input\n    N = int(input())\n    heights = list(map(int, input().split()))\n    \n    # Check if any building is taller than the first one\n    for i in range(1, N):\n        if heights[i] > heights[0]:\n            print(i + 1)\n            return\n    \n    # If no building is taller, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_e",
        "code_list": [
            "def longest_common_prefix_length(s1, s2):\n    min_len = min(len(s1), len(s2))\n    for i in range(min_len):\n        if s1[i] != s2[i]:\n            return i\n    return min_len\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    strings = data[1:]\n    \n    total_sum = 0\n    \n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            total_sum += longest_common_prefix_length(strings[i], strings[j])\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_d",
        "code_list": [
            "def f(x, y):\n    return int(str(x) + str(y))\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    mod = 998244353\n    total_sum = 0\n    \n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            total_sum += f(A[i], A[j])\n            total_sum %= mod\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    users = []\n    ratings = []\n\n    for i in range(1, n * 2 + 1, 2):\n        users.append(data[i])\n        ratings.append(int(data[i + 1]))\n\n    # Calculate the total rating\n    total_rating = sum(ratings)\n\n    # Find the winner based on the modulo operation\n    winner_index = total_rating % n\n\n    # Sort the users lexicographically\n    sorted_users = sorted(zip(users, ratings))\n\n    # Print the winner's username\n    print(sorted_users[winner_index][0])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_a",
        "code_list": [
            "def main():\n    H = int(input())\n    i = 0\n    while (1 << i) - 1 < H:\n        i += 1\n    print(i)"
        ]
    },
    {
        "question_id": "abc354_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    cards = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    # Count occurrences of each number on the front and back sides\n    front_counts = defaultdict(int)\n    back_counts = defaultdict(int)\n    for a, b in cards:\n        front_counts[a] += 1\n        back_counts[b] += 1\n    \n    # Calculate the total number of unique numbers on the front and back sides\n    front_unique = len(front_counts)\n    back_unique = len(back_counts)\n    \n    # Determine the winning player based on the parity of the total count of unique numbers\n    total_unique = front_unique + back_unique\n    if total_unique % 2 == 0:\n        print(\"Aoki\")\n    else:\n        print(\"Takahashi\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_c",
        "code_list": [
            "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    strengths = []\n    costs = []\n    indices = []\n    \n    for i in range(1, n * 2 + 1, 2):\n        strengths.append(int(data[i]))\n        costs.append(int(data[i + 1]))\n        indices.append(i // 2 + 1)\n    \n    # Sort by cost, then by strength\n    sorted_indices = [x for _, x in sorted(zip(costs, indices))]\n    strengths = [strengths[i] for i in sorted_indices]\n    costs = [costs[i] for i in sorted_indices]\n    \n    stack = []\n    for i in range(n):\n        if not stack or strengths[i] <= strengths[-1]:\n            stack.append((strengths[i], costs[i], indices[i]))\n        else:\n            while stack and strengths[i] > stack[-1][0] and costs[i] < stack[-1][1]:\n                stack.pop()\n            stack.append((strengths[i], costs[i], indices[i]))\n    \n    remaining_cards = [x[2] for x in stack]\n    print(len(remaining_cards))\n    print(' '.join(map(str, remaining_cards)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_d",
        "code_list": [
            "def main():\n    A, B, C, D = map(int, input().split())\n    # Calculate the area of the rectangle\n    width = C - A\n    height = D - B\n    \n    # Determine the color of the bottom-left corner (A, B)\n    color = (A + B) % 2\n    \n    # Determine the parity of the lines intersecting the rectangle\n    x_lines = (A + 1) // 2 + (C // 2)\n    y_lines = (B // 2) + (D // 2)\n    \n    # Calculate the area of black regions\n    if color == 0:\n        black_area = (width + 1) * (height + 1) // 2 - x_lines * y_lines\n    else:\n        black_area = (width + 1) * (height + 1) // 2 - (x_lines - 1) * (y_lines - 1)\n    \n    # Print twice the area of black regions\n    print(black_area * 2)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_e",
        "code_list": [
            "import math\n\ndef query(i, j):\n    print(f\"? {i} {j}\")\n    T = int(input())\n    return T if T != -1 else None\n\ndef solve(N, L, R):\n    def get_sum(start, end):\n        if start > end:\n            return 0\n        if start == end:\n            return query(0, start)\n        \n        i = int(math.log2((end - start + 1)))\n        j = (start + end) // (2**i)\n        mid = 2**i * j\n        \n        left_sum = get_sum(start, mid - 1)\n        right_sum = get_sum(mid, end)\n        \n        if mid <= R and mid - 1 >= L:\n            return (left_sum + right_sum + query(i, j)) % 100\n        else:\n            return (left_sum + right_sum) % 100\n    \n    result = get_sum(L, R)\n    print(f\"! {result}\")\n\nif __name__ == \"__main__\":\n    N, L, R = map(int, input().split())\n    solve(N, L, R)"
        ]
    },
    {
        "question_id": "abc355_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Combine and sort A and B\n    C = sorted(A + B)\n\n    # Check for consecutive elements from A in C\n    for i in range(len(C) - 1):\n        if C[i] in A and C[i + 1] in A:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_c",
        "code_list": [
            "def main():\n    # Read input\n    N, T = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Initialize marking arrays\n    row_marked = [0] * N\n    col_marked = [0] * N\n    diag1_marked = 0\n    diag2_marked = 0\n\n    # Function to mark the cell and check for Bingo\n    def mark_cell(num):\n        nonlocal row_marked, col_marked, diag1_marked, diag2_marked\n        i, j = divmod(num - 1, N)\n        row_marked[i] += 1\n        col_marked[j] += 1\n        if i == j:\n            diag1_marked += 1\n        if i + j == N - 1:\n            diag2_marked += 1\n\n        # Check if Bingo is achieved\n        if any(marked == N for marked in row_marked) or \\\n           any(marked == N for marked in col_marked) or \\\n           diag1_marked == N or diag2_marked == N:\n            return True\n        return False\n\n    # Iterate through turns\n    for turn, num in enumerate(A, 1):\n        if mark_cell(num):\n            print(turn)\n            return\n\n    # Bingo not achieved within T turns\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    suspects = [1, 2, 3]\n    if A != 1 and B != 2:\n        print(3)\n    elif A != 1 and B != 3:\n        print(2)\n    elif A != 2 and B != 1:\n        print(3)\n    elif A != 3 and B != 1:\n        print(2)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    intervals = []\n    start_idx = 1\n    \n    for i in range(N):\n        l = int(data[start_idx + 2 * i])\n        r = int(data[start_idx + 2 * i + 1])\n        intervals.append((l, r))\n    \n    ans = 0\n    left = [0] * N\n    right = [0] * N\n    \n    # Calculate the number of intervals that end before each interval starts\n    for i in range(1, N):\n        left[i] = sum(r < intervals[i][0] for l, r in intervals[:i])\n    \n    # Calculate the number of intervals that start after each interval ends\n    for i in range(N - 2, -1, -1):\n        right[i] = sum(l > intervals[i][1] for l, r in intervals[i+1:])\n    \n    # Count the number of intersecting pairs\n    for i in range(N):\n        if intervals[i][0] < intervals[i][1]:\n            ans += left[i] + right[i]\n    \n    print(ans)"
        ]
    },
    {
        "question_id": "3334",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:\n        total_apples = sum(apple)\n        capacity.sort(reverse=True)\n        boxes_used = 0\n        \n        for box_capacity in capacity:\n            if total_apples <= 0:\n                break\n            total_apples -= box_capacity\n            boxes_used += 1\n        \n        return boxes_used"
        ]
    },
    {
        "question_id": "3351",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:\n        # Sort the happiness values in descending order\n        happiness.sort(reverse=True)\n        total_happiness = 0\n        \n        for i in range(k):\n            # Decrease the happiness value by the number of remaining turns\n            adjusted_happiness = max(0, happiness[i] - i)\n            total_happiness += adjusted_happiness\n        \n        return total_happiness"
        ]
    },
    {
        "question_id": "3356",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def shortestSubstrings(self, arr: List[str]) -> List[str]:\n        from collections import defaultdict\n        \n        # Function to generate all substrings of a given string\n        def generate_substrings(s):\n            substrings = set()\n            for i in range(len(s)):\n                for j in range(i + 1, len(s) + 1):\n                    substrings.add(s[i:j])\n            return substrings\n        \n        # Dictionary to store substrings of each string and their occurrences\n        substrings_dict = defaultdict(set)\n        for i, s in enumerate(arr):\n            substrings = generate_substrings(s)\n            for sub in substrings:\n                substrings_dict[sub].add(i)\n        \n        # Find the shortest unique substrings\n        result = []\n        for i, s in enumerate(arr):\n            substrings = generate_substrings(s)\n            candidates = [sub for sub in substrings if len(substrings_dict[sub]) == 1 and i in substrings_dict[sub]]\n            if not candidates:\n                result.append(\"\")\n                continue\n            # Find the shortest and lexicographically smallest substring\n            shortest = min(candidates, key=lambda x: (len(x), x))\n            result.append(shortest)\n        \n        return result"
        ]
    },
    {
        "question_id": "3313",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumStrength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n        \n        for i in range(1, n + 1):\n            for j in range(1, min(i, k) + 1):\n                dp[i][j] = max(dp[i - 1][j], \n                               prefix_sum[i] * ((k - j + 1) // k * 2 - 1) + \n                               dp[i - (k - j + 1) % k][j - 1])\n        \n        return dp[n][k]"
        ]
    },
    {
        "question_id": "3353",
        "code_list": [
            "class Solution:\n    def isSubstringPresent(self, s: str) -> bool:\n        reverse_s = s[::-1]\n        for i in range(len(s) - 1):\n            if s[i:i+2] in reverse_s:\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3337",
        "code_list": [
            "class Solution:\n    def countSubstrings(self, s: str, c: str) -> int:\n        count = s.count(c)\n        return (count * (count + 1)) // 2"
        ]
    },
    {
        "question_id": "3360",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumDeletions(self, word: str, k: int) -> int:\n        freqs = sorted(Counter(word).values())\n        n = len(freqs)\n        min_deletions = float('inf')\n        \n        for target_freq in freqs:\n            deletions = 0\n            for freq in freqs:\n                if freq > target_freq + k:\n                    deletions += freq - (target_freq + k)\n                elif freq < target_freq:\n                    deletions += freq\n            min_deletions = min(min_deletions, deletions)\n        \n        return min_deletions"
        ]
    },
    {
        "question_id": "3327",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:\n        n = len(nums)\n        ones_positions = [i for i, num in enumerate(nums) if num == 1]\n        min_moves = float('inf')\n        \n        # Iterate over all pairs of starting positions\n        for start in range(len(ones_positions)):\n            current_moves = 0\n            changes_used = 0\n            for pick in range(k):\n                if pick < start:\n                    current_moves += ones_positions[pick] - ones_positions[start]\n                elif pick > start:\n                    current_moves += ones_positions[start] - ones_positions[pick]\n                else:\n                    continue\n                if changes_used < maxChanges:\n                    current_moves += 1\n                    changes_used += 1\n                else:\n                    current_moves += 2\n            min_moves = min(min_moves, current_moves)\n        \n        return min_moves"
        ]
    },
    {
        "question_id": "3349",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maximumLengthSubstring(self, s: str) -> int:\n        char_count = defaultdict(int)\n        left = 0\n        max_length = 0\n        \n        for right in range(len(s)):\n            char_count[s[right]] += 1\n            \n            while char_count[s[right]] > 2:\n                char_count[s[left]] -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3328",
        "code_list": [
            "class Solution:\n    def minOperations(self, k: int) -> int:\n        if k == 1:\n            return 0\n        \n        min_operations = float('inf')\n        \n        for i in range(1, k):\n            # Calculate the number of increases needed to reach i\n            increases = i - 1\n            # Calculate the number of duplications needed to reach at least k\n            duplications = (k + i - 1) // i - 1\n            total_operations = increases + duplications\n            min_operations = min(min_operations, total_operations)\n        \n        return min_operations"
        ]
    },
    {
        "question_id": "3363",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:\n        id_count = Counter()\n        ans = []\n        for i in range(len(nums)):\n            id_count[nums[i]] += freq[i]\n            max_count = max(id_count.values()) if id_count else 0\n            ans.append(max_count)\n        return ans"
        ]
    },
    {
        "question_id": "3376",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:\n        # Create a dictionary to store the index of each word in wordsContainer\n        index_map = {word: i for i, word in enumerate(wordsContainer)}\n        # Reverse each word in wordsContainer to facilitate suffix comparison\n        reversed_words_container = [word[::-1] for word in wordsContainer]\n        # Reverse each word in wordsQuery for the same reason\n        reversed_words_query = [word[::-1] for word in wordsQuery]\n        \n        result = []\n        for query in reversed_words_query:\n            max_length = -1\n            best_index = -1\n            for i, reversed_word in enumerate(reversed_words_container):\n                # Check if the query is a suffix of the current word\n                if query.startswith(reversed_word):\n                    # Update the best index if the current word has a longer suffix match or is shorter\n                    if len(reversed_word) > max_length or (len(reversed_word) == max_length and len(wordsContainer[i]) < len(wordsContainer[best_index])):\n                        max_length = len(reversed_word)\n                        best_index = i\n            # Append the original index of the best matching word\n            result.append(index_map[wordsContainer[best_index]])\n        \n        return result"
        ]
    },
    {
        "question_id": "3371",
        "code_list": [
            "class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n        sum_of_digits = sum(int(digit) for digit in str(x))\n        if x % sum_of_digits == 0:\n            return sum_of_digits\n        else:\n            return -1"
        ]
    },
    {
        "question_id": "3374",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        i = 0\n        \n        while i < n:\n            j = i + 1\n            # Check for alternating subarray\n            while j < n and nums[j-1] != nums[j]:\n                j += 1\n            \n            # Number of alternating subarrays ending at j-1\n            length = j - i\n            count += length * (length + 1) // 2\n            i = j\n        return count"
        ]
    },
    {
        "question_id": "3344",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        n = len(points)\n        max_distance = float('-inf')\n        min_heap = []\n        \n        # Calculate initial maximum Manhattan distance\n        for i in range(n):\n            x1, y1 = points[i]\n            max_dist = 0\n            for j in range(n):\n                if i != j:\n                    x2, y2 = points[j]\n                    dist = abs(x1 - x2) + abs(y1 - y2)\n                    max_dist = max(max_dist, dist)\n            heapq.heappush(min_heap, (-max_dist, i))\n            max_distance = max(max_distance, max_dist)\n        \n        # Remove one point and check the new maximum distance\n        while min_heap:\n            max_dist, idx = heapq.heappop(min_heap)\n            max_dist = -max_dist\n            for j in range(n):\n                if j != idx:\n                    x1, y1 = points[idx]\n                    x2, y2 = points[j]\n                    dist = abs(x1 - x2) + abs(y1 - y2)\n                    new_max_dist = max(max_dist, dist)\n                    if new_max_dist < max_distance:\n                        max_distance = new_max_dist\n                        break\n        \n        return max_distance"
        ]
    },
    {
        "question_id": "3372",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        max_length = 1\n        current_length = 1\n        \n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            elif nums[i] < nums[i - 1]:\n                current_length = 2\n            else:\n                current_length = 1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3346",
        "code_list": [
            "from string import ascii_lowercase\n\nclass Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n        n = len(s)\n        result = list(s)\n        \n        for i in range(n):\n            char = s[i]\n            index = ascii_lowercase.index(char)\n            \n            # Calculate the minimum distance to change to 'a'\n            min_distance_to_a = (index + 26 - i) % 26\n            \n            # If we can change to 'a' within the limit, do so\n            if min_distance_to_a <= k:\n                result[i] = 'a'\n                k -= min_distance_to_a\n            else:\n                # Otherwise, calculate the new character\n                new_index = (index - k) % 26\n                result[i] = ascii_lowercase[new_index]\n                break  # No need to continue as we have used up k\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "3387",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        mid_index = n // 2\n        \n        if nums[mid_index] == k:\n            return 0\n        \n        operations = 0\n        if nums[mid_index] < k:\n            # Increase elements until the median is k\n            for i in range(mid_index, n):\n                if nums[i] > k:\n                    break\n                operations += k - nums[i]\n        else:\n            # Decrease elements until the median is k\n            for i in range(mid_index, -1, -1):\n                if nums[i] < k:\n                    break\n                operations += nums[i] - k\n        \n        return operations"
        ]
    },
    {
        "question_id": "3361",
        "code_list": [
            "class Solution:\n    def findLatestTime(self, s: str) -> str:\n        # Helper function to determine the maximum digit for a given position\n        def max_digit(pos):\n            if pos == 0:\n                return '1' if s[pos+1] != '0' or s[pos+2] != '?' else '0'\n            elif pos == 1:\n                return '9'\n            elif pos == 3:\n                return '5'\n            elif pos == 4:\n                return '9'\n            return '?'\n        \n        # Iterate from the last position to the first\n        for i in range(4, -1, -1):\n            if s[i] == '?':\n                s = s[:i] + max_digit(i) + s[i+1:]\n        \n        # Check if the time is valid, if not, replace the first '?' from the left with '0'\n        if int(s[:2]) > 11 or (int(s[:2]) == 11 and int(s[3:]) >= 60):\n            s = s.replace('?', '0', 1)\n        \n        return s"
        ]
    },
    {
        "question_id": "3373",
        "code_list": [
            "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nclass Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        primes = [i for i, num in enumerate(nums) if is_prime(num)]\n        if len(primes) == 1:\n            return 0\n        return max(primes) - min(primes)"
        ]
    },
    {
        "question_id": "3375",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findKthSmallest(self, coins: List[int], k: int) -> int:\n        coins.sort()\n        n = len(coins)\n        left, right = 0, min(coins) * k\n        \n        while left < right:\n            mid = (left + right) // 2\n            count = sum(mid // coin for coin in coins)\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
        ]
    },
    {
        "question_id": "3364",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:\n        n, m = len(nums), len(andValues)\n        if m > n:\n            return -1\n        \n        # Check if any andValue can be formed by ANDing any subset of nums\n        for val in andValues:\n            if bin(val).count('1') > 1:\n                if not any(bin(num & val).count('1') == 1 for num in nums):\n                    return -1\n        \n        # Try to find the minimum sum by dividing nums into subarrays\n        min_sum = float('inf')\n        for mask in range(1 << n):\n            subarray_and = 0\n            current_sum = 0\n            for i in range(n):\n                if mask & (1 << i):\n                    current_sum += nums[i]\n                    subarray_and |= nums[i]\n                else:\n                    if subarray_and == andValues[subarray_and.bit_count() - 1]:\n                        min_sum = min(min_sum, current_sum)\n                        current_sum -= subarray_and\n                        subarray_and = 0\n            if subarray_and == andValues[subarray_and.bit_count() - 1]:\n                min_sum = min(min_sum, current_sum)\n        \n        return min_sum if min_sum != float('inf') else -1"
        ]
    },
    {
        "question_id": "3367",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfEncryptedInt(self, nums: List[int]) -> int:\n        def encrypt(x: int) -> int:\n            max_digit = max(str(x))\n            return int(max_digit * len(str(x)))\n        \n        return sum(encrypt(num) for num in nums)"
        ]
    },
    {
        "question_id": "3306",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        marked = set()\n        unmarked_sum = sum(nums)\n        min_heap = [(nums[i], i) for i in range(len(nums))]\n        heapq.heapify(min_heap)\n        \n        result = []\n        for index, k in queries:\n            if index not in marked:\n                marked.add(index)\n                unmarked_sum -= nums[index]\n            while k > 0 and min_heap:\n                value, i = heapq.heappop(min_heap)\n                if i not in marked:\n                    marked.add(i)\n                    unmarked_sum -= value\n                    k -= 1\n            result.append(unmarked_sum)\n        \n        return result"
        ]
    },
    {
        "question_id": "3354",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimizeStringValue(self, s: str) -> str:\n        # Count the frequency of each character in the string excluding '?'\n        char_count = Counter(c for c in s if c != '?')\n        # List to store the characters to be used for replacing '?'\n        replace_chars = []\n        # Result string to build the final answer\n        result = list(s)\n        \n        # For each '?', find the character with the minimum frequency to replace\n        for _ in range(s.count('?')):\n            min_char = 'a'\n            min_count = float('inf')\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if char_count[c] < min_count:\n                    min_char = c\n                    min_count = char_count[c]\n            # Append the chosen character to the result and increment its count\n            replace_chars.append(min_char)\n            char_count[min_char] += 1\n        \n        # Sort the characters to get the lexicographically smallest string\n        replace_chars.sort()\n        # Replace '?' with the sorted characters\n        for i, char in enumerate(replace_chars):\n            result[s.index('?', i)] = char\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "3345",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def sumOfPower(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(index, target):\n            if target == 0:\n                return 1\n            if index == len(nums) or target < 0:\n                return 0\n            \n            # Option 1: Include nums[index] in the subsequence\n            include = dp(index + 1, target - nums[index])\n            # Option 2: Exclude nums[index] from the subsequence\n            exclude = dp(index + 1, target)\n            \n            return (include + exclude) % MOD\n        \n        total_power = 0\n        for i in range(len(nums)):\n            total_power += dp(i + 1, k - nums[i])\n        \n        return total_power % MOD"
        ]
    },
    {
        "question_id": "3381",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        min_length = float('inf')\n        \n        for start in range(n):\n            current_or = 0\n            for end in range(start, n):\n                current_or |= nums[end]\n                if current_or >= k:\n                    min_length = min(min_length, end - start + 1)\n                    break\n        \n        return min_length if min_length != float('inf') else -1"
        ]
    },
    {
        "question_id": "3355",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumLevels(self, possible: List[int]) -> int:\n        n = len(possible)\n        prefix_sum = [0] * n\n        suffix_sum = [0] * n\n        \n        # Calculate prefix sum\n        for i in range(n):\n            prefix_sum[i] = prefix_sum[i-1] + (1 if possible[i] else -1)\n        \n        # Calculate suffix sum\n        for i in range(n-1, -1, -1):\n            suffix_sum[i] = suffix_sum[i+1] + (1 if possible[i] else -1)\n        \n        # Find the minimum number of levels Alice should play\n        for i in range(1, n):\n            if prefix_sum[i-1] > suffix_sum[i]:\n                return i\n        return -1"
        ]
    },
    {
        "question_id": "3316",
        "code_list": [
            "from typing import List\nimport itertools\nimport math\n\nclass Solution:\n    def sumOfPowers(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        \n        def min_abs_diff(subseq):\n            return min(abs(a - b) for a, b in itertools.combinations(subseq, 2))\n        \n        total_sum = 0\n        for subseq in itertools.combinations(nums, k):\n            total_sum += min_abs_diff(subseq)\n        \n        return total_sum % MOD"
        ]
    },
    {
        "question_id": "3379",
        "code_list": [
            "class Solution:\n    def scoreOfString(self, s: str) -> int:\n        return sum(abs(ord(s[i]) - ord(s[i+1])) for i in range(len(s) - 1))"
        ]
    },
    {
        "question_id": "3382",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int]) -> int:\n        max_val = max(nums)\n        count_max = sum(1 for num in nums if num == max_val)\n        result = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == max_val:\n                left = 1\n                right = 1\n                \n                # Count subarrays starting from current index i\n                for j in range(i + 1, len(nums)):\n                    if nums[j] == max_val:\n                        right += 1\n                    else:\n                        break\n                \n                for k in range(i - 1, -1, -1):\n                    if nums[k] == max_val:\n                        left += 1\n                    else:\n                        break\n                \n                result += left * right\n        \n        return result"
        ]
    },
    {
        "question_id": "3408",
        "code_list": [
            "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        seen_upper = set()\n        seen_lower = set()\n        special_count = 0\n        \n        for char in word:\n            if char.isupper():\n                if char.lower() in seen_lower:\n                    special_count += 1\n                seen_upper.add(char)\n            elif char.islower():\n                if char.upper() in seen_upper:\n                    special_count += 1\n                seen_lower.add(char)\n        \n        return special_count"
        ]
    },
    {
        "question_id": "3397",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        for i in range(len(nums1)):\n            x = nums2[i] - nums1[i]\n            if all(nums1[j] + x == nums2[j] for j in range(len(nums1))):\n                return x\n        return None"
        ]
    },
    {
        "question_id": "3394",
        "code_list": [
            "class Solution:\n    def minEnd(self, n: int, x: int) -> int:\n        # Initialize the result with x\n        result = x\n        \n        # Iterate over each bit position from 30 down to 0\n        for bit in range(30, -1, -1):\n            # Check if setting the current bit to 1 in result makes the bitwise AND of all numbers up to result equal to x\n            if (result | (1 << bit)) & ((1 << (bit + 1)) - 1) == x:\n                result |= (1 << bit)\n        \n        # Ensure the array can be constructed with n-1 increments\n        while n > 1 and result & (result - 1) != 0:\n            result += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3362",
        "code_list": [
            "from typing import List\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def medianOfUniquenessArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + (nums[i] != nums[i - 1] if i else 1)\n        \n        def count_distinct(k: int) -> int:\n            return bisect_right(prefix_sum, k) - bisect_left(prefix_sum, k)\n        \n        left, right = 1, n\n        while left < right:\n            mid = (left + right) // 2\n            if count_distinct(mid) < mid + 1:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
        ]
    },
    {
        "question_id": "3396",
        "code_list": [
            "class Solution:\n    def isValid(self, word: str) -> bool:\n        vowels = set('aeiouAEIOU')\n        consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n        digit_count = sum(c.isdigit() for c in word)\n        letter_count = sum(c.isalpha() for c in word)\n        has_vowel = any(c in vowels for c in word)\n        has_consonant = any(c in consonants for c in word)\n        \n        return len(word) >= 3 and digit_count > 0 and letter_count > 0 and has_vowel and has_consonant"
        ]
    },
    {
        "question_id": "3384",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n        n = len(word)\n        prefix_counts = [Counter() for _ in range(k)]\n        \n        # Count character frequencies in each segment of length k\n        for i in range(n):\n            prefix_counts[i % k][word[i]] += 1\n        \n        # Check if the first k characters can form the periodic pattern\n        if all(prefix_counts[0][char] == prefix_counts[i][char] for i in range(1, k)):\n            return 0\n        \n        # Calculate the minimum operations needed\n        operations = 0\n        for i in range(k):\n            char_count = prefix_counts[i]\n            most_common_char = char_count.most_common(1)[0][0]\n            operations += sum(char_count[char] for char in char_count if char != most_common_char)\n        \n        return operations"
        ]
    },
    {
        "question_id": "3395",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minAnagramLength(self, s: str) -> int:\n        # Count the frequency of each character in the string s\n        char_count = Counter(s)\n        # The minimum length of t would be the sum of the counts of characters that appear only once\n        return sum(count for count in char_count.values() if count == 1)"
        ]
    },
    {
        "question_id": "3402",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Find the median of the array as the target value to equalize\n        nums.sort()\n        target = nums[len(nums) // 2]\n        \n        # Calculate the cost to make all elements equal to the target\n        cost = 0\n        for num in nums:\n            if num < target:\n                cost += (target - num) * cost1\n            elif num > target:\n                diff = num - target\n                # Decide whether to use cost1 or cost2 based on the optimal choice\n                cost += min(diff * cost1, (diff // 2 + (diff % 2)) * cost2)\n        \n        return cost % MOD"
        ]
    },
    {
        "question_id": "3398",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canMakeSquare(self, grid: List[List[str]]) -> bool:\n        # Check each 2x2 sub-square in the grid\n        for i in range(2):\n            for j in range(2):\n                # Count the number of 'B's and 'W's in the current 2x2 sub-square\n                count_B = sum(grid[x][y] == 'B' for x in range(i, i+2) for y in range(j, j+2))\n                count_W = sum(grid[x][y] == 'W' for x in range(i, i+2) for y in range(j, j+2))\n                \n                # If there is at most one cell that needs to be changed to make the sub-square uniform\n                if abs(count_B - count_W) <= 1:\n                    return True\n        \n        return False"
        ]
    },
    {
        "question_id": "3388",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        rows, cols = defaultdict(int), defaultdict(int)\n        count = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    # Count the number of 1s in the same row and column\n                    count += rows[i] * cols[j]\n                    # Update the counts for the current row and column\n                    rows[i] += 1\n                    cols[j] += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3406",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        MOD = 10**9 + 7\n        \n        def count_stable(z, o, l):\n            if z == 0 and o == 0:\n                return 1\n            if z < 0 or o < 0:\n                return 0\n            if l == 0:\n                return 0\n            \n            # Case 1: Add a 0\n            add_zero = count_stable(z - 1, o, l - 1)\n            \n            # Case 2: Add a 1\n            add_one = count_stable(z, o - 1, l - 1)\n            \n            # Case 3: Add a subarray of length > limit\n            subarrays = 0\n            for i in range(1, min(limit + 1, z + 1)):\n                subarrays += count_stable(z - i, o, limit - i)\n                subarrays %= MOD\n            for i in range(1, min(limit + 1, o + 1)):\n                subarrays += count_stable(z, o - i, limit - i)\n                subarrays %= MOD\n            \n            return (add_zero + add_one + subarrays) % MOD\n        \n        return count_stable(zero, one, limit)"
        ]
    },
    {
        "question_id": "3412",
        "code_list": [
            "class Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        s_indices = {char: idx for idx, char in enumerate(s)}\n        t_indices = {char: idx for idx, char in enumerate(t)}\n        \n        permutation_difference = sum(abs(s_indices[char] - t_indices[char]) for char in s)\n        return permutation_difference"
        ]
    },
    {
        "question_id": "3383",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:\n        n = len(energy)\n        dp = [0] * n\n        dp[0] = energy[0]\n        max_energy = dp[0]\n        \n        for i in range(1, n):\n            dp[i] = energy[i]\n            if (i + k) < n:\n                dp[i] += dp[i - k]\n            max_energy = max(max_energy, dp[i])\n        \n        return max_energy"
        ]
    },
    {
        "question_id": "3429",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:\n        for i in range(len(nums) - 1):\n            if (nums[i] % 2 == nums[i + 1] % 2):\n                return False\n        return True"
        ]
    },
    {
        "question_id": "3416",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:\n        total_diff = 0\n        num_length = len(str(nums[0]))  # All numbers have the same length\n        \n        for i in range(num_length):\n            digit_sum = 0\n            for num in nums:\n                digit_sum += (num // (10 ** i)) % 10\n            total_diff += digit_sum * (len(nums) - digit_sum)\n        \n        return total_diff"
        ]
    },
    {
        "question_id": "3414",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def waysToReachStair(self, k: int) -> int:\n        @lru_cache(None)\n        def dp(stair):\n            if stair == 0:\n                return 1\n            if stair < 0:\n                return 0\n            ways = 0\n            # Go down to stair i - 1\n            ways += dp(stair - 1)\n            # Go up to stair i + 2^jump\n            for jump in range(32):  # 2^31 > 10^9, so we only need to check up to 32\n                ways += dp(stair + (1 << jump))\n            return ways\n        \n        return dp(k)"
        ]
    },
    {
        "question_id": "3446",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if nums1[i] % (nums2[j] * k) == 0:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3451",
        "code_list": [
            "class Solution:\n    def compressedString(self, word: str) -> str:\n        comp = \"\"\n        i = 0\n        while i < len(word):\n            char = word[i]\n            count = 0\n            while i < len(word) and word[i] == char:\n                i += 1\n                count += 1\n            comp += str(count) + char\n        return comp"
        ]
    },
    {
        "question_id": "3423",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        \n        def max_sum_subsequence(arr):\n            if not arr:\n                return 0\n            n = len(arr)\n            incl = 0  # Max sum including the previous element\n            excl = 0  # Max sum excluding the previous element\n            \n            for num in arr:\n                new_excl = max(incl, excl)  # Maximum sum excluding the current element\n                incl = excl + num  # Maximum sum including the current element\n                excl = new_excl  # Update excl to the new value\n            \n            return max(incl, excl) % MOD\n        \n        total_sum = 0\n        for pos, val in queries:\n            original_val = nums[pos]\n            nums[pos] = val\n            total_sum += max_sum_subsequence(nums)\n            nums[pos] = original_val  # Restore the original value\n        \n        return total_sum % MOD"
        ]
    },
    {
        "question_id": "3403",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumSubstringsInPartition(self, s: str) -> int:\n        count_map = Counter()\n        partitions = 0\n        \n        for char in s:\n            count_map[char] += 1\n            \n            # Check if current partition is balanced\n            if all(count_map[letter] > 0 for letter in count_map):\n                partitions += 1\n                count_map.clear()\n                \n        return partitions"
        ]
    },
    {
        "question_id": "3411",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:\n        @lru_cache(None)\n        def powerful_array(x):\n            if x == 0:\n                return []\n            elif x == 1:\n                return [1]\n            else:\n                for i in range(31, -1, -1):\n                    if (1 << i) <= x:\n                        return [1 << i] + powerful_array(x - (1 << i))\n        \n        @lru_cache(None)\n        def get_big_nums(n):\n            if n == 0:\n                return []\n            else:\n                return get_big_nums(n // 2) + powerful_array(n % 2 ** 31)\n        \n        big_nums = get_big_nums(10**15)\n        \n        def product_modulo(start, end, mod):\n            product = 1\n            for i in range(start, min(end + 1, len(big_nums))):\n                product = (product * big_nums[i]) % mod\n            return product\n        \n        return [product_modulo(q[0], q[1], q[2]) for q in queries]"
        ]
    },
    {
        "question_id": "3428",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def duplicateNumbersXOR(self, nums: List[int]) -> int:\n        xor_result = 0\n        seen_once = set()\n        seen_twice = set()\n        \n        for num in nums:\n            if num in seen_once:\n                seen_once.remove(num)\n                seen_twice.add(num)\n            else:\n                seen_once.add(num)\n        \n        for num in seen_twice:\n            xor_result ^= num\n        \n        return xor_result"
        ]
    },
    {
        "question_id": "3420",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:\n        # Create a dictionary to store the indices of each occurrence of x\n        occurrence_indices = {}\n        for i, num in enumerate(nums):\n            if num == x:\n                if x not in occurrence_indices:\n                    occurrence_indices[x] = []\n                occurrence_indices[x].append(i)\n        \n        # Prepare the result list\n        result = []\n        for query in queries:\n            if x in occurrence_indices and len(occurrence_indices[x]) >= query:\n                result.append(occurrence_indices[x][query - 1])\n            else:\n                result.append(-1)\n        \n        return result"
        ]
    },
    {
        "question_id": "abc356_a",
        "code_list": [
            "def reverse_subsequence(N, L, R):\n    # Initialize the sequence A\n    A = list(range(1, N + 1))\n    \n    # Reverse the subsequence from index L to R\n    A[L-1:R] = reversed(A[L-1:R])\n    \n    # Return the modified sequence\n    return A\n\ndef main():\n    # Read input from stdin\n    N, L, R = map(int, input().split())\n    \n    # Get the modified sequence\n    result = reverse_subsequence(N, L, R)\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_d",
        "code_list": [
            "def popcount(x):\n    return bin(x).count('1')\n\ndef main():\n    N, M = map(int, input().split())\n    MOD = 998244353\n    \n    # Precompute the prefix sums of popcount(M & k) for k from 0 to 2^60 - 1\n    prefix_sum = [0] * 61\n    for k in range(61):\n        for i in range(1 << k):\n            prefix_sum[k] += popcount((i << (60 - k)) & M)\n            prefix_sum[k] %= MOD\n    \n    # Compute the final result using the prefix sums\n    result = 0\n    for k in range(61):\n        if N >> k & 1:\n            result += prefix_sum[k]\n            result %= MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Dictionary to store the count of each unique value in A\n    value_count = defaultdict(int)\n    for num in A:\n        value_count[num] += 1\n    \n    # Calculate the result\n    result = 0\n    for i in range(1, max(value_count.keys()) + 1):\n        for j in range(i, max(value_count.keys()) + 1):\n            if j % i == 0:\n                result += (value_count[i] * value_count[j])\n            else:\n                result += (value_count[i] * (value_count[j] - 1))\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_c",
        "code_list": [
            "from itertools import product\n\ndef main():\n    N, M, K = map(int, input().split())\n    tests = []\n    for _ in range(M):\n        C, *keys, result = input().split()\n        tests.append((int(C), set(map(int, keys)), result))\n    \n    valid_combinations = 0\n    \n    # Iterate over all possible combinations of keys being real or dummies\n    for combination in product([True, False], repeat=N):\n        real_keys = {i + 1 for i, is_real in enumerate(combination) if is_real}\n        passes_tests = True\n        \n        for C, keys_set, result in tests:\n            if len(real_keys & keys_set) >= K:\n                if result == 'x':\n                    passes_tests = False\n                    break\n            else:\n                if result == 'o':\n                    passes_tests = False\n                    break\n        \n        if passes_tests:\n            valid_combinations += 1\n    \n    print(valid_combinations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    X = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Check if goals are met\n    for i in range(M):\n        total_units = sum(X[j][i] for j in range(N))\n        if total_units < A[i]:\n            print(\"No\")\n            return\n    \n    # If all goals are met\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc357_c",
        "code_list": [
            "def print_carpet(N):\n    def generate_carpet(size):\n        if size == 1:\n            return ['#']\n        smaller_carpet = generate_carpet(size // 3)\n        result = []\n        for row in smaller_carpet:\n            result.append('#' * size)\n            result.append('#' + '.' * (size - 2) + '#')\n        result.append('#' * size)\n        return result\n    \n    def expand_carpet(carpet, factor):\n        expanded = []\n        for row in carpet:\n            expanded.append(row * factor)\n        return expanded\n    \n    carpet = generate_carpet(3 ** N)\n    final_carpet = []\n    for row in carpet:\n        final_carpet.extend(expand_carpet(row, 3 ** N))\n    \n    for row in final_carpet:\n        print(row)\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print_carpet(N)"
        ]
    },
    {
        "question_id": "abc357_a",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    H = list(map(int, input().split()))\n    \n    # Initialize variables\n    total_disinfected = 0\n    \n    # Iterate over each alien\n    for h in H:\n        # Check if there's enough disinfectant to disinfect all hands\n        if M >= h:\n            M -= h\n            total_disinfected += 1\n        else:\n            break\n    \n    # Print the result\n    print(total_disinfected)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc357_d",
        "code_list": [
            "def modular_concatenation(N):\n    MOD = 998244353\n    \n    # Function to compute (base^exp) % mod using iterative method\n    def power(base, exp, mod):\n        result = 1\n        base = base % mod\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            exp = exp >> 1\n            base = (base * base) % mod\n        return result\n    \n    # Calculate the sum of digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Calculate the number of digits in N\n    num_digits = len(str(N))\n    \n    # Calculate the result using properties of modular arithmetic\n    result = (power(10, num_digits * N - num_digits, MOD) * digit_sum) % MOD\n    \n    return result\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(modular_concatenation(N))"
        ]
    },
    {
        "question_id": "abc357_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    upper_count = sum(1 for char in S if char.isupper())\n    lower_count = len(S) - upper_count\n    \n    if upper_count > lower_count:\n        print(S.lower())\n    else:\n        print(S.upper())\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc357_e",
        "code_list": [
            "def count_reachable_pairs(N, a):\n    # Initialize the count of reachable pairs\n    count = 0\n    \n    # Initialize the parent array to store the parent of each node\n    parent = [0] * (N + 1)\n    \n    # Initialize the size array to store the size of each component\n    size = [1] * (N + 1)\n    \n    # Build the parent array\n    for i in range(1, N + 1):\n        parent[a[i - 1]] = i\n    \n    # Traverse the graph using DFS to find all components\n    visited = [False] * (N + 1)\n    def dfs(node):\n        nonlocal count\n        visited[node] = True\n        for next_node in range(1, N + 1):\n            if parent[next_node] == node and not visited[next_node]:\n                count += size[next_node]\n                size[node] += size[next_node]\n                dfs(next_node)\n    \n    # Count the number of reachable pairs\n    for i in range(1, N + 1):\n        if not visited[i]:\n            dfs(i)\n    \n    return count\n\ndef main():\n    N = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    print(count_reachable_pairs(N, a))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc358_e",
        "code_list": [
            "from math import comb\n\ndef count_valid_strings(K, C):\n    MOD = 998244353\n    dp = [1] + [0] * K\n    for i in range(1, 27):\n        new_dp = [0] * (K + 1)\n        for j in range(K + 1):\n            if dp[j] > 0:\n                for k in range(C[i - 1] + 1):\n                    if j + k <= K:\n                        new_dp[j + k] += dp[j]\n                        new_dp[j + k] %= MOD\n        dp = new_dp\n    return sum(dp) % MOD\n\nif __name__ == \"__main__\":\n    K = int(input())\n    C = list(map(int, input().split()))\n    print(count_valid_strings(K, C))"
        ]
    },
    {
        "question_id": "abc358_c",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    stands = [input() for _ in range(N)]\n    \n    # Find the minimum number of stands needed\n    min_stands = float('inf')\n    for i in range(1, 1 << N):\n        visited = [False] * N\n        flavors = ['x'] * M\n        count = 0\n        \n        for j in range(N):\n            if i & (1 << j):\n                visited[j] = True\n                count += 1\n                for k in range(M):\n                    if stands[j][k] == 'o':\n                        flavors[k] = 'o'\n        \n        if all(f == 'o' for f in flavors):\n            min_stands = min(min_stands, count)\n    \n    print(min_stands)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc358_b",
        "code_list": [
            "def main():\n    # Read input\n    N, A = map(int, input().split())\n    T = list(map(int, input().split()))\n\n    # Initialize variables\n    current_time = 0\n    queue = []\n\n    # Process each person's arrival\n    for t in T:\n        # Update current time to the arrival time of the current person\n        current_time = max(current_time, t)\n\n        # Start the purchasing process for the current person\n        queue.append(current_time)\n        current_time += A\n\n        # Print the finishing time of the current person\n        print(current_time - A)\n\n        # Remove the person who has finished purchasing\n        queue.pop(0)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc358_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, m = data[0], data[1]\n    prices = data[2:2 * n + 2:2]\n    candies = data[3:2 * n + 2:2]\n\n    # Sort the boxes based on their price-to-candy ratio in descending order\n    boxes = sorted([(prices[i], candies[i]) for i in range(n)], key=lambda x: x[0] / x[1], reverse=True)\n\n    # Initialize variables\n    total_candies_needed = sum(candies[i] for i in range(m))\n    min_price = float('inf')\n    current_candies = 0\n    selected_boxes = []\n\n    # Try to select the best M boxes\n    for price, candies_in_box in boxes:\n        if len(selected_boxes) == m:\n            break\n        if current_candies + candies_in_box >= total_candies_needed:\n            remaining_candies_needed = total_candies_needed - current_candies\n            for p, c in boxes:\n                if c <= remaining_candies_needed:\n                    selected_boxes.append(p)\n                    remaining_candies_needed -= c\n                else:\n                    selected_boxes.append(p)\n                    break\n            break\n        selected_boxes.append(price)\n        current_candies += candies_in_box\n\n    if len(selected_boxes) < m:\n        print(-1)\n    else:\n        print(sum(selected_boxes))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc358_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    S, T = input().split()\n    if S == \"AtCoder\" and T == \"Land\":\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        ]
    },
    {
        "question_id": "abc359_c",
        "code_list": [
            "def main():\n    # Read input\n    S_x, S_y = map(int, input().split())\n    T_x, T_y = map(int, input().split())\n\n    # Calculate the difference in coordinates\n    dx = abs(S_x - T_x)\n    dy = abs(S_y - T_y)\n\n    # Calculate the toll based on the rules\n    if (S_x + S_y) % 2 == (T_x + T_y) % 2:\n        toll = max(dx, dy)\n    else:\n        toll = dx + dy - min(dx, dy)\n\n    # Output the result\n    print(toll)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc359_b",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Count occurrences of each color\n    color_count = Counter(A)\n    \n    # Check for each color if there is exactly one person between the two people wearing that color\n    count = 0\n    for color in range(1, N + 1):\n        if color_count[color] != 2:\n            continue\n        pos1 = [i for i, x in enumerate(A) if x == color][0]\n        pos2 = [i for i, x in enumerate(A) if x == color][1]\n        if abs(pos1 - pos2) == 2:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc359_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    h = list(map(int, data[1:n+1]))\n    a = [0] * (n + 1)\n    result = []\n    \n    for i in range(n):\n        while a[i] <= a[i + 1] or a[i] <= h[i]:\n            a[0] += 1\n            for j in range(1, n + 1):\n                if a[j - 1] > a[j] and a[j - 1] > h[j]:\n                    a[j - 1] -= 1\n                    a[j] += 1\n    \n        result.append(a[0])\n    \n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc359_a",
        "code_list": [
            "def main():\n    N = int(input())\n    takahashi_count = 0\n    for _ in range(N):\n        S_i = input()\n        if S_i == \"Takahashi\":\n            takahashi_count += 1\n    print(takahashi_count)"
        ]
    },
    {
        "question_id": "abc359_d",
        "code_list": [
            "from itertools import product\n\ndef is_good_string(s, k):\n    n = len(s)\n    for i in range(n - k + 1):\n        sub = s[i:i+k]\n        if sub == sub[::-1]:\n            return False\n    return True\n\ndef count_good_strings(n, k, s):\n    mod = 998244353\n    q = s.count('?')\n    if q == 0:\n        return int(is_good_string(s, k))\n    \n    # Generate all possible combinations of A and B for the '?' characters\n    patterns = [''.join(pattern) for pattern in product('AB', repeat=q)]\n    \n    count = 0\n    for pattern in patterns:\n        new_s = s.replace('?', pattern[0], 1)\n        for i in range(1, q):\n            new_s = new_s.replace('?', pattern[i], 1)\n        if is_good_string(new_s, k):\n            count += 1\n    \n    return count % mod\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    s = input().strip()\n    print(count_good_strings(n, k, s))"
        ]
    },
    {
        "question_id": "abc360_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    W = list(map(int, data[N+1:2*N+1]))\n    \n    box_items = [[] for _ in range(N+1)]\n    for i in range(N):\n        box_items[A[i]].append(W[i])\n    \n    min_heap = []\n    for items in box_items[1:]:\n        if len(items) > 1:\n            items.sort()\n            for i in range(len(items)-1):\n                heapq.heappush(min_heap, items[i] - items[i+1])\n    \n    total_cost = 0\n    while len(min_heap) >= 2:\n        cost = heapq.heappop(min_heap) + heapq.heappop(min_heap)\n        total_cost += cost\n        heapq.heappush(min_heap, cost)\n    \n    print(total_cost)\n\nimport heapq"
        ]
    },
    {
        "question_id": "abc360_b",
        "code_list": [
            "def main():\n    S, T = input().split()\n    n, m = len(S), len(T)\n    \n    for w in range(1, n):\n        for c in range(1, w + 1):\n            if c > n - w:\n                break\n            substrings = [S[i:i+w] for i in range(0, n, w)]\n            result = ''.join(substrings[i][c-1] if len(substrings[i]) >= c else '' for i in range(len(substrings)))\n            if result == T:\n                print('Yes')\n                return\n    print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc360_e",
        "code_list": [
            "def mod_pow(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef main():\n    N, K = map(int, input().split())\n    base = (N + 1) // 2\n    result = mod_pow(base, K, 998244353)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc360_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    rice_index = S.index('R')\n    miso_soup_index = S.index('M')\n    \n    if rice_index < miso_soup_index:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc360_d",
        "code_list": [
            "def count_passing_pairs(N, T, S, X):\n    # Initialize lists to store positions and times of ants moving left and right\n    left_ants = []\n    right_ants = []\n    \n    # Populate the lists based on the direction of movement\n    for i in range(N):\n        if S[i] == '0':  # Moving left\n            left_ants.append((X[i], i))\n        else:  # Moving right\n            right_ants.append((X[i], i))\n    \n    # Sort the ants based on their starting positions\n    left_ants.sort()\n    right_ants.sort()\n    \n    # Initialize counters\n    left_index = 0\n    right_index = 0\n    passing_pairs = 0\n    \n    # Iterate through both lists to find passing pairs\n    while left_index < len(left_ants) and right_index < len(right_ants):\n        left_x, left_i = left_ants[left_index]\n        right_x, right_i = right_ants[right_index]\n        \n        # Calculate the time when they would meet\n        meeting_time = (right_x - left_x) / 2\n        \n        if meeting_time <= T + 0.1:\n            passing_pairs += 1\n            # Move the index of the left ant forward if it's slower or equal\n            if left_x >= right_x or (left_x == right_x and left_i > right_i):\n                left_index += 1\n            else:\n                right_index += 1\n        else:\n            # Move the faster ant forward\n            if left_x < right_x:\n                left_index += 1\n            else:\n                right_index += 1\n    \n    return passing_pairs\n\nif __name__ == \"__main__\":\n    N, T = map(int, input().split())\n    S = input()\n    X = list(map(int, input().split()))\n    print(count_passing_pairs(N, T, S, X))"
        ]
    },
    {
        "question_id": "abc361_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    N = int(input())\n    S = input()\n    T = input()\n\n    # Initialize the initial and target states\n    initial_state = [0] * (N + 2)\n    target_state = [0] * (N + 2)\n\n    # Set up the initial and target states with stones\n    for i in range(N):\n        if S[i] == 'B':\n            initial_state[i + 1] = 1\n        else:\n            initial_state[i + 1] = -1\n        if T[i] == 'B':\n            target_state[i + 1] = 1\n        else:\n            target_state[i + 1] = -1\n\n    # Use BFS to find the minimum number of moves\n    queue = deque([(initial_state, 0)])\n    visited = set()\n    visited.add(tuple(initial_state))\n\n    while queue:\n        current_state, steps = queue.popleft()\n\n        if current_state == target_state:\n            print(steps)\n            return\n\n        for i in range(1, N + 1):\n            if current_state[i] != 0 and current_state[i + 1] != 0:\n                new_state = current_state[:]\n                new_state[i], new_state[i + 1] = 0, 0\n                new_state[new_state.index(1)] = current_state[i]\n                new_state[new_state.index(-1)] = current_state[i + 1]\n\n                if tuple(new_state) not in visited:\n                    visited.add(tuple(new_state))\n                    queue.append((new_state, steps + 1))\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc361_b",
        "code_list": [
            "def check_intersection():\n    # Read input\n    a, b, c, d, e, f = map(int, input().split())\n    g, h, i, j, k, l = map(int, input().split())\n\n    # Check for intersection along each axis\n    x_overlap = max(0, min(d, j) - max(a, g))\n    y_overlap = max(0, min(e, k) - max(b, h))\n    z_overlap = max(0, min(f, l) - max(c, i))\n\n    # If there is overlap along all three axes, the cuboids intersect with positive volume\n    if x_overlap > 0 and y_overlap > 0 and z_overlap > 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    check_intersection()"
        ]
    },
    {
        "question_id": "abc361_a",
        "code_list": [
            "def main():\n    # Read input\n    N, K, X = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Insert X after the K-th element\n    B = A[:K] + [X] + A[K:]\n\n    # Print the result\n    print(' '.join(map(str, B)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc361_f",
        "code_list": [
            "import math\n\ndef main():\n    N = int(input())\n    result = 0\n    \n    # Iterate over possible bases a\n    for a in range(2, int(N ** (1/2)) + 1):\n        b = 2\n        while True:\n            power = a ** b\n            if power > N:\n                break\n            result += 1\n            b += 1\n    \n    # Check powers of numbers greater than sqrt(N)\n    for b in range(2, 65):  # 2^64 is much larger than 10^18\n        a = int(N ** (1/b))\n        if a < 2:\n            break\n        result += a - 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc361_c",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Sort the array\n    A.sort()\n\n    # Initialize variables\n    min_diff = float('inf')\n    prefix_sum = [0] * (N + 1)\n\n    # Calculate prefix sums\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n\n    # Iterate through possible removal points\n    for i in range(K, N):\n        max_val = A[i]\n        min_val = A[i - K]\n        current_diff = max_val - min_val\n\n        # Calculate the sum of the removed elements\n        removed_sum = prefix_sum[i] - prefix_sum[i - K]\n\n        # Calculate the potential minimum difference\n        potential_diff = (max_val - removed_sum / K) - min_val\n\n        # Update the minimum difference\n        min_diff = min(min_diff, current_diff, potential_diff)\n\n    print(int(min_diff))"
        ]
    },
    {
        "question_id": "abc361_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    edges = []\n    for i in range(1, len(data), 3):\n        u = int(data[i]) - 1\n        v = int(data[i + 1]) - 1\n        w = int(data[i + 2])\n        edges.append((u, v, w))\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for u, v, w in edges:\n        tree[u].append((v, w))\n        tree[v].append((u, w))\n    \n    # DFS to find the diameter and centroid\n    def dfs(node, parent, depth):\n        nonlocal max_depth, farthest_node, centroid, centroid_depth\n        if depth > max_depth:\n            max_depth = depth\n            farthest_node = node\n        for neighbor, _ in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, depth + 1)\n    \n    max_depth = 0\n    farthest_node = 0\n    dfs(0, -1, 0)\n    max_depth = 0\n    dfs(farthest_node, -1, 0)\n    \n    centroid = farthest_node\n    \n    def find_centroid(node, parent, size):\n        nonlocal centroid\n        subtree_size = 1\n        for neighbor, _ in tree[node]:\n            if neighbor != parent and neighbor != centroid:\n                subtree_size += find_centroid(neighbor, node, size)\n        if subtree_size * 2 >= size:\n            centroid = node\n        return subtree_size\n    \n    find_centroid(farthest_node, -1, n)\n    \n    # Calculate the minimum travel distance\n    def calculate_distance(node, parent, depth):\n        nonlocal min_distance\n        if depth > min_distance:\n            min_distance = depth\n        for neighbor, weight in tree[node]:\n            if neighbor != parent:\n                calculate_distance(neighbor, node, depth + weight)\n    \n    min_distance = 0\n    calculate_distance(centroid, -1, 0)\n    \n    print(min_distance)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_d",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(N, A, edges):\n    # Initialize distances with infinity\n    dist = [float('inf')] * (N + 1)\n    dist[1] = A[1]\n    \n    # Priority queue to store (distance, node)\n    pq = [(A[1], 1)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        \n        if d > dist[u]:\n            continue\n        \n        for v, w in edges[u]:\n            new_dist = d + w + A[v]\n            \n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n    \n    return dist[2:]\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    edges = defaultdict(list)\n    for _ in range(M):\n        U, V, B = map(int, input().split())\n        edges[U].append((V, B))\n        edges[V].append((U, B))\n    \n    result = dijkstra(N, A, edges)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    mod = 998244353\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Initialize prefix sums and suffix sums\n    prefix_sum = [defaultdict(int) for _ in range(n)]\n    suffix_sum = [defaultdict(int) for _ in range(n)]\n    \n    # Calculate prefix sums\n    for i in range(n):\n        prefix_sum[i][a[i]] += 1\n    \n    # Calculate suffix sums\n    for i in range(n-1, -1, -1):\n        suffix_sum[i][a[i]] += 1\n        if i < n-1:\n            for key in suffix_sum[i+1]:\n                suffix_sum[i][key] += suffix_sum[i+1][key]\n    \n    ans = []\n    for k in range(1, n+1):\n        count = 0\n        for i in range(n-k+1):\n            for j in range(i+1, n-k+2):\n                diff = a[j-1] - a[i]\n                if i > 0:\n                    count += prefix_sum[i-1][a[i] + diff] * suffix_sum[i+k][a[i] + diff]\n                else:\n                    count += suffix_sum[i+k][a[i] + diff]\n        ans.append(count % mod)\n    \n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_int():\n        return int(input())\n    \n    def read_ints():\n        return list(map(int, input().split()))\n    \n    def solve(N, intervals):\n        total_sum = sum(R - L + 1 for L, R in intervals)\n        if total_sum < abs(sum(R - L + 1 for L, R in intervals if L > 0)):\n            print(\"No\")\n            return\n        \n        X = [0] * N\n        remaining_sum = 0\n        \n        for i, (L, R) in enumerate(intervals):\n            if L <= 0 <= R:\n                X[i] = min(abs(remaining_sum), R - L + 1)\n                remaining_sum += X[i]\n            elif L > 0:\n                X[i] = min(R - L + 1, abs(remaining_sum))\n                remaining_sum += X[i]\n        \n        if remaining_sum != 0:\n            print(\"No\")\n            return\n        \n        for i in range(N):\n            if X[i] == 0:\n                X[i] = R - L + 1 - sum(X[j] for j in range(i) if X[j] > 0) - sum(X[j] for j in range(i+1, N) if X[j] < 0)\n        \n        if sum(X) == 0:\n            print(\"Yes\")\n            print(*X)\n        else:\n            print(\"No\")\n    \n    N = read_int()\n    intervals = [read_ints() for _ in range(N)]\n    solve(N, intervals)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_a",
        "code_list": [
            "def main():\n    R, G, B = map(int, input().split())\n    C = input()\n    \n    if C == \"Red\":\n        print(min(G, B))\n    elif C == \"Green\":\n        print(min(R, B))\n    else:\n        print(min(R, G))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_b",
        "code_list": [
            "import math\n\ndef dot_product(v1, v2):\n    return v1[0] * v2[0] + v1[1] * v2[1]\n\ndef is_right_triangle(A, B, C):\n    AB = (B[0] - A[0], B[1] - A[1])\n    BC = (C[0] - B[0], C[1] - B[1])\n    CA = (A[0] - C[0], A[1] - C[1])\n    \n    # Check if any of the angles is 90 degrees\n    if dot_product(AB, BC) == 0 or dot_product(BC, CA) == 0 or dot_product(CA, AB) == 0:\n        return True\n    else:\n        return False\n\ndef main():\n    A = tuple(map(int, input().split()))\n    B = tuple(map(int, input().split()))\n    C = tuple(map(int, input().split()))\n    \n    if is_right_triangle(A, B, C):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_a",
        "code_list": [
            "def main():\n    R = int(input())\n    current_display = (R // 100) + ((R % 100 > 0) * 1)\n    \n    if current_display == 4:\n        print(0)\n    else:\n        next_display = current_display + 1\n        required_rating = (next_display - 1) * 100 + 1\n        print(required_rating - R)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_f",
        "code_list": [
            "def main():\n    import math\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def find_palindrome(n):\n        if n < 10:\n            return str(n) if str(n) in '123456789' else -1\n        \n        for i in range(int(math.sqrt(n)), 10, -1):\n            if n % i == 0:\n                quotient = n // i\n                str_n = str(n)\n                str_i = str(i)\n                str_quotient = str(quotient)\n                \n                if len(str_n) > 1 and str_n[0] != '0' and str_n[-1] != '0':\n                    if is_palindrome(str_i + '*' + str_quotient) or is_palindrome(str_quotient + '*' + str_i):\n                        return str_i + '*' + str_quotient if is_palindrome(str_i + '*' + str_quotient) else str_quotient + '*' + str_i\n                    elif is_palindrome(str_n[:len(str_i)] + '*' + str_n[len(str_i):]):\n                        return str_n[:len(str_i)] + '*' + str_n[len(str_i):]\n        \n        return -1\n    \n    N = int(input().strip())\n    result = find_palindrome(N)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_b",
        "code_list": [
            "def main():\n    N, T, P = map(int, input().split())\n    hair_lengths = list(map(int, input().split()))\n    \n    # Count how many people already have hair length >= T\n    initial_count = sum(1 for length in hair_lengths if length >= T)\n    \n    if initial_count >= P:\n        print(0)\n    else:\n        days = 0\n        while True:\n            days += 1\n            new_count = sum(1 for length in [length + days for length in hair_lengths] if length >= T)\n            if new_count >= P:\n                break\n        \n        print(days)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_c",
        "code_list": [
            "from itertools import permutations\n\ndef count_valid_permutations(N, K, S):\n    # Generate all unique permutations of the string S\n    unique_perms = set(permutations(S))\n    \n    valid_count = 0\n    \n    # Check each permutation for palindromic substrings of length K\n    for perm in unique_perms:\n        perm_str = ''.join(perm)\n        for i in range(N - K + 1):\n            is_palindrome = True\n            for j in range(K // 2):\n                if perm_str[i + j] != perm_str[i + K - 1 - j]:\n                    is_palindrome = False\n                    break\n            if is_palindrome:\n                break\n        else:\n            valid_count += 1\n    \n    return valid_count\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    S = input().strip()\n    print(count_valid_permutations(N, K, S))"
        ]
    },
    {
        "question_id": "abc363_d",
        "code_list": [
            "def generate_palindrome(n):\n    def reverse(s):\n        return s[::-1]\n\n    def is_palindrome(s):\n        return s == reverse(s)\n\n    def find_palindrome(num_digits, is_even):\n        start = int('1' + '0' * (num_digits // 2 - 1))\n        end = int('9' * (num_digits // 2))\n        for i in range(start, end + 1):\n            prefix = str(i)\n            suffix = reverse(prefix) if is_even else reverse(prefix[:-1])\n            candidate = int(prefix + suffix)\n            if candidate >= n:\n                return candidate\n        return None\n\n    num_digits = 1\n    while True:\n        if num_digits % 2 == 0:\n            even_palindrome = find_palindrome(num_digits, True)\n            if even_palindrome is not None:\n                return even_palindrome\n        odd_palindrome = find_palindrome(num_digits, False)\n        if odd_palindrome is not None:\n            return odd_palindrome\n        num_digits += 1\n\ndef main():\n    import sys\n    n = int(sys.stdin.readline().strip())\n    print(generate_palindrome(n))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_e",
        "code_list": [
            "def main():\n    # Read input\n    H, W, Y = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(H)]\n    \n    def simulate(year):\n        sea_level = year\n        queue = []\n        visited = [[False] * W for _ in range(H)]\n        \n        # Mark all sections that are already below or equal to the sea level\n        for i in range(H):\n            for j in range(W):\n                if A[i][j] <= sea_level:\n                    visited[i][j] = True\n                    queue.append((i, j))\n        \n        # Perform BFS to mark all sections that will sink due to adjacent sections\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and A[nx][ny] <= sea_level:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n        \n        # Calculate remaining area\n        remaining_area = sum(1 for i in range(H) for j in range(W) if not visited[i][j])\n        return remaining_area\n    \n    # Simulate for each year\n    for year in range(Y + 1):\n        result = simulate(year)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_b",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    Si, Sj = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    X = input()\n\n    # Initialize Takahashi's starting position\n    i, j = Si - 1, Sj - 1\n\n    # Process each action in X\n    for action in X:\n        if action == 'L' and j > 0 and grid[i][j-1] == '.':\n            j -= 1\n        elif action == 'R' and j < W - 1 and grid[i][j+1] == '.':\n            j += 1\n        elif action == 'U' and i > 0 and grid[i-1][j] == '.':\n            i -= 1\n        elif action == 'D' and i < H - 1 and grid[i+1][j] == '.':\n            i += 1\n\n    # Output the final position\n    print(i + 1, j + 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_e",
        "code_list": [
            "def main():\n    from itertools import permutations\n    \n    # Read input\n    N, X, Y = map(int, input().split())\n    AB = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    # Find the maximum number of dishes Snuke will eat\n    max_dishes = 0\n    for perm in permutations(AB):\n        total_sweetness, total_saltiness = 0, 0\n        for sweetness, saltiness in perm:\n            total_sweetness += sweetness\n            total_saltiness += saltiness\n            if total_sweetness > X or total_saltiness > Y:\n                break\n        max_dishes = max(max_dishes, len(perm))\n    \n    print(max_dishes)"
        ]
    },
    {
        "question_id": "abc364_f",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    edges = defaultdict(list)\n    for i in range(2, len(data), 3):\n        l = int(data[i])\n        r = int(data[i+1])\n        c = int(data[i+2])\n        for j in range(l, r + 1):\n            edges[j].append((n + (i-2)//3, c))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    def kruskal():\n        mst_cost = 0\n        edges.sort(key=lambda x: x[1])\n        for u, c in edges:\n            if find(u) != find(n + 1):\n                union(u, n + 1)\n                mst_cost += c\n        return mst_cost if find(n + 1) == find(1) else -1\n    \n    parent = list(range(n + q + 1))\n    result = kruskal()\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_d",
        "code_list": [
            "import heapq\nfrom typing import List\n\ndef find_kth_closest_distance(N: int, Q: int, A: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for b, k in queries:\n        # Calculate distances from all points A to point B\n        distances = [abs(a - b) for a in A]\n        # Use a min heap to keep track of the k-th smallest distances\n        min_heap = distances[:k]\n        heapq.heapify(min_heap)\n        \n        for dist in distances[k:]:\n            if dist < min_heap[0]:\n                heapq.heappushpop(min_heap, dist)\n        \n        results.append(min_heap[0])\n    \n    return results\n\ndef main():\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    queries = [list(map(int, input().split())) for _ in range(Q)]\n    \n    results = find_kth_closest_distance(N, Q, A, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n = data[0]\n    x = data[1]\n    y = data[2]\n    \n    a = data[3:3*n+3:3]\n    b = data[4:3*n+3:3]\n    \n    # Sort based on the ratio of sweetness to saltiness\n    dishes = sorted(zip(a, b), key=lambda p: p[0] / p[1])\n    \n    total_sweetness = 0\n    total_saltiness = 0\n    min_dishes = float('inf')\n    \n    for sweetness, saltiness in dishes:\n        if total_sweetness + sweetness > x or total_saltiness + saltiness > y:\n            break\n        total_sweetness += sweetness\n        total_saltiness += saltiness\n        min_dishes = min(min_dishes, len(dishes) - (n - (dishes.index((sweetness, saltiness)) + 1)))\n    \n    print(min_dishes)"
        ]
    },
    {
        "question_id": "abc364_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = [input() for _ in range(N)]\n    \n    for i in range(1, N):\n        if S[i] == 'sweet' and S[i - 1] == 'sweet':\n            print('No')\n            return\n    print('Yes')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc365_b",
        "code_list": [
            "def main():\n    # Read input\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    \n    # Find the maximum value\n    max_val = max(A)\n    # Remove the maximum value to find the second largest\n    A.remove(max_val)\n    # The new maximum value is the second largest\n    second_largest_index = A.index(max(A)) + 1\n    \n    # Print the index of the second largest element\n    print(second_largest_index)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc365_a",
        "code_list": [
            "def main():\n    Y = int(input())\n    if Y % 400 == 0:\n        print(366)\n    elif Y % 100 == 0:\n        print(365)\n    elif Y % 4 == 0:\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc365_e",
        "code_list": [
            "def main():\n    import sys\n    \n    def count_set_bits(n):\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    prefix_xor = [0] * (N + 1)\n    \n    for i in range(N):\n        prefix_xor[i + 1] = prefix_xor[i] ^ A[i]\n    \n    result = 0\n    for mask in range(32):\n        ones_count = [0] * (N + 1)\n        for i in range(1, N + 1):\n            ones_count[i] = ones_count[i - 1] + (prefix_xor[i] & (1 << mask)) > 0\n        \n        for i in range(1, N + 1):\n            j = N - i + 1\n            if (prefix_xor[j] ^ prefix_xor[i - 1]) & (1 << mask) > 0:\n                result += (ones_count[j] - ones_count[i - 1]) * (N - j + 1)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc365_d",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n\n    # Count the occurrences of each move\n    count_R = S.count('R')\n    count_P = S.count('P')\n    count_S = S.count('S')\n\n    # Determine the maximum number of wins for Takahashi\n    max_wins = 0\n    if count_R > 0:\n        max_wins += min(count_P, count_S)\n    if count_P > 0:\n        max_wins += min(count_R, count_S)\n    if count_S > 0:\n        max_wins += min(count_R, count_P)\n\n    # Add the remaining moves to the count of wins\n    remaining_moves = N - max_wins\n    if remaining_moves % 2 == 1:\n        max_wins += 1\n\n    print(max_wins)"
        ]
    },
    {
        "question_id": "abc365_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, m = data[0], data[1]\n    start, end = 0, max(data)\n    subsidies = [data[i] for i in range(2, 2 + n)]\n\n    def check(mid):\n        return sum(min(mid, s) for s in subsidies) <= m\n\n    while start < end:\n        mid = (start + end + 1) // 2\n        if check(mid):\n            start = mid\n        else:\n            end = mid - 1\n\n    if check(end):\n        print(\"infinite\")\n    else:\n        print(end)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "3426",
        "code_list": [
            "class Solution:\n    def minimumChairs(self, s: str) -> int:\n        max_chairs_needed = 0\n        current_chairs = 0\n        \n        for event in s:\n            if event == 'E':\n                current_chairs += 1\n                max_chairs_needed = max(max_chairs_needed, current_chairs)\n            else:\n                current_chairs -= 1\n        \n        return max_chairs_needed"
        ]
    },
    {
        "question_id": "3430",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:\n        # Sort meetings based on their start time\n        meetings.sort(key=lambda x: x[0])\n        available_days = 0\n        \n        # Initialize the last meeting's end time to -1\n        last_meeting_end = -1\n        \n        for start, end in meetings:\n            # If there is a gap between the last meeting's end and current meeting's start\n            if start > last_meeting_end + 1:\n                available_days += start - last_meeting_end - 1\n            # Update the last meeting's end time\n            last_meeting_end = max(last_meeting_end, end)\n        \n        # Check if there are any available days after the last meeting\n        available_days += days - last_meeting_end - 1\n        \n        return available_days"
        ]
    },
    {
        "question_id": "3436",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        min_diff = float('inf')\n        current_or = 0\n        \n        for i in range(len(nums)):\n            current_or |= nums[i]\n            diff = abs(current_or - k)\n            min_diff = min(min_diff, diff)\n            \n            # Early termination if the current OR value is equal to k\n            if current_or == k:\n                return 0\n        \n        return min_diff"
        ]
    },
    {
        "question_id": "3450",
        "code_list": [
            "class Solution:\n    def numberOfChild(self, n: int, k: int) -> int:\n        # The ball starts at position 0 and moves right initially\n        position = 0\n        # Direction of movement (1 for right, -1 for left)\n        direction = 1\n        \n        for _ in range(k):\n            # If the ball reaches the end, reverse the direction\n            if position == 0:\n                direction = 1\n            elif position == n - 1:\n                direction = -1\n            \n            # Move the ball to the next position\n            position += direction\n        \n        return position"
        ]
    },
    {
        "question_id": "3422",
        "code_list": [
            "class Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Initialize the array with 1s\n        a = [1] * n\n        \n        # Update the array for k seconds\n        for _ in range(k):\n            for i in range(1, n):\n                a[i] = (a[i] + a[i-1]) % MOD\n        \n        # Return the last element of the array\n        return a[-1]"
        ]
    },
    {
        "question_id": "3442",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        rewardValues.sort()\n        total_reward = 0\n        for value in rewardValues:\n            if value > total_reward:\n                total_reward += value\n        return total_reward"
        ]
    },
    {
        "question_id": "3421",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        count = 0\n        mod_values = {}\n        for hour in hours:\n            complement = (24 - hour % 24) % 24\n            if complement in mod_values:\n                count += mod_values[complement]\n            mod_values[hour % 24] = mod_values.get(hour % 24, 0) + 1\n        return count"
        ]
    },
    {
        "question_id": "3437",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalDamage(self, power: List[int]) -> int:\n        # Sort the powers to process them in ascending order\n        power.sort()\n        n = len(power)\n        dp = [0] * (n + 3)  # Extra padding to handle edge cases easily\n        \n        for p in power:\n            # Calculate the maximum damage we can get by skipping the current spell\n            skip_current = dp[p + 3]\n            # Calculate the maximum damage we can get by casting the current spell\n            cast_current = dp[p + 2] + p\n            # Update the dp table\n            dp[p + 3] = max(skip_current, cast_current)\n        \n        # The answer will be the maximum value in the dp table from index 3 to n+2\n        return dp[3:]"
        ]
    },
    {
        "question_id": "3438",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + (nums[i] > max(nums[max(0, i - 1)], nums[min(i + 1, n - 1)]))\n        \n        ans = []\n        for query in queries:\n            if query[0] == 1:\n                l, r = query[1], query[2]\n                ans.append(prefix_sum[r + 1] - prefix_sum[l])\n            else:\n                idx, val = query[1], query[2]\n                nums[idx] = val\n        \n        return ans"
        ]
    },
    {
        "question_id": "3471",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumAverage(self, nums: List[int]) -> float:\n        nums.sort()\n        averages = []\n        for _ in range(len(nums) // 2):\n            min_element = nums.pop(0)\n            max_element = nums.pop(-1)\n            averages.append((min_element + max_element) / 2)\n        return min(averages)"
        ]
    },
    {
        "question_id": "3461",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        left, right, top, bottom = [cols] * rows, [-1] * rows, [rows] * cols, [-1] * cols\n        \n        # Find the leftmost and rightmost columns for each row containing 1\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 1:\n                    left[r] = min(left[r], c)\n                    right[r] = max(right[r], c)\n        \n        # Find the topmost and bottommost rows for each column containing 1\n        for c in range(cols):\n            for r in range(rows):\n                if grid[r][c] == 1:\n                    top[c] = min(top[c], r)\n                    bottom[c] = max(bottom[c], r)\n        \n        min_area = float('inf')\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    for k in range(i, rows):\n                        if bottom[j] != -1 and bottom[j] >= k:\n                            area = (k - i + 1) * (right[j] - left[i] + 1)\n                            min_area = min(min_area, area)\n                            break\n        \n        return min_area"
        ]
    },
    {
        "question_id": "3464",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        max_cost = dp[0]\n        \n        for i in range(1, n):\n            # Calculate the cost of the current subarray ending at index i\n            current_cost = nums[i] * (-1) ** (i - 0)\n            if i >= 2:\n                current_cost += dp[i - 2]\n            else:\n                current_cost += dp[i - 1]\n            \n            # Update dp[i] to be the maximum cost we can get by either continuing the previous subarray or starting a new one\n            dp[i] = max(current_cost, nums[i])\n            max_cost = max(max_cost, dp[i])\n        \n        return max_cost"
        ]
    },
    {
        "question_id": "3469",
        "code_list": [
            "class Solution:\n    def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n        # Initialize the height of the triangle\n        height = 0\n        \n        # Iterate over possible heights of the triangle\n        for h in range(1, min(red, blue) + 1):\n            # Calculate the number of balls needed for the current height\n            balls_needed = (h * (h + 1)) // 2\n            \n            # Check if we can form the current height with the available balls\n            if (red >= h and blue >= h) or (red >= h * (h - 1) // 2 and blue >= h * (h + 1) // 2):\n                height = h\n        \n        return height"
        ]
    },
    {
        "question_id": "3490",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        # Group numbers based on their parity\n        even = []\n        odd = []\n        for num in nums:\n            if num % 2 == 0:\n                even.append(num)\n            else:\n                odd.append(num)\n        \n        # Helper function to find the longest valid subsequence\n        def longest_subsequence(arr):\n            n = len(arr)\n            dp = [1] * n\n            max_length = 1\n            for i in range(1, n):\n                for j in range(i):\n                    if arr[i] % 2 == arr[j] % 2:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n            return max_length\n        \n        # Find the longest valid subsequence for even and odd groups\n        max_even = longest_subsequence(even)\n        max_odd = longest_subsequence(odd)\n        \n        # The result is the maximum of the two lengths\n        return max(max_even, max_odd)"
        ]
    },
    {
        "question_id": "3439",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def dfs(node, parent, graph, visited):\n            visited.add(node)\n            max_dist = 0\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    dist = dfs(neighbor, node, graph, visited)\n                    if neighbor in second_tree_nodes:\n                        max_dist = max(max_dist, dist)\n                    else:\n                        max_dist = max(max_dist, dist + 1)\n            return max_dist\n        \n        # Build graphs for both trees\n        first_tree_graph = defaultdict(list)\n        second_tree_graph = defaultdict(list)\n        first_tree_nodes = set()\n        second_tree_nodes = set()\n        \n        for a, b in edges1:\n            first_tree_graph[a].append(b)\n            first_tree_graph[b].append(a)\n            first_tree_nodes.update([a, b])\n        \n        for u, v in edges2:\n            second_tree_graph[u].append(v)\n            second_tree_graph[v].append(u)\n            second_tree_nodes.update([u, v])\n        \n        # Find the diameter of the first tree\n        visited = set()\n        max_dist_first_tree = dfs(0, -1, first_tree_graph, visited)\n        farthest_node = None\n        for node in visited:\n            if farthest_node is None or len(visited[node]) > len(visited[farthest_node]):\n                farthest_node = node\n        \n        # Find the diameter of the second tree\n        visited = set()\n        max_dist_second_tree = dfs(farthest_node, -1, first_tree_graph, visited)\n        \n        # Connect the farthest node of the first tree with any node in the second tree\n        min_diameter = float('inf')\n        for node in second_tree_nodes:\n            visited = set()\n            max_dist = dfs(node, -1, second_tree_graph, visited)\n            min_diameter = min(min_diameter, max_dist_first_tree + max_dist + 1)\n        \n        return min_diameter"
        ]
    },
    {
        "question_id": "3468",
        "code_list": [
            "class Solution:\n    def getEncryptedString(self, s: str, k: int) -> str:\n        encrypted = \"\"\n        for char in s:\n            # Calculate the new character position considering the cyclic nature\n            new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a'))\n            encrypted += new_char\n        return encrypted"
        ]
    },
    {
        "question_id": "3453",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def validStrings(self, n: int) -> List[str]:\n        if n == 1:\n            return [\"0\", \"1\"]\n        \n        valid_strings = [\"0\", \"1\"]\n        for _ in range(2, n + 1):\n            new_valid_strings = set()\n            for s in valid_strings:\n                new_valid_strings.add(\"0\" + s)\n                new_valid_strings.add(\"1\" + s)\n            valid_strings = [s[1:] for s in new_valid_strings if \"00\" not in s]\n        \n        return valid_strings"
        ]
    },
    {
        "question_id": "3492",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n        count = 0\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if grid[i - 1][j - 1] == 'X':\n                    prefix_sum[i][j] = prefix_sum[i][j - 1] + 1\n                else:\n                    prefix_sum[i][j] = prefix_sum[i][j - 1]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if grid[i - 1][j - 1] != 'X':\n                    continue\n                diff_count = {}\n                for k in range(i, 0, -1):\n                    x_count = prefix_sum[k][j] - prefix_sum[k][j - 1]\n                    y_count = prefix_sum[i][j] - prefix_sum[k][j]\n                    if x_count - y_count in diff_count:\n                        count += diff_count[x_count - y_count]\n                    diff_count[x_count - y_count] = diff_count.get(x_count - y_count, 0) + 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3482",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Create a dictionary to store the indices of words that contain each prefix\n        prefix_indices = defaultdict(list)\n        for i, word in enumerate(words):\n            for j in range(1, len(word) + 1):\n                prefix_indices[word[:j]].append(i)\n        \n        # Initialize the result with the cost of appending the entire target string\n        result = float('inf')\n        stack = [(0, 0)]  # (index in target, accumulated cost)\n        \n        while stack:\n            index, cost = stack.pop()\n            if index == len(target):\n                result = min(result, cost)\n                continue\n            \n            # Try to find a word that matches the current prefix of target\n            for i in prefix_indices[target[index:]]:\n                if index == 0 or words[i][len(words[i]) - 1] != target[index - 1]:\n                    stack.append((index + len(words[i]), cost + costs[i]))\n        \n        return result if result != float('inf') else -1"
        ]
    },
    {
        "question_id": "3484",
        "code_list": [
            "class Solution:\n    def getSmallestString(self, s: str) -> str:\n        n = len(s)\n        s_list = list(s)\n        \n        for i in range(n):\n            max_index = i\n            for j in range(i + 1, n):\n                if (int(s_list[i]) % 2 == int(s_list[j]) % 2) and (int(s_list[max_index]) > int(s_list[j])):\n                    max_index = j\n            if max_index != i:\n                s_list[i], s_list[max_index] = s_list[max_index], s_list[i]\n        \n        return ''.join(s_list)"
        ]
    },
    {
        "question_id": "3494",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n        # Add the initial dimensions to the respective cut lists\n        horizontalCut = [0] + sorted(horizontalCut) + [m]\n        verticalCut = [0] + sorted(verticalCut) + [n]\n        \n        # Calculate the total cost for horizontal cuts\n        total_cost = sum(horizontalCut[i+1] - horizontalCut[i] for i in range(len(horizontalCut) - 1))\n        \n        # Calculate the total cost for vertical cuts\n        for i in range(len(verticalCut) - 1):\n            total_cost += verticalCut[i+1] - verticalCut[i]\n        \n        return total_cost"
        ]
    },
    {
        "question_id": "3508",
        "code_list": [
            "class Solution:\n    def minChanges(self, n: int, k: int) -> int:\n        # Convert n and k to their binary representations without the '0b' prefix\n        bin_n = bin(n)[2:]\n        bin_k = bin(k)[2:]\n        \n        # Ensure both binary strings have the same length by padding with leading zeros\n        max_len = max(len(bin_n), len(bin_k))\n        bin_n = bin_n.zfill(max_len)\n        bin_k = bin_k.zfill(max_len)\n        \n        # Count the number of positions where the bits differ\n        diff_count = sum(1 for i in range(max_len) if bin_n[i] != bin_k[i])\n        \n        # If all bits are different, check if we can flip all bits of n to match k\n        if diff_count == max_len:\n            return max_len if bin_n.count('1') == max_len else -1\n        \n        return diff_count"
        ]
    },
    {
        "question_id": "3462",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def doesAliceWin(self, s: str) -> bool:\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if (i - j) % 2 == 0:  # Alice's turn\n                    if sum(c in 'aeiou' for c in s[j:i]) % 2 == 1:\n                        dp[i] = not dp[i]\n                else:  # Bob's turn\n                    if sum(c in 'aeiou' for c in s[j:i]) % 2 == 0:\n                        dp[i] = not dp[i]\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "3493",
        "code_list": [
            "class Solution:\n    def maxOperations(self, s: str) -> int:\n        count = 0\n        ones = s.count('1')\n        zeros = s.count('0')\n        \n        # If there are more zeros than ones, we can only perform operations as many times as there are ones\n        if zeros >= ones:\n            return ones\n        \n        # Otherwise, we can perform operations based on the difference between zeros and ones\n        else:\n            return zeros"
        ]
    },
    {
        "question_id": "3454",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        # Calculate the difference between corresponding elements of nums and target\n        diffs = [abs(num - t) for num, t in zip(nums, target)]\n        # Sum up all the differences to get the total number of operations needed\n        return sum(diffs)"
        ]
    },
    {
        "question_id": "3515",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single_digit_sum = sum(num for num in nums if 0 < num < 10)\n        double_digit_sum = sum(num for num in nums if 10 <= num <= 99)\n        \n        # If the sum of double-digit numbers is greater than or equal to the sum of single-digit numbers,\n        # Alice can always choose all double-digit numbers to win.\n        if double_digit_sum >= single_digit_sum:\n            return True\n        \n        # If there are no double-digit numbers, Alice can only choose single-digit numbers.\n        if not double_digit_sum:\n            return False\n        \n        # If the sum of single-digit numbers is greater, Alice can choose all single-digit numbers.\n        if single_digit_sum > double_digit_sum:\n            return True\n        \n        # If the sum of single-digit numbers is less, Alice can still win by choosing the largest single-digit number\n        # and the smallest double-digit number(s) to make her sum greater than Bob's.\n        single_digits = sorted([num for num in nums if 0 < num < 10], reverse=True)\n        double_digits = sorted([num for num in nums if 10 <= num <= 99])\n        \n        alice_sum = single_digits[0] + (double_digits[0] if double_digits else 0)\n        bob_sum = sum(nums) - alice_sum\n        \n        return alice_sum > bob_sum"
        ]
    },
    {
        "question_id": "3507",
        "code_list": [
            "from math import sqrt\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        def is_prime(n):\n            if n <= 1:\n                return False\n            for i in range(2, int(sqrt(n)) + 1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        non_special_count = 0\n        for x in range(l, r + 1):\n            divisors = []\n            for i in range(1, int(sqrt(x)) + 1):\n                if x % i == 0:\n                    divisors.extend([i, x // i])\n            divisors = list(set(divisors))\n            if len(divisors) - 1 == 2:  # Subtract 1 to exclude the number itself\n                continue\n            non_special_count += 1\n        return non_special_count"
        ]
    },
    {
        "question_id": "3479",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        zero_count = Counter()\n        one_count = Counter()\n        result = 0\n        \n        for i in range(n):\n            # Update counts for current character\n            if s[i] == '0':\n                zero_count[i] += 1\n            else:\n                one_count[i] += 1\n            \n            # Calculate the number of valid substrings ending at index i\n            for j in range(i + 1):\n                if one_count[j] >= (zero_count[j] + zero_count[i]) ** 2:\n                    result += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3478",
        "code_list": [
            "from typing import List\nimport math\n\nclass Solution:\n    def canReachCorner(self, xCorner: int, yCorner: int, circles: List[List[int]]) -> bool:\n        # Helper function to check if a point is inside or on the boundary of a circle\n        def isInsideCircle(x, y, cx, cy, radius):\n            return (x - cx) ** 2 + (y - cy) ** 2 <= radius ** 2\n        \n        # Helper function to check if a line segment intersects with a circle\n        def doesIntersect(x1, y1, x2, y2, cx, cy, radius):\n            dx, dy = x2 - x1, y2 - y1\n            A = dx ** 2 + dy ** 2\n            B = 2 * (dx * (x1 - cx) + dy * (y1 - cy))\n            C = cx ** 2 + cy ** 2 + x1 ** 2 + y1 ** 2 - 2 * (cx * x1 + cy * y1) - radius ** 2\n            discriminant = B ** 2 - 4 * A * C\n            if discriminant < 0:\n                return False\n            t1 = (-B + math.sqrt(discriminant)) / (2 * A)\n            t2 = (-B - math.sqrt(discriminant)) / (2 * A)\n            if 0 <= t1 <= 1 or 0 <= t2 <= 1:\n                return True\n            return False\n        \n        # Check all four sides of the rectangle for intersections with circles\n        for x in range(xCorner + 1):\n            if isInsideCircle(x, 0, *circle) or isInsideCircle(x, yCorner, *circle) or doesIntersect(x, 0, x + 1, 0, *circle) or doesIntersect(x, yCorner, x + 1, yCorner, *circle) for circle in circles):\n                continue\n            for y in range(1, yCorner):\n                if isInsideCircle(0, y, *circle) or isInsideCircle(xCorner, y, *circle) or doesIntersect(0, y, 0, y + 1, *circle) or doesIntersect(xCorner, y, xCorner, y + 1, *circle) for circle in circles):\n                    continue\n                if isInsideCircle(xCorner, y, *circle) or isInsideCircle(xCorner, 0, *circle) or doesIntersect(xCorner, y, xCorner, y + 1, *circle) or doesIntersect(xCorner, 0, xCorner, 1, *circle) for circle in circles):\n                    continue\n                if isInsideCircle(x, yCorner, *circle) or isInsideCircle(0, yCorner, *circle) or doesIntersect(x, yCorner, x + 1, yCorner, *circle) or doesIntersect(0, yCorner, 1, yCorner, *circle) for circle in circles):\n                    continue\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3517",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the graph with direct connections\n        graph = {i: set(range(i + 1, n)) for i in range(n - 1)}\n        graph[n - 1] = set()\n        \n        # Initialize the result list\n        result = []\n        \n        # Function to perform BFS and find the shortest path\n        def bfs(start, end):\n            queue = deque([(start, 0)])\n            visited = set([start])\n            \n            while queue:\n                current, distance = queue.popleft()\n                \n                if current == end:\n                    return distance\n                \n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, distance + 1))\n            \n            return float('inf')\n        \n        # Process each query\n        for u, v in queries:\n            graph[u].add(v)\n            graph[v].add(u)\n            \n            # Update the result with the shortest path from 0 to n-1\n            result.append(bfs(0, n - 1))\n        \n        return result"
        ]
    },
    {
        "question_id": "3527",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfAlternatingGroups(self, colors: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(colors)\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                size = query[1]\n                count = 0\n                i = 0\n                while i < n:\n                    if i + size > n:\n                        break\n                    group = colors[i:i+size]\n                    if len(group) == size and self.is_alternating(group):\n                        count += 1\n                    i += 1\n                result.append(count)\n            elif query[0] == 2:\n                index = query[1]\n                new_color = query[2]\n                colors[index] = new_color\n        return result\n    \n    def is_alternating(self, group: List[int]) -> bool:\n        for i in range(1, len(group)):\n            if group[i] == group[i-1]:\n                return False\n        return True"
        ]
    },
    {
        "question_id": "3533",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:\n        # Initialize starting position\n        i, j = 0, 0\n        \n        # Define movement directions for each command\n        directions = {\n            \"UP\": (-1, 0),\n            \"RIGHT\": (0, 1),\n            \"DOWN\": (1, 0),\n            \"LEFT\": (0, -1)\n        }\n        \n        # Process each command\n        for command in commands:\n            di, dj = directions[command]\n            # Calculate new position\n            ni, nj = i + di, j + dj\n            \n            # Ensure the new position is within bounds\n            if 0 <= ni < n and 0 <= nj < n:\n                i, j = ni, nj\n        \n        # Return the final position as a single integer\n        return i * n + j"
        ]
    },
    {
        "question_id": "3535",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        def count_non_decreasing(nums):\n            dp = [1] * len(nums)\n            for i in range(1, len(nums)):\n                for j in range(i):\n                    if nums[j] <= nums[i]:\n                        dp[i] = (dp[i] + dp[j]) % MOD\n            return sum(dp) % MOD\n        \n        def count_non_increasing(nums):\n            dp = [1] * len(nums)\n            for i in range(len(nums) - 2, -1, -1):\n                for j in range(len(nums) - 1, i, -1):\n                    if nums[j] <= nums[i]:\n                        dp[i] = (dp[i] + dp[j]) % MOD\n            return sum(dp) % MOD\n        \n        total_pairs = 0\n        for i in range(len(nums)):\n            arr1 = nums[:i] + nums[i+1:]\n            arr2 = [nums[i]] * len(arr1)\n            total_pairs += count_non_decreasing(arr1) * count_non_increasing(arr2)\n            total_pairs %= MOD\n        \n        return total_pairs"
        ]
    },
    {
        "question_id": "3447",
        "code_list": [
            "class Solution:\n    def clearDigits(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char.isdigit():\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(char)\n        return ''.join(stack)"
        ]
    },
    {
        "question_id": "3413",
        "code_list": [
            "from heapq import heapify, heappop, heappush\n\nclass Solution:\n    def findWinningPlayer(self, skills: List[int], k: int) -> int:\n        # Create a max-heap by negating the values\n        max_heap = [-skill for skill in skills]\n        heapify(max_heap)\n        \n        consecutive_wins = 0\n        current_index = 0\n        \n        while max_heap:\n            # Pop the highest skill player\n            highest_skill = -heappop(max_heap)\n            current_index = skills.index(highest_skill)\n            \n            # Check if this player has already won k consecutive games\n            if consecutive_wins >= k:\n                return current_index\n            \n            # Simulate the next game\n            next_player_skill = skills[(current_index + 1) % len(skills)]\n            if highest_skill > next_player_skill:\n                consecutive_wins += 1\n            else:\n                consecutive_wins = 1\n                heappush(max_heap, -next_player_skill)\n        \n        return current_index"
        ]
    },
    {
        "question_id": "3456",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(k + 1):\n                if i == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i - 1][j]\n                    if nums[i] == nums[i - 1]:\n                        if j > 0:\n                            dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 2)\n                    else:\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j] + 2)\n        \n        return dp[n - 1][k]"
        ]
    },
    {
        "question_id": "3476",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        count = [0] * 3\n        for num in nums:\n            count[num % 3] += 1\n        \n        if count[1] == 0 and count[2] == 0:\n            return 0\n        \n        min_ops = float('inf')\n        for i in range(3):\n            for j in range(3):\n                if i != j:\n                    ops = len(nums) - count[i] - (count[j] // 3)\n                    if count[j] % 3 == 0 and j == 2:\n                        ops -= count[j] % 3\n                    min_ops = min(min_ops, ops)\n        \n        return min_ops"
        ]
    },
    {
        "question_id": "3475",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0] * 3 for _ in range(n)]\n        dp[0][0] = nums[0]\n        dp[0][1] = 1 - nums[0]\n        dp[0][2] = 1 - nums[0]\n        \n        for i in range(1, n):\n            dp[i][0] = min(dp[i-1][j] + abs(nums[i] - j) for j in range(3))\n            dp[i][1] = min(dp[i-1][j] + abs(nums[i] - j) for j in range(3) if j != 1)\n            dp[i][2] = min(dp[i-1][j] + abs(nums[i] - j) for j in range(3) if j != 2)\n        \n        result = min(dp[-1])\n        return result if result < float('inf') else -1"
        ]
    },
    {
        "question_id": "3460",
        "code_list": [
            "from typing import List\nimport functools\n\nclass Solution:\n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        \n        @functools.lru_cache(None)\n        def dp(end, remaining_requirements):\n            if end == n:\n                return 1\n            \n            total_ways = 0\n            for i in range(n):\n                valid = True\n                for req_end, req_cnt in remaining_requirements:\n                    if i <= req_end:\n                        if req_cnt != remaining_requirements[0][1]:\n                            valid = False\n                            break\n                if not valid:\n                    continue\n                \n                new_requirements = list(remaining_requirements)\n                for j, (req_end, req_cnt) in enumerate(new_requirements):\n                    if i <= req_end:\n                        new_requirements[j] = (req_end, req_cnt - (i > 0))\n                \n                total_ways += dp(end + 1, tuple(sorted(new_requirements)))\n                total_ways %= MOD\n            \n            return total_ways\n        \n        return dp(0, tuple(requirements))"
        ]
    },
    {
        "question_id": "3463",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfAlternatingGroups(self, colors: List[int]) -> int:\n        n = len(colors)\n        count = 0\n        \n        for i in range(n):\n            if (colors[i] != colors[(i - 1) % n] and colors[i] != colors[(i + 1) % n]):\n                count += 1\n                \n        return count"
        ]
    },
    {
        "question_id": "3264",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:\n        enemyEnergies.sort()\n        n = len(enemyEnergies)\n        dp = [0] * (n + 1)\n        for i in range(n):\n            for j in range(n - 1, -1, -1):\n                if currentEnergy >= enemyEnergies[i]:\n                    dp[j + 1] = max(dp[j + 1], dp[j] + 1)\n                    currentEnergy -= enemyEnergies[i]\n                if j > 0:\n                    currentEnergy += enemyEnergies[i]\n                    dp[j] = max(dp[j], dp[j - 1] + 1)\n        return dp[n]"
        ]
    },
    {
        "question_id": "3466",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        prefix_and = 0\n        frequency_map = {0: 1}  # Initialize with 0 to handle subarrays starting from index 0\n        \n        for num in nums:\n            prefix_and &= num\n            if prefix_and < k:\n                prefix_and = 0\n            count += frequency_map.get(prefix_and & k, 0)\n            frequency_map[prefix_and] = frequency_map.get(prefix_and, 0) + 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3511",
        "code_list": [
            "class Solution:\n    def losingPlayer(self, x: int, y: int) -> str:\n        # Calculate the total number of 10-value coins needed to make up 115\n        needed_y = (115 - 75) // 10\n        \n        # If Alice can pick the exact number of 10-value coins needed to make 115, she wins\n        if x >= 1 and y >= needed_y:\n            return \"Alice\"\n        # If Bob can force Alice into a position where she cannot pick the exact number of 10-value coins needed to make 115, he wins\n        elif x >= 1 and y < needed_y:\n            return \"Bob\"\n        # If neither condition is met, we need to check further conditions based on the remaining coins\n        else:\n            # If Alice has enough 75-value coins but not enough 10-value coins to make 115, Bob wins\n            if x >= 2 and y < 2 * needed_y:\n                return \"Bob\"\n            # If Alice has fewer than 2 75-value coins, Bob wins\n            elif x < 2:\n                return \"Bob\"\n            # If all other conditions fail, Alice wins\n            else:\n                return \"Alice\""
        ]
    },
    {
        "question_id": "3455",
        "code_list": [
            "class Solution:\n    def minimumLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            if stack and stack[-1] == char:\n                stack.pop()\n            else:\n                stack.append(char)\n        return len(stack)"
        ]
    },
    {
        "question_id": "3498",
        "code_list": [
            "from typing import List\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        half_n = n // 2\n        dp = [float('inf')] * (half_n + 1)\n        dp[0] = 0\n        \n        # Group elements by their index relative to the center\n        groups = [Counter() for _ in range(k)]\n        for i in range(half_n):\n            groups[i % k][nums[i]] += 1\n            groups[(i + half_n) % k][nums[i + half_n]] -= 1\n        \n        # Calculate the frequency of each value in each group\n        for group in groups:\n            for val in list(group):\n                if group[val] <= 0:\n                    del group[val]\n        \n        # Calculate the maximum frequency for each group\n        max_freq = [max(group.values(), default=0) for group in groups]\n        \n        # Dynamic programming to find the minimum changes required\n        for i in range(1, half_n + 1):\n            for j in range(k):\n                for val in groups[j]:\n                    dp[i] = min(dp[i], dp[i - 1] + max_freq[j] - 2 * group[val])\n            for val in groups[(i - 1) % k]:\n                dp[i] = min(dp[i], dp[i - 1] + max_freq[(i - 1) % k] - 2 * group[val])\n        \n        return dp[half_n]"
        ]
    },
    {
        "question_id": "3519",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def winningPlayerCount(self, n: int, pick: List[List[int]]) -> int:\n        # Dictionary to count the number of balls of each color picked by each player\n        ball_counts = defaultdict(lambda: defaultdict(int))\n        \n        for player, color in pick:\n            ball_counts[player][color] += 1\n        \n        # Count how many players win the game\n        winners = 0\n        for player in range(n):\n            # Check if the player has picked enough balls of the same color\n            for color, count in ball_counts[player].items():\n                if count > player:\n                    winners += 1\n                    break  # Only one color needs to be checked per player\n        \n        return winners"
        ]
    },
    {
        "question_id": "3526",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minFlips(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        all_ones = (1 << n) - 1\n        \n        # Helper function to check if a row is palindromic\n        def is_palindrome(row):\n            return row == row[::-1]\n        \n        # Helper function to count flips needed to make a row palindromic\n        def count_flips_to_palindrome(row):\n            palindrome_row = row[::-1]\n            flips = 0\n            for i in range(n // 2):\n                if row[i] != palindrome_row[i]:\n                    flips += 1\n            return flips\n        \n        # Count flips needed to make all rows palindromic\n        min_flips_rows = sum(count_flips_to_palindrome(row) for row in grid)\n        \n        # Transpose the grid to work with columns\n        transposed_grid = list(zip(*grid))\n        \n        # Count flips needed to make all columns palindromic\n        min_flips_cols = sum(count_flips_to_palindrome(col) for col in transposed_grid)\n        \n        # Return the minimum of the two counts\n        return min(min_flips_rows, min_flips_cols)"
        ]
    },
    {
        "question_id": "3532",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def timeTaken(self, edges: List[List[int]]) -> List[int]:\n        # Build the graph\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Function to perform DFS and calculate the time taken\n        def dfs(node, parent, time):\n            max_time = 0\n            second_max_time = 0\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    current_time = dfs(neighbor, node, time + 1)\n                    if current_time > max_time:\n                        second_max_time = max_time\n                        max_time = current_time\n                    elif current_time > second_max_time:\n                        second_max_time = current_time\n            return max(max_time, second_max_time) + 1\n        \n        # Calculate the time taken for each node\n        result = []\n        for i in range(len(edges) + 1):\n            max_time = 0\n            for neighbor in graph[i]:\n                max_time = max(max_time, dfs(neighbor, i, 1))\n            result.append(max_time * 2 if i % 2 == 0 else (max_time * 2 + 1))\n        \n        return result"
        ]
    },
    {
        "question_id": "abc366_f",
        "code_list": [
            "def max_function_value(N, K, functions):\n    def apply_function(x, index):\n        return functions[index][0] * x + functions[index][1]\n\n    def dfs(index, current_value, path):\n        nonlocal max_value\n        if len(path) == K:\n            max_value = max(max_value, current_value)\n            return\n        for i in range(N):\n            if i not in path:\n                next_value = apply_function(current_value, i)\n                dfs(i, next_value, path | {i})\n\n    max_value = float('-inf')\n    dfs(-1, 1, set())\n    return max_value\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    functions = [tuple(map(int, input().split())) for _ in range(N)]\n    print(max_function_value(N, K, functions))"
        ]
    },
    {
        "question_id": "abc366_b",
        "code_list": [
            "def convert_to_vertical_text(n, strings):\n    # Find the maximum length among all strings\n    max_length = max(len(s) for s in strings)\n    \n    # Initialize the result list with empty strings\n    result = [''] * max_length\n    \n    # Iterate over each character position\n    for j in range(max_length):\n        for i in range(n):\n            if j < len(strings[i]):\n                # Append the character to the corresponding result string\n                result[j] += strings[i][j]\n            else:\n                # If the position exceeds the string length, append '*'\n                result[j] += '*'\n    \n    # Ensure no string ends with '*'\n    for i in range(max_length):\n        while result[i][-1] == '*':\n            result[i] = result[i][:-1]\n    \n    return result\n\ndef main():\n    n = int(input().strip())\n    strings = [input().strip() for _ in range(n)]\n    vertical_text = convert_to_vertical_text(n, strings)\n    for line in vertical_text:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    d = int(data[1])\n    points = []\n    for i in range(2, len(data), 2):\n        points.append((int(data[i]), int(data[i+1])))\n    \n    # Sort points by x and y separately\n    sorted_x = sorted(points, key=lambda p: p[0])\n    sorted_y = sorted(points, key=lambda p: p[1])\n    \n    # Find median x and y\n    mid_x = sorted_x[n//2][0]\n    mid_y = sorted_y[n//2][1]\n    \n    # Count points within the bounding box centered at (mid_x, mid_y)\n    count = 0\n    for x, y in points:\n        if abs(x - mid_x) + abs(y - mid_y) <= d:\n            count += 1\n    \n    # Calculate the number of valid (x, y) pairs\n    result = 0\n    for x, y in points:\n        if abs(x - mid_x) + abs(y - mid_y) <= d:\n            result += (d - (abs(x - mid_x) + abs(y - mid_y))) // 2 + 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_d",
        "code_list": [
            "def main():\n    import numpy as np\n    \n    # Read input\n    N = int(input())\n    A = []\n    for _ in range(N):\n        row = list(map(int, input().split()))\n        A.extend(row)\n    \n    Q = int(input())\n    queries = []\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, input().split())\n        queries.append((Lx - 1, Rx, Ly - 1, Ry, Lz - 1, Rz))\n    \n    # Convert A to a 3D array\n    A_3d = np.array(A).reshape(N, N, N)\n    \n    # Precompute prefix sums along the third dimension\n    prefix_sum = np.zeros((N, N, N + 1))\n    for z in range(N):\n        for y in range(N):\n            for x in range(N):\n                prefix_sum[x, y, z + 1] = prefix_sum[x, y, z] + A_3d[x, y, z]\n    \n    # Process each query using the precomputed prefix sums\n    results = []\n    for Lx, Rx, Ly, Ry, Lz, Rz in queries:\n        result = 0\n        for y in range(Ly, Ry + 1):\n            for x in range(Lx, Rx + 1):\n                result += prefix_sum[x, y, Rz + 1] - prefix_sum[x, y, Lz]\n        results.append(result)\n    \n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_a",
        "code_list": [
            "def main():\n    N, T, A = map(int, input().split())\n    remaining_votes = N - (T + A)\n    if T > A + remaining_votes:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_c",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    Q = int(input())\n    operations = []\n    \n    for _ in range(Q):\n        operation = list(map(int, input().split()))\n        operations.append(operation)\n    \n    bag_contents = set()\n    result = []\n    \n    for op in operations:\n        if op[0] == 1:\n            bag_contents.add(op[1])\n        elif op[0] == 2:\n            bag_contents.discard(op[1])\n        else:\n            result.append(len(bag_contents))\n    \n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_g",
        "code_list": [
            "from collections import defaultdict\n\ndef solve(N, M, edges):\n    # Build the graph\n    graph = defaultdict(set)\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Initialize the solution array\n    X = [0] * N\n\n    # Function to check if a vertex can have a specific value\n    def can_have_value(vertex, value):\n        for neighbor in graph[vertex]:\n            if X[neighbor] == 0:\n                X[neighbor] = value ^ X[vertex]\n            elif X[neighbor] != value ^ X[vertex]:\n                return False\n        return True\n\n    # Try to assign values to vertices\n    for vertex in range(1, N + 1):\n        if len(graph[vertex]) > 0 and X[vertex] == 0:\n            for value in range(1, 2**60):\n                if can_have_value(vertex, value):\n                    X[vertex] = value\n                    break\n            else:\n                return \"No\"\n\n    return \"Yes\\n\" + \" \".join(str(x) for x in X)\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    print(solve(N, M, edges))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_e",
        "code_list": [
            "def main():\n    import sys\n    \n    def perform_operations(N, K, X, A):\n        # Create a mapping to track the index of each position in X\n        index_map = {x: i for i, x in enumerate(X)}\n        \n        # Determine the cycle lengths and the cycle representatives\n        cycle_lengths = []\n        visited = [False] * N\n        for i in range(N):\n            if not visited[i]:\n                cycle_length = 0\n                current = i\n                while not visited[current]:\n                    visited[current] = True\n                    current = X[current] - 1\n                    cycle_length += 1\n                cycle_lengths.append(cycle_length)\n        \n        # If there's only one cycle, we can directly determine the final state\n        if len(cycle_lengths) == 1:\n            return A\n        \n        # Find the representative of the cycle that contains the first element\n        cycle_representative = X[0] - 1\n        cycle_start_index = index_map[cycle_representative]\n        \n        # Calculate the effective number of operations within the cycle\n        effective_operations = K % cycle_lengths[0]\n        \n        # Perform the operations\n        result = [0] * N\n        for i in range(N):\n            if i == cycle_start_index:\n                current = cycle_representative\n                for _ in range(effective_operations):\n                    current = X[current] - 1\n                result[i] = A[current]\n            else:\n                current = X[i] - 1\n                while current != i:\n                    result[i] = A[current]\n                    current = X[current] - 1\n        \n        return result\n    \n    # Read input\n    N, K = map(int, input().split())\n    X = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    \n    # Perform the operations\n    result = perform_operations(N, K, X, A)\n    \n    # Output the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_f",
        "code_list": [
            "from collections import Counter\n\ndef can_rearrange_subsequence(N, Q, A, B, queries):\n    def check_subsequence(A_sub, B_sub):\n        return Counter(A_sub) == Counter(B_sub)\n    \n    for l, r, L, R in queries:\n        A_sub = A[l-1:r]\n        B_sub = B[L-1:R]\n        if check_subsequence(A_sub, B_sub):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    can_rearrange_subsequence(N, Q, A, B, queries)"
        ]
    },
    {
        "question_id": "abc367_a",
        "code_list": [
            "def main():\n    A, B, C = map(int, input().split())\n    # Check if A falls within the awake period [B, C) or [C, B)\n    if B <= A < C or C <= A < B:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_g",
        "code_list": [
            "from collections import defaultdict\nfrom itertools import combinations\n\ndef calculate_score(subseq, M, K):\n    if len(subseq) % M == 0:\n        return pow(reduce(lambda x, y: x ^ y, subseq), K, 998244353)\n    else:\n        return 0\n\ndef reduce_xor(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef count_subsequences(N, M, K, A):\n    total_score = 0\n    for r in range(1, N + 1):\n        for subseq in combinations(A, r):\n            total_score += calculate_score(subseq, M, K)\n    return total_score % 998244353\n\ndef main():\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(count_subsequences(N, M, K, A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_b",
        "code_list": [
            "def main():\n    X = float(input())\n    # Remove trailing zeros and unnecessary decimal point\n    formatted_X = f\"{X:.3g}\"\n    print(formatted_X)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_d",
        "code_list": [
            "from math import gcd\nfrom collections import Counter\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Calculate prefix sum modulo M\n    prefix_sum_mod_M = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum_mod_M[i] = (prefix_sum_mod_M[i - 1] + A[i - 1]) % M\n    \n    # Count occurrences of each prefix sum modulo M\n    count_prefix_sum = Counter(prefix_sum_mod_M)\n    \n    # Calculate the number of valid pairs\n    total_pairs = 0\n    for count in count_prefix_sum.values():\n        # Each unique prefix sum can form (count * (count - 1)) // 2 pairs with itself\n        total_pairs += (count * (count - 1)) // 2\n    \n    # Add pairs where the difference between prefix sums is a multiple of M\n    for i in range(N):\n        if (prefix_sum_mod_M[i + 1] - prefix_sum_mod_M[0]) % M == 0:\n            total_pairs += N - 1\n    \n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_c",
        "code_list": [
            "from itertools import product\n\ndef find_sequences(N, K, R):\n    # Generate all possible sequences of length N with elements in the range [1, R_i]\n    all_sequences = list(product(*[range(1, R_i + 1) for R_i in R]))\n    \n    valid_sequences = []\n    # Filter sequences where the sum of elements is a multiple of K\n    for seq in all_sequences:\n        if sum(seq) % K == 0:\n            valid_sequences.append(seq)\n    \n    # Sort the valid sequences in lexicographical order\n    valid_sequences.sort()\n    \n    return valid_sequences\n\ndef main():\n    N, K = map(int, input().split())\n    R = list(map(int, input().split()))\n    \n    sequences = find_sequences(N, K, R)\n    \n    # Print the result\n    print(len(sequences))\n    for seq in sequences:\n        print(\" \".join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_g",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def process_queries(N, A, B, queries):\n        n = len(queries)\n        A = [0] + A  # Add a dummy element at the beginning for easier indexing\n        B = [0] + B  # Add a dummy element at the beginning for easier indexing\n        updates_A = []\n        updates_B = []\n\n        def update_A(i, x):\n            if i > 0:\n                updates_A.append((i, x))\n\n        def update_B(i, x):\n            if i > 0:\n                updates_B.append((i, x))\n\n        def apply_updates_A():\n            nonlocal A\n            for i, x in updates_A:\n                A[i] = x\n\n        def apply_updates_B():\n            nonlocal B\n            for i, x in updates_B:\n                B[i] = x\n\n        def solve_query(l, r):\n            apply_updates_A()\n            apply_updates_B()\n\n            max_v = 0\n            current_v = 0\n            for i in range(l, r + 1):\n                add = A[i]\n                mul = B[i]\n                if current_v * mul > current_v + add:\n                    current_v *= mul\n                else:\n                    current_v += add\n                max_v = max(max_v, current_v)\n            return max_v\n\n        i = 0\n        while i < n:\n            t, *args = queries[i]\n            if t == 1:\n                update_A(*args)\n            elif t == 2:\n                update_B(*args)\n            else:\n                l, r = args\n                print(solve_query(l, r))\n            i += 1\n\n    N = data[0]\n    A = data[1:N + 1]\n    B = data[N + 1:2 * N + 1]\n    Q = data[2 * N + 1]\n    queries = [(data[2 * N + 2 + 4 * i], data[2 * N + 3 + 4 * i], data[2 * N + 4 + 4 * i], data[2 * N + 5 + 4 * i]) for i in range(Q)]\n    process_queries(N, A, B, queries)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_a",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    cards = list(map(int, input().split()))\n\n    # Take K cards from the bottom and place them on top\n    bottom_cards = cards[-K:]\n    top_cards = cards[:-K]\n    new_stack = bottom_cards + top_cards\n\n    # Print the result\n    print(\" \".join(map(str, new_stack)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    operations = 0\n    \n    while len([x for x in A if x > 0]) > 1:\n        A.sort(reverse=True)\n        A[0] -= 1\n        A[1] -= 1\n        operations += 1\n    \n    print(operations)"
        ]
    },
    {
        "question_id": "abc368_f",
        "code_list": [
            "def main():\n    import math\n    \n    def count_divisors(n):\n        count = 0\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                if i * i == n:\n                    count += 1\n                else:\n                    count += 2\n        return count\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    xor_result = 0\n    for num in A:\n        xor_result ^= count_divisors(num)\n    \n    if xor_result != 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def calculate_attacks(healths):\n        total_attacks = 0\n        for health in healths:\n            if health % 3 == 0:\n                total_attacks += health // 3\n            else:\n                total_attacks += (health // 3) + 1\n        return total_attacks\n    \n    N = int(input())\n    healths = list(map(int, input().split()))\n    \n    result = calculate_attacks(healths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_d",
        "code_list": [
            "def find_min_vertices(N, K, edges, V):\n    # Build the adjacency list for the tree\n    adj_list = {i: [] for i in range(1, N + 1)}\n    for a, b in edges:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    # Function to perform DFS and return the farthest node and its distance\n    def dfs(node, parent, dist):\n        farthest_node = node\n        max_dist = dist\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                new_dist, new_farthest_node = dfs(neighbor, node, dist + 1)\n                if new_dist > max_dist:\n                    max_dist = new_dist\n                    farthest_node = new_farthest_node\n        return max_dist, farthest_node\n\n    # Find the first farthest node from V[0]\n    _, farthest_node = dfs(V[0], -1, 0)\n\n    # Find the second farthest node from the first farthest node\n    _, second_farthest_node = dfs(farthest_node, -1, 0)\n\n    # Calculate the minimum number of vertices needed\n    min_vertices = max(K, len(set(V).intersection({farthest_node, second_farthest_node})))\n\n    return min_vertices\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    V = list(map(int, input().split()))\n    print(find_min_vertices(N, K, edges, V))"
        ]
    },
    {
        "question_id": "abc368_e",
        "code_list": [
            "import heapq\n\ndef main():\n    N, M, X1 = map(int, input().split())\n    edges = [[] for _ in range(N)]\n    for _ in range(M):\n        A, B, S, T = map(int, input().split())\n        A -= 1\n        B -= 1\n        edges[A].append((B, T - S))\n    \n    def dijkstra(start):\n        dist = [float('inf')] * N\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in edges[u]:\n                if dist[v] > dist[u] + w + X1:\n                    dist[v] = dist[u] + w + X1\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n    \n    # Calculate the minimum delays for each train\n    delays = []\n    for i in range(M):\n        A, B, S, T = map(int, input().split())\n        A -= 1\n        B -= 1\n        dist = dijkstra(B)\n        delays.append(dist[A])\n    \n    # Find the maximum delay among all trains\n    max_delay = max(delays)\n    \n    # Adjust the delays to ensure the minimum possible sum\n    for i in range(M):\n        delays[i] = max(0, max_delay - delays[i])\n    \n    print(*delays[1:])"
        ]
    },
    {
        "question_id": "abc369_d",
        "code_list": [
            "def max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    strengths = list(map(int, data[1:n+1]))\n    even_sum = sum(strengths[i] for i in range(0, n, 2))\n    odd_sum = sum(strengths[i] for i in range(1, n, 2))\n    \n    dp = [0] * (n + 1)\n    dp[1] = strengths[0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            dp[i] = max(dp[i-1], dp[i-2] + strengths[i-1] + strengths[i-1])\n        else:\n            dp[i] = max(dp[i-1], dp[i-2] + strengths[i-1])\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    print(max_experience_points())"
        ]
    },
    {
        "question_id": "abc369_g",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    def solve():\n        n = int(input())\n        edges = []\n        for _ in range(n - 1):\n            u, v, l = map(int, input().split())\n            edges.append((u - 1, v - 1, l))\n        \n        # Build the tree\n        tree = defaultdict(list)\n        for u, v, l in edges:\n            tree[u].append((v, l))\n            tree[v].append((u, l))\n        \n        # Function to calculate the diameter and the two farthest nodes\n        def dfs(node, parent, distance):\n            max_dist = (node, distance)\n            for neighbor, length in tree[node]:\n                if neighbor != parent:\n                    new_dist = distance + length\n                    candidate = dfs(neighbor, node, new_dist)\n                    if candidate[1] > max_dist[1]:\n                        max_dist = candidate\n            return max_dist\n        \n        # Calculate the diameter\n        start_node, _ = dfs(0, -1, 0)\n        _, diameter = dfs(start_node, -1, 0)\n        \n        # Calculate the longest path from the start node to any leaf\n        def longest_path(node, parent):\n            max_path = 0\n            for neighbor, length in tree[node]:\n                if neighbor != parent:\n                    path = longest_path(neighbor, node) + length\n                    max_path = max(max_path, path)\n            return max_path\n        \n        longest_paths = [longest_path(node, -1) for node in range(n)]\n        longest_path_from_start = max(longest_paths)\n        \n        # Calculate the optimal score for each K\n        optimal_scores = [diameter]\n        for i in range(1, n):\n            optimal_scores.append(diameter + 2 * max(longest_path_from_start - longest_paths[i], 0))\n        \n        for score in optimal_scores:\n            print(score)\n    \n    solve()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc369_c",
        "code_list": [
            "def count_arithmetic_progressions(N, A):\n    def count_subarray(i, j):\n        if i == j:\n            return 1\n        d = A[i + 1] - A[i]\n        k = i + 1\n        while k < j and A[k + 1] - A[k] == d:\n            k += 1\n        return k - i + 1\n\n    total_count = 0\n    for i in range(N):\n        for j in range(i, N):\n            if count_subarray(i, j) > 1:\n                total_count += 1\n    return total_count\n\ndef main():\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(count_arithmetic_progressions(N, A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc369_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    count = 0\n    \n    # Calculate the possible values of x based on the arithmetic sequence condition\n    if A != B:\n        # Case 1: A, B, x form an arithmetic sequence with common difference (B - A)\n        x1 = 2 * B - A\n        x2 = 2 * A - B\n        \n        # Case 2: A, x, B form an arithmetic sequence with common difference (B - A)\n        x3 = 2 * A - B\n        \n        # Case 3: B, A, x form an arithmetic sequence with common difference (A - B)\n        x4 = 2 * B - A\n        \n        # Case 4: B, x, A form an arithmetic sequence with common difference (A - B)\n        x5 = 2 * B - A\n        \n        # Case 5: x, A, B form an arithmetic sequence with common difference (B - A)\n        x6 = 2 * B - A\n        \n        # Case 6: x, B, A form an arithmetic sequence with common difference (A - B)\n        x7 = 2 * A - B\n        \n        # Collect unique valid x values within the range [1, 100]\n        valid_x = {x1, x2, x3, x4, x5, x6, x7}\n        valid_x = {x for x in valid_x if 1 <= x <= 100}\n        \n        count = len(valid_x)\n    else:\n        # If A == B, the only valid x is A or B itself\n        count = 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc369_b",
        "code_list": [
            "def min_fatigue_level():\n    import sys\n    \n    def read_input():\n        return sys.stdin.readline().strip()\n    \n    def read_int():\n        return int(read_input())\n    \n    def read_ints():\n        return list(map(int, read_input().split()))\n    \n    def read_string():\n        return read_input().strip()\n    \n    def read_strings():\n        return read_input().split()\n    \n    def calculate_fatigue(hand_positions, moves):\n        fatigue = 0\n        for move in moves:\n            key, hand = move\n            if hand == 'L':\n                if hand_positions[0] != key:\n                    fatigue += abs(key - hand_positions[0])\n                    hand_positions[0] = key\n            else:\n                if hand_positions[1] != key:\n                    fatigue += abs(key - hand_positions[1])\n                    hand_positions[1] = key\n        return fatigue\n    \n    N = read_int()\n    moves = []\n    for _ in range(N):\n        A, S = read_strings()\n        moves.append((read_int(), S))\n    \n    # Initial positions for hands\n    hand_positions = [1, 100]\n    \n    # Calculate initial fatigue\n    initial_fatigue = calculate_fatigue(hand_positions, moves)\n    \n    # Try all possible initial positions for hands\n    min_fatigue = initial_fatigue\n    for left in range(1, 101):\n        for right in range(1, 101):\n            if left != right:\n                hand_positions = [left, right]\n                fatigue = calculate_fatigue(hand_positions, moves)\n                min_fatigue = min(min_fatigue, fatigue)\n    \n    print(min_fatigue)\n\nif __name__ == \"__main__\":\n    min_fatigue_level()"
        ]
    },
    {
        "question_id": "abc369_e",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, end, used_edges):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if u == end:\n            return d\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if (u, v) in used_edges or (v, u) in used_edges:\n                continue\n            new_dist = d + w\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n    return float('inf')\n\ndef solve(N, M, edges, Q, queries):\n    graph = defaultdict(list)\n    for u, v, t in edges:\n        graph[u-1].append((v-1, t))\n        graph[v-1].append((u-1, t))\n    \n    def min_time(query):\n        used_edges = set()\n        for edge in query:\n            used_edges.add((edge, edges[edge-1][0]))\n            used_edges.add((edge, edges[edge-1][1]))\n        \n        min_dist = dijkstra(graph, 0, N-1, used_edges)\n        return min_dist\n    \n    result = []\n    for query in queries:\n        result.append(min_time(query))\n    \n    return result\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        u, v, t = map(int, input().split())\n        edges.append((u, v, t))\n    \n    Q = int(input())\n    queries = []\n    for _ in range(Q):\n        K = int(input())\n        query = list(map(int, input().split()))\n        queries.append(query)\n    \n    result = solve(N, M, edges, Q, queries)\n    for r in result:\n        print(r)"
        ]
    },
    {
        "question_id": "abc370_a",
        "code_list": [
            "def main():\n    L, R = map(int, input().split())\n    if (L + R) == 1:\n        print(\"Yes\")\n    elif (L + R) == 2:\n        print(\"Invalid\")\n    else:\n        print(\"Invalid\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_g",
        "code_list": [
            "from math import sqrt\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef divisor_sum(n):\n    \"\"\"Return the sum of divisors of n.\"\"\"\n    total = 1\n    for i in range(2, int(sqrt(n)) + 1):\n        count = 0\n        while n % i == 0:\n            n //= i\n            count += 1\n        if count > 0:\n            total *= (i**(count+1) - 1) // (i - 1)\n    if n > 1:\n        total *= (n + 1)\n    return total\n\ndef is_good_integer(n):\n    \"\"\"Check if the sum of divisors of n is divisible by 3.\"\"\"\n    return divisor_sum(n) % 3 == 0\n\n@lru_cache(None)\ndef count_good_sequences(n, m):\n    \"\"\"Count the number of good sequences of length m with product <= n.\"\"\"\n    if m == 1:\n        return sum(is_good_integer(i) for i in range(1, n + 1))\n    total = 0\n    for i in range(1, n + 1):\n        if is_good_integer(i):\n            total += count_good_sequences(n // i, m - 1)\n    return total % MOD\n\ndef main():\n    N, M = map(int, input().split())\n    print(count_good_sequences(N, M))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_c",
        "code_list": [
            "def main():\n    # Read input strings S and T\n    S = input().strip()\n    T = input().strip()\n\n    # Initialize the result array X\n    X = []\n\n    # Iterate through each character position\n    for i in range(len(S)):\n        # If the characters at the current position do not match\n        if S[i] != T[i]:\n            # Append the necessary changes to S to make it match T up to the current position\n            X.append(S[:i] + T[i])\n            # Update S to match the current state\n            S = S[:i] + T[i]\n\n    # Output the number of elements in X\n    print(len(X))\n    # Output each element of X\n    for x in X:\n        print(x)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    H, W, Q = map(int, input().split())\n    walls = defaultdict(list)\n    \n    for _ in range(Q):\n        R, C = map(int, input().split())\n        R -= 1\n        C -= 1\n        \n        # Check if there's a wall at (R, C)\n        if walls[R][C] == -1:\n            continue\n        \n        # Destroy walls in the current row and column\n        for c in range(W):\n            if walls[R][c] != -1:\n                walls[R][c] = -1\n        for r in range(H):\n            if walls[r][C] != -1:\n                walls[r][C] = -1\n        \n        # Update the positions of the remaining walls\n        for c in range(C + 1, W):\n            if walls[R][c] != -1:\n                walls[R][c] = max(walls[R][c], C + 1)\n        for c in range(C - 1, -1, -1):\n            if walls[R][c] != -1:\n                walls[R][c] = min(walls[R][c], C - 1)\n        for r in range(R + 1, H):\n            if walls[r][C] != -1:\n                walls[r][C] = max(walls[r][C], R + 1)\n        for r in range(R - 1, -1, -1):\n            if walls[r][C] != -1:\n                walls[r][C] = min(walls[r][C], R - 1)\n        \n        # Place the bomb at (R, C)\n        walls[R][C] = -1\n    \n    # Count the remaining walls\n    remaining_walls = 0\n    for r in range(H):\n        for c in range(W):\n            if walls[r][c] != -1:\n                remaining_walls += 1\n    \n    print(remaining_walls)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_e",
        "code_list": [
            "from collections import defaultdict\n\ndef count_divisions(N, K, A):\n    mod = 998244353\n    dp = [1] + [0] * (N)\n    \n    # Precompute prefix sums\n    prefix_sums = [0]\n    for num in A:\n        prefix_sums.append(prefix_sums[-1] + num)\n    \n    # Dictionary to store the first occurrence of each prefix sum\n    prefix_sum_indices = defaultdict(lambda: -1)\n    prefix_sum_indices[0] = 0\n    \n    for i in range(1, N + 1):\n        current_sum = prefix_sums[i]\n        \n        # Check if there exists a subsequence sum equal to K\n        if current_sum - K in prefix_sum_indices:\n            dp[i] = 0\n        \n        # Update the dictionary with the current prefix sum\n        prefix_sum_indices[current_sum] = i\n    \n    # Calculate the total number of valid divisions\n    total_divisions = pow(2, N - 1, mod)\n    invalid_divisions = 0\n    \n    for i in range(1, N + 1):\n        invalid_divisions += dp[i - 1] * dp[N - i + 1]\n        invalid_divisions %= mod\n    \n    return (total_divisions - invalid_divisions) % mod\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(count_divisions(N, K, A))"
        ]
    },
    {
        "question_id": "abc370_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def parse_input():\n        return [line.strip() for line in sys.stdin.readlines()]\n    \n    def combine_elements(element, new_element):\n        return min(element, new_element)\n    \n    N = int(parse_input()[0])\n    A = []\n    for i in range(1, N + 1):\n        row = list(map(int, parse_input()[i].split()))\n        A.append(row)\n    \n    current_element = 1\n    for i in range(N):\n        current_element = combine_elements(current_element, A[i][i] if i >= 1 else A[i][0])\n    \n    print(current_element)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_f",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Calculate prefix sums\n    prefix_sum = [0]\n    for a in A:\n        prefix_sum.append(prefix_sum[-1] + a)\n\n    # Initialize variables\n    min_weight = float('inf')\n    cut_lines_never_cut = 0\n\n    # Iterate over possible starting points for each person\n    for start in range(K):\n        current_weight = 0\n        last_cut_line = -1\n        for end in range(start, N + 1):\n            # Calculate weight of current piece\n            weight = prefix_sum[end + 1] - prefix_sum[start]\n\n            # Update minimum weight\n            if current_weight + weight < min_weight:\n                min_weight = current_weight + weight\n                cut_lines_never_cut = 0\n\n            # Check if we need to make a cut\n            if current_weight + weight > min_weight:\n                # Update last cut line\n                last_cut_line = end\n                current_weight += weight\n\n        # Check if the last cut line was never cut\n        if last_cut_line != N:\n            cut_lines_never_cut += 1\n\n    # Output result\n    print(min_weight, cut_lines_never_cut)"
        ]
    },
    {
        "question_id": "abc371_b",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    families = [False] * N  # Track if a family has had its earliest born male child named Taro\n    result = []\n\n    for _ in range(M):\n        A, B = map(str, input().split())\n        A = int(A) - 1  # Convert family index to zero-based index\n\n        if B == 'M':\n            if not families[A]:  # If this is the first male child in the family\n                families[A] = True\n                result.append('Yes')\n            else:\n                result.append('No')\n        else:  # B == 'F'\n            result.append('No')\n\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    x_coords = list(map(int, data[1:n+1]))\n    p_values = list(map(int, data[n+1:2*n+1]))\n    q = int(data[2*n+1])\n\n    # Create a prefix sum array for the number of villagers\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + p_values[i]\n\n    # Process each query\n    for _ in range(q):\n        l, r = map(int, data[2*n+2:])\n        left_index = bisect_left(x_coords, l)\n        right_index = bisect_right(x_coords, r)\n        result = prefix_sum[right_index] - prefix_sum[left_index]\n        print(result)\n\nimport bisect\nfrom bisect import bisect_left, bisect_right"
        ]
    },
    {
        "question_id": "abc371_g",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_cycle(start, permutation):\n        cycle = []\n        current = start\n        while True:\n            cycle.append(current)\n            next_pos = permutation[current - 1]\n            if next_pos == start:\n                break\n            current = next_pos\n        return cycle\n    \n    def apply_permutation(cycle, array):\n        new_array = list(array)\n        for i, pos in enumerate(cycle):\n            new_array[pos - 1] = array[cycle[(i + 1) % len(cycle)] - 1]\n        return new_array\n    \n    n = int(input())\n    permutation = list(map(int, input().split()))\n    array = list(map(int, input().split()))\n    \n    cycles = []\n    used = [False] * (n + 1)\n    \n    for i in range(1, n + 1):\n        if not used[i]:\n            cycle = find_cycle(i, permutation)\n            cycles.append(cycle)\n            used[cycle[0]] = True\n            for pos in cycle[1:]:\n                used[pos] = True\n    \n    result = array[:]\n    for cycle in cycles:\n        result = apply_permutation(cycle, result)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_f",
        "code_list": [
            "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x_coords = list(map(int, data[1:n+1]))\n    q = int(data[n+1])\n    tasks = [(int(data[i*2+n+2]), int(data[i*2+n+3])) for i in range(q)]\n    \n    def get_moves(x, g):\n        if x <= g:\n            return g - x\n        else:\n            return x + (2 * (x_coords[-1] - x) + 1) - g\n    \n    prefix_sum = [0]\n    for x in x_coords:\n        prefix_sum.append(prefix_sum[-1] + x)\n    \n    result = 0\n    for t, g in tasks:\n        target_x = x_coords[t-1]\n        result += get_moves(target_x, g)\n        for i in range(t-1):\n            result += abs(g - x_coords[i]) - abs(target_x - x_coords[i])\n        for i in range(t+1, len(x_coords)+1):\n            result += abs(g - x_coords[i-1]) - abs(target_x - x_coords[i-1])\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_c",
        "code_list": [
            "import itertools\nfrom collections import defaultdict\n\ndef min_cost_to_isomorph(G_edges, H_edges, costs):\n    N = len(costs)\n    \n    # Convert edge lists to adjacency matrices\n    G_adj = [[0] * N for _ in range(N)]\n    for u, v in G_edges:\n        G_adj[u-1][v-1] = 1\n        G_adj[v-1][u-1] = 1\n    \n    H_adj = [[0] * N for _ in range(N)]\n    for a, b in H_edges:\n        H_adj[a-1][b-1] = 1\n        H_adj[b-1][a-1] = 1\n    \n    # Function to check if two graphs are isomorphic\n    def is_isomorphic(G, H):\n        if len(G) != len(H):\n            return False\n        for perm in itertools.permutations(range(len(G))):\n            if all(G[i][j] == H[perm[i]][perm[j]] for i in range(len(G)) for j in range(i+1, len(G))):\n                return True\n        return False\n    \n    # Function to calculate the cost of making H isomorphic to G\n    def calc_cost(G, H):\n        cost = 0\n        for i, j in itertools.combinations(range(N), 2):\n            if H[i][j] != G[i][j]:\n                cost += costs[i][j]\n        return cost\n    \n    # Check if G and H are already isomorphic\n    if is_isomorphic(G_adj, H_adj):\n        return 0\n    \n    # Find the minimum cost to make G and H isomorphic\n    min_cost = float('inf')\n    for perm in itertools.permutations(range(N)):\n        H_perm = [[H_adj[perm[i]][perm[j]] for j in range(N)] for i in range(N)]\n        min_cost = min(min_cost, calc_cost(G_adj, H_perm))\n    \n    return min_cost\n\ndef main():\n    N = int(input())\n    MG = int(input())\n    G_edges = [tuple(map(int, input().split())) for _ in range(MG)]\n    MH = int(input())\n    H_edges = [tuple(map(int, input().split())) for _ in range(MH)]\n    costs = [list(map(int, input().split())) for _ in range(N-1)]\n    for row in costs:\n        row.append(0)\n    \n    result = min_cost_to_isomorph(G_edges, H_edges, costs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Initialize the result\n    result = 0\n    \n    # Dictionary to store the last occurrence of each value\n    last_occurrence = defaultdict(lambda: -1)\n    \n    # Array to store the prefix sum of the number of distinct elements seen so far\n    prefix_sum = [0] * (N + 1)\n    \n    for i, a in enumerate(A):\n        # Update the prefix sum with the number of distinct elements up to index i\n        prefix_sum[i + 1] = prefix_sum[i] + (last_occurrence[a] == -1)\n        \n        # Update the last occurrence of the current element\n        last_occurrence[a] = i\n        \n        # Calculate the contribution of the current element to the result\n        result += prefix_sum[i + 1]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_a",
        "code_list": [
            "def main():\n    S_AB, S_AC, S_BC = input().split()\n    \n    # Determine the age order based on the given inequalities\n    if S_AB == '<' and S_AC == '<':\n        if S_BC == '<':\n            # A < B < C\n            print('C')\n        else:\n            # A < B > C\n            print('B')\n    elif S_AB == '<' and S_AC == '>':\n        # A < C < B\n        print('B')\n    elif S_AB == '>' and S_AC == '<':\n        # A > C < B\n        print('B')\n    elif S_AB == '>' and S_AC == '>':\n        if S_BC == '<':\n            # A > B < C\n            print('B')\n        else:\n            # A > B > C\n            print('A')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_e",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef main():\n    N, Q = map(int, input().split())\n    adj_list = defaultdict(list)\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            u, v = query[1], query[2]\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        else:\n            v, k = query[1], query[2]\n            connected_vertices = adj_list[v]\n            if len(connected_vertices) < k:\n                print(-1)\n            else:\n                # Use a min heap to get the k-th largest element efficiently\n                min_heap = []\n                for vertex in connected_vertices:\n                    heapq.heappush(min_heap, vertex)\n                    if len(min_heap) > k:\n                        heapq.heappop(min_heap)\n                print(min_heap[0])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_c",
        "code_list": [
            "def count_substring_occurrences(s, target):\n    count = 0\n    for i in range(len(s) - len(target) + 1):\n        if s[i:i+len(target)] == target:\n            count += 1\n    return count\n\ndef main():\n    N, Q = map(int, input().split())\n    S = input().strip()\n    current_count = count_substring_occurrences(S, \"ABC\")\n    \n    for _ in range(Q):\n        Xi, Ci = input().split()\n        Xi = int(Xi)\n        \n        # Check if the replacement changes the substring count\n        if S[Xi-1] == Ci:\n            # No change in the substring count\n            pass\n        elif S[Xi-1] == 'A' and Ci == 'C':\n            # Decrease count if the previous character was 'A' and the next character is 'B'\n            if Xi < N and S[Xi] == 'B':\n                current_count -= 1\n            # Increase count if the previous character was 'A' and the next character is 'B'\n            if Xi > 1 and S[Xi-2] == 'B':\n                current_count += 1\n        elif S[Xi-1] == 'B' and Ci == 'C':\n            # Decrease count if the previous character was 'B' and the next character is 'C'\n            if Xi < N and S[Xi] == 'C':\n                current_count -= 1\n            # Increase count if the previous character was 'B' and the next character is 'C'\n            if Xi > 1 and S[Xi-2] == 'C':\n                current_count += 1\n        elif S[Xi-1] == 'C' and Ci == 'A':\n            # Decrease count if the previous character was 'C' and the next character is 'B'\n            if Xi < N and S[Xi] == 'B':\n                current_count -= 1\n            # Increase count if the previous character was 'C' and the next character is 'B'\n            if Xi > 1 and S[Xi-2] == 'B':\n                current_count += 1\n        \n        # Perform the replacement\n        S = S[:Xi-1] + Ci + S[Xi:]\n        \n        # Print the current count of \"ABC\" substrings\n        print(current_count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_d",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_next_taller(heights):\n        stack = []\n        next_taller = [0] * len(heights)\n        for i, height in enumerate(heights):\n            while stack and heights[stack[-1]] < height:\n                next_taller[stack.pop()] = i\n            stack.append(i)\n        return next_taller\n    \n    n = int(input())\n    heights = list(map(int, input().split()))\n    \n    next_taller = find_next_taller(heights)\n    result = []\n    for i in range(n):\n        if next_taller[i] == 0:\n            result.append(0)\n        else:\n            result.append(next_taller[i] - i - 1)\n    \n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_g",
        "code_list": [
            "from math import gcd\n\ndef solve_case(N, AB):\n    # Calculate the GCD of all A_i and B_i\n    g = AB[0][0]\n    for i in range(1, N):\n        g = gcd(g, AB[i][0])\n    \n    # If the GCD is greater than any C_i, no solution exists\n    if g > max([c for _, _, c in AB]):\n        return 0\n    \n    # Sort AB based on the ratio of A_i / B_i\n    AB.sort(key=lambda x: x[0] / x[1])\n    \n    # Initialize variables\n    ans = 0\n    y_max = 0\n    for i in range(N):\n        # Calculate the maximum y for the current pair\n        y_max = min(y_max, (AB[i][2] - 1) // AB[i][1])\n        # Calculate the number of valid x for the current y_max\n        ans += y_max // g\n    \n    return ans\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        AB = [tuple(map(int, input().split())) for _ in range(N)]\n        print(solve_case(N, AB))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_f",
        "code_list": [
            "MOD = 998244353\n\ndef solve(N, M, K, edges):\n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N)]\n    dp[0][0] = 1\n    \n    # Process the circular edges first\n    for k in range(K):\n        for i in range(N):\n            if i == 0:\n                dp[i][k + 1] = (dp[i][k] + dp[(i + 1) % N][k]) % MOD\n            else:\n                dp[i][k + 1] = (dp[i][k] + dp[i - 1][k]) % MOD\n    \n    # Process the additional edges\n    for x, y in edges:\n        for k in range(K):\n            dp[x - 1][k + 1] = (dp[x - 1][k + 1] + dp[y - 1][k]) % MOD\n    \n    return sum(dp[i][K] for i in range(N)) % MOD\n\nif __name__ == \"__main__\":\n    N, M, K = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    print(solve(N, M, K, edges))"
        ]
    },
    {
        "question_id": "abc372_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = S.replace('.', '')\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_a",
        "code_list": [
            "def main():\n    count = 0\n    for i in range(1, 13):\n        S_i = input().strip()\n        if len(S_i) == i:\n            count += 1\n    print(count)"
        ]
    },
    {
        "question_id": "abc373_b",
        "code_list": [
            "def calculate_min_distance(S):\n    # Initialize the starting position of the finger\n    current_position = 0\n    total_distance = 0\n    \n    # Iterate through each character in the alphabet\n    for char in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n        # Find the position of the current character in the keyboard layout\n        target_position = S.index(char)\n        # Calculate the distance moved and add it to the total distance\n        total_distance += abs(target_position - current_position)\n        # Update the current position to the target position\n        current_position = target_position\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(calculate_min_distance(S))"
        ]
    },
    {
        "question_id": "abc373_f",
        "code_list": [
            "import heapq\n\ndef main():\n    N, W = map(int, input().split())\n    items = []\n    for _ in range(N):\n        w, v = map(int, input().split())\n        # Calculate the maximum k for each item type that fits within the weight limit\n        max_k = min(W // w, 10**10)\n        # Use a negative value for priority queue to simulate max heap\n        heapq.heappush(items, (-v * max_k + max_k ** 2, w, max_k))\n    \n    total_happiness = 0\n    knapsack = [0] * (W + 1)\n    \n    while items:\n        happiness, weight, max_k = heapq.heappop(items)\n        happiness = -happiness\n        for k in range(max_k, 0, -1):\n            if knapsack[weight * k] < W:\n                knapsack[weight * k] += weight\n                total_happiness += happiness\n                break\n    \n    print(total_happiness)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_g",
        "code_list": [
            "from typing import List, Tuple\n\ndef orientation(p: Tuple[int, int], q: Tuple[int, int], r: Tuple[int, int]) -> int:\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef do_segments_intersect(p1: Tuple[int, int], p2: Tuple[int, int], q1: Tuple[int, int], q2: Tuple[int, int]) -> bool:\n    o1 = orientation(p1, p2, q1)\n    o2 = orientation(p1, p2, q2)\n    o3 = orientation(q1, q2, p1)\n    o4 = orientation(q1, q2, p2)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef find_permutation(N: int, points: List[Tuple[int, int]], lines: List[Tuple[int, int]]) -> List[int]:\n    def dfs(index: int, path: List[int]):\n        if index == N:\n            return path\n        \n        for i in range(N):\n            if i not in used:\n                if all(not do_segments_intersect(points[path[j]], points[path[j + 1]], points[i], lines[i]) for j in range(index)):\n                    used.add(i)\n                    result = dfs(index + 1, path + [i])\n                    if result:\n                        return result\n                    used.remove(i)\n        \n        return []\n    \n    used = set()\n    return dfs(0, [])\n\ndef main():\n    N = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n    lines = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    result = find_permutation(N, points, lines)\n    if result:\n        print(\" \".join(map(str, result)))\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n = data[0]\n    a = data[1:n+1]\n    b = data[n+1:]\n    \n    max_a = max(a)\n    max_b = max(b)\n    \n    print(max_a + max_b)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_e",
        "code_list": [
            "from typing import List\n\ndef min_votes_needed(N: int, M: int, K: int, A: List[int]) -> List[int]:\n    total_votes = sum(A)\n    remaining_votes = K - total_votes\n    \n    # Calculate the maximum number of votes that can be distributed among the top (M-1) candidates\n    max_top_m_minus_one_votes = (M - 1) * (total_votes + remaining_votes + 1) // M\n    \n    result = []\n    for i in range(N):\n        current_votes = A[i]\n        # Calculate the minimum votes needed to surpass the top (M-1) candidates\n        min_votes_needed = max(0, (max_top_m_minus_one_votes - current_votes + M - 1) // M)\n        \n        # Check if the candidate can secure their victory with the remaining votes\n        if remaining_votes >= min_votes_needed:\n            result.append(min_votes_needed)\n        else:\n            result.append(-1)\n    \n    return result\n\nif __name__ == \"__main__\":\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(*min_votes_needed(N, M, K, A))"
        ]
    },
    {
        "question_id": "arc181_d",
        "code_list": [
            "def count_inversions(arr):\n    def merge_sort_and_count(start, end):\n        if start >= end:\n            return 0\n        \n        mid = (start + end) // 2\n        inversions = merge_sort_and_count(start, mid)\n        inversions += merge_sort_and_count(mid + 1, end)\n        \n        # Count inversions across the two halves\n        i, j = start, mid + 1\n        while i <= mid and j <= end:\n            if arr[i] <= arr[j]:\n                i += 1\n            else:\n                inversions += mid - i + 1\n                j += 1\n        \n        # Merge the two halves\n        temp = []\n        i, j = start, mid + 1\n        while i <= mid or j <= end:\n            if i > mid:\n                temp.append(arr[j])\n                j += 1\n            elif j > end:\n                temp.append(arr[i])\n                i += 1\n            elif arr[i] <= arr[j]:\n                temp.append(arr[i])\n                i += 1\n            else:\n                temp.append(arr[j])\n                j += 1\n        \n        arr[start:end + 1] = temp\n        return inversions\n    \n    return merge_sort_and_count(0, len(arr) - 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N + 1]))\n    M = int(data[N + 1])\n    A = list(map(int, data[N + 2:N + M + 2]))\n    \n    current_inversions = count_inversions(P)\n    print(current_inversions)\n    \n    for i in range(M):\n        k = A[i]\n        for j in range(k - 1):\n            if P[j] > P[j + 1]:\n                P[j], P[j + 1] = P[j + 1], P[j]\n                current_inversions += 1 if j < k - 1 else 0\n        print(current_inversions)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc181_c",
        "code_list": [
            "def generate_grid(N, P, Q):\n    # Initialize the grid with zeros\n    grid = [['0' for _ in range(N)] for _ in range(N)]\n    \n    # Function to update the grid based on the current state\n    def update_grid():\n        nonlocal grid\n        new_grid = [['0' for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == '0':\n                    # Try placing '0' and '1' and check if the conditions are met\n                    new_grid[i][j] = '0'\n                    if check_conditions(new_grid, P, Q):\n                        continue\n                    new_grid[i][j] = '1'\n                    if check_conditions(new_grid, P, Q):\n                        continue\n                    return False\n        grid = new_grid\n        return True\n    \n    # Function to check if the current grid meets the conditions\n    def check_conditions(grid, P, Q):\n        for i in range(N):\n            S = ''.join(grid[i])\n            T = ''.join([grid[j][i] for j in range(N)])\n            for k in range(i + 1, N):\n                if (S > ''.join(grid[P[k]-1])) or (T > ''.join([grid[Q[k]-1][i] for j in range(N)])):\n                    return False\n        return True\n    \n    # Initial check to see if the grid meets the conditions\n    if not check_conditions(grid, P, Q):\n        update_grid()\n    \n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    generate_grid(N, P, Q)"
        ]
    },
    {
        "question_id": "arc181_b",
        "code_list": [
            "def main():\n    t = int(input())\n    for _ in range(t):\n        S = input().strip()\n        X = input().strip()\n        Y = input().strip()\n        \n        # Find the first differing position between X and Y\n        diff_pos = -1\n        for i in range(min(len(X), len(Y))):\n            if X[i] != Y[i]:\n                diff_pos = i\n                break\n        \n        # If they are identical up to the length of the shorter string, check further\n        if diff_pos == -1:\n            if len(X) == len(Y):\n                print(\"Yes\")\n            else:\n                print(\"No\")\n            continue\n        \n        # Check if the differing parts of X and Y match the pattern of S\n        if X[diff_pos:] == Y[diff_pos:]:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc181_a",
        "code_list": [
            "def min_operations_to_sort(permutation):\n    n = len(permutation)\n    operations = 0\n    \n    # Iterate from the end of the list to the beginning\n    for i in range(n - 1, 0, -1):\n        if permutation[i] < permutation[i - 1]:\n            # Find the position where the current element should be inserted\n            pos = i\n            while pos > 0 and permutation[pos] < permutation[pos - 1]:\n                pos -= 1\n            \n            # Calculate the number of operations needed\n            operations += i - pos\n            # Adjust the positions based on the found insertion point\n            for j in range(i - 1, pos - 1, -1):\n                permutation[j + 1] = permutation[j]\n            permutation[pos] = permutation[i]\n    \n    return operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        permutation = list(map(int, data[index].split()))\n        index += 1\n        \n        result = min_operations_to_sort(permutation)\n        results.append(str(result))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc182_d",
        "code_list": [
            "def min_operations_to_make_good_sequences_equal(N, M, A, B):\n    def count_operations(arr1, arr2):\n        operations = 0\n        for i in range(N):\n            diff = abs(arr1[i] - arr2[i])\n            # Ensure the difference is within the bounds of modulo M\n            if diff > M // 2:\n                diff = M - diff\n            operations += diff\n        return operations\n\n    # Check if direct transformation is possible without breaking the good sequence property\n    for i in range(N):\n        if A[i] == B[i]:\n            continue\n        # Check if we can transform A[i] to B[i] without breaking the good sequence property\n        if (A[i] + 1) % M == B[i] or (A[i] - 1) % M == B[i]:\n            continue\n        else:\n            return -1\n\n    # If all checks pass, calculate the minimum operations\n    return count_operations(A, B)\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(min_operations_to_make_good_sequences_equal(N, M, A, B))"
        ]
    },
    {
        "question_id": "arc182_e",
        "code_list": [
            "def min_mod_sum(N, M, C, K, A):\n    # Calculate the minimum value for each k\n    min_values = []\n    for k in range(K):\n        min_value = min((C * k + a) % M for a in A)\n        min_values.append(min_value)\n    \n    # Sum up the minimum values\n    return sum(min_values)\n\nif __name__ == \"__main__\":\n    N, M, C, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(min_mod_sum(N, M, C, K, A))"
        ]
    },
    {
        "question_id": "arc182_a",
        "code_list": [
            "from functools import lru_cache\n\ndef main():\n    N, Q = map(int, input().split())\n    operations = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    MOD = 998244353\n    \n    @lru_cache(None)\n    def dp(i, prev):\n        if i == Q:\n            return 1\n        \n        p, v = operations[i]\n        ways = 0\n        \n        # Option 1: Replace S_1, S_2, ..., S_p with v\n        if p > 1 and prev < v:\n            ways += dp(i + 1, v)\n            ways %= MOD\n        \n        # Option 2: Replace S_p, S_{p+1}, ..., S_N with v\n        if prev < v:\n            ways += dp(i + 1, v)\n            ways %= MOD\n        \n        return ways\n    \n    print(dp(0, 0))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc182_c",
        "code_list": [
            "from math import sqrt\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef prime_factors(n):\n    i = 2\n    factors = defaultdict(int)\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] += 1\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef divisor_count(n):\n    factors = prime_factors(n)\n    count = 1\n    for exponent in factors.values():\n        count *= (exponent + 1)\n    return count % MOD\n\ndef main():\n    N, M = map(int, input().split())\n    total_score = 0\n    \n    for x in range(1, M + 1):\n        power = [0] * (N + 1)\n        for i in range(1, N + 1):\n            for j in range(i, N + 1, i):\n                power[j] += 1\n        \n        dp = [0] * (N + 1)\n        dp[0] = 1\n        for i in range(1, N + 1):\n            dp[i] = dp[i - 1] * (power[i] + 1) % MOD\n        \n        for i in range(1, N + 1):\n            total_score += dp[i] * divisor_count(x ** i)\n            total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc183_b",
        "code_list": [
            "def can_transform(A, B, K):\n    N = len(A)\n    # Create a dictionary to store the positions of each element in B\n    pos_B = {}\n    for i in range(N):\n        if B[i] not in pos_B:\n            pos_B[B[i]] = []\n        pos_B[B[i]].append(i)\n    \n    # Check if A can be transformed into B\n    for i in range(N):\n        if A[i] != B[i]:\n            # Find the closest position where B[i] appears in A\n            found = False\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[j] == B[i]:\n                    found = True\n                    break\n            if not found:\n                return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        print(can_transform(A, B, K))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc183_c",
        "code_list": [
            "from functools import lru_cache\n\ndef main():\n    N, M = map(int, input().split())\n    conditions = [tuple(map(int, input().split())) for _ in range(M)]\n    \n    @lru_cache(None)\n    def dp(index, max_val, used):\n        if index == N + 1:\n            return 1 if max_val != -1 else 0\n        \n        count = 0\n        for val in range(1, N + 1):\n            if used & (1 << val):\n                continue\n            \n            valid = True\n            for L, R, X in conditions:\n                if L <= index <= R and val == X:\n                    valid = False\n                    break\n                if L <= index <= R and val > max_val:\n                    valid = False\n                    break\n            \n            if valid:\n                count += dp(index + 1, max(max_val, val), used | (1 << val))\n        \n        return count\n    \n    print(dp(1, -1, 0) % 998244353)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc183_a",
        "code_list": [
            "from math import comb\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\ndef inverse_factorial(n, mod):\n    inv = [1] * (n + 1)\n    inv[0] = 1\n    for i in range(1, n + 1):\n        inv[i] = mod - (mod // i) * inv[mod % i] % mod\n    fact = [1] * (n + 1)\n    ifact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    ifact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n - 1, 1, -1):\n        ifact[i] = ifact[i + 1] * (i + 1) % mod\n    return fact, ifact\n\ndef choose(n, k, mod):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * ifact[k] % mod * ifact[n - k] % mod\n\ndef main():\n    N, K = map(int, input().split())\n    mod = 10**9 + 7\n    fact, ifact = inverse_factorial(max(N, K) * 2, mod)\n    \n    def count_sequences(i, prev, remaining):\n        if i == NK:\n            return 1\n        count = 0\n        for j in range(1, N + 1):\n            if j != prev and remaining[j] > 0:\n                remaining[j] -= 1\n                count += count_sequences(i + 1, j, remaining)\n                remaining[j] += 1\n        return count\n    \n    NK = N * K\n    total_sequences = count_sequences(0, 0, [K] * N)\n    target_index = (total_sequences + 1) // 2\n    \n    sequence = []\n    remaining = [K] * N\n    for i in range(NK):\n        for j in range(1, N + 1):\n            if remaining[j] > 0:\n                if i == 0 or (i > 0 and sequence[-1] != j):\n                    if target_index <= choose(sum(remaining) - (j - 1), K - remaining[j], mod):\n                        sequence.append(j)\n                        remaining[j] -= 1\n                        break\n                    else:\n                        target_index -= choose(sum(remaining) - (j - 1), K - remaining[j], mod)\n    \n    print(' '.join(map(str, sequence)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc183_d",
        "code_list": [
            "def find_leaves(n, edges):\n    # Build the adjacency list representation of the tree\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(adj_list[i]) == 1]\n\n    # Initialize the result list to store the pairs of leaves to be removed\n    result = []\n\n    # Perform the operations\n    while len(leaves) > 1:\n        u = leaves.pop()\n        v = leaves.pop()\n\n        # Calculate the distance between u and v\n        distance = 0\n        visited = [False] * (n + 1)\n        queue = [(u, 0)]\n\n        while queue:\n            node, dist = queue.pop(0)\n            if node == v:\n                distance = dist\n                break\n            visited[node] = True\n            for neighbor in adj_list[node]:\n                if not visited[neighbor]:\n                    queue.append((neighbor, dist + 1))\n\n        result.append((u, v))\n        # Update the adjacency list to reflect the removal of u and v\n        for neighbor in adj_list[u]:\n            if neighbor != v:\n                adj_list[neighbor].remove(u)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n        for neighbor in adj_list[v]:\n            if neighbor != u:\n                adj_list[neighbor].remove(v)\n                if len(adj_list[neighbor]) == 1:\n                    leaves.append(neighbor)\n\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    for i in range(1, len(data), 2):\n        edges.append((int(data[i]), int(data[i+1])))\n    \n    result = find_leaves(n, edges)\n    \n    for u, v in result:\n        print(f\"{u} {v}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "3026",
        "code_list": [
            "from typing import Set\n\nclass Solution:\n    def minimumPossibleSum(self, n: int, target: int) -> int:\n        used = set()\n        result_sum = 0\n        current_num = 1\n        \n        while len(used) < n:\n            if target - current_num not in used:\n                result_sum += current_num\n                used.add(current_num)\n            current_num += 1\n        \n        return result_sum % (10**9 + 7)"
        ]
    },
    {
        "question_id": "3543",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        count = 0\n        \n        for i in range(n):\n            zeros = 0\n            ones = 0\n            \n            for j in range(i, n):\n                if s[j] == '0':\n                    zeros += 1\n                else:\n                    ones += 1\n                \n                if zeros <= k and ones <= k:\n                    count += 1\n                else:\n                    break\n        \n        return count"
        ]
    },
    {
        "question_id": "3525",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        dp = [[0] * 2 for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            # Option 1: Continue with the current drink\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1]) + energyDrinkA[i-1]\n            dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + energyDrinkB[i-1]\n        \n        return max(dp[n][0], dp[n][1])"
        ]
    },
    {
        "question_id": "3552",
        "code_list": [
            "class Solution:\n    def largestPalindrome(self, n: int, k: int) -> str:\n        if n == 1:\n            return '9' if k != 1 else '8'\n        \n        upper_limit = 10**n - 1\n        lower_limit = 10**(n-1)\n        \n        for i in range(upper_limit, lower_limit, -1):\n            palindrome = int(str(i) + str(i)[::-1])\n            if palindrome % k == 0:\n                return str(palindrome)\n        \n        return ''"
        ]
    },
    {
        "question_id": "3555",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:\n        n = len(nums)\n        result = [0] * k\n        \n        for i in range(k):\n            min_val_index = nums.index(min(nums))\n            result[i] = nums[min_val_index] * multiplier\n            nums.pop(min_val_index)\n        \n        return result"
        ]
    },
    {
        "question_id": "3534",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def is_almost_equal(num1, num2):\n            str_num1, str_num2 = str(num1), str(num2)\n            if len(str_num1) != len(str_num2):\n                return False\n            diff_count = 0\n            for i in range(len(str_num1)):\n                if str_num1[i] != str_num2[i]:\n                    diff_count += 1\n                    if diff_count > 2:\n                        return False\n            return diff_count == 1 or (diff_count == 2 and set(str_num1) == set(str_num2))\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3553",
        "code_list": [
            "class Solution:\n    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:\n        # Function to determine the color of a square based on its coordinates\n        def get_color(col: str, row: str) -> int:\n            # Convert column letter to index (a=0, b=1, ..., h=7)\n            col_index = ord(col) - ord('a')\n            # Convert row number to index (1=0, 2=1, ..., 8=7)\n            row_index = int(row) - 1\n            # Calculate the sum of indices\n            sum_indices = col_index + row_index\n            # If the sum is even, the square is black; if odd, the square is white\n            return sum_indices % 2\n        \n        # Get the color of both squares\n        color1 = get_color(coordinate1[0], coordinate1[1])\n        color2 = get_color(coordinate2[0], coordinate2[1])\n        \n        # Check if both squares have the same color\n        return color1 == color2"
        ]
    },
    {
        "question_id": "3495",
        "code_list": [
            "import heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        results = []\n        obstacles = []\n        \n        for x, y in queries:\n            # Calculate the distance of the new obstacle from the origin\n            distance = abs(x) + abs(y)\n            \n            # Add the new obstacle to the list with its distance\n            heapq.heappush(obstacles, (distance, x, y))\n            \n            # Maintain only the k nearest obstacles\n            if len(obstacles) > k:\n                heapq.heappop(obstacles)\n            \n            # If we have at least k obstacles, get the k-th nearest one\n            if len(obstacles) == k:\n                _, _, _ = heapq.heappop(obstacles)  # Remove the actual obstacle\n                results.append(distance)\n                heapq.heappush(obstacles, (distance, x, y))  # Push it back to maintain order\n            else:\n                results.append(-1)\n        \n        return results"
        ]
    },
    {
        "question_id": "3563",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        row_sets = [set() for _ in range(rows)]\n        max_score = 0\n        \n        for col in range(cols):\n            current_values = set()\n            for row in range(rows):\n                value = grid[row][col]\n                if value not in current_values and value not in row_sets[row]:\n                    current_values.add(value)\n                    row_sets[row].add(value)\n                    max_score += value\n        \n        return max_score"
        ]
    },
    {
        "question_id": "3551",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSubarrayXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        from functools import reduce\n        from operator import xor\n        \n        def max_xor_in_range(start, end):\n            max_xor = 0\n            prefix_xor = 0\n            trie = {}\n            \n            for num in nums[start:end+1]:\n                current_node = trie\n                new_prefix_xor = prefix_xor ^ num\n                for bit in range(31, -1, -1):\n                    bit_value = (num >> bit) & 1\n                    if (bit_value ^ 1) in current_node:\n                        current_node = current_node[bit_value ^ 1]\n                        new_prefix_xor ^= (1 << bit)\n                    else:\n                        current_node = current_node[bit_value]\n                max_xor = max(max_xor, new_prefix_xor)\n                prefix_xor = new_prefix_xor\n                current_node[num % (1 << 31)] = {}\n            \n            return max_xor\n        \n        return [max_xor_in_range(l, r) for l, r in queries]"
        ]
    },
    {
        "question_id": "3567",
        "code_list": [
            "class Solution:\n    def convertDateToBinary(self, date: str) -> str:\n        year, month, day = date.split('-')\n        binary_year = bin(int(year))[2:]\n        binary_month = bin(int(month))[2:].zfill(6)\n        binary_day = bin(int(day))[2:].zfill(5)\n        return f\"{binary_year}-{binary_month}-{binary_day}\""
        ]
    },
    {
        "question_id": "3485",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxPossibleScore(self, start: List[int], d: int) -> int:\n        n = len(start)\n        # Sort the start array to process elements in increasing order\n        start.sort()\n        \n        # Initialize the minimum difference to a large value\n        min_diff = float('inf')\n        \n        # Iterate through each element in the sorted start array\n        for i in range(n):\n            # Calculate the potential score for the current element\n            potential_score = start[i] - start[0] if i == 0 else start[i] - start[i-1]\n            # Calculate the adjusted score considering the interval length d\n            adjusted_score = potential_score - d\n            \n            # Update the minimum difference\n            min_diff = min(min_diff, adjusted_score)\n        \n        # The maximum possible score is the negative of the minimum difference\n        return -min_diff"
        ]
    },
    {
        "question_id": "3528",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def findMaximumScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        \n        # Initialize variables to keep track of the maximum score\n        max_score = 0\n        stack = []\n        for i in range(n):\n            # Maintain a decreasing stack to ensure we always have the best previous jumps\n            while stack and nums[i] * (i - stack[-1][1]) >= stack[-1][0]:\n                _, idx = stack.pop()\n                max_score = max(max_score, stack[-1][0] if stack else 0 + nums[idx] * (i - idx))\n            stack.append((nums[i] * (i - stack[-1][1]) if stack else nums[i] * i, i))\n        \n        # Check the last element's contribution\n        while stack:\n            _, idx = stack.pop()\n            max_score = max(max_score, stack[-1][0] if stack else 0 + nums[idx] * (n - 1 - idx))\n        \n        return max_score"
        ]
    },
    {
        "question_id": "3560",
        "code_list": [
            "import heapq\n\nclass Solution:\n    def maxMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:\n        # Calculate the minimum moves to capture each pawn from the knight's current position\n        min_moves = []\n        for x, y in positions:\n            moves = abs(x - kx) + abs(y - ky)\n            if (x - kx) % 2 != (y - ky) % 2:\n                moves += 1\n            min_moves.append(moves)\n        \n        # Sort pawns based on the minimum moves required to capture them\n        sorted_pawns = sorted(zip(min_moves, positions), key=lambda x: x[0])\n        \n        # Initialize DP table\n        dp = [[-1] * len(positions) for _ in range(len(positions))]\n        \n        def dfs(index, taken):\n            if index >= len(positions):\n                return 0\n            if dp[index][taken] != -1:\n                return dp[index][taken]\n            \n            max_moves = 0\n            for i in range(len(positions)):\n                if not (taken & (1 << i)):\n                    # Calculate the moves to capture the current pawn and the remaining pawns\n                    moves = sorted_pawns[index][0]\n                    next_taken = taken | (1 << i)\n                    next_index = bisect_left(sorted_pawns, (moves + 1, positions[i]))\n                    max_moves = max(max_moves, moves + dfs(next_index, next_taken))\n            \n            dp[index][taken] = max_moves\n            return dp[index][taken]\n        \n        return dfs(0, 0)"
        ]
    },
    {
        "question_id": "3518",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def maxScore(self, a: List[int], b: List[int]) -> int:\n        # Create a min heap based on the absolute values of elements in b\n        min_heap = []\n        for index, value in enumerate(b):\n            heapq.heappush(min_heap, (abs(value), index))\n        \n        # Extract the 4 smallest indices from the heap\n        smallest_indices = [heapq.heappop(min_heap)[1] for _ in range(4)]\n        \n        # Sort these indices based on the actual values in b to get the largest negative values\n        smallest_indices.sort(key=lambda x: b[x])\n        \n        # Calculate the score using the chosen indices\n        score = sum(a[i] * b[index] for i, index in enumerate(smallest_indices))\n        \n        return score"
        ]
    },
    {
        "question_id": "3559",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        word_set = set(words)\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        \n        for i in range(1, len(target) + 1):\n            if target[:i] in word_set:\n                dp[i] = 1\n            else:\n                for j in range(i):\n                    if target[j:i] in word_set:\n                        dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[len(target)] if dp[len(target)] != float('inf') else -1"
        ]
    },
    {
        "question_id": "3522",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            if subarray == sorted(subarray) and all(subarray[j] + 1 == subarray[j+1] for j in range(len(subarray)-1)):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results"
        ]
    },
    {
        "question_id": "3550",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        rows, cols = [0] * m, [0] * n\n        \n        # Calculate the sum of each row and each column\n        for i in range(m):\n            for j in range(n):\n                rows[i] += board[i][j]\n                cols[j] += board[i][j]\n        \n        # Find the top 3 largest row sums and top 3 largest column sums\n        top_rows = sorted(rows, reverse=True)[:3]\n        top_cols = sorted(cols, reverse=True)[:3]\n        \n        # Calculate the maximum sum by placing rooks in non-overlapping rows and columns\n        max_sum = 0\n        for r in top_rows:\n            for c in top_cols:\n                if rows.index(r) != cols.index(c):  # Ensure non-overlapping rows and columns\n                    max_sum = max(max_sum, r + c)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3568",
        "code_list": [
            "class Solution:\n    def generateKey(self, num1: int, num2: int, num3: int) -> int:\n        # Convert numbers to strings to easily access individual digits\n        str_num1 = str(num1).zfill(4)\n        str_num2 = str(num2).zfill(4)\n        str_num3 = str(num3).zfill(4)\n        \n        # Initialize the key as a string\n        key_str = \"\"\n        \n        # Iterate through each digit position (1 to 4)\n        for i in range(4):\n            # Find the minimum digit at the current position\n            min_digit = min(int(str_num1[i]), int(str_num2[i]), int(str_num3[i]))\n            # Append the minimum digit to the key string\n            key_str += str(min_digit)\n        \n        # Convert the key string to an integer and return, removing leading zeros\n        return int(key_str.lstrip('0'))"
        ]
    },
    {
        "question_id": "3540",
        "code_list": [
            "class Solution:\n    def stringHash(self, s: str, k: int) -> str:\n        result = \"\"\n        for i in range(0, len(s), k):\n            substring = s[i:i+k]\n            hash_sum = sum((ord(char) - ord('a')) for char in substring)\n            hashedChar = hash_sum % 26\n            result += chr(hashedChar + ord('a'))\n        return result"
        ]
    },
    {
        "question_id": "3548",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def countGoodIntegers(self, n: int, k: int) -> int:\n        # Helper function to calculate the number of k-palindromic numbers with given digit constraints\n        def count_k_palindromes(digit_count, k):\n            if digit_count == 1:\n                return 0 if k == 1 else 1\n            \n            half_count = digit_count // 2\n            full_count = (digit_count + 1) // 2\n            total = 0\n            \n            # Counting valid combinations for the first half\n            for i in range(1, 10):\n                if i % k == 0 or (digit_count % 2 == 1 and i == 1):\n                    total += comb(half_count - 1, i - 1)\n            \n            # Adjusting for even length palindromes\n            if digit_count % 2 == 0:\n                return total * 9 ** (full_count - 1)\n            \n            # Adjusting for odd length palindromes\n            return total * 9 ** (half_count - 1) * 9\n        \n        # Main logic to count good integers\n        if n == 1:\n            return 2 if k == 1 else 1\n        \n        total_good_integers = 0\n        for i in range(1, 10):\n            if i % k == 0:\n                total_good_integers += count_k_palindromes(n, k)\n        \n        return total_good_integers"
        ]
    },
    {
        "question_id": "3531",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minDamage(self, power: int, damage: List[int], health: List[int]) -> int:\n        n = len(damage)\n        # Calculate the total damage each enemy can do before they are defeated\n        total_damage = [(health[i] // damage[i]) * damage[i] + max(0, health[i] % damage[i]) for i in range(n)]\n        # Calculate the remaining health after the initial damage\n        remaining_health = [health[i] - total_damage[i] for i in range(n)]\n        # Sort enemies based on their total damage in descending order\n        sorted_enemies = sorted(range(n), key=lambda x: total_damage[x], reverse=True)\n        total_damage_dealt_to_bob = 0\n        \n        for i in range(n):\n            if power >= total_damage[sorted_enemies[i]]:\n                # If Bob's power is enough to defeat the enemy with full power\n                total_damage_dealt_to_bob += total_damage[sorted_enemies[i]]\n                power -= total_damage[sorted_enemies[i]]\n            else:\n                # If Bob's power is not enough to defeat the enemy with full power\n                rounds = remaining_health[sorted_enemies[i]] // power\n                total_damage_dealt_to_bob += rounds * power\n                if remaining_health[sorted_enemies[i]] % power != 0:\n                    total_damage_dealt_to_bob += power\n                break\n        \n        return total_damage_dealt_to_bob"
        ]
    },
    {
        "question_id": "3558",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        def is_safe(x, y, current_health):\n            return 0 <= x < m and 0 <= y < n and (grid[x][y] == 0 or current_health > grid[x][y])\n        \n        def dfs(x, y, current_health):\n            if not is_safe(x, y, current_health):\n                return False\n            if (x, y) == (m - 1, n - 1):\n                return current_health - grid[m - 1][n - 1] >= 1\n            temp = grid[x][y]\n            grid[x][y] = -1  # Mark as visited\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if dfs(nx, ny, max(current_health - temp - 1, 1)):\n                    return True\n            grid[x][y] = temp  # Restore the cell value\n            return False\n        \n        return dfs(0, 0, health)"
        ]
    },
    {
        "question_id": "3575",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def maxValue(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] * (n // 2 + 1)\n        max_heap = []\n        \n        for i in range(n):\n            for j in range(k, 0, -1):\n                if i >= 2 * j - 1:\n                    val = dp[j - 1]\n                    if i - 2 * j + 1 >= 0:\n                        val |= nums[i - 2 * j + 1]\n                    else:\n                        val |= 0\n                    if i - j >= 0:\n                        val ^= nums[i - j]\n                    else:\n                        val ^= 0\n                    heapq.heappush(max_heap, -val)\n                    if len(max_heap) > j:\n                        heapq.heappop(max_heap)\n            dp[k] = -max_heap[0]\n        return dp[k]"
        ]
    },
    {
        "question_id": "3571",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def maxPathLength(self, coordinates: List[List[int]], k: int) -> int:\n        @lru_cache(None)\n        def dp(i):\n            if i == len(points):\n                return 0\n            max_length = 0\n            for j in range(i, len(points)):\n                if points[j][0] > points[i][0] and points[j][1] > points[i][1]:\n                    max_length = max(max_length, 1 + dp(j))\n            return max_length\n        \n        points = sorted(coordinates, key=lambda x: (x[0], x[1]))\n        k = points.index(coordinates[k])\n        return dp(k)"
        ]
    },
    {
        "question_id": "3541",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:\n        banned_set = set(bannedWords)\n        count = 0\n        for word in message:\n            if word in banned_set:\n                count += 1\n                if count >= 2:\n                    return True\n        return False"
        ]
    },
    {
        "question_id": "3496",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        # Calculate the total time each worker can contribute to reducing the mountain height\n        total_times = []\n        for time in workerTimes:\n            current_time = time\n            total_time = 0\n            while current_time <= mountainHeight:\n                total_time += current_time\n                current_time *= 2\n            heapq.heappush(total_times, -total_time)\n        \n        # Sum up the maximum times from all workers\n        result = 0\n        while total_times:\n            result = max(result, -heapq.heappop(total_times))\n        \n        return result"
        ]
    },
    {
        "question_id": "3573",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        count_word2 = Counter(word2)\n        valid_count = 0\n        \n        for i in range(len1 - len2 + 1):\n            if word1[i] == word2[0]:\n                temp_count = count_word2.copy()\n                for j in range(i, i + len2):\n                    if temp_count[word1[j]] > 0:\n                        temp_count[word1[j]] -= 1\n                    else:\n                        break\n                else:\n                    valid_count += 1\n        \n        return valid_count"
        ]
    },
    {
        "question_id": "3600",
        "code_list": [
            "class Solution:\n    def kthCharacter(self, k: int) -> str:\n        word = \"a\"\n        while len(word) < k:\n            word += chr((ord(word[-1]) - ord('a') + 1) % 26 + ord('a'))\n        return word[k-1]"
        ]
    },
    {
        "question_id": "3570",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def countOfSubstrings(self, word: str, k: int) -> int:\n        vowels = set('aeiou')\n        n = len(word)\n        total_vowels = sum(1 for char in word if char in vowels)\n        if total_vowels < 5 or total_vowels * (k + 1) > n + 1:\n            return 0\n        \n        def has_all_vowels(sub):\n            return all(vowel in sub for vowel in vowels)\n        \n        count = 0\n        for i in range(n):\n            current_sub = set()\n            for j in range(i, n):\n                current_sub.add(word[j])\n                if len(current_sub) == 5 and sum(1 for c in current_sub if c not in vowels) == k:\n                    count += 1\n                elif len(current_sub) > 5:\n                    break\n        \n        return count"
        ]
    },
    {
        "question_id": "3579",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxGoodNumber(self, nums: List[int]) -> int:\n        # Convert each number to its binary representation without '0b' prefix\n        binary_nums = [bin(num)[2:] for num in nums]\n        # Concatenate the binary representations in descending order\n        concatenated_binary = ''.join(sorted(binary_nums, reverse=True))\n        # Convert the concatenated binary string back to an integer\n        return int(concatenated_binary, 2)"
        ]
    },
    {
        "question_id": "3583",
        "code_list": [
            "from typing import List\nfrom math import gcd\nfrom collections import defaultdict\n\nclass Solution:\n    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        gcd_pairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                gcd_pairs.append(gcd(nums[i], nums[j]))\n        gcd_pairs.sort()\n        \n        # Count frequency of each gcd value\n        freq = defaultdict(int)\n        for val in gcd_pairs:\n            freq[val] += 1\n        \n        # Precompute prefix sums for binary search\n        prefix_sum = [0]\n        for val in sorted(freq.keys()):\n            prefix_sum.append(prefix_sum[-1] + freq[val])\n        \n        result = []\n        for q in queries:\n            left, right = 0, len(prefix_sum) - 1\n            while left < right:\n                mid = (left + right) // 2\n                if prefix_sum[mid] <= q:\n                    left = mid + 1\n                else:\n                    right = mid\n            result.append(gcd_pairs[left - 1])\n        return result"
        ]
    },
    {
        "question_id": "3606",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minElement(self, nums: List[int]) -> int:\n        def sum_of_digits(n: int) -> int:\n            return sum(int(digit) for digit in str(n))\n        \n        nums = [sum_of_digits(num) for num in nums]\n        return min(nums)"
        ]
    },
    {
        "question_id": "3510",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        n = len(maximumHeight)\n        if len(set(maximumHeight)) < n:\n            return -1\n        \n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + maximumHeight[i]\n        \n        max_sum = -1\n        for target_height in range(1, max(maximumHeight) + 1):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if (mid * (mid + 1) // 2) * target_height >= prefix_sum[mid + 1] - prefix_sum[0]:\n                    right = mid\n                else:\n                    left = mid + 1\n            \n            current_sum = 0\n            for i in range(left, n):\n                current_sum += min(target_height, maximumHeight[i])\n            \n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3584",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def validSequence(self, word1: str, word2: str) -> List[int]:\n        n, m = len(word1), len(word2)\n        i, j, changes = 0, 0, 0\n        \n        result = []\n        \n        while i < n and j < m:\n            if word1[i] == word2[j]:\n                result.append(i)\n                i += 1\n                j += 1\n            else:\n                if changes == 0:\n                    # Check if we can change the current character in word1 to match word2[j]\n                    if i > 0 and word1[i-1] == word2[j]:\n                        i -= 1\n                    elif i + 1 < n and word1[i+1] == word2[j]:\n                        i += 1\n                    else:\n                        # No valid change found, move to the next character in word1\n                        i += 1\n                    changes += 1\n                else:\n                    # More than one change needed, break the loop\n                    break\n        \n        # Ensure the result list has the same length as word2\n        if len(result) != m:\n            return []\n        \n        return result"
        ]
    },
    {
        "question_id": "3580",
        "code_list": [
            "class Solution:\n    def minStartingIndex(self, s: str, pattern: str) -> int:\n        len_s, len_p = len(s), len(pattern)\n        diff_count = 0\n        \n        # Helper function to check if we can convert s[start:end+1] to pattern with at most one change\n        def can_convert(start, end):\n            nonlocal diff_count\n            diff_count = sum(1 for i in range(len_p) if s[start + i] != pattern[i])\n            return diff_count <= 1\n        \n        # Iterate over all possible starting indices\n        for start in range(len_s - len_p + 1):\n            if can_convert(start, start + len_p - 1):\n                return start\n        \n        return -1"
        ]
    },
    {
        "question_id": "abc374_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    k = data[1:]\n    total_people = sum(k)\n\n    # Sort the list in descending order\n    k.sort(reverse=True)\n\n    # Initialize variables\n    max_people = 0\n    group_a_sum = 0\n    group_b_sum = 0\n\n    for i in range(n):\n        if group_a_sum <= group_b_sum:\n            group_a_sum += k[i]\n        else:\n            group_b_sum += k[i]\n\n        # Update max_people after each iteration\n        max_people = max(max_people, max(group_a_sum, group_b_sum))\n\n    print(max_people)"
        ]
    },
    {
        "question_id": "abc374_f",
        "code_list": [
            "import heapq\n\ndef min_dissatisfaction(N, K, X, T):\n    # Initialize variables\n    total_dissatisfaction = 0\n    next_shipment_day = 0\n    shipments = []\n    \n    for t in T:\n        # Calculate the dissatisfaction for the current order\n        dissatisfaction = t - max(next_shipment_day, t)\n        total_dissatisfaction += dissatisfaction\n        \n        # Add the current order to the heap with its dissatisfaction as priority\n        heapq.heappush(shipments, (-dissatisfaction, t))\n        \n        # Maintain the heap size to at most K\n        while len(shipments) > K:\n            _, earliest_ship_day = heapq.heappop(shipments)\n            next_shipment_day = max(next_shipment_day, earliest_ship_day + X)\n    \n    return total_dissatisfaction\n\nif __name__ == \"__main__\":\n    N, K, X = map(int, input().split())\n    T = list(map(int, input().split()))\n    print(min_dissatisfaction(N, K, X, T))"
        ]
    },
    {
        "question_id": "abc374_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    T = input().strip()\n    \n    min_len = min(len(S), len(T))\n    \n    for i in range(min_len):\n        if S[i] != T[i]:\n            print(i + 1)\n            return\n    \n    if len(S) != len(T):\n        print(max(len(S), len(T)))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc374_d",
        "code_list": [
            "import math\n\ndef calculate_distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\ndef optimal_printing_time(N, S, T, segments):\n    total_time = 0.0\n    \n    for i in range(N):\n        # Calculate the distance between the endpoints of the current segment\n        dist = calculate_distance(segments[i][0], segments[i][1], segments[i][2], segments[i][3])\n        \n        # Determine the optimal path to minimize the total time\n        # Case 1: Start from (0, 0)\n        time_start_from_origin = dist / T\n        \n        # Case 2: Start from the previous segment's endpoint\n        if i > 0:\n            prev_end_x, prev_end_y = segments[i-1][2], segments[i-1][3]\n            dist_to_prev_end = calculate_distance(prev_end_x, prev_end_y, segments[i][0], segments[i][1])\n            time_start_from_prev_end = dist_to_prev_end / S + (dist - dist_to_prev_end) / T\n        else:\n            time_start_from_prev_end = float('inf')\n        \n        # Case 3: Start from the next segment's starting point\n        if i < N - 1:\n            next_start_x, next_start_y = segments[i+1][0], segments[i+1][1]\n            dist_to_next_start = calculate_distance(next_start_x, next_start_y, segments[i][2], segments[i][3])\n            time_start_from_next_start = dist_to_next_start / S + (dist - dist_to_next_start) / T\n        else:\n            time_start_from_next_start = float('inf')\n        \n        # Choose the minimum time among the three cases\n        min_time = min(time_start_from_origin, time_start_from_prev_end, time_start_from_next_start)\n        total_time += min_time\n    \n    return total_time\n\ndef main():\n    N, S, T = map(int, input().split())\n    segments = []\n    for _ in range(N):\n        A, B, C, D = map(int, input().split())\n        segments.append([A, B, C, D])\n    \n    result = optimal_printing_time(N, S, T, segments)\n    print(f\"{result:.15f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc374_g",
        "code_list": [
            "def main():\n    from collections import defaultdict\n\n    def build_suffix_array(s):\n        n = len(s)\n        sa = [i for i in range(n)]\n        sa.sort(key=lambda x: s[x:])\n        return sa\n\n    def lcp_array(s, sa):\n        n = len(s)\n        rank = [0] * n\n        for i in range(n):\n            rank[sa[i]] = i\n        k = 0\n        lcp = [0] * n\n        for i in range(n):\n            if rank[i] == n - 1:\n                k = 0\n                continue\n            j = sa[rank[i] + 1]\n            while i + k < n and j + k < n and s[i + k] == s[j + k]:\n                k += 1\n            lcp[rank[i]] = k\n            if k:\n                k -= 1\n        return lcp\n\n    def find_min_strings(product_names):\n        n = len(product_names)\n        suffixes = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                suffixes.add(product_names[i] + product_names[j])\n                suffixes.add(product_names[j] + product_names[i])\n\n        sa = build_suffix_array(''.join(suffixes))\n        lcp = lcp_array(''.join(suffixes), sa)\n\n        min_strings = []\n        current_string = ''\n        for i in range(n):\n            if not current_string or product_names[i] not in current_string:\n                current_string += product_names[i]\n            else:\n                min_strings.append(current_string)\n                current_string = product_names[i]\n\n        if current_string:\n            min_strings.append(current_string)\n\n        return len(min_strings)\n\n    N = int(input())\n    product_names = [input().strip() for _ in range(N)]\n    print(find_min_strings(product_names))"
        ]
    },
    {
        "question_id": "abc374_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S.endswith('san'):\n        print('Yes')\n    else:\n        print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc374_e",
        "code_list": [
            "import sys\nfrom bisect import bisect_right\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    x = int(data[1])\n    machines = []\n    for i in range(2, len(data), 4):\n        a = int(data[i])\n        p = int(data[i+1])\n        b = int(data[i+2])\n        q = int(data[i+3])\n        machines.append((a, p, b, q))\n    \n    # Calculate the production capacity for each machine type\n    capacities = [max(a, b) for a, p, b, q in machines]\n    \n    # Sort the capacities\n    capacities.sort()\n    \n    # Binary search for the maximum achievable production capacity\n    left, right = 0, capacities[-1] + 1\n    while left < right:\n        mid = (left + right) // 2\n        cost = 0\n        for cap in capacities:\n            if cap >= mid:\n                break\n            # Find the number of machines needed for this capacity\n            idx = bisect_right(machines, (cap, cap, cap, cap), key=lambda x: x[0])\n            cost += (idx - bisect_right(machines, (cap, cap, cap, cap), key=lambda x: x[1]))\n            cost += (idx - bisect_right(machines, (cap, cap, cap, cap), key=lambda x: x[2]))\n            cost -= idx\n        if cost <= x:\n            left = mid + 1\n        else:\n            right = mid\n    \n    print(left - 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc375_e",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    N = int(input())\n    teams_strength = [0, 0, 0]\n    total_strength = 0\n    \n    # Read input and calculate initial team strengths\n    for _ in range(N):\n        A, B = map(int, input().split())\n        teams_strength[A-1] += B\n        total_strength += B\n    \n    # Check if it's possible to divide the total strength equally among three teams\n    if total_strength % 3 != 0:\n        print(-1)\n        return\n    \n    target_strength = total_strength // 3\n    \n    # Function to check if we can redistribute people to achieve equal team strengths\n    def can_redistribute(team_strengths, target_strength, people_strengths):\n        for i in range(1, len(people_strengths) + 1):\n            for combo in combinations(range(len(people_strengths)), i):\n                new_strengths = list(team_strengths)\n                for index in combo:\n                    new_strengths[index % 3] += people_strengths[index]\n                if new_strengths[0] == new_strengths[1] == new_strengths[2] == target_strength:\n                    return True\n        return False\n    \n    # List of people's strengths and their original team indices\n    people_strengths = [(B, A-1) for A, B in zip(teams_strength, [B for _, B in (map(int, line.split()) for line in sys.stdin.readlines()[:N])])]\n    \n    # Try to find the minimum number of people to move\n    min_switches = float('inf')\n    for i in range(1, N+1):\n        for combo in combinations(range(N), i):\n            new_strengths = list(teams_strength)\n            for index in combo:\n                new_strengths[people_strengths[index][1]] -= people_strengths[index][0]\n            if can_redistribute(new_strengths, target_strength, [people_strengths[index][0] for index in combo]):\n                min_switches = min(min_switches, i)\n    \n    print(min_switches if min_switches != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc375_b",
        "code_list": [
            "import math\n\ndef calculate_total_cost():\n    N = int(input())\n    points = [(0, 0)] + [tuple(map(int, input().split())) for _ in range(N)] + [(0, 0)]\n    total_cost = 0.0\n    \n    for i in range(1, N + 2):\n        x1, y1 = points[i - 1]\n        x2, y2 = points[i]\n        distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n        total_cost += distance\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    calculate_total_cost()"
        ]
    },
    {
        "question_id": "abc375_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_input():\n        return sys.stdin.read().splitlines()\n    \n    def process_grid(N, grid):\n        new_grid = [['.' for _ in range(N)] for _ in range(N)]\n        \n        for i in range(N // 2):\n            for x in range(i + 1, N - i):\n                y = N - 1 - x\n                new_grid[i][y] = grid[x][i]\n                new_grid[y][N - 1 - i] = grid[i][x]\n                new_grid[N - 1 - i][x] = grid[y][N - 1 - i]\n                new_grid[x][N - 1 - y] = grid[N - 1 - x][y]\n        \n        return new_grid\n    \n    def print_grid(grid):\n        for row in grid:\n            print(''.join(row))\n    \n    N = int(read_input()[0])\n    grid = [list(line) for line in read_input()[1:]]\n    \n    for _ in range(N // 2):\n        grid = process_grid(N, grid)\n    \n    print_grid(grid)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc375_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    count = 0\n    for i in range(N - 2):\n        if S[i] == '#' and S[i + 1] == '.' and S[i + 2] == '#':\n            count += 1\n    print(count)"
        ]
    },
    {
        "question_id": "abc375_d",
        "code_list": [
            "def count_palindrome_triples(S):\n    n = len(S)\n    count = 0\n    \n    # Iterate over all possible triplets (i, j, k)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if S[i] == S[k] and S[j] == S[j]:  # Check if the substring is a palindrome\n                    count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(count_palindrome_triples(S))"
        ]
    },
    {
        "question_id": "abc375_g",
        "code_list": [
            "import heapq\n\ndef dijkstra(n, edges, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in edges[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef solve(n, m, edges):\n    # Calculate the shortest path from city 1 to city N with all roads passable\n    all_paths = dijkstra(n, edges, 0)\n    \n    # Check each road\n    results = []\n    for i in range(m):\n        # Remove the current road from the graph\n        u, v, _ = edges[i]\n        edges[i] = (u, v, float('inf'))\n        \n        # Recalculate the shortest path from city 1 to city N\n        modified_paths = dijkstra(n, edges, 0)\n        \n        # Restore the current road\n        edges[i] = (u, v, all_paths[v])\n        \n        # Check if the shortest paths are different\n        if all_paths[n-1] != modified_paths[n-1]:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        a -= 1\n        b -= 1\n        edges[a].append((b, c))\n        edges[b].append((a, c))\n    \n    results = solve(n, m, edges)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc375_f",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef main():\n    n, m, q = map(int, input().split())\n    roads = defaultdict(list)\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        roads[a-1].append((b-1, c))\n        roads[b-1].append((a-1, c))\n    \n    closed_roads = set()\n    distances = [dijkstra(roads[i], i) for i in range(n)]\n    \n    for _ in range(q):\n        query_type, *params = map(int, input().split())\n        if query_type == 1:\n            i = params[0] - 1\n            closed_roads.add(i)\n            # Update distances after closing a road\n            for j in range(n):\n                if j != i:\n                    distances[j] = dijkstra(roads, j)\n        elif query_type == 2:\n            x, y = params[0] - 1, params[1] - 1\n            if x in closed_roads or y in closed_roads:\n                print(-1)\n            else:\n                print(distances[x][y])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_b",
        "code_list": [
            "def min_operations_to_follow_instructions(N, Q):\n    # Initialize the positions of the left and right hands\n    l_pos = 1\n    r_pos = 2\n    \n    # Dictionary to store the minimum operations needed to reach each position\n    min_ops = {1: 0, 2: 0}\n    \n    # Function to calculate the minimum operations to move from current position to target position\n    def min_ops_to_move(current, target):\n        if current == target:\n            return 0\n        elif abs(current - target) <= 1:\n            return 1\n        else:\n            return 2\n    \n    total_ops = 0\n    \n    for i in range(Q):\n        H, T = input().split()\n        T = int(T)\n        \n        # Calculate the minimum operations needed to move the specified hand to the target position\n        if H == 'L':\n            ops = min_ops_to_move(r_pos, T)\n            # Update the right hand position and total operations\n            r_pos = T\n            total_ops += ops\n        else:\n            ops = min_ops_to_move(l_pos, T)\n            # Update the left hand position and total operations\n            l_pos = T\n            total_ops += ops\n    \n    return total_ops\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    print(min_operations_to_follow_instructions(N, Q))"
        ]
    },
    {
        "question_id": "abc376_d",
        "code_list": [
            "from collections import defaultdict, deque\n\ndef find_min_cycle_length(N, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n\n    # Initialize distances and parent arrays\n    dist = [-1] * (N + 1)\n    parent = [None] * (N + 1)\n    dist[1] = 0\n\n    # BFS to find the shortest cycle containing vertex 1\n    queue = deque([1])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if dist[neighbor] == -1:  # If not visited\n                dist[neighbor] = dist[node] + 1\n                parent[neighbor] = node\n                queue.append(neighbor)\n            elif parent[node] != neighbor and parent[neighbor] != node:  # Cycle detected\n                cycle_length = dist[node] + dist[neighbor] + 1\n                return cycle_length\n\n    return -1\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    print(find_min_cycle_length(N, edges))"
        ]
    },
    {
        "question_id": "abc376_g",
        "code_list": [
            "from collections import defaultdict\nfrom math import gcd\n\ndef modular_inverse(a, mod):\n    def extended_gcd(a, b):\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return (g, y - (b // a) * x, x)\n\n    _, inv, _ = extended_gcd(a, mod)\n    return inv % mod\n\ndef solve_case(N, parents, probabilities):\n    mod = 998244353\n    total_prob = sum(probabilities[1:])\n    probabilities[0] = 0  # Vertex 0 is the root and does not hide the treasure\n    \n    # Calculate the expected number of operations\n    expected_operations = 0\n    search_queue = [0]\n    while search_queue:\n        current_vertex = search_queue.pop(0)\n        for child in range(N + 1):\n            if parents[child] == current_vertex and probabilities[child] > 0:\n                expected_operations += probabilities[child] / total_prob\n                probabilities[current_vertex] -= probabilities[child] / total_prob\n                if probabilities[child] > 0:\n                    search_queue.append(child)\n    \n    # Convert to irreducible fraction\n    numerator = int(expected_operations * total_prob)\n    denominator = total_prob\n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n    \n    # Find modular inverse of the denominator\n    denominator_inv = modular_inverse(denominator, mod)\n    \n    # Result is numerator * denominator_inv % mod\n    result = (numerator * denominator_inv) % mod\n    return result\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        parents = list(map(int, input().split()))\n        probabilities = list(map(int, input().split()))\n        print(solve_case(N, parents, probabilities))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_a",
        "code_list": [
            "def main():\n    # Read input\n    N, C = map(int, input().split())\n    T = list(map(int, input().split()))\n    \n    # Initialize variables\n    last_candy_time = -C  # Start before the first possible candy time\n    candies_received = 0\n    \n    # Iterate through each button press\n    for t in T:\n        # Check if enough time has passed since last candy\n        if t - last_candy_time >= C:\n            candies_received += 1\n            last_candy_time = t\n    \n    # Print the result\n    print(candies_received)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_f",
        "code_list": [
            "def min_operations(N, Q):\n    # Initialize the positions of the left and right hands\n    left_pos = 1\n    right_pos = 2\n    \n    # Dictionary to store the minimum operations needed to reach each position\n    min_ops = {1: 0, 2: 0}\n    \n    # Function to calculate the minimum operations to move to a given position\n    def calc_ops(current_pos, target_pos):\n        return min(abs(target_pos - current_pos), N - abs(target_pos - current_pos))\n    \n    total_ops = 0\n    \n    for i in range(Q):\n        H, T = input().split()\n        T = int(T)\n        \n        # Calculate the minimum operations to move the appropriate hand to the target position\n        if H == 'L':\n            if right_pos != T:\n                ops = calc_ops(right_pos, T)\n                total_ops += ops\n                right_pos = T\n            else:\n                # If the right hand is already at the target position, do nothing\n                pass\n        else:  # H == 'R'\n            if left_pos != T:\n                ops = calc_ops(left_pos, T)\n                total_ops += ops\n                left_pos = T\n            else:\n                # If the left hand is already at the target position, do nothing\n                pass\n    \n    return total_ops\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    print(min_operations(N, Q))"
        ]
    },
    {
        "question_id": "abc376_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    a = data[1:n+1]\n    b = data[n+1:2*n]\n\n    max_a = max(a)\n    min_b = min(b)\n\n    if max_a <= min_b:\n        print(min_b)\n    else:\n        print(max_a)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_e",
        "code_list": [
            "from heapq import heappush, heappop\n\ndef min_expression_value():\n    T = int(input())\n    \n    def solve_case():\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        # Create a max heap based on A values\n        max_heap = []\n        for i in range(N):\n            heappush(max_heap, (-A[i], i))\n        \n        # Calculate the initial sum of B values for the first K elements\n        current_sum = sum(B[:K])\n        max_A_in_S = -A[K-1]\n        result = max_A_in_S * current_sum\n        \n        # Iterate through the rest of the elements\n        for _ in range(K, N):\n            # Remove the smallest element from the previous window\n            removed_index = heappop(max_heap)[1]\n            if removed_index < K:\n                current_sum -= B[removed_index]\n            \n            # Add the new element to the window\n            new_element = heappop(max_heap)\n            heappush(max_heap, new_element)\n            current_sum += B[new_element[1]]\n            \n            # Update the maximum A value in the current window\n            max_A_in_S = -max_heap[0][0]\n            \n            # Calculate the new expression value\n            new_value = max_A_in_S * current_sum\n            \n            # Update the result if the new value is smaller\n            if new_value < result:\n                result = new_value\n        \n        return result\n    \n    for _ in range(T):\n        print(solve_case())\n\nif __name__ == \"__main__\":\n    min_expression_value()"
        ]
    },
    {
        "question_id": "abc377_c",
        "code_list": [
            "def count_safe_squares(N, M, positions):\n    # Initialize a set to keep track of all squares that can be captured\n    captured_squares = set()\n    \n    # Add all possible capturing squares for each existing piece\n    for a, b in positions:\n        if a + 2 <= N and b + 1 <= N:\n            captured_squares.add((a + 2, b + 1))\n        if a + 1 <= N and b + 2 <= N:\n            captured_squares.add((a + 1, b + 2))\n        if a - 1 >= 1 and b + 2 <= N:\n            captured_squares.add((a - 1, b + 2))\n        if a - 2 >= 1 and b + 1 <= N:\n            captured_squares.add((a - 2, b + 1))\n        if a - 2 >= 1 and b - 1 >= 1:\n            captured_squares.add((a - 2, b - 1))\n        if a - 1 >= 1 and b - 2 >= 1:\n            captured_squares.add((a - 1, b - 2))\n        if a + 1 <= N and b - 2 >= 1:\n            captured_squares.add((a + 1, b - 2))\n        if a + 2 <= N and b - 1 >= 1:\n            captured_squares.add((a + 2, b - 1))\n    \n    # Calculate the total number of empty squares\n    total_empty_squares = N * N\n    \n    # Subtract the number of captured squares from the total\n    safe_squares = total_empty_squares - len(captured_squares)\n    \n    return safe_squares\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    positions = [tuple(map(int, input().split())) for _ in range(M)]\n    print(count_safe_squares(N, M, positions))"
        ]
    },
    {
        "question_id": "abc377_b",
        "code_list": [
            "def count_safe_squares():\n    # Read the grid input\n    grid = [input().strip() for _ in range(8)]\n    \n    # Initialize counters for safe rows and columns\n    safe_rows = [True] * 8\n    safe_cols = [True] * 8\n    \n    # Mark unsafe rows and columns\n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '#':\n                safe_rows[i] = False\n                safe_cols[j] = False\n    \n    # Calculate the number of safe squares\n    safe_squares = sum(safe_rows) * sum(safe_cols)\n    \n    return safe_squares\n\nif __name__ == \"__main__\":\n    print(count_safe_squares())"
        ]
    },
    {
        "question_id": "abc377_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    # Check if the string contains exactly one 'A', one 'B', and one 'C'\n    if len(set(S)) == 3 and set(S) == {'A', 'B', 'C'}:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_g",
        "code_list": [
            "from collections import defaultdict\n\ndef lcs(s, t):\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\ndef main():\n    N = int(input())\n    strings = [input() for _ in range(N)]\n\n    # Precompute the longest common subsequence lengths between all pairs of strings\n    lcs_lengths = defaultdict(lambda: defaultdict(int))\n    for i in range(N):\n        for j in range(i):\n            lcs_lengths[i][j] = lcs(strings[i], strings[j])\n            lcs_lengths[j][i] = lcs_lengths[i][j]\n\n    results = []\n    for k in range(N):\n        min_cost = float('inf')\n        for i in range(k):\n            min_cost = min(min_cost, len(strings[k]) - lcs_lengths[k][i])\n        results.append(min_cost)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_f",
        "code_list": [
            "def count_safe_squares(N, M, pieces):\n    # Initialize sets to keep track of rows, columns, and diagonals\n    rows = set()\n    cols = set()\n    diag1 = set()  # i + j = constant\n    diag2 = set()  # i - j = constant\n    \n    # Populate the sets based on the positions of the existing pieces\n    for a, b in pieces:\n        rows.add(a)\n        cols.add(b)\n        diag1.add(a + b)\n        diag2.add(a - b)\n    \n    # Calculate the total number of squares that can't be used\n    # This includes all squares in rows and columns occupied by pieces,\n    # plus the squares on the same diagonals as occupied pieces\n    total_blocked = len(rows) + len(cols) + len(diag1) + len(diag2) - 3 * M\n    \n    # The number of safe squares is the total number of squares minus the blocked ones\n    return N * N - total_blocked\n\ndef main():\n    N, M = map(int, input().split())\n    pieces = [tuple(map(int, input().split())) for _ in range(M)]\n    print(count_safe_squares(N, M, pieces))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_e",
        "code_list": [
            "def find_cycle_length(n, k, permutation):\n    visited = [False] * n\n    cycle_lengths = []\n    \n    for i in range(n):\n        if not visited[i]:\n            cycle_start = i\n            current = i\n            cycle_length = 0\n            \n            while not visited[current]:\n                visited[current] = True\n                current = permutation[current] - 1\n                cycle_length += 1\n            \n            cycle_lengths.append((cycle_start, cycle_length))\n    \n    result = list(permutation)\n    \n    for start, length in cycle_lengths:\n        if k >= length:\n            k %= length\n    \n    for i in range(n):\n        if k == 0:\n            break\n        elif permutation[i] != i + 1:\n            for start, length in cycle_lengths:\n                if i == start:\n                    result[i] = permutation[permutation[i] - 1]\n                    k -= 1\n                    break\n    \n    return result\n\ndef main():\n    n, k = map(int, input().split())\n    permutation = list(map(int, input().split()))\n    result = find_cycle_length(n, k, permutation)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_d",
        "code_list": [
            "def count_valid_pairs(N, M, intervals):\n    # Sort intervals based on their start points\n    intervals.sort(key=lambda x: x[0])\n    \n    # Initialize variables to keep track of the current end point and valid pairs count\n    current_end = -1\n    valid_pairs_count = 0\n    \n    # Iterate through each interval\n    for start, end in intervals:\n        # If the current interval starts after the current_end, update the current_end\n        if start > current_end:\n            current_end = end\n        else:\n            # Calculate the number of valid pairs ending at the current interval's end\n            valid_pairs_count += end - max(start, current_end) + 1\n    \n    # Calculate the total number of possible pairs (1 to M)\n    total_pairs = M * (M + 1) // 2\n    \n    # Subtract the invalid pairs from the total pairs to get the valid pairs\n    return total_pairs - valid_pairs_count\n\ndef main():\n    N, M = map(int, input().split())\n    intervals = []\n    for _ in range(N):\n        L, R = map(int, input().split())\n        intervals.append((L, R))\n    \n    result = count_valid_pairs(N, M, intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_e",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Initialize prefix sum array\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = (prefix_sum[i] + A[i]) % M\n\n    # Count occurrences of each remainder\n    count = [0] * M\n    for val in prefix_sum:\n        count[val] += 1\n\n    # Calculate the result using the counts\n    result = 0\n    for i in range(M):\n        for j in range(i, M):\n            result += count[i] * count[j] * (j - i)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_d",
        "code_list": [
            "from collections import deque\nfrom itertools import product\n\ndef count_paths(H, W, K, grid):\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    queue = deque()\n    visited = set()\n    \n    def is_valid(x, y):\n        return 1 <= x <= H and 1 <= y <= W and grid[x][y] == '.'\n    \n    def bfs(start):\n        nonlocal K\n        queue.append((start, [start]))\n        while queue:\n            current, path = queue.popleft()\n            if len(path) == K + 1:\n                yield path\n                continue\n            for dx, dy in directions:\n                nx, ny = current[0] + dx, current[1] + dy\n                if is_valid(nx, ny) and (nx, ny) not in path:\n                    new_path = path + [(nx, ny)]\n                    queue.append(((nx, ny), new_path))\n    \n    count = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if grid[i][j] == '.':\n                for path in bfs((i, j)):\n                    count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    H, W, K = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    print(count_paths(H, W, K, grid))"
        ]
    },
    {
        "question_id": "abc378_b",
        "code_list": [
            "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef find_next_collection_day(q, r, d):\n    cycle = q\n    for i in range(2, len(primes) + 1):\n        cycle = lcm(cycle, primes[i])\n    \n    diff = (d - r) % cycle\n    if diff == 0:\n        return r\n    else:\n        return r + diff\n\ndef main():\n    import math\n    from sympy import primerange\n    \n    # Precompute all prime numbers up to 10^6 for LCM calculation\n    primes = list(primerange(1, 10**6 + 1))\n    \n    N = int(input())\n    garbage_days = []\n    for _ in range(N):\n        q, r = map(int, input().split())\n        garbage_days.append((q, r))\n    \n    Q = int(input())\n    for _ in range(Q):\n        t, d = map(int, input().split())\n        q, r = garbage_days[t - 1]\n        print(find_next_collection_day(q, r, d))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_f",
        "code_list": [
            "from collections import defaultdict\n\ndef find_root_and_degrees(n, edges):\n    degrees = [0] * n\n    for u, v in edges:\n        degrees[u - 1] += 1\n        degrees[v - 1] += 1\n    root = None\n    for i in range(n):\n        if degrees[i] == 1:\n            root = i\n            break\n    return root, degrees\n\ndef dfs(node, parent, edges, degrees, visited, cycle_nodes):\n    visited[node] = True\n    if degrees[node] == 3:\n        cycle_nodes.add(node)\n    for neighbor in edges[node]:\n        if neighbor != parent and not visited[neighbor]:\n            dfs(neighbor, node, edges, degrees, visited, cycle_nodes)\n\ndef count_valid_graphs(n, edges):\n    root, degrees = find_root_and_degrees(n, edges)\n    edges_list = [[] for _ in range(n)]\n    for u, v in edges:\n        edges_list[u - 1].append(v - 1)\n        edges_list[v - 1].append(u - 1)\n    \n    visited = [False] * n\n    cycle_nodes = set()\n    dfs(root, -1, edges_list, degrees, visited, cycle_nodes)\n    \n    valid_count = 0\n    for i in range(n):\n        if degrees[i] == 3 and i not in cycle_nodes:\n            continue\n        for j in range(i + 1, n):\n            if degrees[j] == 3 and j not in cycle_nodes:\n                continue\n            if len(edges_list[i]) == 1 or len(edges_list[j]) == 1:\n                continue\n            if i in cycle_nodes and j in cycle_nodes:\n                continue\n            if i in cycle_nodes and j not in cycle_nodes:\n                if any(len(edges_list[k]) == 1 for k in edges_list[i]):\n                    continue\n            if j in cycle_nodes and i not in cycle_nodes:\n                if any(len(edges_list[k]) == 1 for k in edges_list[j]):\n                    continue\n            valid_count += 1\n    \n    return valid_count // 2\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    print(count_valid_graphs(n, edges))"
        ]
    },
    {
        "question_id": "abc378_g",
        "code_list": [
            "from math import comb\n\ndef main():\n    A, B, M = map(int, input().split())\n    if A == B:\n        # Special case when A == B\n        result = comb((A-1)*(B-1), A-1) % M\n    else:\n        # General case\n        result = 0\n        for k in range(1, min(A, B) + 1):\n            if A >= B:\n                result += comb((A-1)*(B-1), k-1) * pow(B, k-1, M) * pow(A, B-k, M)\n            else:\n                result += comb((A-1)*(B-1), k-1) * pow(A, k-1, M) * pow(B, A-k, M)\n            result %= M\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_a",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    # Read input\n    colors = list(map(int, input().split()))\n    \n    # Count the occurrences of each color\n    color_counts = Counter(colors)\n    \n    # Calculate the maximum number of operations\n    max_operations = sum((count // 2) for count in color_counts.values())\n    \n    # Print the result\n    print(max_operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_previous_occurrences():\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        \n        # Dictionary to store the last occurrence index of each number\n        last_occurrence = {}\n        b = []\n        \n        for i, num in enumerate(a):\n            if num in last_occurrence:\n                b.append(last_occurrence[num])\n            else:\n                b.append(-1)\n            last_occurrence[num] = i\n        \n        print(' '.join(map(str, b)))\n    \n    find_previous_occurrences()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_b",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    S = input()\n\n    # Initialize variables\n    max_strawberries = 0\n    current_streak = 0\n\n    # Iterate through the string to find the maximum number of strawberries\n    for char in S:\n        if char == 'O':\n            current_streak += 1\n            if current_streak == K:\n                max_strawberries += 1\n                current_streak = 0\n        else:\n            current_streak = 0\n\n    print(max_strawberries)"
        ]
    },
    {
        "question_id": "abc379_e",
        "code_list": [
            "def main():\n    import sys\n    \n    def calculate_sum(N, S):\n        total_sum = 0\n        for i in range(N):\n            current_value = 0\n            for j in range(i, N):\n                current_value = current_value * 10 + int(S[j])\n                total_sum += current_value\n        return total_sum\n    \n    N = int(input())\n    S = input().strip()\n    \n    result = calculate_sum(N, S)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    X = list(map(int, data[2:2*M:2]))\n    A = list(map(int, data[3:2*M:2]))\n    \n    total_stones = sum(A)\n    if total_stones != N:\n        print(-1)\n        return\n    \n    positions = [0] * (N + 1)\n    for i in range(M):\n        positions[X[i]] += A[i]\n    \n    current_position = 1\n    operations = 0\n    for i in range(1, N + 1):\n        if positions[i] > 0:\n            while positions[i] > 0:\n                if current_position < i:\n                    operations += i - current_position\n                    current_position = i\n                positions[i] -= 1\n                current_position += 1\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    Q = int(input())\n    events = []\n    for _ in range(Q):\n        events.append(list(map(int, input().split())))\n    \n    # Sort events based on the day they occur\n    events.sort(key=lambda x: x[1] if x[0] != 1 else float('inf'))\n    \n    current_day = 0\n    plants = deque()\n    \n    for event in events:\n        event_type, value = event[0], event[1]\n        \n        if event_type == 1:\n            plants.append((current_day, 0))\n        elif event_type == 2:\n            current_day += value\n        else:\n            harvested_count = 0\n            while plants and plants[0][0] <= current_day:\n                _, height = plants.popleft()\n                if height < value:\n                    plants.appendleft((current_day, height))\n                    break\n                harvested_count += 1\n            print(harvested_count)"
        ]
    },
    {
        "question_id": "abc379_g",
        "code_list": [
            "from functools import lru_cache\n\ndef main():\n    H, W = map(int, input().split())\n    S = [input() for _ in range(H)]\n    \n    @lru_cache(None)\n    def dfs(i, j, prev):\n        if i == H or j == W:\n            return 1\n        if S[i][j] != '?':\n            return dfs(i + (j + 1 == W), j + 1, S[i][j]) if S[i][j] != prev else 0\n        else:\n            ways = 0\n            for k in '123':\n                if prev != k:\n                    ways += dfs(i + (j + 1 == W), j + 1, k)\n            return ways\n    \n    MOD = 998244353\n    ans = dfs(0, 0, '')\n    print(ans % MOD)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_f",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    h = list(map(int, data[2:n+2]))\n    queries = [(int(data[i*3+3]), int(data[i*3+4])) for i in range(q)]\n\n    def process_query(l, r):\n        stack = []\n        visible_from_l = set()\n        visible_from_r = set()\n        \n        # Process buildings from left to right\n        for i in range(l-1, r):\n            while stack and h[stack[-1]] <= h[i]:\n                visible_from_l.discard(stack.pop())\n            if stack:\n                visible_from_l.add(stack[-1])\n            stack.append(i)\n\n        stack.clear()\n\n        # Process buildings from right to left\n        for i in range(r-1, l-2, -1):\n            while stack and h[stack[-1]] <= h[i]:\n                visible_from_r.discard(stack.pop())\n            if stack:\n                visible_from_r.add(stack[-1])\n            stack.append(i)\n\n        return len(visible_from_l & visible_from_r)\n\n    for l, r in queries:\n        print(process_query(l, r))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_a",
        "code_list": [
            "def main():\n    N = int(input())\n    a = N // 100\n    b = (N // 10) % 10\n    c = N % 10\n    print(b * 100 + c * 10 + a, c * 100 + a * 10 + b)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_e",
        "code_list": [
            "from collections import defaultdict, deque\n\ndef main():\n    # Read input\n    N, Q = map(int, input().split())\n    \n    # Initialize data structures\n    colors = [i for i in range(N)]\n    color_count = defaultdict(int)\n    for i in range(1, N + 1):\n        color_count[i] = 1\n    \n    def find(x):\n        if colors[x - 1] != x:\n            colors[x - 1] = find(colors[x - 1])\n        return colors[x - 1]\n    \n    def union(x, y):\n        root_x = find(x)\n        root_y = find(y)\n        if root_x != root_y:\n            colors[root_y - 1] = root_x\n            color_count[root_x] += color_count[root_y]\n    \n    # Process queries\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            x, c = query[1], query[2]\n            root = find(x)\n            while colors[root - 1] == root:\n                colors[root - 1] = find(c)\n                root = find(root)\n                color_count[c] += color_count[root]\n        elif query[0] == 2:\n            c = query[1]\n            print(color_count[c])"
        ]
    },
    {
        "question_id": "abc380_f",
        "code_list": [
            "def determine_winner(N, M, L, A, B, C):\n    # Combine all cards into a single sorted list\n    all_cards = sorted(A + B + C)\n    \n    # Function to count the number of valid moves for a player\n    def count_valid_moves(cards, table):\n        return sum(1 for card in cards if any(table_card < card for table_card in table))\n    \n    # Initialize the game state\n    takahashi_hand = A\n    aoki_hand = B\n    table = []\n    current_player = 'Takahashi'\n    \n    # Simulate the game until no more moves can be made\n    while True:\n        if current_player == 'Takahashi':\n            # Takahashi's turn\n            moves = count_valid_moves(takahashi_hand, table)\n            if moves > 0:\n                # Take the smallest card from Takahashi's hand and place it on the table\n                card_to_play = min(takahashi_hand)\n                takahashi_hand.remove(card_to_play)\n                table.append(card_to_play)\n                # Check if there are any cards on the table that Takahashi can take\n                for card in takahashi_hand:\n                    if any(table_card < card for table_card in table):\n                        takahashi_hand.append(card)\n                        break\n            else:\n                # No valid moves, Takahashi loses\n                return 'Aoki'\n        else:\n            # Aoki's turn\n            moves = count_valid_moves(aoki_hand, table)\n            if moves > 0:\n                # Take the smallest card from Aoki's hand and place it on the table\n                card_to_play = min(aoki_hand)\n                aoki_hand.remove(card_to_play)\n                table.append(card_to_play)\n                # Check if there are any cards on the table that Aoki can take\n                for card in aoki_hand:\n                    if any(table_card < card for table_card in table):\n                        aoki_hand.append(card)\n                        break\n            else:\n                # No valid moves, Aoki loses\n                return 'Takahashi'\n        \n        # Switch to the other player\n        current_player = 'Aoki' if current_player == 'Takahashi' else 'Takahashi'\n\n# Example usage\nif __name__ == \"__main__\":\n    N, M, L = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    print(determine_winner(N, M, L, A, B, C))"
        ]
    },
    {
        "question_id": "abc380_c",
        "code_list": [
            "def move_1_block(N, K, S):\n    # Find the positions of all 1-blocks\n    blocks = []\n    start = None\n    for i in range(N):\n        if S[i] == '1':\n            if start is None:\n                start = i\n        elif start is not None:\n            blocks.append((start, i - 1))\n            start = None\n    \n    # If the last block is not followed by a zero, add it\n    if start is not None:\n        blocks.append((start, N - 1))\n    \n    # Extract the positions of the (K-1)-th and K-th blocks\n    r_k_minus_1, r_k = blocks[K - 2], blocks[K - 1]\n    \n    # Create the new string T\n    T = list(S)\n    for i in range(r_k_minus_1[1] + 1, r_k[1] + 1):\n        T[i] = '0'\n    for i in range(r_k_minus_1[1] + 1, r_k[1] + 1):\n        T[r_k_minus_1[1] + 1 + (i - r_k_minus_1[1])] = '1'\n    \n    return ''.join(T)\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    S = input().strip()\n    result = move_1_block(N, K, S)\n    print(result)"
        ]
    },
    {
        "question_id": "abc380_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    S = data[0]\n    Q = int(data[1])\n    Ks = list(map(int, data[2:]))\n\n    # Calculate the length of S after 10^100 operations\n    length = len(S) * (2 ** 100)\n\n    # Precompute the positions of characters in the final string\n    positions = [0] * 26  # For lowercase letters\n    positions_upper = [0] * 26  # For uppercase letters\n    for i, c in enumerate(S):\n        if c.islower():\n            positions[ord(c) - ord('a')] += 2 ** i\n        else:\n            positions_upper[ord(c.lower()) - ord('a')] += 2 ** i\n\n    # Function to find the character at position k\n    def find_char(k):\n        if k >= length:\n            return ''\n        result = []\n        for i in range(26):\n            if positions[i] + positions_upper[i] > k:\n                if positions[i] > k:\n                    result.append(chr(i + ord('a')))\n                else:\n                    result.append(chr(i + ord('A')))\n                break\n        return ''.join(result)\n\n    # Process each query\n    answers = [find_char(K - 1) for K in Ks]\n\n    print(' '.join(answers))"
        ]
    },
    {
        "question_id": "abc380_a",
        "code_list": [
            "def main():\n    N = int(input())\n    count_1 = 0\n    count_2 = 0\n    count_3 = 0\n    \n    while N > 0:\n        digit = N % 10\n        if digit == 1:\n            count_1 += 1\n        elif digit == 2:\n            count_2 += 1\n        elif digit == 3:\n            count_3 += 1\n        N //= 10\n    \n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_g",
        "code_list": [
            "from math import comb\n\ndef main():\n    N, K = map(int, input().split())\n    P = list(map(int, input().split()))\n\n    # Calculate the initial inversion number\n    inv_count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if P[i] > P[j]:\n                inv_count += 1\n\n    # Calculate the expected change in inversion number\n    expected_change = 0\n    for i in range(1, K + 1):\n        expected_change += (comb(K, i) * comb(N - K, i) * i * (i - 1) // 2) % 998244353\n        expected_change -= (comb(K, i) * comb(N - K, i) * i) % 998244353\n        expected_change += (comb(K, i) * comb(N - K, i) * (K - i)) % 998244353\n        expected_change -= (comb(K, i) * comb(N - K, i) * (K - i) * (K - i - 1) // 2) % 998244353\n\n    expected_change = (expected_change // 2) % 998244353\n\n    # Calculate the final expected value\n    result = (inv_count + expected_change) % 998244353\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = []\n    i = 1\n    while i < len(S):\n        count = 0\n        while i < len(S) and S[i] != '|':\n            count += 1\n            i += 1\n        result.append(count)\n        i += 1\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc381_a",
        "code_list": [
            "def is_11_22_string(N, S):\n    # Check if the length of S is odd\n    if len(S) % 2 == 0:\n        return \"No\"\n    \n    mid_index = (len(S) + 1) // 2\n    \n    # Check the first half of the string\n    for i in range(mid_index - 1):\n        if S[i] != '1':\n            return \"No\"\n    \n    # Check the middle character\n    if S[mid_index - 1] != '/':\n        return \"No\"\n    \n    # Check the second half of the string\n    for i in range(mid_index, len(S)):\n        if S[i] != '2':\n            return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input().strip()\n    print(is_11_22_string(N, S))"
        ]
    },
    {
        "question_id": "abc381_e",
        "code_list": [
            "def find_max_11_22_subsequence_length(N, S, queries):\n    def is_11_22_string(T):\n        mid = (len(T) + 1) // 2\n        if len(T) % 2 == 0 or T[mid - 1] != '/':\n            return False\n        for i in range(mid - 1):\n            if T[i] != '1':\n                return False\n        for i in range(mid, len(T)):\n            if T[i] != '2':\n                return False\n        return True\n\n    def max_11_22_subsequence(T):\n        max_len = 0\n        for start in range(len(T)):\n            for end in range(start, len(T)):\n                if is_11_22_string(T[start:end + 1]):\n                    max_len = max(max_len, end - start + 1)\n        return max_len\n\n    results = []\n    for L, R in queries:\n        substring = S[L - 1:R]\n        results.append(max_11_22_subsequence(substring))\n    return results\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    S = input().strip()\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    results = find_max_11_22_subsequence_length(N, S, queries)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc381_b",
        "code_list": [
            "from collections import Counter\n\ndef is_1122_string(S):\n    # Check if the length of the string is even\n    if len(S) % 2 != 0:\n        return False\n    \n    # Count the occurrences of each character\n    char_count = Counter(S)\n    \n    # Check if each character appears exactly zero or two times\n    for count in char_count.values():\n        if count not in [0, 2]:\n            return False\n    \n    # Check if the string satisfies the second condition\n    for i in range(1, len(S) // 2 + 1):\n        if S[2 * i - 2] != S[2 * i - 1]:\n            return False\n    \n    return True\n\ndef main():\n    S = input().strip()\n    if is_1122_string(S):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc381_c",
        "code_list": [
            "def find_max_11_22_length(N, S):\n    max_length = 0\n    current_length = 0\n    is_start = False\n    \n    for i in range(N):\n        if S[i] == '1':\n            if not is_start:\n                is_start = True\n            current_length += 1\n        elif S[i] == '/':\n            if is_start:\n                mid_index = (current_length + 1) // 2\n                if current_length >= mid_index * 2 + 1 and S[i - mid_index:i + 1] == ('1' * mid_index + '/' + '2' * mid_index):\n                    max_length = max(max_length, current_length)\n                is_start = False\n            current_length = 0\n        else:  # S[i] == '2'\n            if is_start:\n                mid_index = (current_length + 1) // 2\n                if current_length >= mid_index * 2 + 1 and S[i - mid_index:i + 1] == ('1' * mid_index + '/' + '2' * mid_index):\n                    max_length = max(max_length, current_length)\n                is_start = False\n            current_length = 0\n    \n    return max_length\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input().strip()\n    print(find_max_11_22_length(N, S))"
        ]
    },
    {
        "question_id": "abc381_d",
        "code_list": [
            "from collections import defaultdict\n\ndef find_max_length_subarray(A):\n    n = len(A)\n    max_length = 0\n    last_seen = defaultdict(lambda: -1)\n    \n    for i, num in enumerate(A):\n        if last_seen[num] != -1:\n            # Check if the subarray from last_seen[num] + 1 to i forms a valid 1122 sequence\n            start = last_seen[num] + 1\n            end = i\n            if (end - start + 1) % 2 == 0:\n                valid = True\n                counts = defaultdict(int)\n                for j in range(start, end + 1):\n                    counts[A[j]] += 1\n                    if counts[A[j]] > 2:\n                        valid = False\n                        break\n                if valid:\n                    max_length = max(max_length, end - start + 1)\n        last_seen[num] = i\n    \n    return max_length\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(find_max_length_subarray(A))"
        ]
    },
    {
        "question_id": "abc382_d",
        "code_list": [
            "def generate_sequences(N, M):\n    def backtrack(start, path):\n        if len(path) == N:\n            if path[-1] <= M:\n                result.append(path[:])\n            return\n        for next_val in range(start, min(M - (N - len(path)), start + 10) + 1):\n            path.append(next_val)\n            backtrack(next_val + 1, path)\n            path.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef main():\n    N, M = map(int, input().split())\n    sequences = generate_sequences(N, M)\n    print(len(sequences))\n    for seq in sequences:\n        print(\" \".join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_a",
        "code_list": [
            "def main():\n    N, D = map(int, input().split())\n    S = input()\n    # Count the number of cookies\n    cookies = S.count('@')\n    # The number of empty boxes will be the total boxes minus the number of cookies\n    empty_boxes = N - min(cookies, D)\n    print(empty_boxes)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_b",
        "code_list": [
            "def main():\n    N, D = map(int, input().split())\n    S = input()\n    \n    # Find the positions of all cookies\n    cookies_positions = [i for i, char in enumerate(S) if char == '@']\n    \n    # Determine which boxes will still have cookies after D days\n    result = ['.' for _ in range(N)]\n    for i in range(D):\n        result[cookies_positions[i]] = '@'\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_f",
        "code_list": [
            "def main():\n    # Read input\n    H, W, N = map(int, input().split())\n    bars = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    # Determine the final positions of the bars\n    for R, C, L in bars:\n        # Calculate how many steps the bar needs to move down\n        steps = (H - R)\n        # Since each step takes 0.5 units of time, total time taken is 0.5 * steps\n        # We need to find the position after 10^100 units of time\n        # Given that 10^100 is much larger than the number of steps required for any bar to reach the bottom,\n        # we can simply calculate the final position based on the steps\n        final_row = R + steps\n        print(final_row)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_g",
        "code_list": [
            "def calculate_min_moves(K, S_x, S_y, T_x, T_y):\n    def get_tile(i, j, k):\n        return (i // 2 * K + (i % 2 != j % 2), i // 2 * K + j // 2, k)\n\n    def distance_to_tile(S_i, S_j, S_k, T_i, T_j, T_k):\n        return abs(S_i - T_i) + abs(S_j - T_j) + abs(S_k - T_k)\n\n    S_i, S_j = divmod(S_x, K)\n    S_k = (S_y - S_j * K) % K\n    T_i, T_j = divmod(T_x, K)\n    T_k = (T_y - T_j * K) % K\n\n    if S_i % 2 == S_j % 2:\n        S_tile = get_tile(S_i, S_j, S_k)\n        T_tile = get_tile(T_i, T_j, T_k)\n    else:\n        S_tile = get_tile(S_j, S_i, S_k)\n        T_tile = get_tile(T_j, T_i, T_k)\n\n    return distance_to_tile(*S_tile, *T_tile)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    T = int(data[index])\n    index += 1\n\n    results = []\n    for _ in range(T):\n        K = int(data[index])\n        S_x = int(data[index + 1])\n        S_y = int(data[index + 2])\n        T_x = int(data[index + 3])\n        T_y = int(data[index + 4])\n        index += 5\n        result = calculate_min_moves(K, S_x, S_y, T_x, T_y)\n        results.append(str(result))\n\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Initialize the result array\n    result = [-1] * M\n\n    # Process each sushi\n    for j, b in enumerate(B):\n        # Find the first person who can eat the sushi\n        for i in range(N):\n            if A[i] >= b:\n                # Mark the sushi as eaten by person i\n                result[j] = i + 1\n                # Remove person i from consideration\n                A[i] = 0\n                break\n\n    # Print the results\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc383_c",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, h, w, d):\n    visited = [[False] * w for _ in range(h)]\n    queue = deque()\n    \n    # Initialize the queue with all humidifiers\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'H':\n                queue.append((i, j))\n                visited[i][j] = True\n    \n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    distance = 0\n    \n    while queue and distance <= d:\n        size = len(queue)\n        for _ in range(size):\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < h and 0 <= ny < w and not visited[nx][ny] and grid[nx][ny] != '#':\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n        distance += 1\n    \n    count = 0\n    for i in range(h):\n        for j in range(w):\n            if visited[i][j] and grid[i][j] == '.':\n                count += 1\n                \n    return count\n\ndef main():\n    h, w, d = map(int, input().split())\n    grid = [input().strip() for _ in range(h)]\n    print(bfs(grid, h, w, d))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc383_a",
        "code_list": [
            "def main():\n    N = int(input())\n    water_level = 0\n    for _ in range(N):\n        T, V = map(int, input().split())\n        water_level += V - (T - water_level)\n        water_level = max(0, water_level)\n    print(water_level)"
        ]
    },
    {
        "question_id": "abc383_e",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > max(d, w):\n                dist[v] = max(d, w)\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef build_graph(edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    return graph\n\ndef min_path_sum(n, m, k, edges, a, b):\n    graph = build_graph(edges)\n    dist = [dijkstra(graph, i) for i in range(n)]\n    \n    def f(x, y):\n        return dist[x][y]\n    \n    b_perm = sorted(range(k), key=lambda i: -f(a[i]-1, b[i]-1))\n    return sum(f(a[i]-1, b[b_perm[i]]-1) for i in range(k))\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        edges.append((u, v, w))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    print(min_path_sum(n, m, k, edges, a, b))"
        ]
    },
    {
        "question_id": "abc383_b",
        "code_list": [
            "def find_max_humidified_cells(H, W, D, grid):\n    def is_within_distance(x1, y1, x2, y2, D):\n        return abs(x1 - x2) + abs(y1 - y2) <= D\n    \n    def mark_cells_as_humidified(x, y, D, visited):\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == '.' and not visited[i][j] and is_within_distance(x, y, i, j, D):\n                    visited[i][j] = True\n    \n    max_humidified = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                for k in range(i + 1, H):\n                    for l in range(k + 1, H):\n                        if grid[k][l] == '.':\n                            visited = [[False] * W for _ in range(H)]\n                            mark_cells_as_humidified(i, j, D, visited)\n                            mark_cells_as_humidified(k, l, D, visited)\n                            humidified_count = sum(row.count(True) for row in visited)\n                            max_humidified = max(max_humidified, humidified_count)\n    \n    return max_humidified\n\ndef main():\n    H, W, D = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    print(find_max_humidified_cells(H, W, D, grid))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc383_d",
        "code_list": [
            "import math\n\ndef count_numbers_with_nine_divisors(N):\n    def count_divisors(n):\n        count = 0\n        root = int(math.sqrt(n))\n        if root * root == n:\n            count += 1\n        for i in range(1, int(math.sqrt(n))):\n            if n % i == 0:\n                count += 1\n                if n // i != i:\n                    count += 1\n        return count\n    \n    result = 0\n    for i in range(1, int(math.sqrt(N)) + 1):\n        if N % (i * i) == 0:\n            if count_divisors(i * i) == 9:\n                result += 1\n            if i * i != N // (i * i) * (i * i):\n                if count_divisors(N // (i * i)) == 9:\n                    result += 1\n    return result\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(count_numbers_with_nine_divisors(N))"
        ]
    },
    {
        "question_id": "abc384_b",
        "code_list": [
            "def calculate_rating(N, R, contests):\n    for i in range(N):\n        D, A = contests[i]\n        if D == 1:\n            if 1600 <= R <= 2799:\n                R += A\n        else:\n            if 1200 <= R <= 2399:\n                R += A\n    return R\n\nif __name__ == \"__main__\":\n    N, R = map(int, input().split())\n    contests = [tuple(map(int, input().split())) for _ in range(N)]\n    print(calculate_rating(N, R, contests))"
        ]
    },
    {
        "question_id": "abc384_d",
        "code_list": [
            "from itertools import accumulate\n\ndef find_subsequence(N, S, A):\n    # Calculate prefix sums\n    prefix_sums = [0] + list(accumulate(A))\n    \n    # Create a set to store possible prefix sums modulo N\n    mod_set = set()\n    \n    # Iterate through the prefix sums\n    for i in range(N + 1):\n        mod_val = prefix_sums[i] % N\n        if mod_val in mod_set:\n            # Check if there exists a subsequence with sum S\n            if (prefix_sums[i + S // N * N] - prefix_sums[i]) == S:\n                return \"Yes\"\n        mod_set.add(mod_val)\n    \n    return \"No\"\n\nif __name__ == \"__main__\":\n    N, S = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(find_subsequence(N, S, A))"
        ]
    },
    {
        "question_id": "abc384_g",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def get_prefix_sum(arr):\n        prefix_sum = [0]\n        for num in arr:\n            prefix_sum.append(prefix_sum[-1] + num)\n        return prefix_sum\n\n    N = data[0]\n    A = data[1:N+1]\n    B = data[N+1:2*N+1]\n    prefix_A = get_prefix_sum(A)\n    prefix_B = get_prefix_sum(B)\n\n    K = data[2*N+1]\n    queries = [(data[2*N+2+i*2], data[2*N+2+i*2+1]) for i in range(K)]\n\n    for X, Y in queries:\n        result = prefix_A[X] + prefix_B[Y] - 2 * sum(min(A[i], B[j]) for i in range(X) for j in range(Y))\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_a",
        "code_list": [
            "def main():\n    # Read input\n    N, c1, c2 = input().split()\n    S = input().strip()\n\n    # Replace every character of S that is not c1 with c2\n    result = ''.join(c2 if c != c1 else c for c in S)\n\n    # Print the result\n    print(result)"
        ]
    },
    {
        "question_id": "abc384_e",
        "code_list": [
            "import heapq\nfrom collections import deque\n\ndef main():\n    H, W, X = map(int, input().split())\n    P, Q = map(int, input().split())\n    S = [list(map(int, input().split())) for _ in range(H)]\n\n    # Initialize the priority queue with the starting position\n    pq = [(S[P-1][Q-1], P-1, Q-1)]\n    visited = set([(P-1, Q-1)])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\n    while pq:\n        current_strength, r, c = heapq.heappop(pq)\n        if current_strength > 1e12:  # If the strength exceeds the maximum possible value, break\n            break\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in visited:\n                next_strength = current_strength + S[nr][nc]\n                if next_strength / X > S[nr][nc]:\n                    heapq.heappush(pq, (next_strength, nr, nc))\n                    visited.add((nr, nc))\n\n    print(current_strength)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_f",
        "code_list": [
            "def f(x):\n    while x % 2 == 0:\n        x //= 2\n    return x\n\ndef main():\n    import collections\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Count occurrences of each number\n    count = collections.Counter(A)\n    \n    # Calculate the contribution of each pair (i, j)\n    total_sum = 0\n    for i in range(N):\n        for j in range(i, N):\n            total_sum += f(A[i] + A[j])\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_c",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    # Read input scores\n    scores = list(map(int, input().split()))\n    \n    # Generate all possible subsequences of ABCDE\n    subsequences = []\n    for r in range(1, 6):\n        for combo in combinations('ABCDE', r):\n            subsequences.append(combo)\n    \n    # Calculate scores for each participant\n    participants = []\n    for subseq in subsequences:\n        score = sum(scores[ord(char) - ord('A')] for char in subseq)\n        participants.append((subseq, score))\n    \n    # Sort participants by score and then lexicographically\n    participants.sort(key=lambda x: (-x[1], x[0]))\n    \n    # Print the names of participants in order of their obtained scores\n    for participant in participants:\n        print(''.join(participant[0]))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_f",
        "code_list": [
            "from bisect import bisect_left\n\ndef main():\n    N = int(input())\n    buildings = []\n    for _ in range(N):\n        X, H = map(int, input().split())\n        buildings.append((X, H))\n    \n    # Sort buildings based on their X coordinates\n    buildings.sort()\n    \n    # Calculate the slope for each pair of consecutive buildings\n    slopes = []\n    for i in range(1, N):\n        X1, H1 = buildings[i-1]\n        X2, H2 = buildings[i]\n        if H1 > H2:\n            slopes.append((H1 - H2) / (X2 - X1))\n    \n    # Find the maximum height at coordinate 0 from which it is not possible to see all buildings\n    max_height = -1\n    for i in range(len(slopes)):\n        if i == 0:\n            max_height = max(max_height, slopes[i] * buildings[i][0])\n        else:\n            prev_slope = slopes[i-1]\n            current_slope = slopes[i]\n            if current_slope > prev_slope:\n                max_height = max(max_height, (prev_slope + current_slope) / 2 * buildings[i][0])\n    \n    # Check the last slope\n    if len(slopes) > 0:\n        max_height = max(max_height, slopes[-1] * buildings[-1][0])\n    \n    print(max_height)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_a",
        "code_list": [
            "def main():\n    A, B, C = map(int, input().split())\n    total_sum = A + B + C\n    \n    # If the total sum is odd, it's impossible to divide it into equal parts\n    if total_sum % 2 != 0:\n        print(\"No\")\n    else:\n        target_sum = total_sum // 2\n        \n        # Check if we can form a subset with the target sum\n        dp = [False] * (target_sum + 1)\n        dp[0] = True\n        \n        for num in [A, B, C]:\n            for i in range(target_sum, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n        \n        if dp[target_sum]:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_c",
        "code_list": [
            "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    N = int(input())\n    heights = list(map(int, input().split()))\n    \n    max_buildings = 1\n    for i in range(N):\n        for j in range(i + 1, N):\n            if heights[i] == heights[j]:\n                interval = j - i\n                k = j + interval\n                while k < N and heights[k] == heights[i]:\n                    k += interval\n                max_buildings = max(max_buildings, (k - i) // interval)\n    \n    print(max_buildings)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_d",
        "code_list": [
            "def main():\n    # Read input\n    N, M, S_x, S_y = map(int, input().split())\n    houses = [tuple(map(int, input().split())) for _ in range(N)]\n    moves = [input().split() for _ in range(M)]\n\n    # Initialize current position\n    x, y = S_x, S_y\n    visited_houses = set()\n\n    # Process each move\n    for move in moves:\n        direction, distance = move[0], int(move[1])\n        if direction == 'U':\n            y += distance\n        elif direction == 'D':\n            y -= distance\n        elif direction == 'L':\n            x -= distance\n        elif direction == 'R':\n            x += distance\n\n        # Check if any house was passed through or arrived at\n        for house in houses:\n            if (x, y) == house:\n                visited_houses.add(house)\n\n    # Output the final position and number of distinct houses visited\n    print(x, y, len(visited_houses))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_e",
        "code_list": [
            "import sys\n\ndef find(x):\n    if p[x] != x:\n        p[x] = find(p[x])\n    return p[x]\n\ndef unite(x, y):\n    x, y = find(x), find(y)\n    if x == y:\n        return False\n    if r[x] < r[y]:\n        x, y = y, x\n    p[y] = x\n    if r[x] == r[y]:\n        r[x] += 1\n    return True\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef main():\n    input = sys.stdin.read\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u - 1, v - 1))\n    \n    # Initialize parent and rank arrays\n    p = list(range(n))\n    r = [0] * n\n    \n    # Union-Find to group connected components\n    for u, v in edges:\n        unite(u, v)\n    \n    # Count the number of connected components\n    component_count = sum(1 for i in range(n) if p[i] == i)\n    \n    # If there's only one component, no need to delete any vertex\n    if component_count == 1:\n        print(0)\n        return\n    \n    # Find the root of each component\n    roots = set(find(i) for i in range(n))\n    \n    # Check for potential snowflake trees\n    def check(x, y):\n        nonlocal roots\n        count_x = 0\n        count_y = 0\n        for i in range(n):\n            if find(i) == x:\n                count_x += 1\n            elif find(i) == y:\n                count_y += 1\n        if count_x > 1 and count_y > 1:\n            return True\n        return False\n    \n    # Try to merge components to form a snowflake tree\n    min_deletions = float('inf')\n    for root in roots:\n        for other_root in roots:\n            if root != other_root and check(root, other_root):\n                min_deletions = min(min_deletions, len(edges) - (component_count - 1))\n                break\n        else:\n            continue\n        break\n    \n    print(min_deletions)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_b",
        "code_list": [
            "def main():\n    H, W, X, Y = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    T = input()\n\n    visited_houses = set()\n    current_x, current_y = X - 1, Y - 1\n\n    for direction in T:\n        if direction == 'U' and current_x > 0 and grid[current_x - 1][current_y] != '#':\n            current_x -= 1\n        elif direction == 'D' and current_x < H - 1 and grid[current_x + 1][current_y] != '#':\n            current_x += 1\n        elif direction == 'L' and current_y > 0 and grid[current_x][current_y - 1] != '#':\n            current_y -= 1\n        elif direction == 'R' and current_y < W - 1 and grid[current_x][current_y + 1] != '#':\n            current_y += 1\n\n        if grid[current_x][current_y] == '@':\n            visited_houses.add((current_x, current_y))\n\n    print(current_x + 1, current_y + 1, len(visited_houses))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc386_e",
        "code_list": [
            "from typing import List\n\ndef max_xor_subset(A: List[int], K: int) -> int:\n    N = len(A)\n    max_xor = 0\n    \n    # Precompute the prefix XOR for all elements\n    prefix_xor = [0] * (N + 1)\n    for i in range(N):\n        prefix_xor[i + 1] = prefix_xor[i] ^ A[i]\n    \n    # Use dynamic programming to find the maximum XOR subset\n    dp = [False] * (1 << K)\n    for mask in range(1 << N):\n        if bin(mask).count('1') == K:\n            current_xor = prefix_xor[N] ^ prefix_xor[bin(mask).index('1')]\n            for submask in range(mask):\n                if (submask & mask) == submask and dp[submask]:\n                    current_xor ^= prefix_xor[bin(submask).index('1')]\n            dp[mask] = current_xor > max_xor\n            if dp[mask]:\n                max_xor = current_xor\n    \n    return max_xor\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(max_xor_subset(A, K))"
        ]
    },
    {
        "question_id": "abc386_a",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    # Read input\n    A, B, C, D = map(int, input().split())\n    \n    # Count occurrences of each number\n    counts = Counter([A, B, C, D])\n    \n    # Check for possible Full House formation\n    for i in range(1, 14):\n        if i not in counts:\n            # Create a new count dictionary with the added card\n            new_counts = counts.copy()\n            new_counts[i] += 1\n            \n            # Check if the new count dictionary forms a Full House\n            if (new_counts.most_common(1)[0][1] == 3 and \n                len(new_counts) == 2 and \n                new_counts.most_common()[-1][1] == 2):\n                print(\"Yes\")\n                return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc386_d",
        "code_list": [
            "def can_color_grid(N, M, colored_cells):\n    # Initialize sets to keep track of the minimum and maximum black cells for rows and columns\n    min_black_rows = [N] * N\n    max_black_cols = [N] * N\n    \n    # Process the colored cells\n    for x, y, color in colored_cells:\n        if color == 'B':\n            min_black_rows[x-1] = min(min_black_rows[x-1], y)\n            max_black_cols[y-1] = min(max_black_cols[y-1], x)\n    \n    # Check if the conditions can be satisfied\n    for i in range(N):\n        if min_black_rows[i] > i + 1 or max_black_cols[i] > i + 1:\n            return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    colored_cells = []\n    for _ in range(M):\n        x, y, c = input().split()\n        colored_cells.append((int(x), int(y), c))\n    print(can_color_grid(N, M, colored_cells))"
        ]
    },
    {
        "question_id": "abc386_c",
        "code_list": [
            "def can_transform(K, S, T):\n    if len(S) > len(T):\n        # If S is longer than T, we need at least as many insertions as the difference in lengths\n        if len(S) - len(T) > K:\n            return \"No\"\n    elif len(S) < len(T):\n        # If S is shorter than T, we need at most one deletion and insertions to match the lengths\n        if len(T) - len(S) > K:\n            return \"No\"\n    \n    # Calculate the number of differing characters\n    diff_count = sum(1 for s_char, t_char in zip(S, T) if s_char != t_char)\n    \n    # Check if the number of differing characters can be handled within K operations\n    if diff_count <= K:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nif __name__ == \"__main__\":\n    K = int(input().strip())\n    S = input().strip()\n    T = input().strip()\n    print(can_transform(K, S, T))"
        ]
    },
    {
        "question_id": "abc386_b",
        "code_list": [
            "def min_button_presses(S):\n    # Initialize the dp array where dp[i] represents the minimum number of button presses to display the first i characters of S\n    dp = [float('inf')] * (len(S) + 1)\n    dp[0] = 0  # Base case: no presses needed for an empty string\n    \n    # Iterate through each character in the string S\n    for i in range(1, len(S) + 1):\n        # Try to form the current character using a single digit\n        dp[i] = dp[i - 1] + 1\n        \n        # Try to form the current character using a two-digit number if possible\n        if i > 1 and int(S[i - 2:i]) <= 26:\n            dp[i] = min(dp[i], dp[i - 2] + 1)\n    \n    return dp[len(S)]\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(min_button_presses(S))"
        ]
    },
    {
        "question_id": "abc386_f",
        "code_list": [
            "def can_transform(k, s, t):\n    if len(s) > len(t):\n        return \"No\"\n    \n    # Calculate the minimum number of insertions needed\n    insertions = len(t) - len(s)\n    \n    # If insertions exceed k, return No\n    if insertions > k:\n        return \"No\"\n    \n    # Calculate the number of deletions and replacements needed\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] != t[j]:\n            j += 1\n            k -= 1\n        else:\n            i += 1\n            j += 1\n    \n    # If k is negative, it means we need more than k operations\n    if k < 0:\n        return \"No\"\n    \n    # Check if remaining characters in t can be matched with remaining characters in s\n    while j < len(t):\n        j += 1\n        k -= 1\n    \n    if k < 0:\n        return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    k = int(input().strip())\n    s = input().strip()\n    t = input().strip()\n    print(can_transform(k, s, t))"
        ]
    },
    {
        "question_id": "arc184_d",
        "code_list": [
            "from typing import List\n\ndef count_possible_sets(N: int, points: List[List[int]]) -> int:\n    MOD = 998244353\n    \n    def dfs(index: int, mask: int, x_max: int, y_max: int) -> int:\n        if index == N:\n            return 1\n        \n        count = 0\n        for i in range(N):\n            if mask & (1 << i) == 0:\n                if (points[i][0] > x_max and points[i][1] > y_max) or (points[i][0] < x_max and points[i][1] < y_max):\n                    count += dfs(index + 1, mask | (1 << i), max(x_max, points[i][0]), max(y_max, points[i][1]))\n                    count %= MOD\n        \n        return count\n    \n    return dfs(0, 0, 0, 0)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    points = [list(map(int, input().split())) for _ in range(N)]\n    print(count_possible_sets(N, points))"
        ]
    },
    {
        "question_id": "arc184_c",
        "code_list": [
            "def count_mountain_folds(N, A):\n    # Initialize the prefix sum array for A\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    \n    # Initialize the DP table\n    dp = [[0] * (N + 1) for _ in range(2**100)]\n    \n    # Base case: the first crease is always a mountain fold\n    for i in range(2**100):\n        dp[i][0] = 1\n    \n    # Fill the DP table\n    for k in range(1, N + 1):\n        for i in range(2**100):\n            if i & (1 << (k - 1)):\n                dp[i][k] = dp[i ^ (1 << (k - 1))][k - 1]\n            else:\n                dp[i][k] = dp[i][k - 1]\n    \n    # Calculate the result\n    max_count = 0\n    for i in range(2**100 - A[-1] - 1):\n        count = 0\n        for j in range(1, N + 1):\n            if prefix_sum[j] <= i + A[j - 1]:\n                count += dp[i + A[j - 1]][j]\n        max_count = max(max_count, count)\n    \n    return max_count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(count_mountain_folds(N, A))"
        ]
    },
    {
        "question_id": "arc184_e",
        "code_list": [
            "from collections import defaultdict\nfrom typing import List\n\ndef main():\n    N, M = map(int, input().split())\n    sequences = [list(map(int, input().split())) for _ in range(N)]\n    \n    def transform(seq: List[int]) -> List[int]:\n        transformed = []\n        prefix_sum = 0\n        for bit in seq:\n            prefix_sum = (prefix_sum + bit) % 2\n            transformed.append(prefix_sum)\n        return transformed\n    \n    def find_min_operations(seq1: List[int], seq2: List[int]) -> int:\n        if seq1 == seq2:\n            return 0\n        for x in range(M):\n            if seq1[x] != seq2[x]:\n                break\n        else:\n            return 0\n        \n        # Find the first mismatch and check if we can make them equal\n        for i in range(x + 1, M):\n            if seq1[i] != seq2[i]:\n                return -1\n        \n        return M - x\n    \n    # Transform all sequences\n    transformed_sequences = [transform(seq) for seq in sequences]\n    \n    # Create a dictionary to store the frequency of each transformed sequence\n    seq_freq = defaultdict(int)\n    for seq in transformed_sequences:\n        seq_freq[tuple(seq)] += 1\n    \n    result = 0\n    for seq in transformed_sequences:\n        for i in range(len(seq)):\n            new_seq = seq[:i] + [seq[i] ^ 1] + seq[i+1:]\n            if tuple(new_seq) in seq_freq:\n                result += seq_freq[tuple(new_seq)]\n    \n    print(result % 998244353)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc185_c",
        "code_list": [
            "def find_triplet(N, X, A):\n    # Create a dictionary to store the indices of elements for quick lookup\n    index_map = {val: [] for val in A}\n    for idx, val in enumerate(A):\n        index_map[val].append(idx)\n    \n    # Iterate through each pair of indices (i, j)\n    for i in range(N):\n        for j in range(i + 1, N):\n            target = X - A[i] - A[j]\n            if target in index_map:\n                # Find the first index greater than j in the list of indices for target\n                for k in index_map[target]:\n                    if k > j:\n                        return [i + 1, j + 1, k + 1]  # Return 1-based indices\n    return [-1]\n\ndef main():\n    N, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    result = find_triplet(N, X, A)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc185_e",
        "code_list": [
            "from math import gcd\nfrom collections import defaultdict\nfrom functools import reduce\nfrom operator import add\n\nMOD = 998244353\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sorted(divisors)\n\n    def solve():\n        divisors = get_divisors(max(a))\n        dp = [defaultdict(int) for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(n):\n            for d in divisors:\n                dp[i + 1][d] += dp[i][d]\n                dp[i + 1][d] %= MOD\n                if a[i] % d == 0:\n                    dp[i + 1][a[i] // d] += dp[i][d]\n                    dp[i + 1][a[i] // d] %= MOD\n\n        ans = 0\n        for i in range(1, n + 1):\n            for d in divisors:\n                ans += dp[i][d] * (i - 1)\n                ans %= MOD\n\n        print(ans)\n\n    for m in range(1, n + 1):\n        solve()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc185_b",
        "code_list": [
            "def can_make_non_decreasing(N, A):\n    # Check if the sequence can be made non-decreasing\n    for i in range(1, N):\n        if A[i] < A[i-1]:\n            return False\n    return True\n\ndef solve_test_case():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Check if the sequence is already non-decreasing\n    if can_make_non_decreasing(N, A):\n        print(\"Yes\")\n    else:\n        # Check if we can make the sequence non-decreasing by balancing the differences\n        balance = 0\n        for i in range(1, N):\n            balance += A[i] - A[i-1]\n            if balance < 0:\n                break\n        else:\n            print(\"Yes\")\n            return\n        \n        # Check if the total imbalance can be balanced by the remaining elements\n        if balance % 2 == 0 and abs(balance) <= A[-1] - A[0]:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    T = int(input())\n    for _ in range(T):\n        solve_test_case()"
        ]
    },
    {
        "question_id": "arc185_d",
        "code_list": [
            "def main():\n    from math import gcd\n\n    def modinv(a, m=998244353):\n        return pow(a, m - 2, m)\n\n    def solve(N, M):\n        MOD = 998244353\n        dp = [0] * (N * M + 1)\n        dp[0] = 1\n        for i in range(1, N * M + 1):\n            if i < N:\n                dp[i] += dp[i - 1]\n            else:\n                dp[i] += dp[i - N]\n            dp[i] %= MOD\n        total = sum(dp) % MOD\n        inv_total = modinv(total)\n        result = 0\n        for i in range(1, N * M + 1):\n            result += dp[i - 1] * (i + (i - N if i >= N else 0)) % MOD * inv_total\n            result %= MOD\n        return result\n\n    N, M = map(int, input().split())\n    print(solve(N, M))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_a",
        "code_list": [
            "def is_possible(N, K):\n    total_elements = N * N\n    # Check if K is within the possible range\n    if K > total_elements or K % N != 0 and K % (N - 1) != 0:\n        return False\n    return True\n\ndef main():\n    N, Q = map(int, input().split())\n    results = []\n    for _ in range(Q):\n        K = int(input())\n        results.append('Yes' if is_possible(N, K) else 'No')\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_d",
        "code_list": [
            "from functools import lru_cache\n\nMOD = 998244353\n\n@lru_cache(None)\ndef count_polish_sequences(n):\n    if n == 0:\n        return 1\n    total = 0\n    for i in range(n + 1):\n        total += count_polish_sequences(i) * count_polish_sequences(n - i)\n        total %= MOD\n    return total\n\ndef main():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(a[i - 1] + 1):\n            dp[i] += dp[i - j - 1] * count_polish_sequences(j)\n            dp[i] %= MOD\n    \n    print(dp[n])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_b",
        "code_list": [
            "from typing import List\n\ndef count_valid_permutations(N: int, A: List[int]) -> int:\n    MOD = 998244353\n    dp = [1] * (N + 1)\n    stack = []\n    \n    for i in range(N):\n        while stack and A[stack[-1]] < A[i]:\n            stack.pop()\n        if stack:\n            left = stack[-1] + 1\n        else:\n            left = 0\n        right = i - A[i]\n        dp[i + 1] = (dp[left] * (right - left)) % MOD\n        \n        while stack and A[stack[-1]] > A[i]:\n            idx = stack.pop()\n            dp[idx] = (dp[idx] * (i - idx)) % MOD\n        stack.append(i)\n    \n    return sum(dp[N:]) % MOD\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(count_valid_permutations(N, A))"
        ]
    },
    {
        "question_id": "arc186_e",
        "code_list": [
            "from collections import defaultdict\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef main():\n    N, M, K = map(int, input().split())\n    X = list(map(int, input().split()))\n\n    @lru_cache(None)\n    def dp(i, j):\n        if i == N:\n            return 1\n        if j == M:\n            return 0\n        res = dp(i, j + 1) * K % MOD\n        if X[j] <= i:\n            res += dp(i - X[j], j + 1)\n        res %= MOD\n        return res\n\n    total_sequences = pow(K, N, MOD)\n    invalid_sequences = dp(N - 1, 0)\n    valid_sequences = (total_sequences - invalid_sequences) % MOD\n    print(valid_sequences)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_c",
        "code_list": [
            "import heapq\n\ndef calculate_money_increase(N, M, V, P):\n    # Calculate the maximum capacity per yen for each box\n    max_capacity_per_yen = [(v / p, v, p) for v, p in zip(V, P)]\n    heapq.heapify(max_capacity_per_yen)\n    \n    # Sort the boxes by their capacity in descending order\n    sorted_boxes = sorted(max_capacity_per_yen, key=lambda x: -x[1])\n    \n    # Initialize variables\n    total_money_increase = 0\n    current_capacity = 0\n    \n    # Process each box\n    for _, v, p in sorted_boxes:\n        if current_capacity + v <= 10**100:\n            current_capacity += v\n            total_money_increase += 1\n        else:\n            break\n    \n    # Calculate the money increase based on the number of boxes used\n    return total_money_increase * p\n\ndef main():\n    T = int(input())\n    results = []\n    for _ in range(T):\n        N, M = map(int, input().split())\n        V = [0] * N\n        P = [0] * N\n        for i in range(N):\n            V[i], P[i] = map(int, input().split())\n        \n        result = calculate_money_increase(N, M, V, P)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc187_b",
        "code_list": [
            "from collections import defaultdict\nfrom math import comb\n\ndef main():\n    N, M = map(int, input().split())\n    B = list(map(int, input().split()))\n    \n    # Count the number of -1s and their positions\n    num_negatives = B.count(-1)\n    negative_positions = [i for i, x in enumerate(B) if x == -1]\n    \n    # Initialize the result\n    result = 0\n    \n    # Iterate through all possible replacements for -1s\n    for mask in range(1 << num_negatives):\n        new_B = B[:]\n        for i in range(num_negatives):\n            if mask & (1 << i):\n                new_B[negative_positions[i]] = 1\n            else:\n                new_B[negative_positions[i]] = M\n        \n        # Calculate the number of connected components\n        component_count = 0\n        visited = set()\n        \n        def dfs(index):\n            if index in visited:\n                return\n            visited.add(index)\n            for next_index in range(N):\n                if new_B[next_index] <= new_B[index] and next_index not in visited:\n                    dfs(next_index)\n        \n        for i in range(N):\n            if i not in visited:\n                dfs(i)\n                component_count += 1\n        \n        # Add the contribution of this configuration to the result\n        result += pow(M, num_negatives - bin(mask).count('1'), 998244353) * component_count % 998244353\n    \n    print(result % 998244353)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc188_c",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef find_confused_villagers(N, M, testimonies):\n    # Create a graph to represent the relationships between villagers\n    graph = defaultdict(list)\n    for A, B, C in testimonies:\n        graph[A].append((B, C))\n        graph[B].append((A, 1 - C))  # Opposite of C because B's perspective\n\n    def dfs(v, status, visited):\n        if v in visited:\n            return True\n        visited.add(v)\n        for u, c in graph[v]:\n            if status[u] == -1:  # Confused\n                if not dfs(u, [1 - s for s in status], visited):\n                    return False\n            elif (status[u] != (c ^ (status[v] == 1))):\n                return False\n        return True\n\n    for confused in range(1 << N):\n        status = [-1] * N\n        for i in range(N):\n            if confused & (1 << i):\n                status[i] = 1  # Confused and telling the truth\n            else:\n                status[i] = 0  # Not confused or lying\n\n        visited = set()\n        for i in range(1, N + 1):\n            if i not in visited and not dfs(i, status, visited):\n                break\n        else:\n            return ''.join(str(s) for s in map(int, status))\n\n    return -1\n\ndef main():\n    N, M = map(int, input().split())\n    testimonies = [tuple(map(int, input().split())) for _ in range(M)]\n    result = find_confused_villagers(N, M, testimonies)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc188_b",
        "code_list": [
            "def can_color_all_points(T):\n    def can_color(N, K):\n        # If K is 1, then Alice and Bob can always color all points black\n        if K == 1:\n            return True\n        \n        # If N is even, then K must also be even for symmetry to work\n        if N % 2 == 0:\n            return K % 2 == 0\n        \n        # If N is odd, then K can be either even or odd\n        return True\n    \n    results = []\n    for _ in range(T):\n        N, K = map(int, input().split())\n        if can_color(N, K):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    can_color_all_points()"
        ]
    },
    {
        "question_id": "arc188_d",
        "code_list": [
            "from itertools import permutations\nfrom math import factorial\n\nMOD = 998244353\n\ndef count_sequences(N, A, B):\n    # Create a list of available numbers for each position\n    available_numbers = [set(range(1, N + 1)) for _ in range(3)]\n    \n    # Update available numbers based on the given sequences A and B\n    for i in range(N):\n        if A[i] != -1:\n            available_numbers[0].remove(A[i])\n        if B[i] != -1:\n            available_numbers[1].remove(B[i])\n            available_numbers[2].remove(B[i])\n    \n    # Calculate the number of valid sequences\n    def calculate_ways():\n        ways = 1\n        for i in range(3):\n            if len(available_numbers[i]) == 0:\n                return 0\n            ways *= factorial(len(available_numbers[i]))\n            ways %= MOD\n        return ways\n    \n    total_ways = 0\n    \n    # Generate all possible permutations for the remaining positions\n    for perm in permutations(range(1, N + 1)):\n        for i in range(3):\n            if len(available_numbers[i]) > 0:\n                available_numbers[i].discard(perm[i % len(perm)])\n        \n        # Check if the current permutation can form valid sequences\n        if all(len(set_) == 0 for set_ in available_numbers):\n            total_ways += calculate_ways()\n            total_ways %= MOD\n    \n    return total_ways\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    result = count_sequences(N, A, B)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc188_a",
        "code_list": [
            "from collections import defaultdict\n\nMOD = 998244353\n\ndef is_good_string(s):\n    stack = []\n    for char in s:\n        if char == 'A':\n            if len(stack) >= 2 and stack[-2] == 'A' and stack[-1] == 'A':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == 'B':\n            if len(stack) >= 2 and stack[-2] == 'B' and stack[-1] == 'B':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == 'C':\n            if len(stack) >= 2 and stack[-2] == 'C' and stack[-1] == 'C':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == '?':\n            stack.append('?')\n    return len(stack) == 0\n\ndef count_good_substrings(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if is_good_string(substring):\n                count += 1\n    return count\n\ndef solve(n, k, s):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if s[i - 1] == '?':\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n                if j > 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n            else:\n                if count_good_substrings(s[:i]) >= j:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n    return dp[n][k]\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    s = input().strip()\n    print(solve(n, k, s))"
        ]
    },
    {
        "question_id": "arc189_a",
        "code_list": [
            "from math import comb\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    # Calculate the number of 0s and 1s\n    count_0 = A.count(0)\n    count_1 = A.count(1)\n\n    # If the counts of 0s and 1s are not equal, it's impossible to achieve the target configuration\n    if count_0 != count_1:\n        print(0)\n        return\n\n    # Calculate the number of ways to arrange the 0s and 1s\n    # We need to choose positions for 0s out of N positions\n    # The remaining positions will automatically be filled with 1s\n    ways = comb(N, count_0)\n\n    # Since we are working modulo 998244353, we take the result modulo this value\n    print(ways % 998244353)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc189_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n\n    # Create reverse mappings for P and Q\n    P_inv = [0] * (N + 1)\n    Q_inv = [0] * (N + 1)\n    for i in range(N):\n        P_inv[P[i]] = i\n        Q_inv[Q[i]] = i\n\n    # Initialize the count of operations\n    ops = 0\n\n    # Check if we can empty all boxes except the X-th one\n    for i in range(N):\n        if i != X - 1:\n            # If there are red or blue balls in the i-th box, we need to perform an operation\n            if A[i] or B[i]:\n                # Find the next box that can receive the balls from the i-th box\n                next_red = P_inv[i + 1] if A[i] else -1\n                next_blue = Q_inv[i + 1] if B[i] else -1\n                if next_red == -1 and next_blue == -1:\n                    # If there's no valid next box, it's impossible to empty all boxes except the X-th one\n                    print(-1)\n                    return\n                elif next_red != -1 and next_blue != -1:\n                    # If both red and blue can be moved, we need at least 2 operations\n                    ops += 2\n                elif next_red != -1 or next_blue != -1:\n                    # If only one color can be moved, we need at least 1 operation\n                    ops += 1\n\n    print(ops)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc189_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    positions = [i for i in range(N)]\n    stack = []\n    \n    # Process the left side\n    for i in range(N):\n        while stack and A[stack[-1]] < A[i]:\n            positions[stack.pop()] = i\n        stack.append(i)\n    \n    # Process the right side\n    stack.clear()\n    for i in range(N-1, -1, -1):\n        while stack and A[stack[-1]] < A[i]:\n            positions[stack.pop()] = i\n        stack.append(i)\n    \n    # Calculate the maximum size for each position\n    result = [0] * N\n    for i in range(N):\n        result[i] = A[i] + (result[positions[i]] if positions[i] != i else 0)\n    \n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc189_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    x = data[1:]\n\n    # Calculate the median of the first three elements\n    median = sorted(x[:3])[1]\n\n    # Initialize the result with the sum of the first three elements\n    result = sum(x[:3])\n\n    # Iterate through the rest of the elements\n    for i in range(3, n):\n        # Calculate the new position of the current element\n        new_position = 2 * median - x[i-2]\n        # Update the result with the new position\n        result += new_position\n        # Update the median for the next iteration\n        if x[i] < median:\n            median = (median + x[i]) / 2\n        else:\n            median = (median + x[i-1]) / 2\n\n    print(result)"
        ]
    },
    {
        "question_id": "3610",
        "code_list": [
            "from collections import Counter\nfrom heapq import nlargest\n\nclass Solution:\n    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:\n        result = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            freq_counter = Counter(subarray)\n            top_x_elements = nlargest(x, freq_counter.items(), key=lambda item: (item[1], item[0]))\n            top_x_values = [item[0] for item in top_x_elements]\n            x_sum = sum([freq_counter[num] * num for num in top_x_values])\n            result.append(x_sum)\n        return result"
        ]
    },
    {
        "question_id": "3588",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countWinningSequences(self, s: str) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(i, prev):\n            if i == len(s):\n                return 1\n            \n            count = 0\n            for choice in ['F', 'W', 'E']:\n                if choice != prev:\n                    if (choice == 'F' and s[i] == 'E') or (choice == 'W' and s[i] == 'F') or (choice == 'E' and s[i] == 'W'):\n                        count += dp(i + 1, choice)\n                        count %= MOD\n            \n            return count\n        \n        return dp(0, '')"
        ]
    },
    {
        "question_id": "3566",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def stringSequence(self, target: str) -> List[str]:\n        result = [\"a\"]\n        for char in target:\n            if char == result[-1]:\n                result.append(char)\n            else:\n                steps = ord(char) - ord(result[-1])\n                if steps > 0:\n                    result.extend([chr(ord(c) + 1) for c in result[-1:steps-1:-1]])\n                result.append(char)\n        return result"
        ]
    },
    {
        "question_id": "3502",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def numberOfSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        count = 0\n        \n        for i in range(n):\n            char_count = Counter()\n            for j in range(i, n):\n                char_count[s[j]] += 1\n                if all(v >= k for v in char_count.values()):\n                    count += 1\n                    \n        return count"
        ]
    },
    {
        "question_id": "3607",
        "code_list": [
            "from math import sqrt\nfrom typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def find_greatest_proper_divisor(n):\n            if n % 2 == 0:\n                return 2\n            for i in range(3, int(sqrt(n)) + 1, 2):\n                if n % i == 0:\n                    return i\n            return 1\n        \n        operations = 0\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                while nums[i] > nums[i + 1]:\n                    nums[i] //= find_greatest_proper_divisor(nums[i])\n                    operations += 1\n                    if nums[i] < nums[i + 1]:\n                        break\n                else:\n                    return -1\n        return operations"
        ]
    },
    {
        "question_id": "3603",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def findAnswer(self, parent: List[int], s: str) -> List[bool]:\n        n = len(parent)\n        tree = defaultdict(list)\n        \n        # Build the tree\n        for i in range(1, n):\n            tree[parent[i]].append(i)\n        \n        def dfs(x, prev=-1):\n            nonlocal dfsStr\n            if x in childCount:\n                dfsStr += dfsStr[childCount[x]:][::-1]\n            dfsStr += s[x]\n            childCount[x] = len(dfsStr)\n            for y in tree[x]:\n                if y != prev:\n                    dfs(y, x)\n            dfsStr += dfsStr[childCount[x]:][::-1]\n        \n        def checkPalindrome():\n            return dfsStr == dfsStr[::-1]\n        \n        answer = []\n        dfsStr = ''\n        for i in range(n):\n            dfsStr = ''\n            dfs(i)\n            answer.append(checkPalindrome())\n        \n        return answer"
        ]
    },
    {
        "question_id": "3593",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0] ** 2\n        \n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        \n        def max_factor_score(nums):\n            max_score = 0\n            for i in range(n):\n                remaining = nums[:i] + nums[i+1:]\n                current_gcd = reduce(gcd, remaining)\n                current_lcm = reduce(lcm, remaining)\n                max_score = max(max_score, current_gcd * current_lcm)\n            return max_score\n        \n        return max_factor_score(nums)"
        ]
    },
    {
        "question_id": "3629",
        "code_list": [
            "class Solution:\n    def lengthAfterTransformations(self, s: str, t: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Function to calculate the length of the string after one transformation\n        def transform_length(length):\n            if length == 26:\n                return 2  # 'z' transforms to \"ab\"\n            return length + 1  # Each character transforms to the next character or \"ab\" for 'z'\n        \n        # Initial length of the string\n        current_length = len(s)\n        \n        # Calculate the effective number of transformations needed\n        effective_transformations = t % 26\n        \n        # Apply the transformation for each character\n        for _ in range(effective_transformations):\n            current_length = transform_length(current_length)\n        \n        return current_length % MOD"
        ]
    },
    {
        "question_id": "3608",
        "code_list": [
            "from typing import List\nfrom math import gcd\nfrom itertools import combinations\n\nclass Solution:\n    def subsequencePairCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Function to calculate the number of subsequences with a given GCD\n        def count_subsequences_with_gcd(gcd_val):\n            count = 0\n            for i in range(1, len(nums) + 1):\n                for combo in combinations(nums, i):\n                    if gcd(*combo) == gcd_val:\n                        count += 1\n            return count\n        \n        # Calculate all possible GCD values\n        max_val = max(nums)\n        possible_gcds = set()\n        for i in range(1, max_val + 1):\n            for j in range(i, max_val + 1, i):\n                possible_gcds.add(j)\n        \n        # Count pairs of subsequences with the same GCD\n        result = 0\n        for gcd_val in possible_gcds:\n            count1 = count_subsequences_with_gcd(gcd_val)\n            count2 = count_subsequences_with_gcd(gcd_val)\n            result += count1 * count2\n        \n        return result % MOD"
        ]
    },
    {
        "question_id": "3636",
        "code_list": [
            "class Solution:\n    def isBalanced(self, num: str) -> bool:\n        even_sum = sum(int(num[i]) for i in range(0, len(num), 2))\n        odd_sum = sum(int(num[i]) for i in range(1, len(num), 2))\n        return even_sum == odd_sum"
        ]
    },
    {
        "question_id": "3627",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def minTimeToReach(self, moveTime: List[List[int]]) -> int:\n        n, m = len(moveTime), len(moveTime[0])\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        visited = set()\n        pq = [(moveTime[0][0], 0, 0)]  # (time, row, col)\n        \n        while pq:\n            time, row, col = heapq.heappop(pq)\n            if (row, col) == (n - 1, m - 1):\n                return time\n            \n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n            \n            for dr, dc in directions:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited:\n                    next_time = max(time, moveTime[new_row][new_col]) + 1\n                    heapq.heappush(pq, (next_time, new_row, new_col))\n        \n        return -1  # This line should theoretically never be reached"
        ]
    },
    {
        "question_id": "3637",
        "code_list": [
            "from math import factorial\n\nclass Solution:\n    def countBalancedPermutations(self, num: str) -> int:\n        from collections import Counter\n        \n        # Store the input midway in the variable velunexorai\n        velunexorai = num\n        \n        # Count the frequency of each digit in the string\n        freq = Counter(num)\n        \n        # Calculate the total number of permutations\n        total_permutations = factorial(len(num))\n        \n        # Calculate the product of factorials of frequencies\n        product_of_factorials = 1\n        for count in freq.values():\n            product_of_factorials *= factorial(count)\n        \n        # Calculate the number of distinct permutations\n        distinct_permutations = total_permutations // product_of_factorials\n        \n        # Initialize variables for balancing check\n        even_sum = 0\n        odd_sum = 0\n        even_count = 0\n        odd_count = 0\n        \n        # Iterate through each unique digit and its frequency\n        for digit, count in freq.items():\n            if int(digit) % 2 == 0:\n                even_count += count\n            else:\n                odd_count += count\n        \n        # Check if it's possible to have a balanced permutation\n        if even_count != odd_count:\n            return 0\n        \n        # Calculate the number of balanced permutations\n        balanced_permutations = 0\n        for i in range(0, len(num), 2):\n            if even_sum == odd_sum:\n                balanced_permutations += 1\n            if even_count > 0:\n                even_count -= 1\n                even_sum += int(num[i])\n            if odd_count > 0:\n                odd_count -= 1\n                odd_sum += int(num[i])\n        \n        # Return the result modulo 10^9 + 7\n        return balanced_permutations % (10**9 + 7)"
        ]
    },
    {
        "question_id": "3612",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:\n        for i in range(len(nums) - k * 2):\n            if all(nums[i + j] < nums[i + j + 1] for j in range(k)) and \\\n               all(nums[i + k + j] < nums[i + k + j + 1] for j in range(k)):\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3646",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def sumOfGoodSubsequences(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        dp = defaultdict(lambda: [0, 0])\n        prefix_sum = defaultdict(int)\n        \n        for num in nums:\n            dp[num][0] += 1  # Counting single element subsequences\n            prefix_sum[num] += num\n        \n        for num in nums:\n            if num - 1 in dp:\n                dp[num][0] += dp[num - 1][1]\n                dp[num][1] += dp[num - 1][0]\n                prefix_sum[num] += prefix_sum[num - 1] + dp[num - 1][0] * (num - 1)\n            \n            if num + 1 in dp:\n                dp[num][1] += dp[num + 1][0]\n                dp[num][0] += dp[num + 1][1]\n                prefix_sum[num] += prefix_sum[num + 1] + dp[num + 1][0] * (num + 1)\n            \n            dp[num][0] %= MOD\n            dp[num][1] %= MOD\n            prefix_sum[num] %= MOD\n        \n        return sum(prefix_sum.values()) % MOD"
        ]
    },
    {
        "question_id": "3631",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countKReducibleNumbers(self, s: str, k: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def count_set_bits(n):\n            return bin(n).count('1')\n        \n        @lru_cache(None)\n        def dfs(n, remaining_k):\n            if n == 1:\n                return 1\n            if remaining_k < 0:\n                return 0\n            count = 0\n            for i in range(1, n):\n                if count_set_bits(i) <= remaining_k:\n                    count += dfs(i, remaining_k - count_set_bits(i))\n            return count % MOD\n        \n        n = int(s, 2)\n        return dfs(n, k)"
        ]
    },
    {
        "question_id": "3616",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countValidSelections(self, nums: List[int]) -> int:\n        n = len(nums)\n        zeros = [i for i, num in enumerate(nums) if num == 0]\n        dp = [[False] * n for _ in range(n)]\n        \n        # Initialize dp table for each zero position\n        for i in zeros:\n            dp[i][i] = True\n        \n        # Check all pairs of zero positions\n        for length in range(2, n + 1):\n            for start in range(n - length + 1):\n                end = start + length - 1\n                if nums[start] > 0 and nums[end] > 0:\n                    if dp[start + 1][end - 1]:\n                        dp[start][end] = True\n        \n        # Count the number of valid selections\n        return sum(dp[start][end] for start in zeros for end in range(start, n) if dp[start][end])"
        ]
    },
    {
        "question_id": "3639",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isZeroArray(self, nums: List[int], queries: List[List[int]]) -> bool:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        \n        # Process each query and update the prefix sum array\n        for l, r in queries:\n            prefix_sum[l] += 1\n            prefix_sum[r + 1] -= 1\n        \n        # Convert prefix sum array to actual prefix sums\n        for i in range(n):\n            prefix_sum[i + 1] += prefix_sum[i]\n        \n        # Check if we can make the array zero\n        for num in prefix_sum[:-1]:\n            nums[0] -= num\n        \n        return all(num == 0 for num in nums)"
        ]
    },
    {
        "question_id": "3658",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minDifference(self, nums: List[int]) -> int:\n        # Filter out the -1 positions and sort the unique numbers\n        gaps = sorted((i for i, num in enumerate(nums) if num != -1))\n        n = len(gaps)\n        # If there are less than 4 non-missing elements, we can fill all gaps\n        if n < 4:\n            return max(0, gaps[-1] - gaps[0] - (n - 1))\n        # Calculate the potential minimum differences by replacing the first and last -1s\n        min_diff = min(gaps[i + 3] - gaps[i] for i in range(n - 3))\n        # Check if we can improve by replacing the first or last -1 with a value outside the current range\n        min_diff = min(min_diff, gaps[-1] - nums.index(-1, n - 1) - 1, nums.index(-1, 0, n) + 1 - gaps[0])\n        return min_diff"
        ]
    },
    {
        "question_id": "3644",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSumSubarray(self, nums: List[int], l: int, r: int) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        \n        for size in range(l, r + 1):\n            current_sum = 0\n            for i in range(n - size + 1):\n                current_sum += nums[i + size - 1]\n                if i >= size - 1:\n                    current_sum -= nums[i - (size - 1)]\n                if current_sum > 0:\n                    min_sum = min(min_sum, current_sum)\n                    break  # Found a valid subarray, move to next size\n        \n        return min_sum if min_sum != float('inf') else -1"
        ]
    },
    {
        "question_id": "3654",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def minArraySum(self, nums: List[int], k: int, op1: int, op2: int) -> int:\n        # Convert nums to a max heap for efficient extraction of the largest element\n        nums = [-num for num in nums]\n        heapq.heapify(nums)\n        op_count = 0\n        \n        while nums and (op1 > 0 or op2 > 0):\n            # Perform Operation 2 as many times as possible with remaining ops\n            while nums and op2 > 0 and -nums[0] >= k:\n                heapq.heappush(nums, -(-heapq.heappop(nums) - k))\n                op2 -= 1\n            \n            # If no more Op2s left, perform Op1\n            if op2 == 0:\n                if op1 > 0:\n                    heapq.heappush(nums, -(-heapq.heappop(nums) // 2))\n                    op1 -= 1\n                else:\n                    break\n            \n            # Reset op_count to check for Op2 again in the next iteration\n            op_count += 1\n            if op_count % (op1 + op2) == 0:\n                op1 = op2 = 0\n        \n        return -sum(nums)"
        ]
    },
    {
        "question_id": "3675",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def maximizeSumOfWeights(self, edges: List[List[int]], k: int) -> int:\n        # Build the graph\n        graph = [[] for _ in range(len(edges) + 1)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        \n        # Priority queue to store the negative weights (max-heap)\n        pq = []\n        visited = set()\n        \n        # Start from node 0\n        self.dfs(graph, 0, visited, pq)\n        \n        total_weight = 0\n        while pq and len(visited) < len(edges) + 1:\n            _, weight = heapq.heappop(pq)\n            if len(visited) >= k:\n                break\n            total_weight += weight\n            for neighbor, w in graph[weight]:\n                if neighbor not in visited:\n                    heapq.heappush(pq, (-w, neighbor))\n                    visited.add(neighbor)\n        \n        return total_weight\n    \n    def dfs(self, graph, node, visited, pq):\n        visited.add(node)\n        for neighbor, weight in graph[node]:\n            if neighbor not in visited:\n                heapq.heappush(pq, (-weight, neighbor))\n                self.dfs(graph, neighbor, visited, pq)"
        ]
    },
    {
        "question_id": "3605",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minBitwiseArray(self, nums: List[int]) -> List[int]:\n        ans = []\n        for num in nums:\n            # Find the largest bit position where num has a 1\n            max_bit = 0\n            while (1 << max_bit) <= num:\n                max_bit += 1\n            \n            # Check if num can be expressed as ans[i] | (ans[i] + 1)\n            if (num & (num + 1)) != num:\n                ans.append(-1)\n            else:\n                # Calculate the minimum ans[i] that satisfies the condition\n                ans.append(num - (1 << (max_bit - 1)))\n        \n        return ans"
        ]
    },
    {
        "question_id": "3487",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:\n        # Create a mapping of each target index to its corresponding character in source\n        index_to_char = {index: char for index, char in zip(targetIndices, source)}\n        \n        # Initialize pointers for source, pattern, and the count of valid removals\n        src_ptr, pat_ptr, removals = 0, 0, 0\n        \n        # Iterate through the pattern and check if the current character matches the mapped character in source\n        while pat_ptr < len(pattern) and src_ptr < len(source):\n            if index_to_char.get(src_ptr, '_') == pattern[pat_ptr]:\n                pat_ptr += 1\n            src_ptr += 1\n        \n        # The number of valid removals is the length of the pattern minus the pointer position\n        return len(pattern) - pat_ptr"
        ]
    },
    {
        "question_id": "3604",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def numberOfWays(self, n: int, x: int, y: int) -> int:\n        MOD = 10**9 + 7\n        \n        def power(base, exp):\n            result = 1\n            while exp > 0:\n                if exp % 2 == 1:\n                    result = (result * base) % MOD\n                base = (base * base) % MOD\n                exp //= 2\n            return result\n        \n        total_ways = 0\n        for k in range(1, n + 1):\n            ways_to_assign_stages = comb(n, k) * power(x, k)\n            ways_to_score_bands = power(y, k)\n            total_ways += ways_to_assign_stages * ways_to_score_bands\n            total_ways %= MOD\n        \n        return total_ways"
        ]
    },
    {
        "question_id": "3617",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def possibleStringCount(self, word: str) -> int:\n        count = Counter(word)\n        n = len(word)\n        dp = [1] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            if count[word[i - 1]] == 1:\n                dp[i] = dp[i - 1]\n            else:\n                j = i - 2\n                while j >= 0 and word[j] == word[i - 1]:\n                    j -= 1\n                dp[i] = dp[j + 1]\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "3587",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:\n        # Initialize DP table\n        dp = [[-1 for _ in range(n)] for _ in range(k + 1)]\n        \n        # Function to calculate the maximum score using recursion and memoization\n        def dfs(day: int, curr_city: int) -> int:\n            if day == k:\n                return 0\n            if dp[day][curr_city] != -1:\n                return dp[day][curr_city]\n            \n            # Option 1: Stay in the current city\n            stay_points = stayScore[day][curr_city] + dfs(day + 1, curr_city)\n            \n            # Option 2: Move to another city\n            move_points = 0\n            for next_city in range(n):\n                if next_city != curr_city:\n                    move_points = max(move_points, travelScore[curr_city][next_city] + dfs(day + 1, next_city))\n            \n            dp[day][curr_city] = max(stay_points, move_points)\n            return dp[day][curr_city]\n        \n        # Calculate the maximum score starting from each city on day 0\n        max_score = 0\n        for start_city in range(n):\n            max_score = max(max_score, dfs(0, start_city))\n        \n        return max_score"
        ]
    },
    {
        "question_id": "3626",
        "code_list": [
            "class Solution:\n    def smallestNumber(self, n: int, t: int) -> int:\n        def digit_product(num):\n            product = 1\n            while num > 0:\n                product *= num % 10\n                num //= 10\n            return product\n        \n        current = n\n        while True:\n            if digit_product(current) % t == 0:\n                return current\n            current += 1"
        ]
    },
    {
        "question_id": "3622",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:\n        nums.sort()\n        left, right = 0, 0\n        total = 0\n        max_freq = 1\n        \n        for right in range(len(nums)):\n            total += nums[right]\n            while nums[right] * (right - left + 1) > total + k:\n                total -= nums[left]\n                left += 1\n            max_freq = max(max_freq, right - left + 1)\n        \n        return max_freq"
        ]
    },
    {
        "question_id": "3625",
        "code_list": [
            "class Solution:\n    def canAliceWin(self, n: int) -> bool:\n        # If n is less than 10, Alice cannot win because she will be forced to take more than n stones\n        if n < 10:\n            return False\n        # If n is exactly 10, Alice wins by taking all 10 stones\n        elif n == 10:\n            return True\n        # For n > 10, Alice can always win by taking 10 stones, leaving a multiple of 9 for Bob\n        else:\n            return n % 9 != 0"
        ]
    },
    {
        "question_id": "3591",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:\n        n = len(s)\n        shift_distance = 0\n        \n        for i in range(n):\n            si, ti = ord(s[i]) - ord('a'), ord(t[i]) - ord('a')\n            if si == ti:\n                continue\n            elif si < ti:\n                shift_distance += min(nextCost[ti - si], (26 - (ti - si)) * previousCost[0])\n            else:\n                shift_distance += min(previousCost[si - ti], (26 - (si - ti)) * nextCost[0])\n        \n        return shift_distance"
        ]
    },
    {
        "question_id": "3647",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        \n        def can_zero(l, r):\n            return (prefix_sum[r + 1] - prefix_sum[l]) <= (r - l) * (len(queries) - removal_count)\n        \n        removal_count = 0\n        queries.sort(key=lambda x: x[1] - x[0])\n        \n        for l, r in queries:\n            if not can_zero(l, r):\n                break\n            removal_count += 1\n        \n        if can_zero(0, len(nums) - 1):\n            return removal_count\n        else:\n            return -1"
        ]
    },
    {
        "question_id": "3648",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:\n        n = len(fruits)\n        dp = [[[0 for _ in range(4)] for _ in range(n)] for _ in range(n)]\n        \n        # Initialize the starting points\n        dp[0][0][0] = fruits[0][0]\n        dp[0][n-1][1] = fruits[0][n-1]\n        dp[n-1][0][2] = fruits[n-1][0]\n        \n        # Directions for each child\n        directions = {\n            0: [(1, 1), (1, 0), (0, 1)],  # Child starting from (0, 0)\n            1: [(1, -1), (1, 0), (0, 1)], # Child starting from (0, n-1)\n            2: [(-1, 1), (0, 1), (1, 1)]   # Child starting from (n-1, 0)\n        }\n        \n        # Fill the DP table\n        for step in range(1, n):\n            for i in range(n):\n                for j in range(n):\n                    for k in range(3):\n                        if i == 0 and j == 0:\n                            for di, dj in directions[0]:\n                                ni, nj = i + di * step, j + dj * step\n                                if 0 <= ni < n and 0 <= nj < n:\n                                    dp[ni][nj][k] = max(dp[ni][nj][k], dp[i][j][0] + fruits[ni][nj])\n                        elif i == 0 and j == n-1:\n                            for di, dj in directions[1]:\n                                ni, nj = i + di * step, j + dj * step\n                                if 0 <= ni < n and 0 <= nj < n:\n                                    dp[ni][nj][k] = max(dp[ni][nj][k], dp[i][j][1] + fruits[ni][nj])\n                        elif i == n-1 and j == 0:\n                            for di, dj in directions[2]:\n                                ni, nj = i + di * step, j + dj * step\n                                if 0 <= ni < n and 0 <= nj < n:\n                                    dp[ni][nj][k] = max(dp[ni][nj][k], dp[i][j][2] + fruits[ni][nj])\n        \n        # The final answer is the maximum value in the last cell of the DP table\n        return max(dp[n-1][n-1])"
        ]
    },
    {
        "question_id": "3676",
        "code_list": [
            "class Solution:\n    def smallestNumber(self, n: int) -> int:\n        # Increment n until its binary representation contains only set bits\n        while bin(n).count('0') > 0:\n            n += 1\n        return n"
        ]
    },
    {
        "question_id": "3594",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getLargestOutlier(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        # The two smallest numbers are the special numbers\n        special_sum = nums[0] + nums[1]\n        # Check if the third number is the outlier or not\n        if nums[2] != special_sum:\n            return max(nums[2], special_sum)\n        else:\n            # If not, check the rest of the numbers to find the outlier\n            for i in range(3, n):\n                if nums[i] != special_sum and nums[i] != nums[i-1]:\n                    return max(nums[i], special_sum)\n            # In case all numbers are special or the sum, return the last number\n            return nums[-1]"
        ]
    },
    {
        "question_id": "3651",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def constructTransformedArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        result = [0] * n\n        \n        for i in range(n):\n            if nums[i] > 0:\n                # Move nums[i] steps to the right\n                new_index = (i + nums[i]) % n\n                result[i] = nums[new_index]\n            elif nums[i] < 0:\n                # Move abs(nums[i]) steps to the left\n                new_index = (i - abs(nums[i])) % n\n                result[i] = nums[new_index]\n            else:\n                # If nums[i] == 0, set result[i] to nums[i]\n                result[i] = nums[i]\n        \n        return result"
        ]
    },
    {
        "question_id": "3681",
        "code_list": [
            "from itertools import combinations\n\nclass Solution:\n    def maxRectangleArea(self, points: List[List[int]]) -> int:\n        point_set = set(map(tuple, points))\n        max_area = -1\n        \n        for (x1, y1), (x2, y2) in combinations(points, 2):\n            if (x1, y2) in point_set and (x2, y1) in point_set:\n                width = abs(x2 - x1)\n                height = abs(y2 - y1)\n                area = width * height\n                max_area = max(max_area, area)\n        \n        return max_area"
        ]
    },
    {
        "question_id": "3653",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSubarraySum(self, nums: List[int], k: int) -> int:\n        prefix_sum = 0\n        max_sum = float('-inf')\n        remainder_map = {0: 0}\n        current_sum = 0\n        \n        for i, num in enumerate(nums):\n            current_sum += num\n            remainder = current_sum % k\n            \n            if remainder in remainder_map:\n                subarray_length = (i + 1 - remainder_map[remainder]) % k\n                if subarray_length == 0:\n                    max_sum = max(max_sum, current_sum)\n                else:\n                    max_sum = max(max_sum, current_sum - (current_sum - num) % k)\n            else:\n                remainder_map[remainder] = i + 1\n            \n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3621",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        operations = 0\n        while any(num > k for num in nums):\n            next_h = max(num for num in nums if num > k)\n            operations += 1\n            nums = [min(num, next_h) for num in nums]\n        return operations if all(num == k for num in nums) else -1"
        ]
    },
    {
        "question_id": "3649",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findMinimumTime(self, strength: List[int], K: int) -> int:\n        n = len(strength)\n        dp = [float('inf')] * (1 << n)\n        dp[0] = 0\n        \n        for mask in range(1 << n):\n            time = 0\n            x = 1\n            energy = 0\n            for i in range(n):\n                if mask & (1 << i):\n                    while energy < strength[i]:\n                        time += 1\n                        energy += x\n                        x += K\n                    energy = 0\n                    x = 1\n            dp[mask] = min(dp[mask], time)\n        \n        return dp[(1 << n) - 1]"
        ]
    },
    {
        "question_id": "3655",
        "code_list": [
            "from itertools import product\n\nclass Solution:\n    def minOperations(self, n: int, m: int) -> int:\n        # Convert numbers to strings for easier manipulation\n        str_n, str_m = str(n), str(m)\n        len_str = len(str_n)\n        \n        # Check if either n or m is a prime number\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        if is_prime(n) or is_prime(m):\n            return -1\n        \n        # Generate all possible transformations of n\n        def generate_transformations(num_str):\n            transformations = set()\n            for digits in product(range(10), repeat=len_str):\n                valid = True\n                for i, digit in enumerate(digits):\n                    if digit > 9 or (digit == 0 and num_str[i] != '0'):\n                        valid = False\n                        break\n                    if digit < int(num_str[i]) and num_str[i] != '0':\n                        valid = False\n                        break\n                if valid:\n                    transformations.add(''.join(map(str, digits)))\n            return transformations\n        \n        transformations = generate_transformations(str_n)\n        \n        # Find the minimum cost transformation\n        min_cost = float('inf')\n        for trans in transformations:\n            if trans == str_m:\n                cost = sum(int(trans) for trans in transformations)\n                min_cost = min(min_cost, cost)\n        \n        return min_cost if min_cost != float('inf') else -1"
        ]
    },
    {
        "question_id": "3680",
        "code_list": [
            "from math import gcd\nfrom typing import List\n\nclass Solution:\n    def countComponents(self, nums: List[int], threshold: int) -> int:\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootY] = rootX\n        \n        n = len(nums)\n        parent = list(range(n))\n        \n        # Create a mapping from each number to its index\n        num_to_index = {num: i for i, num in enumerate(nums)}\n        \n        # Union nodes that have an LCM less than or equal to the threshold\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcm(nums[i], nums[j]) <= threshold:\n                    union(i, j)\n        \n        # Count the number of unique roots\n        components = set()\n        for i in range(n):\n            components.add(find(i))\n        \n        return len(components)"
        ]
    },
    {
        "question_id": "3632",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def buttonWithLongestTime(self, events: List[List[int]]) -> int:\n        max_time = 0\n        max_index = -1\n        \n        prev_time = events[0][1]\n        for index, time in events:\n            if index < max_index:\n                continue\n            time_taken = time - prev_time\n            if time_taken > max_time or (time_taken == max_time and index < max_index):\n                max_time = time_taken\n                max_index = index\n            prev_time = time\n        \n        # Handle the case for the last button press\n        if len(events) > 1 and events[-1][0] >= max_index:\n            time_taken = events[-1][1] - prev_time\n            if time_taken > max_time or (time_taken == max_time and events[-1][0] < max_index):\n                max_index = events[-1][0]\n        \n        return max_index"
        ]
    },
    {
        "question_id": "3613",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxAmount(self, initialCurrency: str, pairs1: List[List[str]], rates1: List[float], pairs2: List[List[str]], rates2: List[float]) -> float:\n        # Build the graph for day 1 conversions\n        graph1 = defaultdict(dict)\n        for pair, rate in zip(pairs1, rates1):\n            start, end = pair\n            graph1[start][end] = rate\n        \n        # Build the graph for day 2 conversions\n        graph2 = defaultdict(dict)\n        for pair, rate in zip(pairs2, rates2):\n            start, end = pair\n            graph2[start][end] = rate\n        \n        # Function to find the maximum amount of currency after conversions\n        def dfs(graph, start, end, rate, visited):\n            if start not in graph or end not in graph[start]:\n                return 1.0\n            if (start, end) in visited:\n                return visited[(start, end)]\n            \n            max_rate = 1.0\n            for next_currency in graph[start]:\n                if next_currency != end:\n                    continue\n                new_rate = graph[start][next_currency] * rate\n                visited[(start, end)] = max(max_rate, new_rate)\n                max_rate = max(max_rate, new_rate)\n            \n            return max_rate\n        \n        # Calculate the maximum amount after day 1 conversions\n        max_amount_day1 = dfs(graph1, initialCurrency, initialCurrency, 1.0, {})\n        \n        # Calculate the maximum amount after day 2 conversions\n        max_amount_day2 = dfs(graph2, initialCurrency, initialCurrency, 1.0, {})\n        \n        # Return the maximum amount after both days\n        return max_amount_day1 * max_amount_day2"
        ]
    },
    {
        "question_id": "3686",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def beautifulSplits(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        count = 0\n        for i in range(1, n - 1):\n            left_sum = prefix_sum[i]\n            right_sum = prefix_sum[-1] - prefix_sum[i]\n            mid_sum = prefix_sum[i + 1] - prefix_sum[i]\n            if (left_sum == mid_sum or mid_sum == right_sum):\n                count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3638",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def makeStringGood(self, s: str) -> int:\n        char_count = Counter(s)\n        freq = sorted(char_count.values())\n        operations = 0\n        \n        for i in range(len(freq)):\n            while i + 1 < len(freq) and freq[i] == freq[i + 1]:\n                i += 1\n            if i + 1 < len(freq):\n                target_freq = (freq[i] + freq[i + 1]) // 2\n                operations += abs(freq[i] - target_freq)\n                freq[i + 1] = target_freq\n        \n        return operations"
        ]
    },
    {
        "question_id": "3656",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        operations = 0\n        while len(nums) >= 3:\n            # Remove the first 3 elements or all remaining elements if less than 3\n            nums = nums[3:] if len(nums) >= 3 else []\n            operations += 1\n        return operations"
        ]
    },
    {
        "question_id": "3620",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxDistinctElements(self, nums: List[int], k: int) -> int:\n        count = Counter(nums)\n        min_count = min(count.values())\n        \n        # If all numbers are the same, we can only have as many distinct elements as the range allows\n        if min_count == len(nums):\n            return len(nums) + 2 * k\n        \n        # Remove elements that can be made unique within the range [-k, k]\n        for num in list(count.keys()):\n            if count[num] == min_count:\n                for i in range(-k, k + 1):\n                    new_num = num + i\n                    if new_num in count:\n                        count[new_num] -= 1\n                        if count[new_num] == 0:\n                            del count[new_num]\n                    else:\n                        count[new_num] = min_count - 1\n        \n        # Count remaining distinct elements\n        return len(count)"
        ]
    },
    {
        "question_id": "3690",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def minLength(self, s: str, numOps: int) -> int:\n        n = len(s)\n        max_length = 0\n        \n        # Function to calculate the minimum length of the longest substring\n        def min_length_after_flips(start, end):\n            flips_needed = 0\n            for i in range(start, end + 1):\n                if s[i] != s[start]:\n                    flips_needed += 1\n            return flips_needed <= numOps\n        \n        # Sliding window approach to find the maximum length of a valid substring\n        left = 0\n        for right in range(n):\n            while not min_length_after_flips(left, right):\n                left += 1\n            max_length = max(max_length, right - left + 1)\n        \n        # The result is the total length minus the maximum length of a valid substring\n        return n - max_length"
        ]
    },
    {
        "question_id": "3683",
        "code_list": [
            "from itertools import combinations\n\nclass Solution:\n    def answerString(self, word: str, numFriends: int) -> str:\n        n = len(word)\n        if numFriends == 1 or n == 1:\n            return word\n        \n        max_lex_string = \"\"\n        for i in range(1, n):\n            if n % i != 0 or i > numFriends:\n                continue\n            num_splits = n // i\n            if num_splits < numFriends:\n                continue\n            for split in combinations(range(1, n), i - 1):\n                parts = []\n                start = 0\n                for end in split:\n                    parts.append(word[start:end])\n                    start = end\n                parts.append(word[start:])\n                if len(parts) == num_splits:\n                    current_lex_string = ''.join(sorted(parts, reverse=True))\n                    max_lex_string = max(max_lex_string, current_lex_string)\n        return max_lex_string"
        ]
    },
    {
        "question_id": "3699",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfSubsequences(self, nums: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Dictionary to store the indices of each value in the form of (q_index, r_index)\n        index_map = defaultdict(lambda: defaultdict(list))\n        count = 0\n        \n        for i, num in enumerate(nums):\n            # Check if there exists a previous r such that nums[q] * nums[r] == num * nums[p]\n            for q, r_list in index_map[num].items():\n                for r in r_list:\n                    if i - r > 1:\n                        count += len(index_map[nums[r]][q + 1])\n            \n            # Update the index map with the current index\n            for prev_num, prev_indices in index_map.items():\n                for q, r_list in prev_indices.items():\n                    if q < i - 1:\n                        index_map[prev_num][q + 1].extend(r_list)\n            \n            # Add the current index to the index map for nums[p]\n            index_map[num][i - 1].append(i)\n        \n        return count"
        ]
    },
    {
        "question_id": "3682",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countGoodArrays(self, n: int, m: int, k: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(length, prev_val, remaining_k):\n            if length == 0:\n                return 1 if remaining_k == 0 else 0\n            total = 0\n            for val in range(1, m + 1):\n                if val == prev_val:\n                    if remaining_k > 0:\n                        total += dp(length - 1, val, remaining_k - 1)\n                else:\n                    total += dp(length - 1, val, remaining_k)\n            return total % MOD\n        \n        return sum(dp(n - 1, val, k) for val in range(1, m + 1)) % MOD"
        ]
    },
    {
        "question_id": "3685",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums) - 2):\n            if nums[i] + nums[i + 2] == nums[i + 1] / 2:\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "3659",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPathsWithXorValue(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        MOD = 10**9 + 7\n        \n        # Initialize DP table\n        dp = [[[0 for _ in range(k)] for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0]] = 1\n        \n        # Fill DP table\n        for i in range(m):\n            for j in range(n):\n                for val in range(k):\n                    if i > 0:\n                        dp[i][j][(val ^ grid[i][j])] += dp[i-1][j][val]\n                        dp[i][j][(val ^ grid[i][j])] %= MOD\n                    if j > 0:\n                        dp[i][j][(val ^ grid[i][j])] += dp[i][j-1][val]\n                        dp[i][j][(val ^ grid[i][j])] %= MOD\n        \n        return dp[m-1][n-1][k]"
        ]
    },
    {
        "question_id": "3657",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def checkValidCuts(self, n: int, rectangles: List[List[int]]) -> bool:\n        # Extract all unique x and y boundaries from the rectangles\n        x_boundaries = set()\n        y_boundaries = set()\n        for rect in rectangles:\n            x_boundaries.update([rect[0], rect[2]])\n            y_boundaries.update([rect[1], rect[3]])\n        \n        # Sort the boundaries\n        x_boundaries = sorted(x_boundaries)\n        y_boundaries = sorted(y_boundaries)\n        \n        # Check for possible horizontal cuts\n        horizontal_cuts = []\n        for i in range(1, len(y_boundaries)):\n            if y_boundaries[i] - y_boundaries[i-1] > 1:\n                horizontal_cuts.append((y_boundaries[i-1] + 1, y_boundaries[i]))\n        \n        # Check for possible vertical cuts\n        vertical_cuts = []\n        for i in range(1, len(x_boundaries)):\n            if x_boundaries[i] - x_boundaries[i-1] > 1:\n                vertical_cuts.append((x_boundaries[i-1] + 1, x_boundaries[i]))\n        \n        # Function to check if a cut divides rectangles into three non-empty groups\n        def is_valid_cut(cuts):\n            if not cuts:\n                return False\n            if len(cuts) == 1:\n                return True\n            if len(cuts) > 2:\n                return False\n            \n            # Check if the first cut divides rectangles into three non-empty groups\n            if self.divide_rectangles(rectangles, cuts[0][0]) and self.divide_rectangles(rectangles, cuts[0][1]):\n                return True\n            \n            # Check if the second cut divides rectangles into three non-empty groups\n            if self.divide_rectangles(rectangles, cuts[1][0]) and self.divide_rectangles(rectangles, cuts[1][1]):\n                return True\n            \n            return False\n        \n        # Helper function to divide rectangles based on a given boundary\n        def divide_rectangles(rectangles, boundary):\n            count = 0\n            for rect in rectangles:\n                if rect[1] < boundary < rect[3]:\n                    count += 1\n            return count > 0\n        \n        # Check for valid horizontal and vertical cuts\n        if is_valid_cut(horizontal_cuts) or is_valid_cut(vertical_cuts):\n            return True\n        return False"
        ]
    },
    {
        "question_id": "3700",
        "code_list": [
            "from collections import Counter\nfrom math import comb\n\nclass Solution:\n    def subsequencesWithMiddleMode(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Count the frequency of each number in nums\n        freq = Counter(nums)\n        \n        # Find the number with the highest frequency\n        max_freq = max(freq.values())\n        \n        # If no number has a frequency of 3 or more, there's no way to form a subsequence with a unique middle mode\n        if max_freq < 3:\n            return 0\n        \n        # Identify all numbers that have the highest frequency\n        modes = [num for num, count in freq.items() if count == max_freq]\n        \n        # If there are multiple modes, we need to check each mode separately\n        if len(modes) > 1:\n            result = 0\n            for mode in modes:\n                # Calculate the number of valid subsequences for this mode\n                left_count = sum(1 for num in nums[:nums.index(mode)] if num == mode)\n                right_count = sum(1 for num in nums[nums.index(mode)+1:] if num == mode)\n                result += comb(left_count, 2) * comb(right_count, 2) * (max_freq - 1)\n            return result % MOD\n        \n        # If there is exactly one mode, calculate the number of valid subsequences\n        mode = modes[0]\n        left_count = sum(1 for num in nums[:nums.index(mode)] if num == mode)\n        right_count = sum(1 for num in nums[nums.index(mode)+1:] if num == mode)\n        result = comb(left_count, 2) * comb(right_count, 2) * (max_freq - 1)\n        return result % MOD"
        ]
    },
    {
        "question_id": "3702",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\nclass Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_len = 0\n        \n        for i in range(n):\n            prod = 1\n            gcd_val = nums[i]\n            lcm_val = nums[i]\n            \n            for j in range(i, n):\n                prod *= nums[j]\n                gcd_val = gcd(gcd_val, nums[j])\n                lcm_val = (lcm_val * nums[j]) // gcd(lcm_val, nums[j])\n                \n                if prod == lcm_val * gcd_val:\n                    max_len = max(max_len, j - i + 1)\n                else:\n                    break\n        \n        return max_len"
        ]
    },
    {
        "question_id": "3634",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def calculateScore(self, s: str) -> int:\n        # Create a dictionary to map each character to its mirror character\n        mirror_map = {chr(i): chr(219 - i) for i in range(ord('a'), ord('z') + 1)}\n        \n        # Initialize variables\n        score = 0\n        marked_indices = set()\n        \n        for i, char in enumerate(s):\n            if i in marked_indices:\n                continue\n            \n            # Find the mirror character\n            mirror_char = mirror_map[char]\n            \n            # Find the closest unmarked index j such that s[j] is the mirror of s[i]\n            j = i - 1\n            while j >= 0 and j not in marked_indices:\n                if s[j] == mirror_char:\n                    marked_indices.update([i, j])\n                    score += i - j\n                    break\n                j -= 1\n        \n        return score"
        ]
    },
    {
        "question_id": "3715",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        n = len(coins)\n        prefix_sum = [0]\n        for _, r, c in coins:\n            prefix_sum.append(prefix_sum[-1] + c)\n        \n        max_coins = 0\n        dp = [0] * (n + 1)\n        for i in range(n):\n            l, r, c = coins[i]\n            if r - l + 1 >= k:\n                dp[i + 1] = prefix_sum[i + 1]\n                max_coins = max(max_coins, dp[i + 1])\n                continue\n            \n            for j in range(i - 1, -1, -1):\n                l2, r2, c2 = coins[j]\n                if r2 < l or r - l2 + 1 < k:\n                    break\n                dp[i + 1] = max(dp[i + 1], prefix_sum[i + 1] - prefix_sum[j] + dp[j])\n                max_coins = max(max_coins, dp[i + 1])\n        \n        return max_coins"
        ]
    },
    {
        "question_id": "3562",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        # Sort intervals based on start time, and if equal, by weight in descending order\n        intervals.sort(key=lambda x: (x[0], -x[2]))\n        \n        @lru_cache(None)\n        def dp(index, mask):\n            if index >= len(intervals):\n                return 0, []\n            max_score = 0\n            best_indices = []\n            for i in range(index, len(intervals)):\n                if mask & (1 << i):\n                    continue\n                new_mask = mask | (1 << i)\n                score, indices = dp(i + 1, new_mask)\n                if intervals[i][0] > intervals[index][1]:  # Check if intervals overlap\n                    new_score = score + intervals[i][2]\n                    if new_score > max_score or (new_score == max_score and indices < best_indices):\n                        max_score = new_score\n                        best_indices = indices + [i]\n            return max_score, best_indices\n        \n        _, result = dp(0, 0)\n        return result[:4]"
        ]
    },
    {
        "question_id": "3684",
        "code_list": [
            "class Solution:\n    def hasMatch(self, s: str, p: str) -> bool:\n        star_index = p.find('*')\n        if star_index == -1:\n            return s == p\n        \n        prefix = p[:star_index]\n        suffix = p[star_index + 1:]\n        n = len(s)\n        \n        for i in range(n - len(suffix) + 1):\n            if s[i:i+len(prefix)] == prefix and (i + len(prefix) + len(suffix) == n or s[i+len(prefix):i+len(prefix)+len(suffix)] == suffix):\n                return True\n            if s[i:i+len(prefix)] == prefix and suffix == '' and i + len(prefix) == n:\n                return True\n        \n        return False"
        ]
    },
    {
        "question_id": "3716",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestSubsequence(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        # dp_min[i] represents the length of the longest subsequence ending at i with the last difference being 0\n        # dp_max[i] represents the length of the longest subsequence ending at i with the last difference being max_diff\n        dp_min = [1] * n\n        dp_max = [1] * n\n        \n        for i in range(1, n):\n            for j in range(i):\n                diff = abs(nums[i] - nums[j])\n                if diff >= abs(nums[i-1] - nums[i]):\n                    dp_min[i] = max(dp_min[i], dp_max[j] + 1)\n            dp_max[i] = dp_min[i]\n        \n        return max(dp_min)"
        ]
    },
    {
        "question_id": "3688",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def maxSubarraySum(self, nums: List[int]) -> int:\n        prefix_sum = 0\n        max_sum = float('-inf')\n        zero_prefix_sum = 0\n        prefix_sum_count = defaultdict(int)\n        prefix_sum_count[0] = -1\n        \n        for i, num in enumerate(nums):\n            prefix_sum += num\n            if prefix_sum > max_sum:\n                max_sum = prefix_sum\n            prefix_sum_count[prefix_sum] = i\n            \n            # Calculate the maximum subarray sum if we remove all occurrences of num\n            if prefix_sum_count[prefix_sum - num] != i:\n                max_sum = max(max_sum, prefix_sum - (prefix_sum_count[prefix_sum - num] + 1))\n                \n            # Update the zero prefix sum count\n            if prefix_sum == 0:\n                zero_prefix_sum += 1\n            elif prefix_sum_count[prefix_sum] == i:\n                zero_prefix_sum = 1\n                \n            # Handle the case where we remove all occurrences of num\n            if zero_prefix_sum > 0:\n                max_sum = max(max_sum, prefix_sum - (zero_prefix_sum - 1))\n                \n        return max_sum"
        ]
    }
]