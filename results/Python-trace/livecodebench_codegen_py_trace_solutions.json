[
    {
        "question_id": "1873_A",
        "code_list": [
            "def main():\n    for _ in range(int(input())):\n        s = input().strip()\n        # Check if the string is already 'abc'\n        if s == 'abc':\n            print(\"YES\")\n        else:\n            # Count the number of swaps needed to make 'abc'\n            swaps = 0\n            for i in range(3):\n                if s[i] != 'a':\n                    break\n                swaps += 1\n            if s[swaps] != 'b' or s[swaps + 1] != 'c':\n                print(\"NO\")\n            else:\n                print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1873_B",
        "code_list": [
            "def max_product_after_adding_one(t):\n    def calculate_max_product(a):\n        n = len(a)\n        original_product = 1\n        zero_count = 0\n        min_digit = float('inf')\n        \n        for digit in a:\n            if digit == 0:\n                zero_count += 1\n            elif digit < 9:\n                original_product *= digit\n                min_digit = min(min_digit, digit)\n        \n        if zero_count > 0:\n            return original_product * (zero_count + 1)\n        elif original_product == 0:\n            return 1\n        \n        # Adding 1 to the smallest non-zero digit\n        max_product = original_product * (min_digit + 1)\n        \n        # Adding 1 to any zero digit (if any)\n        if zero_count > 0:\n            max_product = max(max_product, original_product * (zero_count + 1))\n        \n        return max_product\n    \n    results = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        results.append(calculate_max_product(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    max_product_after_adding_one(int(input().strip()))"
        ]
    },
    {
        "question_id": "1873_D",
        "code_list": [
            "def min_operations_to_remove_black_cells(t):\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        s = input()\n        operations = 0\n        i = 0\n        while i < n:\n            if s[i] == 'B':\n                start = i\n                while i < n and s[i] == 'B':\n                    i += 1\n                end = i - 1\n                segments = (end - start + k - 1) // k\n                operations += segments\n                i = end + 1\n            else:\n                i += 1\n        results.append(operations)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    min_operations_to_remove_black_cells(int(input()))"
        ]
    },
    {
        "question_id": "1883_B",
        "code_list": [
            "def can_form_palindrome(s, k):\n    char_count = [0] * 26\n    for char in s:\n        char_count[ord(char) - ord('a')] += 1\n    \n    odd_counts = sum(count % 2 for count in char_count)\n    \n    if odd_counts // 2 <= k:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n, k = map(int, data[index:index+2])\n        index += 2\n        s = data[index]\n        index += 1\n        results.append(can_form_palindrome(s, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1883_C",
        "code_list": [
            "from collections import Counter\n\ndef min_operations_to_divisible_by_k(t):\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        count = Counter(arr)\n        \n        operations = 0\n        \n        if k == 2:\n            # Count odd numbers\n            odd_count = count[1] + count[3] + count[5] + count[7] + count[9]\n            operations += (odd_count + 1) // 2\n        elif k == 3:\n            # Count numbers not divisible by 3\n            not_div_by_3 = count[1] + count[2] + count[4] + count[5] + count[7] + count[8]\n            operations += (not_div_by_3 + 2) // 3\n        elif k == 4:\n            # Count numbers not divisible by 4\n            not_div_by_4 = count[1] + count[2] + count[3] + count[5] + count[6] + count[7] + count[9]\n            operations += (not_div_by_4 + 3) // 4\n        elif k == 5:\n            # Count numbers not divisible by 5\n            not_div_by_5 = count[1] + count[2] + count[3] + count[4] + count[6] + count[7] + count[8] + count[9]\n            operations += (not_div_by_5 + 4) // 5\n        \n        print(operations)\n\nif __name__ == \"__main__\":\n    t = int(input())\n    min_operations_to_divisible_by_k(t)"
        ]
    },
    {
        "question_id": "1899_A",
        "code_list": [
            "def determine_winner(n):\n    # If n is already divisible by 3, Vanya wins immediately\n    if n % 3 == 0:\n        return \"First\"\n    \n    # Otherwise, we need to check the optimal moves\n    # Vanya can always force a win if he can make the number divisible by 3 within his moves\n    # Since each move changes the number by \u00b11, we need to check if Vanya can make it divisible by 3 in at most 5 moves (since 10 total moves and Vanya goes first)\n    for i in range(1, 6):\n        if (n + i) % 3 == 0 or (n - i) % 3 == 0:\n            return \"First\"\n    \n    # If none of the above conditions are met, Vova wins\n    return \"Second\"\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        print(determine_winner(n))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_B",
        "code_list": [
            "from typing import List\n\ndef max_weight_difference(n: int, weights: List[int]) -> int:\n    prefix_sum = [0]\n    for weight in weights:\n        prefix_sum.append(prefix_sum[-1] + weight)\n    \n    max_diff = 0\n    for k in range(1, n + 1):\n        if n % k != 0:\n            continue\n        min_weight = float('inf')\n        max_weight = float('-inf')\n        for i in range(k):\n            start = i * (n // k)\n            end = start + (n // k)\n            current_weight = prefix_sum[end] - prefix_sum[start]\n            min_weight = min(min_weight, current_weight)\n            max_weight = max(max_weight, current_weight)\n        max_diff = max(max_diff, max_weight - min_weight)\n    \n    return max_diff\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        weights = list(map(int, data[index:index + n]))\n        index += n\n        result = max_weight_difference(n, weights)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_C",
        "code_list": [
            "def max_alternating_subarray_sum(n, arr):\n    max_sum = float('-inf')\n    current_sum = 0\n    prev_parity = None\n    \n    for i in range(n):\n        if (arr[i] % 2 == 0) ^ (prev_parity == 0):\n            current_sum += arr[i]\n        else:\n            max_sum = max(max_sum, current_sum)\n            current_sum = arr[i]\n        prev_parity = arr[i] % 2\n    \n    max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        print(max_alternating_subarray_sum(n, arr))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_D",
        "code_list": [
            "from collections import Counter\n\ndef count_equal_combinations(t):\n    results = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        counter = Counter(a)\n        total_pairs = 0\n        \n        # Count pairs with the same value\n        for count in counter.values():\n            total_pairs += count * (count - 1) // 2\n        \n        # Count pairs with different values but equal combinations\n        values = list(counter.keys())\n        for i in range(len(values)):\n            for j in range(i + 1, len(values)):\n                if values[i] % values[j] == 0 or values[j] % values[i] == 0:\n                    total_pairs += counter[values[i]] * counter[values[j]]\n        \n        results.append(total_pairs)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    count_equal_combinations(int(input().strip()))"
        ]
    },
    {
        "question_id": "2727",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        count = 0\n        for detail in details:\n            age = int(detail[11:13])\n            if age > 60:\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "2728",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        score = 0\n        while any(nums):\n            max_removed = -1\n            for row in nums:\n                max_removed = max(max_removed, row.pop(row.index(max(row))))\n            score += max_removed\n        return score"
        ]
    },
    {
        "question_id": "2730",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        prefix_or, suffix_or = 0, 0\n        for num in nums:\n            suffix_or |= num\n        max_or = 0\n        current_or = 0\n        \n        for i, num in enumerate(nums):\n            if i > 0:\n                current_or |= nums[i-1]\n            suffix_or ^= num\n            max_or = max(max_or, current_or << k | suffix_or)\n            if i < len(nums) - 1:\n                current_or |= num\n        \n        return max_or"
        ]
    },
    {
        "question_id": "2754",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        # Remove zeros as they do not contribute to the product\n        nums = [num for num in nums if num != 0]\n        \n        # If there are no positive numbers and at most one negative number, the result is 0 or the single negative number\n        if len(nums) == 0:\n            return 0\n        \n        # Separate positive and negative numbers\n        pos_nums = [num for num in nums if num > 0]\n        neg_nums = sorted([num for num in nums if num < 0])\n        \n        # If there's an odd number of negative numbers, remove the smallest (most negative) one\n        if len(neg_nums) % 2 == 1:\n            neg_nums.pop(0)\n        \n        # Calculate the product of the remaining numbers\n        strength = 1\n        for num in pos_nums + neg_nums:\n            strength *= num\n        \n        return strength"
        ]
    },
    {
        "question_id": "2755",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        dp = [float('inf')] * (len(s) + 1)\n        dp[-1] = 0\n        \n        for i in range(len(s) - 1, -1, -1):\n            dp[i] = dp[i + 1] + 1\n            for word in dictionary:\n                if s.startswith(word, i):\n                    dp[i] = min(dp[i], dp[i + len(word)])\n        \n        return dp[0]"
        ]
    },
    {
        "question_id": "2756",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        min1, min2 = float('inf'), float('inf')\n        for price in prices:\n            if price < min1:\n                min2 = min1\n                min1 = price\n            elif price < min2:\n                min2 = price\n        total_cost = min1 + min2\n        return money - total_cost if total_cost <= money else money"
        ]
    },
    {
        "question_id": "2757",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def digit_sum(n, tight, remaining):\n            if len(n) == 0:\n                return 1 if remaining >= min_sum else 0\n            if tight == 0 and remaining < min_sum:\n                return 0\n            \n            ans = 0\n            upper_bound = int(n[0]) if tight else 9\n            for d in range(upper_bound + 1):\n                new_tight = tight and d == upper_bound\n                ans += digit_sum(n[1:], new_tight, remaining - d)\n                ans %= MOD\n            return ans\n        \n        # Convert num1 and num2 to lists of digits\n        num1_digits = tuple(map(int, num1))\n        num2_digits = tuple(map(int, num2))\n        \n        # Count numbers less than or equal to num2 with digit sum within [min_sum, max_sum]\n        count_le_num2 = digit_sum(str(num2_digits), True, max_sum)\n        \n        # Count numbers less than num1 with digit sum within [min_sum, max_sum]\n        count_lt_num1 = digit_sum(str(num1_digits[:-1]), True, max_sum)\n        \n        # Calculate the result\n        result = (count_le_num2 - count_lt_num1) % MOD\n        \n        # Adjust for the exact match of num1\n        if digit_sum(num1, True, max_sum) > 0:\n            result += 1\n        \n        return result % MOD"
        ]
    },
    {
        "question_id": "2777",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        def count_distinct(arr):\n            return len(set(arr))\n        \n        n = len(nums)\n        result = []\n        for i in range(n):\n            prefix_distinct = count_distinct(nums[:i+1])\n            suffix_distinct = count_distinct(nums[i+1:])\n            result.append(prefix_distinct - suffix_distinct)\n        return result"
        ]
    },
    {
        "question_id": "2779",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        nums = [0] * n\n        answer = []\n        count = 0\n        \n        for index, color in queries:\n            if index > 0 and nums[index - 1] == color and nums[index - 1] != 0:\n                count -= 1\n            if index < n - 1 and nums[index + 1] == color and nums[index + 1] != 0:\n                count -= 1\n            \n            if nums[index] != 0:\n                if index > 0 and nums[index - 1] == nums[index]:\n                    count -= 1\n                if index < n - 1 and nums[index + 1] == nums[index]:\n                    count -= 1\n            \n            nums[index] = color\n            \n            if index > 0 and nums[index - 1] == color and nums[index - 1] != 0:\n                count += 1\n            if index < n - 1 and nums[index + 1] == color and nums[index + 1] != 0:\n                count += 1\n            \n            answer.append(count)\n        \n        return answer"
        ]
    },
    {
        "question_id": "2784",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        nums.sort()\n        res = 0\n        prefix_sum = 0\n        \n        for num in nums:\n            # Calculate the power of the current number as a single group\n            res = (res + num**2 * num) % MOD\n            # Add the contribution of the current number to all previous groups\n            prefix_sum = (prefix_sum * 2 + num) % MOD\n            res = (res + num * prefix_sum) % MOD\n        \n        return res"
        ]
    },
    {
        "question_id": "2785",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        idx1, idxn = nums.index(1), nums.index(n)\n        moves = 0\n        \n        # If 1 is to the right of n, we need to move 1 to the front and n to the end\n        if idx1 > idxn:\n            moves += idx1 + (n - 1 - idxn)\n        else:\n            # Otherwise, we just need to move n to the end\n            moves += idxn - 1 + (n - 1 - idxn) if idxn != n - 1 else idxn - 1\n        \n        return moves"
        ]
    },
    {
        "question_id": "2786",
        "code_list": [
            "from itertools import groupby\n\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        max_length = 0\n        for i, (_, group) in enumerate(groupby(zip(s, s[1:])), start=1):\n            if len(list(group)) > 1:\n                break\n            max_length = max(max_length, sum(1 for _ in group) + i - 1)\n        return max(max_length, len(list(groupby(zip(s, s[1:])))) * 2 - 1)"
        ]
    },
    {
        "question_id": "2791",
        "code_list": [
            "class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        visited = set()\n        current_position = 0\n        step = k\n        turn = 1\n        \n        while True:\n            if current_position + step * turn in visited:\n                break\n            visited.add(current_position + step * turn)\n            current_position = (current_position + step * turn) % n\n            if current_position == 0:\n                current_position = n\n            turn += 1\n        \n        return sorted([i for i in range(1, n + 1) if i not in visited])"
        ]
    },
    {
        "question_id": "2792",
        "code_list": [
            "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        # The key observation is that the XOR operation is its own inverse.\n        # This means that if we start with any initial value (0 or 1),\n        # the derived array can always be achieved by some original array.\n        # We just need to check if the XOR of the entire derived array is 0.\n        return sum(derived) % 2 == 0"
        ]
    },
    {
        "question_id": "2800",
        "code_list": [
            "class Solution:\n    def minLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            if char == 'B' and stack and stack[-1] == 'A':\n                stack.pop()\n            elif char == 'D' and stack and stack[-1] == 'C':\n                stack.pop()\n            else:\n                stack.append(char)\n        return len(stack)"
        ]
    },
    {
        "question_id": "2802",
        "code_list": [
            "class Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def is_valid_partition(num_str, target):\n            if not num_str:\n                return target == 0\n            \n            for i in range(1, len(num_str) + 1):\n                current_num = int(num_str[:i])\n                if target >= current_num and (is_valid_partition(num_str[i:], target - current_num) or (target == current_num and i == len(num_str))):\n                    return True\n            return False\n        \n        punishment_sum = 0\n        for i in range(1, n + 1):\n            square = i * i\n            square_str = str(square)\n            if is_valid_partition(square_str, i):\n                punishment_sum += square\n        return punishment_sum"
        ]
    },
    {
        "question_id": "2808",
        "code_list": [
            "from typing import List\nimport functools\n\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        @functools.lru_cache(None)\n        def dp(index, remaining):\n            if remaining <= 0:\n                return 0\n            if index == len(cost):\n                return float('inf')\n            # Option 1: Use the paid painter to paint the current wall\n            paid = cost[index] + dp(index + 1, remaining - time[index] - 1)\n            # Option 2: Skip the current wall (use the free painter)\n            skip = dp(index + 1, remaining)\n            return min(paid, skip)\n        \n        return dp(0, len(cost))"
        ]
    },
    {
        "question_id": "2810",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minCost(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        # Initialize the result with the sum of the first round of buying all chocolates\n        res = sum(nums)\n        # Initialize the cost of changing types for each chocolate in the first round\n        change_cost = [nums[i] for i in range(n)]\n        \n        # Iterate over the number of operations from 1 to n-1\n        for ops in range(1, n):\n            # Calculate the new cost after performing the operation ops times\n            new_change_cost = [min(change_cost[(i - ops) % n] + x, nums[i]) for i in range(n)]\n            # Update the result with the minimum cost found so far\n            res = min(res, sum(new_change_cost))\n            # Update the change_cost for the next iteration\n            change_cost = new_change_cost\n        \n        return res"
        ]
    },
    {
        "question_id": "2811",
        "code_list": [
            "class Solution:\n    def minimumSum(self, n: int, k: int) -> int:\n        # Initialize the result sum and the current number\n        result_sum = 0\n        current_num = 1\n        \n        # Use a set to keep track of numbers that have been used\n        used_numbers = set()\n        \n        while len(used_numbers) < n:\n            # Skip numbers that would form a pair with another number to sum up to k\n            if (k - current_num) in used_numbers:\n                current_num += 1\n                continue\n            \n            # Add the current number to the result sum and mark it as used\n            result_sum += current_num\n            used_numbers.add(current_num)\n            \n            # Move to the next number\n            current_num += 1\n        \n        return result_sum"
        ]
    },
    {
        "question_id": "2812",
        "code_list": [
            "class Solution:\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        return num + t * 2"
        ]
    },
    {
        "question_id": "2816",
        "code_list": [
            "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        result = list(s)\n        for i in range(n // 2):\n            if s[i] != s[n - i - 1]:\n                # Choose the lexicographically smaller character\n                result[i] = result[n - i - 1] = min(s[i], s[n - i - 1])\n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2817",
        "code_list": [
            "class Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        \n        # Iterate through the string to find the minimum cost to make all characters equal\n        for i in range(1, n):\n            if s[i] != s[i-1]:\n                # Calculate the cost of inverting up to index i-1\n                cost += min(i, n - i)\n        \n        return cost"
        ]
    },
    {
        "question_id": "2819",
        "code_list": [
            "class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        # Find the index of the last non-zero digit\n        for i in range(len(num) - 1, -1, -1):\n            if num[i] != '0':\n                return num[:i+1]\n        return \"\""
        ]
    },
    {
        "question_id": "2824",
        "code_list": [
            "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated_str = str(n) + str(2 * n) + str(3 * n)\n        return len(concatenated_str) == 9 and set(concatenated_str) == {'1', '2', '3', '4', '5', '6', '7', '8', '9'}"
        ]
    },
    {
        "question_id": "2825",
        "code_list": [
            "class Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        unique_chars = set(s)\n        return len(unique_chars)"
        ]
    },
    {
        "question_id": "2827",
        "code_list": [
            "from math import gcd\nfrom collections import defaultdict\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums) == 1:\n            return True\n        \n        max_num = max(nums)\n        sieve = [True] * (max_num + 1)\n        primes = []\n        \n        for i in range(2, int(max_num**0.5) + 1):\n            if sieve[i]:\n                for j in range(i*i, max_num + 1, i):\n                    sieve[j] = False\n        \n        for i in range(2, max_num + 1):\n            if sieve[i]:\n                primes.append(i)\n        \n        graph = defaultdict(list)\n        for num in nums:\n            factors = set()\n            for prime in primes:\n                if prime * prime > num:\n                    break\n                while num % prime == 0:\n                    factors.add(prime)\n                    num //= prime\n            if num > 1:\n                factors.add(num)\n            for factor in factors:\n                graph[factor].extend(factors - {factor})\n        \n        visited = set()\n        stack = [nums[0]]\n        \n        while stack:\n            current = stack.pop()\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n        \n        return len(visited) == len(nums)"
        ]
    },
    {
        "question_id": "2828",
        "code_list": [
            "class Solution:\n    def smallestString(self, s: str) -> str:\n        n = len(s)\n        i = 0\n        # Skip leading 'a's\n        while i < n and s[i] == 'a':\n            i += 1\n        if i == n:\n            # If the whole string is 'a's, change the last 'a' to 'z'\n            return s[:-1] + 'z'\n        # Find the end of the substring where we don't want to change 'a's\n        j = i\n        while j < n and s[j] != 'a':\n            j += 1\n        # Change all characters in the found substring to their previous character\n        result = list(s)\n        for k in range(i, j):\n            result[k] = chr(ord(result[k]) - 1)\n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2831",
        "code_list": [
            "from math import gcd\nfrom typing import List\n\nclass Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            first_digit = int(str(nums[i])[0])\n            for j in range(i + 1, len(nums)):\n                last_digit = nums[j] % 10\n                if gcd(first_digit, last_digit) == 1:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2832",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        max_length = 0\n        count_map = defaultdict(int)\n        left = 0\n        \n        for right in range(len(nums)):\n            count_map[nums[right]] += 1\n            current_max_count = max(count_map.values())\n            \n            while (right - left + 1) - current_max_count > k:\n                count_map[nums[left]] -= 1\n                left += 1\n            \n            max_length = max(max_length, current_max_count)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2833",
        "code_list": [
            "from typing import List\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # Sort queries to process them in order\n        query_sorted = sorted((q, i) for i, q in enumerate(queries))\n        logs.sort(key=lambda log: log[1])\n        \n        result = [0] * len(queries)\n        active_servers = SortedList()\n        current_time = 0\n        \n        log_index = 0\n        for query_time, original_query_index in query_sorted:\n            # Add all logs before or at the current query time\n            while log_index < len(logs) and logs[log_index][1] <= query_time:\n                server_id, time = logs[log_index]\n                active_servers.add(server_id)\n                log_index += 1\n            \n            # Remove all logs that are out of the current query time range\n            while current_time < query_time - x + 1:\n                server_id, time = logs[log_index]\n                if server_id in active_servers:\n                    active_servers.remove(server_id)\n                log_index += 1\n                current_time += 1\n            \n            # Calculate the number of inactive servers for the current query\n            result[original_query_index] = n - len(active_servers)\n        \n        return result"
        ]
    },
    {
        "question_id": "2834",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        positions = set(nums)\n        for start, end in zip(moveFrom, moveTo):\n            if start in positions:\n                positions.remove(start)\n                positions.add(end)\n        return sorted(positions)"
        ]
    },
    {
        "question_id": "2837",
        "code_list": [
            "class Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        for ops in range(61):\n            target = num1 - ops * num2\n            if target < 0:\n                continue\n            count_ones = bin(target).count('1')\n            if count_ones <= ops and ops <= target and ops <= 60:\n                return ops\n        return -1"
        ]
    },
    {
        "question_id": "2839",
        "code_list": [
            "from typing import List\nimport bisect\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        # Sort queries by x_i in descending order and store their original indices\n        sorted_queries = sorted((x, y, i) for i, (x, y) in enumerate(queries))\n        n = len(nums1)\n        result = [-1] * len(queries)\n        max_sum = [float('-inf')] * (n + 1)\n        \n        # Sort nums1 and nums2 together based on nums1 in descending order\n        sorted_nums = sorted(zip(nums1, nums2), reverse=True)\n        \n        # Process each query in the sorted order of x_i\n        for x, y, original_index in sorted_queries:\n            while sorted_nums and sorted_nums[-1][0] >= x:\n                num1, num2 = sorted_nums.pop()\n                idx = bisect.bisect_left(nums2, y)\n                max_sum[idx] = max(max_sum[idx], num1 + num2)\n            \n            # Find the maximum sum for the current query\n            idx = bisect.bisect_left(nums2, y)\n            if idx < len(max_sum):\n                result[original_index] = max_sum[idx]\n        \n        return result"
        ]
    },
    {
        "question_id": "2844",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n = len(nums)\n        return sum(num * num for i, num in enumerate(nums, start=1) if n % i == 0)"
        ]
    },
    {
        "question_id": "2845",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        nums.sort()\n        min_partition_value = float('inf')\n        for i in range(1, len(nums)):\n            min_partition_value = min(min_partition_value, nums[i] - nums[i - 1])\n        return min_partition_value"
        ]
    },
    {
        "question_id": "2847",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        seen = set()\n        pairs_count = 0\n        \n        for word in words:\n            reversed_word = word[::-1]\n            if reversed_word in seen:\n                pairs_count += 1\n            else:\n                seen.add(word)\n        \n        return pairs_count"
        ]
    },
    {
        "question_id": "2848",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(index, mask):\n            if index == len(nums):\n                return 1\n            count = 0\n            for i in range(len(nums)):\n                if mask & (1 << i) == 0 and (nums[i] % nums[index] == 0 or nums[index] % nums[i] == 0):\n                    count += dfs(index + 1, mask | (1 << i))\n                    count %= MOD\n            return count\n        \n        return dfs(0, 0)"
        ]
    },
    {
        "question_id": "2849",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        from sortedcontainers import SortedList\n        \n        def imbalance_count(subarray):\n            sarr = SortedList(subarray)\n            imbalance = 0\n            for i in range(len(sarr) - 1):\n                if sarr[i + 1] - sarr[i] > 1:\n                    imbalance += 1\n            return imbalance\n        \n        total_imbalance = 0\n        for start in range(len(nums)):\n            subarray = []\n            for end in range(start, len(nums)):\n                subarray.append(nums[end])\n                total_imbalance += imbalance_count(subarray)\n        \n        return total_imbalance"
        ]
    },
    {
        "question_id": "2850",
        "code_list": [
            "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        # If x and y are equal, we can use all of them without any restrictions\n        if x == y:\n            return 2 * (x + y + z) + 2\n        \n        # If x > y, we can use y \"AA\" strings, all \"AB\" strings, and then use (y-1) \"BB\" strings\n        # This ensures no \"AAA\" or \"BBB\" substrings\n        elif x > y:\n            return 2 * (y + z + y - 1 + min(x - y, 1)) + 2\n        \n        # If y > x, we can use x \"BB\" strings, all \"AB\" strings, and then use (x-1) \"AA\" strings\n        # This ensures no \"AAA\" or \"BBB\" substrings\n        else:\n            return 2 * (z + x + x - 1 + min(y - x, 1)) + 2"
        ]
    },
    {
        "question_id": "2854",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def minimizeConcatenatedLength(self, words: List[str]) -> int:\n        @lru_cache(None)\n        def dp(i, pre_tail, post_head):\n            if i == len(words):\n                return 0\n            a = len(words[i]) + dp(i + 1, words[i][-1], words[i][0])\n            b = len(words[i]) + dp(i + 1, pre_tail, words[i][0]) if words[i][0] == pre_tail else dp(i + 1, pre_tail, words[i][0])\n            c = len(words[i]) + dp(i + 1, words[i][-1], post_head) if words[i][-1] == post_head else dp(i + 1, words[i][-1], post_head)\n            return min(a, b, c)\n        \n        return len(words[0]) + dp(1, words[0][-1], words[0][0])"
        ]
    },
    {
        "question_id": "2855",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [-1] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            if dp[i] == -1:\n                continue\n            for j in range(i + 1, n):\n                if -target <= nums[j] - nums[i] <= target:\n                    dp[j] = max(dp[j], dp[i] + 1)\n        \n        return dp[-1]"
        ]
    },
    {
        "question_id": "2856",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        total_distinct = len(set(nums))\n        count = defaultdict(int)\n        left = 0\n        result = 0\n        \n        for right in range(len(nums)):\n            count[nums[right]] += 1\n            \n            while len(count) == total_distinct:\n                result += len(nums) - right\n                count[nums[left]] -= 1\n                if count[nums[left]] == 0:\n                    del count[nums[left]]\n                left += 1\n                \n        return result"
        ]
    },
    {
        "question_id": "2857",
        "code_list": [
            "class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        distance = 0\n        while mainTank >= 5:\n            # Use 5 liters of fuel\n            mainTank -= 5\n            distance += 50\n            # Transfer 1 liter from additional tank if available\n            if additionalTank > 0:\n                mainTank += 1\n                additionalTank -= 1\n        # Add the remaining distance based on the current fuel in main tank\n        distance += mainTank * 10\n        return distance"
        ]
    },
    {
        "question_id": "2866",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        max_length = 0\n        start_index = -1\n        \n        for i in range(len(nums)):\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                if start_index == -1:\n                    start_index = i\n                current_length = 1\n                while i + 1 < len(nums) and nums[i + 1] <= threshold and nums[i + 1] % 2 != nums[i] % 2:\n                    i += 1\n                    current_length += 1\n                max_length = max(max_length, current_length)\n                start_index = -1\n            else:\n                start_index = -1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2867",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        last_one_index = -1\n        count = 0\n        \n        for i, num in enumerate(nums):\n            if num == 1:\n                if last_one_index == -1:\n                    last_one_index = i\n                else:\n                    count = (count + (i - last_one_index)) % MOD\n                    last_one_index = i\n        \n        return count + (last_one_index != -1)"
        ]
    },
    {
        "question_id": "2868",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        left = 0\n        result = 0\n        max_deque = deque()\n        min_deque = deque()\n        \n        for right in range(len(nums)):\n            # Maintain max_deque\n            while max_deque and nums[right] > nums[max_deque[-1]]:\n                max_deque.pop()\n            max_deque.append(right)\n            \n            # Maintain min_deque\n            while min_deque and nums[right] < nums[min_deque[-1]]:\n                min_deque.pop()\n            min_deque.append(right)\n            \n            # Check if current window is valid\n            while nums[max_deque[0]] - nums[min_deque[0]] > 2:\n                if max_deque[0] == left:\n                    max_deque.popleft()\n                if min_deque[0] == left:\n                    min_deque.popleft()\n                left += 1\n            \n            # Add valid subarrays ending at 'right'\n            result += right - left + 1\n        \n        return result"
        ]
    },
    {
        "question_id": "2869",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        dp1, dp2 = [1] * n, [1] * n\n        \n        for i in range(1, n):\n            if nums1[i] >= nums1[i-1]:\n                dp1[i] = max(dp1[i], dp1[i-1] + 1)\n            if nums1[i] >= nums2[i-1]:\n                dp1[i] = max(dp1[i], dp2[i-1] + 1)\n            \n            if nums2[i] >= nums2[i-1]:\n                dp2[i] = max(dp2[i], dp2[i-1] + 1)\n            if nums2[i] >= nums1[i-1]:\n                dp2[i] = max(dp2[i], dp1[i-1] + 1)\n        \n        return max(max(dp1), max(dp2))"
        ]
    },
    {
        "question_id": "2870",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        max_length = -1\n        start = 0\n        \n        for end in range(1, len(nums)):\n            if nums[end] == nums[start] + 1 and (end - start + 1) % 2 == 0:\n                max_length = max(max_length, end - start + 1)\n                start = end\n            elif nums[end] == nums[start]:\n                start = end\n            else:\n                start = end - 1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2872",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n - 2, -1, -1):\n            if nums[i] <= nums[i + 1]:\n                nums[i + 1] += nums[i]\n        return max(nums)"
        ]
    },
    {
        "question_id": "2873",
        "code_list": [
            "from math import sqrt\n\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(sqrt(num)) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        primes = [num for num in range(2, n) if is_prime(num)]\n        result = []\n        seen = set()\n        \n        for prime in primes:\n            complement = n - prime\n            if complement in primes and (complement, prime) not in seen:\n                result.append([prime, complement])\n                seen.add((prime, complement))\n        \n        return sorted(result)"
        ]
    },
    {
        "question_id": "2876",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        return sum(1 for hour in hours if hour >= target)"
        ]
    },
    {
        "question_id": "2877",
        "code_list": [
            "from itertools import permutations\n\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        def merge(s1, s2):\n            for i in range(len(s2), -1, -1):\n                if s2[:i] in s1:\n                    return s1 + s2[i:]\n            return s1 + s2\n        \n        def shortest_merge(s1, s2, s3):\n            cases = [merge(merge(s1, s2), s3), merge(merge(s2, s1), s3),\n                     merge(merge(s1, s3), s2), merge(merge(s3, s1), s2),\n                     merge(merge(s2, s3), s1), merge(merge(s3, s2), s1)]\n            return min(cases, key=lambda x: (len(x), x))\n        \n        # Generate all permutations of the input strings\n        perms = list(permutations([a, b, c]))\n        result = None\n        \n        for perm in perms:\n            merged = shortest_merge(perm[0], perm[1], perm[2])\n            if result is None or (len(merged) < len(result) or (len(merged) == len(result) and merged < result)):\n                result = merged\n        \n        return result"
        ]
    },
    {
        "question_id": "2878",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n            \n            if i >= k - 1 and nums[i - k + 1] < 0:\n                return False\n            \n            if nums[i] > 0:\n                target = (prefix_sum[min(i + k, n)] - prefix_sum[i]) // nums[i]\n                if target < 0 or (target > 0 and (prefix_sum[min(i + k, n)] - prefix_sum[i]) % nums[i] != 0):\n                    return False\n                \n                for j in range(max(0, i - target + 1), i + 1):\n                    prefix_sum[j] += nums[i]\n                    nums[i] = 0\n        \n        return all(x == 0 for x in nums)"
        ]
    },
    {
        "question_id": "2879",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def minimumChanges(self, s: str, k: int) -> int:\n        n = len(s)\n        \n        @lru_cache(None)\n        def is_semi_palindrome(sub):\n            length = len(sub)\n            for d in range(1, length // 2 + 1):\n                if length % d != 0:\n                    continue\n                palindrome = True\n                for i in range(d):\n                    for j in range(i, length, d):\n                        if sub[i] != sub[j]:\n                            palindrome = False\n                            break\n                    if not palindrome:\n                        break\n                if palindrome:\n                    return True\n            return False\n        \n        @lru_cache(None)\n        def dp(index, remaining_k):\n            if index == n and remaining_k == 0:\n                return 0\n            if index >= n or remaining_k <= 0:\n                return float('inf')\n            \n            min_changes = float('inf')\n            for end in range(index, min(n, index + k)):\n                changes = 0\n                for i in range((end - index + 1) // 2):\n                    changes += abs(ord(s[index + i]) - ord(s[end - i]))\n                if is_semi_palindrome(s[index:end + 1]):\n                    min_changes = min(min_changes, changes + dp(end + 1, remaining_k - 1))\n            return min_changes\n        \n        return dp(0, k)"
        ]
    },
    {
        "question_id": "2881",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            # Split the current word by the separator\n            splits = word.split(separator)\n            # Extend the result list with non-empty splits\n            result.extend([split for split in splits if split])\n        return result"
        ]
    },
    {
        "question_id": "2882",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(remaining, idx):\n            if remaining == 0:\n                return 1\n            if remaining < 0 or idx > n:\n                return 0\n            \n            # Option 1: Skip the current number\n            skip = dp(remaining, idx + 1)\n            \n            # Option 2: Use the current number\n            use = 0\n            num = idx ** x\n            if num <= remaining:\n                use = dp(remaining - num, idx + 1)\n            \n            return (skip + use) % MOD\n        \n        return dp(n, 1)"
        ]
    },
    {
        "question_id": "2883",
        "code_list": [
            "from math import log\n\nclass Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        # Precompute powers of 5 up to the maximum possible value represented by the string length\n        powers_of_5 = {int(log(5 ** i, 2)): 5 ** i for i in range(1, len(s) + 1)}\n        \n        n = len(s)\n        dp = [-1] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if s[j] == '0':\n                    continue\n                num = int(s[j:i], 2)\n                if num in powers_of_5.values():\n                    index = list(powers_of_5.values()).index(num)\n                    if dp[j] != -1:\n                        dp[i] = min(dp[i], dp[j] + 1) if dp[i] != -1 else dp[j] + 1\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "2884",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        max_length = 0\n        last_forbidden_end = -1\n        \n        for i in range(len(word)):\n            for length in range(1, 11):  # forbidden[i] length <= 10\n                if i + length > len(word):\n                    break\n                substring = word[i:i+length]\n                if substring in forbidden:\n                    last_forbidden_end = max(last_forbidden_end, i + length - 1)\n                    break\n            \n            max_length = max(max_length, min(i, last_forbidden_end))\n        \n        return len(word) - max_length"
        ]
    },
    {
        "question_id": "2886",
        "code_list": [
            "class Solution:\n    def finalString(self, s: str) -> str:\n        result = []\n        for char in s:\n            if char == 'i':\n                result.reverse()\n            else:\n                result.append(char)\n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2887",
        "code_list": [
            "class Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = 'aeiouAEIOU'\n        vowel_chars = [char for char in s if char in vowels]\n        vowel_chars.sort(key=lambda x: ord(x))\n        \n        result = []\n        vowel_index = 0\n        \n        for char in s:\n            if char in vowels:\n                result.append(vowel_chars[vowel_index])\n                vowel_index += 1\n            else:\n                result.append(char)\n                \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2888",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        total_count = Counter(nums)\n        dominant_element = max(total_count, key=total_count.get)\n        left_count = 0\n        \n        for i, num in enumerate(nums):\n            left_count += 1 if num == dominant_element else 0\n            right_count = total_count[dominant_element] - left_count\n            \n            if left_count * 2 > i + 1 and right_count * 2 > len(nums) - i - 1:\n                return i\n        \n        return -1"
        ]
    },
    {
        "question_id": "2891",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        max_beauty = 0\n        left = 0\n        for right in range(len(nums)):\n            while nums[right] - nums[left] > 2 * k:\n                left += 1\n            max_beauty = max(max_beauty, right - left + 1)\n        return max_beauty"
        ]
    },
    {
        "question_id": "2892",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        max_num = max(nums)\n        if len(nums) != max_num + 1 or nums.count(max_num) != 2:\n            return False\n        expected_nums = set(range(1, max_num))\n        return set(nums) == expected_nums"
        ]
    },
    {
        "question_id": "2893",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp_even = [0] * n\n        dp_odd = [0] * n\n        \n        if nums[0] % 2 == 0:\n            dp_even[0] = nums[0]\n        else:\n            dp_odd[0] = nums[0]\n        \n        for i in range(1, n):\n            if nums[i] % 2 == 0:\n                dp_even[i] = max(dp_even[i-1] + nums[i], dp_odd[i-1] + nums[i] - x)\n                dp_odd[i] = dp_odd[i-1]\n            else:\n                dp_odd[i] = max(dp_odd[i-1] + nums[i], dp_even[i-1] + nums[i] - x)\n                dp_even[i] = dp_even[i-1]\n        \n        return max(dp_even[-1], dp_odd[-1])"
        ]
    },
    {
        "question_id": "2902",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_sum = -1\n        num_dict = {}\n        \n        for num in nums:\n            max_digit = max(int(digit) for digit in str(num))\n            if max_digit in num_dict:\n                # Calculate the sum of the current number and the number stored in the dictionary\n                current_sum = num + num_dict[max_digit]\n                # Update max_sum if the current_sum is greater\n                max_sum = max(max_sum, current_sum)\n                # Update the dictionary with the maximum value between the current number and the stored number\n                num_dict[max_digit] = max(num, num_dict[max_digit])\n            else:\n                # Initialize the dictionary entry with the current number\n                num_dict[max_digit] = num\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "2915",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        prefix_count = 0\n        count_map = defaultdict(int)\n        count_map[0] = 1\n        result = 0\n        \n        for num in nums:\n            prefix_count += (num % modulo == k)\n            target = (prefix_count - k + modulo) % modulo\n            result += count_map[target]\n            count_map[prefix_count % modulo] += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "2916",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        n = len(nums)\n        # If the array has less than or equal to 2 elements, it can always be split as required\n        if n <= 2:\n            return True\n        \n        # Check if there exists any pair of adjacent elements whose sum is >= m\n        for i in range(n - 1):\n            if nums[i] + nums[i + 1] >= m:\n                return True\n        \n        # If no such pair exists, return False\n        return False"
        ]
    },
    {
        "question_id": "2917",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] < target:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2919",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort()\n        total, count = 0, 0\n        \n        for limit in usageLimits:\n            total += limit\n            if total >= count + 1:\n                count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "2920",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        index_map = defaultdict(list)\n        \n        # Map each value to its indices\n        for i, num in enumerate(nums):\n            index_map[num].append(i)\n        \n        max_distance = 0\n        \n        # Calculate the maximum distance between equal elements for each unique value\n        for indices in index_map.values():\n            max_dist = 0\n            for i in range(len(indices)):\n                dist = (indices[(i + 1) % len(indices)] - indices[i]) // 2\n                max_dist = max(max_dist, dist)\n            max_distance = max(max_distance, max_dist)\n        \n        return max_distance"
        ]
    },
    {
        "question_id": "2921",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(length, is_limit, is_num, prev_digit):\n            if length == 0:\n                return int(is_num)\n            res = 0\n            if not is_num:\n                res = dfs(length - 1, False, False, None)\n            low_digit = 1 if not is_num else 0\n            high_digit = int(high[length - 1]) if is_limit else 9\n            for digit in range(low_digit, high_digit + 1):\n                if prev_digit is None or abs(prev_digit - digit) == 1:\n                    res += dfs(length - 1, is_limit and digit == high[length - 1], True, digit)\n            return res % MOD\n        \n        @lru_cache(None)\n        def count_numbers(n):\n            if n == 0:\n                return 0\n            length = len(n)\n            return dfs(length, True, False, None)\n        \n        @lru_cache(None)\n        def count_stepping_numbers(n):\n            if n == 0:\n                return 1\n            length = len(n)\n            return dfs(length, True, True, None)\n        \n        low_length = len(low)\n        high_length = len(high)\n        low_count = count_numbers(low_length - 1)\n        high_count = count_stepping_numbers(high_length)\n        invalid_count = count_numbers(low_length - 1) - count_stepping_numbers(low_length)\n        return (high_count - low_count + invalid_count + (int(low) == 0)) % MOD"
        ]
    },
    {
        "question_id": "2952",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        n = len(nums1)\n        total_increase = sum(nums2)\n        initial_sum = sum(nums1)\n        \n        # Calculate the total increase needed to make the sum of nums1 <= x\n        total_needed_increase = initial_sum + total_increase - x\n        \n        # If the total increase needed is more than the total increase available, return -1\n        if total_needed_increase > total_increase * n:\n            return -1\n        \n        @lru_cache(None)\n        def dp(index, remaining_increase):\n            if remaining_increase >= total_increase:\n                return 0\n            if index == n:\n                return float('inf')\n            \n            # Option 1: Do nothing at this index\n            option1 = dp(index + 1, remaining_increase)\n            \n            # Option 2: Apply the operation at this index\n            option2 = 1 + dp(index + 1, remaining_increase + nums2[index])\n            \n            return min(option1, option2)\n        \n        result = dp(0, 0)\n        return result if result != float('inf') else -1"
        ]
    },
    {
        "question_id": "2953",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        count = 0\n        n = len(coordinates)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (coordinates[i][0] ^ coordinates[j][0]) + (coordinates[i][1] ^ coordinates[j][1]) == k:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2954",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        max_sum = 0\n        current_sum = 0\n        count_map = defaultdict(int)\n        \n        # Initialize the first window\n        for i in range(k):\n            current_sum += nums[i]\n            count_map[nums[i]] += 1\n        \n        # Check if the first window is valid\n        if len(count_map) >= m:\n            max_sum = current_sum\n        \n        # Slide the window across the array\n        for i in range(k, len(nums)):\n            # Add the new element to the current sum and update its count\n            current_sum += nums[i]\n            count_map[nums[i]] += 1\n            \n            # Remove the element that is sliding out of the window\n            current_sum -= nums[i - k]\n            count_map[nums[i - k]] -= 1\n            \n            # If the count of the element going out of the window becomes zero, remove it from the map\n            if count_map[nums[i - k]] == 0:\n                del count_map[nums[i - k]]\n            \n            # Check if the current window is valid and update max_sum if needed\n            if len(count_map) >= m:\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "2955",
        "code_list": [
            "class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        # Round the purchase amount to the nearest multiple of 10\n        rounded_amount = ((purchaseAmount + 5) // 10) * 10\n        # Calculate the remaining balance\n        balance = 100 - rounded_amount\n        return balance"
        ]
    },
    {
        "question_id": "2977",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        acronym = ''.join(word[0] for word in words)\n        return acronym == s"
        ]
    },
    {
        "question_id": "2979",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        # Sort offers based on the starting index\n        offers.sort(key=lambda x: x[0])\n        \n        # Initialize a DP array where dp[i] represents the maximum profit up to house i\n        dp = [0] * (n + 1)\n        \n        # Dictionary to map each ending index to its corresponding offer index\n        offer_map = {end: idx for idx, (start, end, _) in enumerate(offers)}\n        \n        # Fill the DP array\n        for i in range(n):\n            # The maximum profit without selling any house at i\n            dp[i + 1] = dp[i]\n            \n            # Check if there's an offer ending at i\n            if i in offer_map:\n                idx = offer_map[i]\n                start, end, gold = offers[idx]\n                # The maximum profit by selling the current house\n                dp[i + 1] = max(dp[i + 1], dp[start] + gold)\n                \n            # Check if there's an offer starting at i\n            for j in range(len(offers)):\n                start, end, gold = offers[j]\n                if start > i:\n                    break\n                if end == i:\n                    dp[i + 1] = max(dp[i + 1], dp[start] + gold)\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "2998",
        "code_list": [
            "class Solution:\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        count = 0\n        for num in range(low, high + 1):\n            num_str = str(num)\n            if len(num_str) % 2 != 0:\n                continue\n            mid = len(num_str) // 2\n            first_half_sum = sum(int(digit) for digit in num_str[:mid])\n            second_half_sum = sum(int(digit) for digit in num_str[mid:])\n            if first_half_sum == second_half_sum:\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "2999",
        "code_list": [
            "class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        # Check each character position after applying the allowed operation\n        for i in range(2):\n            if s1[i] != s2[i] and s1[i+2] != s2[i+2]:\n                return False\n        return True"
        ]
    },
    {
        "question_id": "3000",
        "code_list": [
            "from sortedcontainers import SortedList\n\nclass Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        sl = SortedList()\n        min_diff = float('inf')\n        \n        for i, num in enumerate(nums):\n            if i >= x:\n                sl.add(nums[i - x])\n                pos = sl.bisect_left(num)\n                if pos != len(sl):\n                    min_diff = min(min_diff, num - sl[pos])\n                if pos != 0:\n                    min_diff = min(min_diff, sl[pos - 1] - num)\n        \n        return min_diff"
        ]
    },
    {
        "question_id": "3017",
        "code_list": [
            "from math import log10\n\nclass Solution:\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        def count_beautiful_numbers(n, k):\n            if n == 0:\n                return 0\n            length = int(log10(n)) + 1\n            dp = [[[[-1 for _ in range(k)] for _ in range(2)] for _ in range(2)] for _ in range(length + 1)]\n            def dfs(pos, tight, odd_count, even_count, remainder):\n                if pos == length:\n                    return 1 if odd_count == even_count and remainder == 0 else 0\n                if dp[pos][tight][odd_count][even_count][remainder] != -1:\n                    return dp[pos][tight][odd_count][even_count][remainder]\n                end = 9 if tight else n % (10 ** (length - pos))\n                ans = 0\n                for d in range(end + 1):\n                    new_odd_count = odd_count + (d & 1)\n                    new_even_count = even_count + (not d & 1)\n                    new_remainder = (remainder * 10 + d) % k\n                    if new_odd_count <= new_even_count:\n                        ans += dfs(pos + 1, tight and d == end, new_odd_count, new_even_count, new_remainder)\n                dp[pos][tight][odd_count][even_count][remainder] = ans\n                return ans\n            return dfs(0, True, 0, 0, 0)\n        \n        return count_beautiful_numbers(high, k) - count_beautiful_numbers(low - 1, k)"
        ]
    },
    {
        "question_id": "3018",
        "code_list": [
            "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        i, j = 0, 0\n        while i < len(str1) and j < len(str2):\n            # Calculate the next character of str2[j]\n            next_char = chr((ord(str2[j]) - ord('a') + 1) % 26 + ord('a'))\n            # Check if current character of str1 matches str2[j] or its next character\n            if str1[i] == str2[j] or str1[i] == next_char:\n                j += 1\n            i += 1\n        return j == len(str2)"
        ]
    },
    {
        "question_id": "3019",
        "code_list": [
            "class Solution:\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        # Count the number of '_' characters\n        underscore_count = moves.count('_')\n        # Calculate the net movement towards left or right\n        net_movement = moves.count('R') - moves.count('L')\n        # The furthest distance is the sum of net movement and underscores\n        return abs(net_movement) + underscore_count"
        ]
    },
    {
        "question_id": "3024",
        "code_list": [
            "from collections import Counter\nfrom math import pow\n\nclass Solution:\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        if s == t:\n            # If s is already equal to t, we need to check how many suffixes can be chosen in each operation\n            count = Counter([i for i in range(n)])\n            dp = [0] * (k + 1)\n            dp[0] = 1\n            for _ in range(k):\n                for i in range(n - 1, -1, -1):\n                    dp[i] = (dp[i] + dp[i + 1] * count[i]) % MOD\n            return dp[0]\n        else:\n            # Calculate the number of valid suffixes that can transform s to t\n            valid_suffixes = []\n            for i in range(n):\n                if s[i:] + s[:i] == t:\n                    valid_suffixes.append(i)\n            if not valid_suffixes:\n                return 0\n            # Use dynamic programming to find the number of ways to achieve the transformation in k operations\n            dp = [0] * (k + 1)\n            dp[0] = 1\n            for _ in range(k):\n                for i in valid_suffixes:\n                    dp[i] = (dp[i] + dp[i + 1]) % MOD\n            return dp[0]"
        ]
    },
    {
        "question_id": "3025",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        # Convert target to binary representation to check if it's possible to form the target\n        target_bin = bin(target)[2:]\n        target_len = len(target_bin)\n        \n        # Count the frequency of each power of 2 in nums\n        freq = [0] * 31\n        for num in nums:\n            freq[num.bit_length() - 1] += 1\n        \n        # Check if the target can be formed\n        if sum(int(bit) for bit in target_bin) > sum(freq):\n            return -1\n        \n        operations = 0\n        i = 0\n        \n        # Process each bit position from the least significant to the most significant\n        for j in range(30, -1, -1):\n            if target_bin[i] == '1':\n                # If the current bit is 1, we need at least one occurrence of 2^j\n                if freq[j] > 0:\n                    freq[j] -= 1\n                else:\n                    k = j\n                    while k >= 0 and freq[k] == 0:\n                        k -= 1\n                    if k < 0:\n                        return -1\n                    operations += j - k\n                    freq[k] -= 1\n                    freq[j] += 2\n                i += 1\n            \n            # Decrease the count of 2^j if it's used\n            if freq[j] > 0:\n                freq[j] -= 1\n        \n        return operations"
        ]
    },
    {
        "question_id": "3031",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        n, m = len(grid), len(grid[0])\n        total_product = 1\n        zero_count = 0\n        \n        # Calculate the total product of all elements in the grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 0:\n                    total_product *= grid[i][j]\n                else:\n                    zero_count += 1\n        \n        # If there are more than one zero in the grid, the result will be all zeros\n        if zero_count > 1:\n            return [[0] * m for _ in range(n)]\n        \n        result = [[0] * m for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 0:\n                    # Calculate the product excluding the current element\n                    result[i][j] = (total_product // grid[i][j]) % 12345\n                else:\n                    # If the current element is zero, calculate the product of all other elements\n                    result[i][j] = (total_product * pow(12345, -1, 12345)) % 12345\n        \n        return result"
        ]
    },
    {
        "question_id": "3032",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n        n = len(receiver)\n        memo = defaultdict(int)\n        \n        def dfs(x, depth):\n            if depth == 0:\n                return x\n            if (x, depth) in memo:\n                return memo[(x, depth)]\n            next_x = receiver[x]\n            result = dfs(next_x, depth - 1)\n            memo[(x, depth)] = result + x\n            return result + x\n        \n        max_value = 0\n        for start in range(n):\n            value = dfs(start, k)\n            max_value = max(max_value, value)\n        \n        return max_value"
        ]
    },
    {
        "question_id": "3033",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        n = len(s1)\n        diff_indices = [i for i in range(n) if s1[i] != s2[i]]\n        m = len(diff_indices)\n        \n        if m % 2 == 1:\n            return -1\n        \n        dp = [[float('inf')] * (m // 2 + 1) for _ in range(m + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, m + 1):\n            for j in range(min(i, m // 2) + 1):\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + x)\n                if i > 1 and j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + 1)\n        \n        return dp[m][m // 2] if dp[m][m // 2] != float('inf') else -1"
        ]
    },
    {
        "question_id": "3034",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        covered_points = set()\n        for start, end in nums:\n            for point in range(start, end + 1):\n                covered_points.add(point)\n        return len(covered_points)"
        ]
    },
    {
        "question_id": "3044",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        collected = set()\n        operations = 0\n        \n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] <= k:\n                collected.add(nums[i])\n            if len(collected) == k:\n                return len(nums) - i\n            operations += 1\n        \n        return operations"
        ]
    },
    {
        "question_id": "3045",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        # Find the index where the array is broken\n        break_point = -1\n        for i in range(1, n):\n            if nums[i] < nums[i - 1]:\n                if break_point != -1:\n                    return -1  # More than one break point found, cannot be sorted with right shifts\n                break_point = i\n        \n        # If no break point found, the array is already sorted\n        if break_point == -1:\n            return 0\n        \n        # Check if the array can be sorted by rotating from the break point\n        for i in range(break_point, n - 1):\n            if nums[i] > nums[i + 1]:\n                return -1\n        \n        # Check the last and first elements to ensure the array can be sorted\n        if nums[0] < nums[n - 1]:\n            return -1\n        \n        # Calculate the number of right shifts needed\n        return n - break_point"
        ]
    },
    {
        "question_id": "3046",
        "code_list": [
            "class Solution:\n    def minimumOperations(self, num: str) -> int:\n        n = len(num)\n        dp = [float('inf')] * (n + 1)\n        dp[n] = 0\n        \n        for i in range(n - 1, -1, -1):\n            dp[i] = dp[i + 1] + 1\n            if num[i] == '0':\n                for j in range(i + 1, n):\n                    if num[j] in ['0', '5']:\n                        dp[i] = min(dp[i], dp[j + 1] + (j - i))\n            elif num[i] == '5':\n                for j in range(i + 1, n):\n                    if num[j] in ['0', '2', '5', '7']:\n                        dp[i] = min(dp[i], dp[j + 1] + (j - i))\n        \n        return dp[0]"
        ]
    },
    {
        "question_id": "3047",
        "code_list": [
            "from math import sqrt\nfrom collections import defaultdict\n\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        def is_perfect_square(n):\n            return int(sqrt(n)) ** 2 == n\n        \n        def factorize(n):\n            factors = []\n            for i in range(2, int(sqrt(n)) + 1):\n                while n % i == 0:\n                    factors.append(i)\n                    n //= i\n            if n > 1:\n                factors.append(n)\n            return factors\n        \n        n = len(nums)\n        dp = [0] * (n + 1)\n        factor_to_indices = defaultdict(list)\n        \n        for i, num in enumerate(nums, start=1):\n            factors = factorize(num)\n            unique_factors = list(set(factors))\n            mask = 0\n            for f in unique_factors:\n                mask |= 1 << (factors.count(f) % 2)\n            factor_to_indices[mask].append(i)\n        \n        for mask in factor_to_indices:\n            indices = factor_to_indices[mask]\n            for i in range(len(indices)):\n                for j in range(i):\n                    dp[indices[i]] = max(dp[indices[i]], dp[indices[j]])\n            for i in range(len(indices)):\n                dp[indices[i]] += sum(nums[index - 1] for index in indices[:i])\n        \n        return max(dp)"
        ]
    },
    {
        "question_id": "3055",
        "code_list": [
            "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        ones = s.count('1')\n        zeros = s.count('0')\n        # Place all but one '1' at the beginning, followed by all '0's, and end with one '1'\n        return '1' * (ones - 1) + '0' * zeros + '1'"
        ]
    },
    {
        "question_id": "3080",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        min_score = all_num = nums[0]\n        for num in nums:\n            all_num &= num\n            min_score |= (all_num ^ num)\n        \n        if min_score == 0:\n            return len(nums) - nums.count(0)\n        else:\n            return 1"
        ]
    },
    {
        "question_id": "3081",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_count = 1\n        current_count = 1\n        \n        for i in range(1, n):\n            if nums[i] == nums[i - 1]:\n                current_count += 1\n                max_count = max(max_count, current_count)\n            else:\n                current_count = 1\n        \n        return n - (max_count + 1) // 2 * 2"
        ]
    },
    {
        "question_id": "3091",
        "code_list": [
            "from collections import Counter\nfrom typing import List\n\nclass Solution:\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        mod = 10**9 + 7\n        cnt = Counter(nums)\n        dp = [1] + [0] * (r + 1)\n        \n        for num, freq in cnt.items():\n            for s in range(r, num - 1, -1):\n                for i in range(1, freq + 1):\n                    dp[s] = (dp[s] + dp[s - i * num]) % mod\n        \n        res = sum(dp[l:r + 1]) % mod\n        return res"
        ]
    },
    {
        "question_id": "3093",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)"
        ]
    },
    {
        "question_id": "3094",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        operations = 0\n        \n        for freq in count.values():\n            if freq == 1:\n                return -1\n            operations += (freq + 2) // 3\n        \n        return operations"
        ]
    },
    {
        "question_id": "3104",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countWays(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        ways = 0\n        \n        # Case 1: Selecting no student\n        if nums[0] > 0:\n            ways += 1\n        \n        # Case 2: Selecting some or all students\n        for i in range(n):\n            if (i + 1) > nums[i] and (i == n - 1 or (i + 1) < nums[i + 1]):\n                ways += 1\n        \n        # Case 3: Selecting all students\n        if nums[-1] < n:\n            ways += 1\n        \n        return ways"
        ]
    },
    {
        "question_id": "3106",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        dp = [0] * (target + 1)\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = max(dp[j], dp[j - num] + 1)\n        return dp[target] if dp[target] != 0 else -1"
        ]
    },
    {
        "question_id": "3114",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        left = [0] * n\n        right = [0] * n\n        \n        stack = []\n        for i in range(n):\n            while stack and maxHeights[stack[-1]] >= maxHeights[i]:\n                stack.pop()\n            left[i] = (i - stack[-1] - 1) * maxHeights[i] if stack else i * maxHeights[i]\n            if stack:\n                left[i] += left[stack[-1]]\n            stack.append(i)\n        \n        stack = []\n        for i in range(n - 1, -1, -1):\n            while stack and maxHeights[stack[-1]] >= maxHeights[i]:\n                stack.pop()\n            right[i] = (stack[-1] - i - 1) * maxHeights[i] if stack else (n - i - 1) * maxHeights[i]\n            if stack:\n                right[i] += right[stack[-1]]\n            stack.append(i)\n        \n        return max(left[i] + right[i] - maxHeights[i] for i in range(n))"
        ]
    },
    {
        "question_id": "3141",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        total_sum = sum(nums)\n        prefix_sums = {0: -1}\n        current_sum = 0\n        min_length = float('inf')\n        n = len(nums)\n        \n        # Calculate prefix sums and store them in a dictionary\n        for i, num in enumerate(nums):\n            current_sum += num\n            prefix_sums[current_sum] = i\n        \n        # Calculate the number of full arrays needed\n        full_arrays = target // total_sum\n        target %= total_sum\n        \n        # Adjust target if it's greater than the total sum\n        if target == 0:\n            return (full_arrays * n) % (10**9 + 7)\n        \n        # Find the shortest subarray with sum equal to target\n        for i in range(n):\n            complement = current_sum + target - nums[i]\n            if complement in prefix_sums:\n                min_length = min(min_length, i - prefix_sums[complement] + (full_arrays * n))\n        \n        # Check if the entire array repeated enough times can form the target\n        if min_length == float('inf'):\n            return -1\n        else:\n            return min_length"
        ]
    },
    {
        "question_id": "3150",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        n = len(s)\n        min_len = float('inf')\n        result = \"\"\n        \n        left = 0\n        count = 0\n        for right in range(n):\n            if s[right] == '1':\n                count += 1\n            \n            while count == k:\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    result = s[left:right+1]\n                \n                if s[left] == '1':\n                    count -= 1\n                left += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3151",
        "code_list": [
            "from heapq import heapify, heappop\n\nclass Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        # Sort processor times in ascending order\n        processorTime.sort()\n        # Sort tasks in descending order to always assign the largest remaining task to the earliest available processor\n        tasks.sort(reverse=True)\n        # Create a min-heap for tasks\n        task_heap = tasks[:]\n        heapify(task_heap)\n        \n        # Assign tasks to processors\n        for i in range(len(processorTime)):\n            for _ in range(4):\n                # Get the next largest task and add the processor's availability time to it\n                processorTime[i] = max(processorTime[i], heappop(task_heap) + processorTime[i])\n        \n        # Return the maximum time taken by any processor\n        return max(processorTime)"
        ]
    },
    {
        "question_id": "3153",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Count the frequency of each bit position across all numbers\n        bit_counts = [0] * 30\n        for num in nums:\n            for bit in range(30):\n                if num & (1 << bit):\n                    bit_counts[bit] += 1\n        \n        # Construct the k largest possible numbers based on the bit counts\n        result_nums = []\n        for _ in range(k):\n            current_num = 0\n            for bit in range(30):\n                if bit_counts[bit]:\n                    current_num |= (1 << bit)\n                    bit_counts[bit] -= 1\n            result_nums.append(current_num)\n        \n        # Calculate the sum of squares of the k largest numbers\n        return sum(x ** 2 for x in result_nums) % MOD"
        ]
    },
    {
        "question_id": "3154",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        max_value = 0\n        n = len(nums)\n        max_diff = [0] * n\n        max_val = nums[-1]\n        \n        # Calculate the maximum value for nums[k] from the end\n        for k in range(n - 2, 1, -1):\n            max_val = max(max_val, nums[k])\n            max_diff[k] = max_val\n        \n        # Iterate through the array to find the maximum triplet value\n        for j in range(1, n - 1):\n            for k in range(j + 1, n):\n                max_value = max(max_value, (nums[j] - nums[k]) * max_diff[j])\n        \n        return max_value"
        ]
    },
    {
        "question_id": "3163",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        total_sum = 0\n        \n        for i in range(n):\n            seen = set()\n            for j in range(i, n):\n                seen.add(nums[j])\n                total_sum += len(seen) ** 2\n        \n        return total_sum"
        ]
    },
    {
        "question_id": "3164",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def lastVisitedIntegers(self, words: List[str]) -> List[int]:\n        result = []\n        nums = []\n        prev_count = 0\n        \n        for word in words:\n            if word != \"prev\":\n                nums.append(int(word))\n                prev_count = 0\n            else:\n                prev_count += 1\n                if len(nums) < prev_count:\n                    result.append(-1)\n                else:\n                    result.append(nums[-prev_count])\n        \n        return result"
        ]
    },
    {
        "question_id": "3166",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        values = list(count.values())\n        n = len(nums)\n        \n        def is_valid(group_size):\n            total_groups = 0\n            for val in values:\n                q, r = divmod(val, group_size)\n                if r > 0:\n                    if q < r:\n                        return False\n                    total_groups += q + 1\n                else:\n                    total_groups += q\n            return total_groups <= n\n        \n        # Find the minimum group size\n        for group_size in range(min(values), 0, -1):\n            if is_valid(group_size):\n                break\n        \n        # Calculate the minimum number of groups needed\n        total_groups = 0\n        for val in values:\n            q, r = divmod(val, group_size)\n            if r > 0:\n                total_groups += q + 1\n            else:\n                total_groups += q\n        return total_groups"
        ]
    },
    {
        "question_id": "3171",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        zeros1, total1 = nums1.count(0), sum(nums1)\n        zeros2, total2 = nums2.count(0), sum(nums2)\n        \n        # Calculate the required sums to balance the arrays\n        req_sum1 = total1 + zeros1\n        req_sum2 = total2 + zeros2\n        \n        # Check if it's possible to make the sums equal\n        if (total1 + zeros1 > total2 + zeros2 and zeros1 == 0) or (total2 + zeros2 > total1 + zeros1 and zeros2 == 0):\n            return -1\n        \n        # Return the maximum of the required sums\n        return max(req_sum1, req_sum2)"
        ]
    },
    {
        "question_id": "3172",
        "code_list": [
            "class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        num1 = sum(i for i in range(1, n + 1) if i % m != 0)\n        num2 = sum(i for i in range(1, n + 1) if i % m == 0)\n        return num1 - num2"
        ]
    },
    {
        "question_id": "3174",
        "code_list": [
            "class Solution:\n    def minChanges(self, s: str) -> int:\n        changes = 0\n        for i in range(0, len(s), 2):\n            if s[i] != s[i + 1]:\n                changes += 1\n        return changes"
        ]
    },
    {
        "question_id": "3176",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        left_min = [0] * n\n        right_min = [0] * n\n        \n        # Fill left_min array with the minimum value to the left of each index\n        left_min[0] = nums[0]\n        for i in range(1, n):\n            left_min[i] = min(left_min[i-1], nums[i])\n        \n        # Fill right_min array with the minimum value to the right of each index\n        right_min[n-1] = nums[n-1]\n        for i in range(n-2, -1, -1):\n            right_min[i] = min(right_min[i+1], nums[i])\n        \n        # Find the mountain triplet\n        for j in range(1, n-1):\n            if nums[j] > left_min[j] and nums[j] > right_min[j]:\n                min_sum = min(min_sum, left_min[j] + nums[j] + right_min[j])\n        \n        return min_sum if min_sum != float('inf') else -1"
        ]
    },
    {
        "question_id": "3183",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        bit_count = [0] * 31\n        \n        for num in nums:\n            for i in range(31):\n                if num & (1 << i):\n                    bit_count[i] += 1\n        \n        result = 0\n        for i, count in enumerate(bit_count):\n            if count >= k:\n                result |= (1 << i)\n        \n        return result"
        ]
    },
    {
        "question_id": "3184",
        "code_list": [
            "from typing import List\nimport bisect\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        dp = []\n        min_vals = []\n        max_sum = float('-inf')\n        \n        for i, num in enumerate(nums):\n            # Find the position to insert the current number in the dp list\n            pos = bisect.bisect_left(dp, num - i)\n            if pos == len(dp):\n                dp.append(num - i)\n                min_vals.append(num)\n            else:\n                dp[pos] = num - i\n                min_vals[pos] = min(min_vals[pos], num)\n            \n            # Calculate the maximum sum ending at the current index\n            if pos > 0:\n                max_sum = max(max_sum, min_vals[pos - 1] + dp[pos - 1])\n            else:\n                max_sum = max(max_sum, min_vals[pos])\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3188",
        "code_list": [
            "class Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        strongest_team = -1\n        for i in range(len(grid)):\n            if sum(grid[i]) == len(grid) - 1:\n                if strongest_team != -1:\n                    return -1  # More than one team can be a champion\n                strongest_team = i\n        return strongest_team"
        ]
    },
    {
        "question_id": "3190",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        max1, max2 = max(nums1), max(nums2)\n        if nums1[-1] >= max1 and nums2[-1] >= max2:\n            return 0\n        \n        def check_swap(i):\n            temp1, temp2 = nums1[:], nums2[:]\n            temp1[i], temp2[i] = temp2[i], temp1[i]\n            if temp1[-1] >= max1 and temp2[-1] >= max2:\n                return True\n            return False\n        \n        def count_operations():\n            count = 0\n            for i in range(n):\n                if nums1[i] > max1 or nums2[i] > max2:\n                    if not check_swap(i):\n                        return float('inf')\n                    count += 1\n            return count\n        \n        operations_without_swap = count_operations()\n        operations_with_swap = count_operations() + 1\n        \n        if operations_without_swap == float('inf') and operations_with_swap == float('inf'):\n            return -1\n        else:\n            return min(operations_without_swap, operations_with_swap)"
        ]
    },
    {
        "question_id": "3192",
        "code_list": [
            "from functools import reduce\nfrom operator import xor\n\nclass Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        mod = 10**9 + 7\n        \n        # Function to find the maximum x such that (a ^ x) * (b ^ x) is maximized\n        def max_xor_product(a, b):\n            diff = a - b\n            mask = reduce(xor, [1 << i for i in range(50) if diff >> i & 1])\n            return (a ^ mask) % mod * (b ^ mask) % mod\n        \n        # Ensure a >= b for simplicity\n        if a < b:\n            a, b = b, a\n        \n        # Calculate the maximum value of (a ^ x) * (b ^ x) for x in range(2^n)\n        max_val = max(max_xor_product(a, b), max_xor_product(a - (1 << n), b))\n        \n        return max_val % mod"
        ]
    },
    {
        "question_id": "3193",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        max_xor = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if abs(nums[i] - nums[j]) <= min(nums[i], nums[j]):\n                    max_xor = max(max_xor, nums[i] ^ nums[j])\n        return max_xor"
        ]
    },
    {
        "question_id": "3194",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        result_indices = []\n        for index, word in enumerate(words):\n            if x in word:\n                result_indices.append(index)\n        return result_indices"
        ]
    },
    {
        "question_id": "3195",
        "code_list": [
            "class Solution:\n    def minimumSteps(self, s: str) -> int:\n        steps = 0\n        zero_count = 0\n        \n        for i in range(len(s)):\n            if s[i] == '0':\n                zero_count += 1\n            else:\n                steps += i - zero_count\n        \n        return steps"
        ]
    },
    {
        "question_id": "3196",
        "code_list": [
            "from typing import List\nfrom collections import Counter\nimport bisect\n\nclass Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        max_score = 0\n        left = 0\n        \n        for right in range(n):\n            k -= (nums[right] - nums[right - 1]) * (right - left)\n            while k < 0:\n                k += nums[right] - nums[left]\n                left += 1\n            max_score = max(max_score, right - left + 1)\n        \n        return max_score"
        ]
    },
    {
        "question_id": "3199",
        "code_list": [
            "from itertools import product\n\nclass Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        return sum(1 for x, y, z in product(range(limit + 1), repeat=3) if x + y + z == n)"
        ]
    },
    {
        "question_id": "3200",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def stringCount(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(length, has_e, has_l, has_t):\n            if length == n:\n                return 1 if has_e and has_l and has_t else 0\n            \n            count = 0\n            if not has_e:\n                count += dp(length + 1, True, has_l, has_t) * 26\n            if not has_l:\n                count += dp(length + 1, has_e, True, has_t) * 26\n            if not has_t:\n                count += dp(length + 1, has_e, has_l, True) * 26\n            if has_e and has_l and not has_t:\n                count += dp(length + 1, has_e, has_l, True) * 3\n            if has_e and has_t and not has_l:\n                count += dp(length + 1, has_e, True, has_t) * 3\n            if has_l and has_t and not has_e:\n                count += dp(length + 1, True, has_l, has_t) * 3\n            \n            return count % MOD\n        \n        return dp(0, False, False, False)"
        ]
    },
    {
        "question_id": "3203",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        def check_palindrome(s):\n            return s == s[::-1]\n        \n        def transform_substring(s, start, end):\n            return s[:start] + s[start:end+1][::-1] + s[end+1:]\n        \n        def can_form_palindrome(s1, s2):\n            for i in range(len(s1)):\n                if s1[i] != s2[i]:\n                    if s1[i:] != s2[i:][::-1]:\n                        return False\n            return True\n        \n        n = len(s)\n        half_n = n // 2\n        result = []\n        \n        for a, b, c, d in queries:\n            s1 = s[:half_n]\n            s2 = s[half_n:]\n            \n            # Rearrange the specified substrings\n            s1 = transform_substring(s1, a, b)\n            s2 = transform_substring(s2, c, d)\n            \n            # Check if the combined string can form a palindrome\n            combined = s1 + s2\n            if check_palindrome(combined):\n                result.append(True)\n            else:\n                # Check if the first half can match the reversed second half\n                if can_form_palindrome(s1, s2[::-1]):\n                    result.append(True)\n                else:\n                    result.append(False)\n        \n        return result"
        ]
    },
    {
        "question_id": "3206",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        set1, set2 = set(nums1), set(nums2)\n        count1 = sum(1 for num in nums1 if num in set2)\n        count2 = sum(1 for num in nums2 if num in set1)\n        return [count1, count2]"
        ]
    },
    {
        "question_id": "3207",
        "code_list": [
            "class Solution:\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        min_length = min(len(s1), len(s2), len(s3))\n        for i in range(min_length):\n            if s1[i] != s2[i] or s1[i] != s3[i]:\n                return -1 if i == 0 else min_length - i * 3\n        return min_length * 3"
        ]
    },
    {
        "question_id": "3209",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            # Option 1: Buy the current fruit and get the next i fruits for free\n            dp[i] = min(dp[i], dp[max(0, i - 2)] + prices[i - 1])\n            # Option 2: Skip buying the current fruit and use the previous state\n            for j in range(i + 1, min(n + 1, i + i)):\n                dp[j] = min(dp[j], dp[i - 1])\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "3210",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        vowels = set('aeiou')\n        prefix_sum = 0\n        count = 0\n        index_map = defaultdict(int)\n        index_map[0] = -1\n        \n        for i, char in enumerate(s):\n            prefix_sum += 1 if char in vowels else -1\n            if prefix_sum % 2 != 0:\n                continue\n            \n            if (prefix_sum // 2) * ((prefix_sum // 2) % k == 0):\n                count += 1\n            \n            if prefix_sum in index_map:\n                count += i - index_map[prefix_sum]\n            else:\n                index_map[prefix_sum] = i\n        \n        return count"
        ]
    },
    {
        "question_id": "3211",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findMaximumLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [1] * n  # dp[i] represents the max length of non-decreasing array ending at index i\n        \n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] <= nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"
        ]
    },
    {
        "question_id": "3212",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        last_occurrence = {}\n        for i, num in enumerate(nums):\n            last_occurrence[num] = i\n        \n        partitions = 1\n        start, end = 0, 0\n        for i, num in enumerate(nums):\n            end = max(end, last_occurrence[num])\n            if i == end:\n                partitions *= 2\n                partitions %= (10**9 + 7)\n                start = i + 1\n                end = i + 1\n        \n        return partitions - 1"
        ]
    },
    {
        "question_id": "3213",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        max_val = max(nums)\n        n = len(nums)\n        count = 0\n        left = 0\n        result = 0\n        \n        for right in range(n):\n            if nums[right] == max_val:\n                count += 1\n            \n            while count >= k:\n                if nums[left] == max_val:\n                    count -= 1\n                left += 1\n            \n            result += left\n        \n        return result"
        ]
    },
    {
        "question_id": "3219",
        "code_list": [
            "from typing import List\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        n = len(nums)\n        sorted_nums = sorted(zip(nums, range(n)))\n        groups = []\n        start = 0\n        \n        for end in range(1, n):\n            if sorted_nums[end][0] - sorted_nums[start][0] > limit:\n                groups.append(sorted_nums[start:end])\n                start = end\n        \n        groups.append(sorted_nums[start:])\n        \n        result = [0] * n\n        for group in groups:\n            indices = [i[1] for i in group]\n            values = [i[0] for i in group]\n            values.sort()\n            for idx, val in zip(indices, values):\n                result[idx] = val\n        \n        return result"
        ]
    },
    {
        "question_id": "3220",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        tested_count = 0\n        for i in range(len(batteryPercentages)):\n            if batteryPercentages[i] > 0:\n                tested_count += 1\n                for j in range(i + 1, len(batteryPercentages)):\n                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1)\n        return tested_count"
        ]
    },
    {
        "question_id": "3221",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        peaks = []\n        for i in range(1, len(mountain) - 1):\n            if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\n                peaks.append(i)\n        return peaks"
        ]
    },
    {
        "question_id": "3223",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        n = len(word)\n        ans = 0\n        \n        def isValid(sub):\n            cnt = Counter(sub)\n            return all(v == k for v in cnt.values())\n        \n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n and abs(ord(word[j]) - ord(word[j-1])) <= 2:\n                j += 1\n            sub = word[i:j]\n            if isValid(sub):\n                ans += 1\n            i = j\n        \n        return ans"
        ]
    },
    {
        "question_id": "3224",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Calculate gaps between consecutive sick children\n        gaps = []\n        for i in range(1, len(sick)):\n            gaps.append(sick[i] - sick[i-1] - 1)\n        gaps.append(n - 1 - sick[-1])\n        gaps.insert(0, sick[0])\n        \n        # Calculate the product of combinations for each gap\n        total_sequences = 1\n        for gap in gaps:\n            if gap > 1:\n                total_sequences *= pow(2, gap - 1, MOD)\n                total_sequences %= MOD\n        \n        return total_sequences"
        ]
    },
    {
        "question_id": "3225",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        freq_map = defaultdict(int)\n        left = 0\n        max_length = 0\n        \n        for right in range(len(nums)):\n            freq_map[nums[right]] += 1\n            \n            while freq_map[nums[right]] > k:\n                freq_map[nums[left]] -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3226",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        arr = []\n        while nums:\n            alice_remove = nums.pop(0)\n            bob_remove = nums.pop(0)\n            arr.append(bob_remove)\n            arr.append(alice_remove)\n        return arr"
        ]
    },
    {
        "question_id": "3227",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid)\n        nums = [0] * (n * n + 1)\n        for row in grid:\n            for num in row:\n                nums[num] += 1\n        \n        repeated = missing = -1\n        for i in range(1, n * n + 1):\n            if nums[i] == 2:\n                repeated = i\n            elif nums[i] == 0:\n                missing = i\n        \n        return [repeated, missing]"
        ]
    },
    {
        "question_id": "3228",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        half_n = n // 2\n        \n        count1 = Counter(nums1)\n        count2 = Counter(nums2)\n        \n        common_elements = (count1 & count2).elements()\n        unique_to_1 = set(nums1) - set(nums2)\n        unique_to_2 = set(nums2) - set(nums1)\n        \n        unique_count_1 = min(len(unique_to_1), half_n)\n        unique_count_2 = min(len(unique_to_2), half_n)\n        \n        common_count = min(len(common_elements), half_n)\n        \n        max_set_size = unique_count_1 + unique_count_2 + common_count\n        \n        return min(max_set_size, n)"
        ]
    },
    {
        "question_id": "3229",
        "code_list": [
            "from typing import List\nfrom math import inf\n\ndef is_palindrome(num: int) -> bool:\n    return str(num) == str(num)[::-1]\n\ndef closest_palindrome(num: int) -> int:\n    num_str = str(num)\n    len_num = len(num_str)\n    \n    # Generate potential palindrome candidates\n    candidates = [\n        int(num_str[:len_num // 2] + num_str[len_num // 2][::-1]),\n        int(num_str[:len_num // 2 + 1] + num_str[len_num // 2 + 1][::-1])\n    ]\n    \n    if len_num % 2 == 1:\n        candidates.append(int(num_str[:len_num // 2] + num_str[len_num // 2] + num_str[len_num // 2][::-1]))\n    \n    # Find the closest palindrome\n    closest = min(candidates, key=lambda x: abs(x - num))\n    return closest\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        median = sorted(nums)[len(nums) // 2]\n        closest_median = closest_palindrome(median)\n        cost_median = sum(abs(num - closest_median) for num in nums)\n        \n        closest_lower = closest_palindrome(median - 1)\n        cost_lower = sum(abs(num - closest_lower) for num in nums)\n        \n        closest_upper = closest_palindrome(median + 1)\n        cost_upper = sum(abs(num - closest_upper) for num in nums)\n        \n        return min(cost_median, cost_lower, cost_upper)"
        ]
    },
    {
        "question_id": "3230",
        "code_list": [
            "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        operations = 0\n        i = 0\n        while i < len(word) - 1:\n            if abs(ord(word[i]) - ord(word[i + 1])) <= 1:\n                operations += 1\n                i += 2  # Skip the next character as it will be checked in the next iteration\n            else:\n                i += 1\n        return operations"
        ]
    },
    {
        "question_id": "3231",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        added_coins = 0\n        max_reachable = 0\n        \n        for coin in sorted(coins):\n            while coin > max_reachable + 1 and max_reachable < target:\n                added_coins += 1\n                max_reachable += max_reachable + 1\n            max_reachable += coin\n            if max_reachable >= target:\n                return added_coins\n        \n        while max_reachable < target:\n            added_coins += 1\n            max_reachable += max_reachable + 1\n        \n        return added_coins"
        ]
    },
    {
        "question_id": "3233",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n        def count_partitions(s, k):\n            partitions = 0\n            i = 0\n            while i < len(s):\n                distinct_chars = set()\n                j = i\n                while j < len(s) and len(distinct_chars) <= k:\n                    distinct_chars.add(s[j])\n                    j += 1\n                if len(distinct_chars) > k:\n                    return partitions\n                partitions += 1\n                i = j\n            return partitions\n        \n        n = len(s)\n        if k == 26:\n            return 1\n        \n        max_partitions = 0\n        for i in range(n):\n            temp_s = s[:i] + chr(ord('a') + (ord(s[i]) - ord('a') + 1) % 26) + s[i+1:]\n            max_partitions = max(max_partitions, count_partitions(temp_s, k))\n        \n        return max_partitions"
        ]
    },
    {
        "question_id": "3234",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        def power_modulo(base: int, exponent: int, modulo: int) -> int:\n            result = 1\n            base = base % modulo\n            while exponent > 0:\n                if exponent % 2 == 1:\n                    result = (result * base) % modulo\n                exponent = exponent >> 1\n                base = (base * base) % modulo\n            return result\n        \n        good_indices = []\n        for i, (a, b, c, m) in enumerate(variables):\n            if power_modulo(power_modulo(a, b, 10), c, m) == target:\n                good_indices.append(i)\n        return good_indices"
        ]
    },
    {
        "question_id": "3235",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        # Build the graph\n        graph = defaultdict(dict)\n        for o, c, co in zip(original, changed, cost):\n            if c not in graph[o]:\n                graph[o][c] = co\n            else:\n                graph[o][c] = min(graph[o][c], co)\n        \n        # Floyd-Warshall algorithm to find the shortest path between any two characters\n        dist = defaultdict(lambda: defaultdict(lambda: float('inf')))\n        for o in graph:\n            dist[o][o] = 0\n            for c, co in graph[o].items():\n                dist[o][c] = co\n        \n        for k in graph:\n            for i in graph:\n                for j in graph:\n                    if dist[i][k] + dist[k][j] < dist[i][j]:\n                        dist[i][j] = dist[i][k] + dist[k][j]\n        \n        # Calculate the total cost\n        total_cost = 0\n        for s, t in zip(source, target):\n            if s == t:\n                continue\n            if dist[s][t] == float('inf'):\n                return -1\n            total_cost += dist[s][t]\n        \n        return total_cost"
        ]
    },
    {
        "question_id": "3236",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 1\n        \n        # Find the longest sequential prefix\n        longest_prefix_sum = nums[0]\n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1:\n                longest_prefix_sum += nums[i]\n            else:\n                break\n        \n        # Find the smallest missing integer greater than or equal to the sum of the longest sequential prefix\n        current = longest_prefix_sum\n        while current in nums:\n            current += 1\n        \n        return current"
        ]
    },
    {
        "question_id": "3239",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:\n        queue = deque([(x, 0)])\n        visited = set([x])\n        \n        while queue:\n            current, steps = queue.popleft()\n            if current == y:\n                return steps\n            \n            # Divide by 11 if possible\n            if current % 11 == 0 and current // 11 not in visited:\n                visited.add(current // 11)\n                queue.append((current // 11, steps + 1))\n            \n            # Divide by 5 if possible\n            if current % 5 == 0 and current // 5 not in visited:\n                visited.add(current // 5)\n                queue.append((current // 5, steps + 1))\n            \n            # Decrement by 1\n            if current - 1 not in visited:\n                visited.add(current - 1)\n                queue.append((current - 1, steps + 1))\n            \n            # Increment by 1\n            if current + 1 not in visited:\n                visited.add(current + 1)\n                queue.append((current + 1, steps + 1))\n        \n        return -1  # This line should theoretically never be reached given the constraints"
        ]
    },
    {
        "question_id": "3240",
        "code_list": [
            "from math import log2, ceil\n\nclass Solution:\n    def findMaximumNumber(self, k: int, x: int) -> int:\n        def count_set_bits_in_range(n, x):\n            total_price = 0\n            for i in range(x, n + 1, x):\n                # Calculate the number of set bits at position i in the binary representation\n                total_price += (n // (1 << i)) + 1 - ((i - 1) // x)\n            return total_price\n        \n        low, high = 1, 10**15\n        while low < high:\n            mid = (low + high + 1) // 2\n            if count_set_bits_in_range(mid, x) > k:\n                high = mid - 1\n            else:\n                low = mid\n        return low"
        ]
    },
    {
        "question_id": "3242",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        freq_counter = Counter(nums)\n        max_freq = max(freq_counter.values())\n        return sum(count for count in freq_counter.values() if count == max_freq)"
        ]
    },
    {
        "question_id": "3243",
        "code_list": [
            "from math import log10, ceil\n\nclass Solution:\n    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:\n        def count_numbers(n, k):\n            if n < len(s):\n                return 0\n            prefix = str(n)[:len(str(n)) - len(s)]\n            suffix = str(n)[-len(s):]\n            if suffix != s:\n                return 0\n            count = 0\n            for i in range(len(prefix)):\n                if prefix[i] == '0':\n                    continue\n                if int(prefix[i]) > k:\n                    break\n                count += (k + 1) * (10 ** (len(prefix) - i - 1))\n            if prefix and int(prefix) <= k:\n                count += 1\n            return count\n        \n        start_str = str(start)\n        finish_str = str(finish)\n        start_suffix = start_str[-len(s):]\n        finish_suffix = finish_str[-len(s):]\n        \n        if start_suffix != s:\n            start_count = count_numbers(int(start_str[:-len(s)] + s), limit)\n        else:\n            start_count = 0\n        \n        if finish_suffix != s:\n            finish_count = count_numbers(int(finish_str[:-len(s)] + s), limit)\n        else:\n            finish_count = 0\n        \n        return finish_count - start_count"
        ]
    },
    {
        "question_id": "3244",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        min_val = min(nums)\n        count_min = nums.count(min_val)\n        \n        for num in nums:\n            if num % min_val != 0:\n                return 1\n        \n        return max(1, count_min - 1)"
        ]
    },
    {
        "question_id": "3245",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        # Find all occurrences of 'a' and 'b' in 's'\n        a_indices = [i for i in range(len(s) - len(a) + 1) if s.startswith(a, i)]\n        b_indices = [i for i in range(len(s) - len(b) + 1) if s.startswith(b, i)]\n        \n        # Initialize the result list\n        result = []\n        \n        # Check each occurrence of 'a' to see if there's a corresponding 'b' within the distance 'k'\n        for i in a_indices:\n            for j in b_indices:\n                if abs(i - j) <= k:\n                    result.append(i)\n                    break\n        \n        return result"
        ]
    },
    {
        "question_id": "3246",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        # Check if there are at least two even numbers in the list\n        return sum(1 for num in nums if num % 2 == 0) >= 2"
        ]
    },
    {
        "question_id": "3249",
        "code_list": [
            "from functools import reduce\nfrom operator import xor\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        # Calculate the XOR of all elements in nums with k\n        target_xor = reduce(xor, nums, k)\n        # Count the number of set bits (1s) in the binary representation of target_xor\n        return bin(target_xor).count('1')"
        ]
    },
    {
        "question_id": "3251",
        "code_list": [
            "from typing import List\nimport math\n\nclass Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n        max_area = 0\n        max_diagonal_squared = 0\n        \n        for length, width in dimensions:\n            diagonal_squared = length ** 2 + width ** 2\n            area = length * width\n            \n            if diagonal_squared > max_diagonal_squared or (diagonal_squared == max_diagonal_squared and area > max_area):\n                max_diagonal_squared = diagonal_squared\n                max_area = area\n        \n        return max_area"
        ]
    },
    {
        "question_id": "3252",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        n = len(nums)\n        left, right = 0, n - 1\n        \n        # Find the longest non-increasing prefix\n        while left < n - 1 and nums[left] < nums[left + 1]:\n            left += 1\n        \n        # Find the longest non-increasing suffix\n        while right > 0 and nums[right - 1] < nums[right]:\n            right -= 1\n        \n        # If the whole array is already strictly increasing\n        if left == n - 1:\n            return (n * (n + 1)) // 2\n        \n        count = 0\n        \n        # Count all subarrays starting from the beginning\n        for i in range(n):\n            if nums[i] <= nums[left]:\n                break\n            count += 1\n        \n        # Count all subarrays ending at the end\n        for i in range(n - 1, -1, -1):\n            if nums[i] <= nums[right]:\n                break\n            count += 1\n        \n        # Count all subarrays that start before the prefix and end after the suffix\n        for i in range(left + 1):\n            j = bisect_right(nums, nums[i], lo=right)\n            count += max(0, j - right)\n        \n        return count"
        ]
    },
    {
        "question_id": "3261",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        # Precompute the prefix OR for each bit position\n        prefix_or = [0] * 30\n        for num in nums:\n            for bit in range(30):\n                if num & (1 << bit):\n                    prefix_or[bit] |= 1 << bit\n        \n        # Function to check if we can achieve a certain OR value\n        def canAchieve(target_or):\n            operations = 0\n            for bit in range(30):\n                if target_or & (1 << bit):\n                    count = 0\n                    for i in range(n):\n                        if nums[i] & (1 << bit):\n                            count += 1\n                        if count == 2:\n                            operations += 1\n                            count = 0\n            return operations <= k\n        \n        # Binary search to find the minimum possible OR value\n        low, high = 0, (1 << 30) - 1\n        while low < high:\n            mid = (low + high) // 2\n            if canAchieve(mid):\n                high = mid\n            else:\n                low = mid + 1\n        \n        return low"
        ]
    },
    {
        "question_id": "3262",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        for i in range(len(nums) - 2):\n            if nums[i] < nums[i + 1] + nums[i + 2]:\n                return nums[i] + nums[i + 1] + nums[i + 2]\n        return -1"
        ]
    },
    {
        "question_id": "3263",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        # The cost of the first subarray is always the first element of nums\n        first_cost = nums[0]\n        # Find the two smallest elements from the rest of the array\n        min1, min2 = float('inf'), float('inf')\n        for num in nums[1:]:\n            if num < min1:\n                min1, min2 = num, min1\n            elif num < min2:\n                min2 = num\n        # Return the sum of the first element and the two smallest elements\n        return first_cost + min1 + min2"
        ]
    },
    {
        "question_id": "3265",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        prefix_sum = 0\n        max_sum = float('-inf')\n        index_map = defaultdict(lambda: float('inf'))\n        index_map[0] = -1\n        \n        for i, num in enumerate(nums):\n            prefix_sum += num\n            target1 = num - k\n            target2 = num + k\n            \n            if target1 in index_map:\n                max_sum = max(max_sum, prefix_sum - index_map[target1])\n            if target2 in index_map:\n                max_sum = max(max_sum, prefix_sum - index_map[target2])\n            \n            if prefix_sum < index_map[num]:\n                index_map[num] = prefix_sum\n            prefix_sum = min(prefix_sum, index_map[num])\n        \n        return max_sum if max_sum != float('-inf') else 0"
        ]
    },
    {
        "question_id": "3267",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maximumLength(self, s: str) -> int:\n        n = len(s)\n        count = defaultdict(list)\n        \n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            length = j - i\n            count[s[i]].append(length)\n            i = j\n        \n        max_length = -1\n        for char, lengths in count.items():\n            lengths.sort(reverse=True)\n            if len(lengths) >= 3:\n                max_length = max(max_length, lengths[2])\n            elif len(lengths) == 2:\n                max_length = max(max_length, min(lengths))\n            else:\n                max_length = max(max_length, lengths[0])\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3269",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        m = len(pattern)\n        \n        for i in range(n - m):\n            matches = True\n            for j in range(m):\n                if pattern[j] == 1 and nums[i + j + 1] <= nums[i + j]:\n                    matches = False\n                    break\n                elif pattern[j] == 0 and nums[i + j + 1] != nums[i + j]:\n                    matches = False\n                    break\n                elif pattern[j] == -1 and nums[i + j + 1] >= nums[i + j]:\n                    matches = False\n                    break\n            if matches:\n                count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3279",
        "code_list": [
            "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        # If both n and m are even or both are odd, Alice cannot guarantee a win\n        if (n % 2 == m % 2):\n            return 0\n        \n        # Calculate the number of valid pairs\n        # For each even x in range [2, n, 2], there are (m // 2 + m % 2) choices for y\n        # For each odd x in range [1, n, 2], there are (m // 2) choices for y\n        # Similarly, for each even y in range [2, m, 2], there are (n // 2 + n % 2) choices for x\n        # For each odd y in range [1, m, 2], there are (n // 2) choices for x\n        return (n // 2 + n % 2) * (m // 2 + m % 2) + (n // 2) * (m // 2)"
        ]
    },
    {
        "question_id": "3291",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        n = len(nums)\n        for i in range(n - 1):\n            while i < n - 1 and bin(nums[i]).count('1') == bin(nums[i + 1]).count('1'):\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n                i += 1\n        return nums == sorted(nums)"
        ]
    },
    {
        "question_id": "3292",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n, m = len(nums), len(changeIndices)\n        last_occurrence = [-1] * (n + 1)\n        \n        # Track the last occurrence of each index in changeIndices\n        for s, idx in enumerate(changeIndices):\n            last_occurrence[idx] = s\n        \n        # Binary search for the earliest second\n        left, right = 1, m\n        while left < right:\n            mid = (left + right) // 2\n            marked = [False] * (n + 1)\n            operations_needed = [0] * (n + 1)\n            \n            # Check if it's possible to mark all indices within mid seconds\n            for s in range(mid, 0, -1):\n                if last_occurrence[changeIndices[s - 1]] >= s:\n                    continue\n                \n                idx = changeIndices[s - 1]\n                if not marked[idx]:\n                    marked[idx] = True\n                    operations_needed[idx] += nums[idx - 1] + 1\n                    if operations_needed[idx] > s:\n                        break\n            \n            if all(marked):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left if all(last_occurrence[i] != -1 for i in range(1, n + 1)) else -1"
        ]
    },
    {
        "question_id": "3297",
        "code_list": [
            "class Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        length = len(word)\n        time = 1\n        while True:\n            # Remove the first k characters\n            word = word[k:]\n            # Check if the remaining word matches the original word starting from some point\n            if word == word[:length - (time * k)]:\n                break\n            time += 1\n        return time"
        ]
    },
    {
        "question_id": "3298",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSelectedElements(self, nums: List[int]) -> int:\n        nums.sort()\n        dp = {}\n        \n        def dfs(index, prev):\n            if index == len(nums):\n                return 0\n            if (index, prev) in dp:\n                return dp[(index, prev)]\n            \n            # Option 1: Skip current element\n            skip = dfs(index + 1, prev)\n            \n            # Option 2: Include current element\n            include = 0\n            if prev is None or prev + 1 == nums[index]:\n                include = 1 + dfs(index + 1, nums[index])\n            elif prev + 2 == nums[index]:\n                include = 1 + dfs(index + 1, nums[index] - 1)\n            \n            dp[(index, prev)] = max(skip, include)\n            return dp[(index, prev)]\n        \n        return dfs(0, None)"
        ]
    },
    {
        "question_id": "3299",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        num_counts = Counter(nums)\n        max_length = 1\n        \n        for num in num_counts:\n            if num == 1:\n                # Special case for 1, as 1^k will always be 1\n                length = 2 * num_counts[1] - (num_counts[1] % 2)\n                max_length = max(max_length, length)\n                continue\n            \n            current_length = 0\n            while num_counts[num] > 1 and num_counts[num**2]:\n                num_counts[num] -= 2\n                num = num**2\n                current_length += 2\n            if num_counts[num] >= 1:\n                current_length += 1\n            max_length = max(max_length, current_length)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3308",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def lastNonEmptyString(self, s: str) -> str:\n        char_indices = {char: [] for char in set(s)}\n        for index, char in enumerate(s):\n            char_indices[char].append(index)\n        \n        max_count = max(len(indices) for indices in char_indices.values())\n        result = []\n        for i in range(len(s) - 1, -1, -1):\n            if len(char_indices[s[i]]) == max_count:\n                result.append(s[i])\n                char_indices[s[i]].pop()\n        \n        return ''.join(result[::-1])"
        ]
    },
    {
        "question_id": "3309",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        def isPrefixAndSuffix(str1: str, str2: str) -> bool:\n            return str2.startswith(str1) and str2.endswith(str1)\n        \n        count = 0\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if isPrefixAndSuffix(words[i], words[j]):\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3311",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        position = 0\n        boundary_count = 0\n        \n        for num in nums:\n            position += num\n            if position == 0:\n                boundary_count += 1\n        \n        return boundary_count"
        ]
    },
    {
        "question_id": "3312",
        "code_list": [
            "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        count = 0\n        prev_char = s[0].lower()\n        for char in s[1:]:\n            current_char = char.lower()\n            if current_char != prev_char:\n                count += 1\n                prev_char = current_char\n        return count"
        ]
    },
    {
        "question_id": "3317",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:\n        # Count the frequency of each character in all words combined\n        char_count = Counter(''.join(words))\n        \n        # Calculate the total number of pairs of characters\n        total_pairs = sum(count // 2 for count in char_count.values())\n        \n        # Sort the lengths of the words to prioritize shorter words which require fewer pairs\n        word_lengths = sorted(len(word) for word in words)\n        \n        # Initialize the result counter\n        result = 0\n        \n        # Try to form as many palindromes as possible\n        for length in word_lengths:\n            # A palindrome of length `length` requires `(length + 1) // 2` pairs of characters\n            required_pairs = (length + 1) // 2\n            if total_pairs >= required_pairs:\n                total_pairs -= required_pairs\n                result += 1\n            else:\n                break\n        \n        return result"
        ]
    },
    {
        "question_id": "3320",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        \n        target_score = nums[0] + nums[1]\n        count = 0\n        \n        i = 0\n        while i < len(nums) - 1:\n            if nums[i] + nums[i + 1] == target_score:\n                count += 1\n                i += 2\n            else:\n                break\n        \n        return count"
        ]
    },
    {
        "question_id": "3324",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        from collections import Counter\n        \n        # Count the occurrences of each element in the array\n        count = Counter(nums)\n        \n        # Check if any element appears more than twice\n        for val in count.values():\n            if val > 2:\n                return False\n        \n        # If no element appears more than twice, it's possible to split the array\n        return True"
        ]
    },
    {
        "question_id": "3329",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        def get_prefixes(num):\n            prefixes = set()\n            for i in range(len(str(num))):\n                prefixes.add(int(str(num)[:i+1]))\n            return prefixes\n        \n        max_length = 0\n        prefixes_arr1 = {num: get_prefixes(num) for num in arr1}\n        prefixes_arr2 = {num: get_prefixes(num) for num in arr2}\n        \n        for num1 in prefixes_arr1:\n            for num2 in prefixes_arr2:\n                common_prefixes = prefixes_arr1[num1].intersection(prefixes_arr2[num2])\n                if common_prefixes:\n                    max_length = max(max_length, max(common_prefixes).bit_length())\n        \n        return max_length - 1 if max_length else 0"
        ]
    },
    {
        "question_id": "3331",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        count = 0\n        while min(nums) < k:\n            nums.remove(min(nums))\n            count += 1\n        return count"
        ]
    },
    {
        "question_id": "3347",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        arr1, arr2 = [nums[0]], [nums[1]]\n        for i in range(2, len(nums)):\n            if arr1[-1] > arr2[-1]:\n                arr1.append(nums[i])\n            else:\n                arr2.append(nums[i])\n        return arr1 + arr2"
        ]
    },
    {
        "question_id": "abc301_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n\n    taka_wins = S.count('T')\n    aoki_wins = S.count('A')\n\n    if taka_wins > aoki_wins:\n        print('T')\n    elif aoki_wins > taka_wins:\n        print('A')\n    else:\n        # Check who reached the number of wins first\n        for i in range(N):\n            if S[:i+1].count('T') > S[:i+1].count('A'):\n                print('T')\n                return\n            elif S[:i+1].count('A') > S[:i+1].count('T'):\n                print('A')\n                return\n\n# Call the main function\nmain()"
        ]
    },
    {
        "question_id": "abc301_b",
        "code_list": [
            "def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    while True:\n        changed = False\n        for i in range(N - 1):\n            if abs(A[i] - A[i + 1]) != 1:\n                if A[i] < A[i + 1]:\n                    A = A[:i + 1] + list(range(A[i] + 1, A[i + 1])) + A[i + 1:]\n                    N += A[i + 1] - A[i] - 1\n                else:\n                    A = A[:i + 1] + list(range(A[i], A[i + 1], -1)) + A[i + 1:]\n                    N += A[i] - A[i + 1] - 1\n                changed = True\n                break\n        if not changed:\n            break\n    \n    print(' '.join(map(str, A)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_c",
        "code_list": [
            "def can_win_game(S, T):\n    # Count the frequency of each character in S and T\n    freq_S = [0] * 26\n    freq_T = [0] * 26\n    \n    for char in S:\n        if char != '@':\n            freq_S[ord(char) - ord('a')] += 1\n    \n    for char in T:\n        if char != '@':\n            freq_T[ord(char) - ord('a')] += 1\n    \n    # Check if we can replace @ in S and T to make them equal\n    for i in range(26):\n        if abs(freq_S[i] - freq_T[i]) > S.count('@') + T.count('@'):\n            return \"No\"\n    \n    # Check if we can rearrange the cards within a row\n    for i in range(len(S)):\n        if S[i] != T[i]:\n            if S[i] == '@' and T[i] != '@':\n                S[i] = T[i]\n            elif T[i] == '@' and S[i] != '@':\n                T[i] = S[i]\n            else:\n                return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    T = input().strip()\n    print(can_win_game(S, T))"
        ]
    },
    {
        "question_id": "abc301_d",
        "code_list": [
            "def main():\n    import re\n    \n    def max_value_in_T(S, N):\n        max_val = -1\n        for i in range(2 ** S.count('?')):\n            binary_str = bin(i)[2:].zfill(S.count('?'))\n            num_str = S.replace('?', lambda m: str(binary_str[int(m.start() / len(S) * S.count('?'))]))\n            num = int(num_str, 2)\n            if num <= N:\n                max_val = max(max_val, num)\n        return max_val\n    \n    S = input().strip()\n    N = int(input())\n    \n    print(max_value_in_T(S, N))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_e",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start, goal, candies):\n    H, W = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[False] * W for _ in range(H)]\n    queue = deque([(start[0], start[1], 0, set())])\n    max_candies = -1\n    \n    while queue:\n        x, y, moves, visited_candies = queue.popleft()\n        \n        if (x, y) == goal:\n            max_candies = max(max_candies, len(visited_candies))\n            continue\n        \n        if moves > 0 and moves > max_candies + (len(candies) - len(visited_candies)):\n            continue\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] != '#' and not visited[nx][ny]:\n                new_visited_candies = visited_candies.copy()\n                if grid[nx][ny] == 'o':\n                    new_visited_candies.add((nx, ny))\n                \n                visited[nx][ny] = True\n                queue.append((nx, ny, moves + 1, new_visited_candies))\n    \n    return max_candies\n\ndef main():\n    H, W, T = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    start = None\n    goal = None\n    candies = []\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n            elif grid[i][j] == 'o':\n                candies.append((i, j))\n    \n    result = bfs(grid, start, goal, candies)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_f",
        "code_list": [
            "def main():\n    from collections import Counter\n    \n    def is_ddos_type(s):\n        return s[0] == s[1] and s[2].islower() and s[3].isupper()\n    \n    def count_valid_strings(s):\n        n = len(s)\n        dp = [1] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            if s[i] != '?':\n                dp[i] = dp[i + 1]\n            else:\n                dp[i] = sum(dp[i + 1:]) % 998244353\n            if i < n - 3 and s[i:i+4] == '???' and not is_ddos_type(s[i+1:i+4]):\n                dp[i] -= dp[i + 4]\n                dp[i] %= 998244353\n        return dp[0]\n    \n    s = input().strip()\n    print(count_valid_strings(s))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    print((-A + B - 1) // B)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_b",
        "code_list": [
            "def find_snukes():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n\n    def check(r, c):\n        if r < 0 or r >= H or c < 0 or c >= W:\n            return False\n        return True\n\n    directions = [\n        (0, 1), (1, 1), (1, 0), (1, -1),\n        (0, -1), (-1, -1), (-1, 0), (-1, 1)\n    ]\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 's':\n                for dr, dc in directions:\n                    r, c = i + dr, j + dc\n                    if not check(r, c) or grid[r][c] != 'n':\n                        continue\n                    for ddr, ddc in directions:\n                        rr, cc = r + ddr, c + ddc\n                        if not check(rr, cc) or grid[rr][cc] != 'u':\n                            continue\n                        for dddr, dddc in directions:\n                            rrr, ccc = rr + dddr, cc + dddc\n                            if not check(rrr, ccc) or grid[rrr][ccc] != 'k':\n                                continue\n                            for dddddr, ddddddcc in directions:\n                                rrrr, ccccc = rrr + dddddr, ccc + ddddddcc\n                                if not check(rrrr, ccccc) or grid[rrrr][ccccc] != 'e':\n                                    continue\n                                # Found the sequence\n                                print(i + 1, j + 1)\n                                print(r + 1, c + 1)\n                                print(rr + 1, cc + 1)\n                                print(rrr + 1, ccc + 1)\n                                print(rrrr + 1, ccccc + 1)\n                                return\n\nif __name__ == \"__main__\":\n    find_snukes()"
        ]
    },
    {
        "question_id": "abc302_c",
        "code_list": [
            "from collections import Counter\n\ndef can_rearrange_strings(N, M, strings):\n    # Count the frequency of each character in each position\n    char_counts = [Counter(s[i] for s in strings) for i in range(M)]\n    \n    # Check if we can form a valid sequence\n    for i in range(1, N):\n        prev_count = char_counts[0][strings[i-1][0]]\n        for j in range(1, M):\n            current_count = char_counts[j][strings[i][j]]\n            if current_count != prev_count + 1:\n                return False\n            prev_count = current_count\n    \n    return True\n\ndef main():\n    N, M = map(int, input().split())\n    strings = [input().strip() for _ in range(N)]\n    \n    if can_rearrange_strings(N, M, strings):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, m, d = data[0], data[1], data[2]\n    start = 3\n    a = data[start:start + n]\n    start += n\n    b = data[start:start + m]\n\n    # Sort the lists to enable efficient searching\n    a.sort()\n    b.sort()\n\n    max_sum = -1\n    j = m - 1\n    for i in range(n):\n        while j >= 0 and a[i] + b[j] > a[i] + b[j] - d:\n            j -= 1\n        if j < 0:\n            break\n        max_sum = max(max_sum, a[i] + b[j + 1])\n\n    print(max_sum)"
        ]
    },
    {
        "question_id": "abc302_e",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    \n    # Initialize sets for connected components\n    connected_components = [set([i]) for i in range(1, N + 1)]\n    component_sizes = [1] * N\n    \n    # Function to find the root component of a vertex\n    def find_root(vertex):\n        return min((component for component in connected_components if vertex in component), key=len)\n    \n    # Function to union two components\n    def union_components(component1, component2):\n        if len(component1) < len(component2):\n            component1, component2 = component2, component1\n        for vertex in component2:\n            connected_components[vertex - 1].update(connected_components[component1 - 1])\n            component_sizes[component1 - 1] += component_sizes[component2 - 1]\n            component_sizes[component2 - 1] = 0\n            connected_components[component2 - 1] = set()\n        connected_components[component1 - 1] -= component2\n    \n    # Process queries\n    for _ in range(Q):\n        query_type, *args = map(int, input().split())\n        if query_type == 1:\n            u, v = args\n            root_u = find_root(u)\n            root_v = find_root(v)\n            if root_u != root_v:\n                union_components(root_u, root_v)\n        elif query_type == 2:\n            v = args[0]\n            root_v = find_root(v)\n            for vertex in connected_components[root_v - 1]:\n                component_sizes[root_v - 1] -= 1\n                connected_components[vertex - 1].remove(root_v)\n            connected_components[root_v - 1] = set()\n        \n        # Print the number of isolated vertices\n        print(sum(size == 1 for size in component_sizes))"
        ]
    },
    {
        "question_id": "abc302_f",
        "code_list": [
            "from collections import defaultdict\n\ndef find_set(x, parent):\n    if parent[x] != x:\n        parent[x] = find_set(parent[x], parent)\n    return parent[x]\n\ndef union_sets(a, b, parent):\n    a = find_set(a, parent)\n    b = find_set(b, parent)\n    if a < b:\n        parent[b] = a\n    else:\n        parent[a] = b\n\ndef min_operations_to_get_set(N, M, sets):\n    parent = list(range(M + 1))\n    has_1 = False\n    has_M = False\n    \n    for i in range(N):\n        current_set = sets[i]\n        for num in current_set:\n            if num == 1:\n                has_1 = True\n            if num == M:\n                has_M = True\n            for other_num in current_set:\n                if num != other_num:\n                    union_sets(num, other_num, parent)\n    \n    if not has_1 or not has_M:\n        return -1\n    \n    root_1 = find_set(1, parent)\n    root_M = find_set(M, parent)\n    \n    if root_1 == root_M:\n        return 0\n    else:\n        return 1\n\ndef main():\n    N, M = map(int, input().split())\n    sets = []\n    for _ in range(N):\n        A = int(input())\n        sets.append(set(map(int, input().split())))\n    \n    result = min_operations_to_get_set(N, M, sets)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc303_a",
        "code_list": [
            "def are_similar_strings(N, S, T):\n    for i in range(N):\n        if S[i] != T[i] and (S[i] not in 'lo' or T[i] not in 'lo10'):\n            return False\n    return True\n\ndef main():\n    N = int(input())\n    S = input().strip()\n    T = input().strip()\n    if are_similar_strings(N, S, T):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc303_b",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    N, M = map(int, input().split())\n    photos = [list(map(int, input().split())) for _ in range(M)]\n    \n    # Find all pairs that are not adjacent in any photo\n    bad_mood_pairs = set()\n    for photo in photos:\n        for i in range(N - 1):\n            if abs(photo[i] - photo[i + 1]) > 1:\n                bad_mood_pairs.add(tuple(sorted((photo[i], photo[i + 1]))))\n    \n    # Count unique bad mood pairs\n    result = len(bad_mood_pairs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc303_c",
        "code_list": [
            "def can_complete_moves(N, M, H, K, S, items):\n    health = H\n    position = [0, 0]\n    \n    for move in range(N):\n        # Move according to the direction\n        if S[move] == 'R':\n            position[0] += 1\n        elif S[move] == 'L':\n            position[0] -= 1\n        elif S[move] == 'U':\n            position[1] += 1\n        elif S[move] == 'D':\n            position[1] -= 1\n        \n        # Check if health becomes negative\n        if health <= 0:\n            return \"No\"\n        \n        # Check if an item is at the new position and health is less than K\n        for item in items:\n            if position == item[:2]:\n                if health < K:\n                    health = K\n                break\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N, M, H, K = map(int, input().split())\n    S = input()\n    items = []\n    for _ in range(M):\n        x, y = map(int, input().split())\n        items.append([x, y])\n    \n    result = can_complete_moves(N, M, H, K, S, items)\n    print(result)"
        ]
    },
    {
        "question_id": "abc303_d",
        "code_list": [
            "def min_time_to_type(X, Y, Z, S):\n    ans = 0\n    caps_on = False\n    for char in S:\n        if char.isupper():\n            if caps_on:\n                ans += Z + X\n            else:\n                ans += Z + Y\n                caps_on = True\n        else:\n            if caps_on:\n                ans += Z + Y\n                caps_on = False\n            else:\n                ans += Z + X\n        caps_on = not caps_on\n    return ans\n\nif __name__ == \"__main__\":\n    X, Y, Z = map(int, input().split())\n    S = input().strip()\n    print(min_time_to_type(X, Y, Z, S))"
        ]
    },
    {
        "question_id": "abc303_e",
        "code_list": [
            "def find_initial_stars(N, edges):\n    # Build the graph\n    graph = {i: [] for i in range(1, N + 1)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Find leaves and their parent\n    leaves = [node for node in graph if len(graph[node]) == 1]\n    parents = {}\n    while leaves:\n        new_leaves = []\n        for leaf in leaves:\n            parent = graph[leaf][0]\n            del graph[leaf]\n            if len(graph[parent]) > 1:\n                parents[leaf] = parent\n                new_leaves.append(parent)\n        leaves = new_leaves\n\n    # Determine the levels of the stars\n    levels = set()\n    for leaf, parent in parents.items():\n        path = [leaf]\n        current = parent\n        while current != leaf:\n            path.append(current)\n            current = parents[current]\n        levels.add(len(path) - 1)\n\n    # Sort the levels and return them\n    return sorted(levels)\n\ndef main():\n    N = int(input().strip())\n    edges = []\n    for _ in range(N - 1):\n        u, v = map(int, input().strip().split())\n        edges.append((u, v))\n    \n    result = find_initial_stars(N, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_a",
        "code_list": [
            "def main():\n    N = int(input())\n    people = []\n    \n    for _ in range(N):\n        name, age = input().split()\n        age = int(age)\n        people.append((name, age))\n    \n    # Find the index of the youngest person\n    youngest_index = min(range(N), key=lambda i: people[i][1])\n    \n    # Reorder the list starting from the youngest person\n    reordered_people = people[youngest_index:] + people[:youngest_index]\n    \n    # Print the names in the new order\n    for person in reordered_people:\n        print(person[0])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_b",
        "code_list": [
            "def main():\n    N = int(input())\n    if N <= 10**3 - 1:\n        print(N)\n    elif N <= 10**4 - 1:\n        print(N // 10)\n    elif N <= 10**5 - 1:\n        print(N // 100)\n    elif N <= 10**6 - 1:\n        print(N // 1000)\n    elif N <= 10**7 - 1:\n        print(N // 10000)\n    elif N <= 10**8 - 1:\n        print(N // 100000)\n    else:\n        print(N // 1000000)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_c",
        "code_list": [
            "import math\n\ndef euclidean_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef main():\n    N, D = map(int, input().split())\n    positions = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    infected = [False] * N\n    infected[0] = True\n    \n    for i in range(1, N):\n        for j in range(i):\n            if euclidean_distance(positions[i], positions[j]) <= D:\n                infected[i] = True\n                break\n    \n    for i in range(N):\n        print(\"Yes\" if infected[i] else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_d",
        "code_list": [
            "def main():\n    W, H = map(int, input().split())\n    N = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n    A = int(input())\n    vertical_lines = sorted(set(map(int, input().split())))\n    B = int(input())\n    horizontal_lines = sorted(set(map(int, input().split())))\n\n    # Add boundary lines to simplify calculations\n    vertical_lines = [0] + vertical_lines + [W]\n    horizontal_lines = [0] + horizontal_lines + [H]\n\n    # Calculate the minimum and maximum number of strawberries\n    min_strawberries = float('inf')\n    max_strawberries = 0\n\n    # Iterate over all possible sub-rectangles\n    for i in range(len(vertical_lines) - 1):\n        for j in range(len(horizontal_lines) - 1):\n            # Count strawberries in the current sub-rectangle\n            count = sum((vertical_lines[i] < p[0] < vertical_lines[i + 1]) and (horizontal_lines[j] < p[1] < horizontal_lines[j + 1]) for p in points)\n            min_strawberries = min(min_strawberries, count)\n            max_strawberries = max(max_strawberries, count)\n\n    print(min_strawberries, max_strawberries)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_e",
        "code_list": [
            "from collections import defaultdict\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    rootX = find(x)\n    rootY = find(y)\n    if rootX != rootY:\n        parent[rootX] = rootY\n\ndef is_good():\n    for x, y in bad_edges:\n        if find(x) == find(y):\n            return False\n    return True\n\ndef add_edge(p, q):\n    union(p, q)\n    if not is_good():\n        return \"No\"\n    return \"Yes\"\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    K = int(input())\n    bad_edges = [tuple(map(int, input().split())) for _ in range(K)]\n    Q = int(input())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    # Initialize parent array for union-find\n    parent = list(range(N + 1))\n\n    # Add existing edges to the union-find structure\n    for u, v in edges:\n        union(u, v)\n\n    # Process each query\n    for p, q in queries:\n        print(add_edge(p, q))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_a",
        "code_list": [
            "def main():\n    N = int(input())\n    # Calculate the nearest water station\n    if N % 5 <= 2:\n        nearest_water_station = N - N % 5\n    else:\n        nearest_water_station = N + (5 - N % 5)\n    print(nearest_water_station)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_b",
        "code_list": [
            "def main():\n    # Define the distances between adjacent points\n    distances = {\n        ('A', 'B'): 3,\n        ('B', 'C'): 1,\n        ('C', 'D'): 4,\n        ('D', 'E'): 1,\n        ('E', 'F'): 5,\n        ('F', 'G'): 9\n    }\n    \n    # Function to calculate the distance between two points\n    def calculate_distance(p, q):\n        if p > q:\n            p, q = q, p\n        \n        # Calculate the total distance\n        total_distance = sum(distances[(p, q)] for p, q in zip([p] * len(distances), list(distances.keys())[0]))\n        \n        return total_distance\n    \n    # Read input\n    p, q = input().strip().split()\n    \n    # Calculate and print the distance\n    print(calculate_distance(p, q))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_c",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    for i in range(1, H - 1):\n        for j in range(1, W - 1):\n            if grid[i][j] == '.':\n                continue\n            if grid[i-1][j] == '#' and grid[i+1][j] == '#' and grid[i][j-1] == '#' and grid[i][j+1] == '#':\n                print(i + 1, j + 1)\n                return\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    a = data[1:2 * n + 1]\n    q = data[2 * n + 1]\n    queries = [(data[i], data[i + 1]) for i in range(2 * n + 2, 2 * n + 2 + q)]\n\n    result = []\n    for l, r in queries:\n        count = 0\n        for i in range(1, len(a), 2):\n            if a[i] >= l and a[i + 1] <= r:\n                count += a[i + 1] - a[i]\n            elif a[i] < l and a[i + 1] > r:\n                continue\n            elif a[i] < l and a[i + 1] < r:\n                count += min(r, a[i + 1]) - max(l, a[i])\n            elif a[i] > l and a[i + 1] > r:\n                continue\n        result.append(count)\n\n    for ans in result:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_e",
        "code_list": [
            "from collections import deque\n\ndef bfs(graph, start, h):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    return [i for i in range(1, n + 1) if visited[i] and i != start and dist[i] <= h]\n\ndef main():\n    n, m, k = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    guards = []\n    for _ in range(k):\n        p, h = map(int, input().split())\n        guards.append((p, h))\n        dist = [float('inf')] * (n + 1)\n        queue = deque([p])\n        dist[p] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if dist[neighbor] == float('inf'):\n                    dist[neighbor] = dist[current] + 1\n                    queue.append(neighbor)\n    \n    guarded_vertices = set()\n    for p, h in guards:\n        guarded_vertices.update(bfs(graph, p, h))\n    \n    print(len(guarded_vertices))\n    print(*sorted(guarded_vertices))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc306_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    result = ''.join([char * 2 for char in S])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc306_b",
        "code_list": [
            "def main():\n    # Read the input sequence\n    sequence = list(map(int, input().split()))\n    \n    # Calculate the result using bitwise operations for efficiency\n    result = sum(a << i for i, a in enumerate(sequence))\n    \n    # Print the result\n    print(result)"
        ]
    },
    {
        "question_id": "abc306_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    numbers = data[1:]\n    \n    # Create a list to store the middle indices for each number\n    middle_indices = []\n    \n    # Iterate through each number from 1 to N\n    for i in range(1, n + 1):\n        # Find the indices of all occurrences of i\n        indices = [j for j, x in enumerate(numbers) if x == str(i)]\n        \n        # The middle index is the second occurrence\n        middle_index = indices[1]\n        middle_indices.append((i, middle_index))\n    \n    # Sort the list based on the middle indices\n    sorted_indices = sorted(middle_indices, key=lambda x: x[1])\n    \n    # Extract the sorted numbers\n    result = [x[0] for x in sorted_indices]\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc306_d",
        "code_list": [
            "def max_tastiness(N, courses):\n    # Initialize variables to keep track of states\n    healthy_max = 0  # Maximum tastiness when healthy\n    upset_max = float('-inf')  # Maximum tastiness when upset (including death)\n    healthy = 0  # Current maximum tastiness when healthy\n    upset = float('-inf')  # Current maximum tastiness when upset\n    \n    for X, Y in courses:\n        # If healthy, we can only eat antidotal courses or skip poisonous ones\n        if X == 0:\n            healthy = max(healthy + Y, healthy_max + Y)\n            upset = max(upset, healthy_max + Y)\n        else:\n            # If upset, we can only eat antidotal courses or skip poisonous ones\n            healthy = max(healthy, upset_max + Y)\n            upset = max(upset, healthy_max + Y)\n        \n        # Update the maximum tastiness when healthy and upset\n        healthy_max = max(healthy_max, healthy)\n        upset_max = max(upset_max, upset)\n    \n    # Return the maximum tastiness when healthy at the end\n    return max(healthy_max, upset_max)\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    courses = []\n    for _ in range(N):\n        X, Y = map(int, input().strip().split())\n        courses.append((X, Y))\n    print(max_tastiness(N, courses))"
        ]
    },
    {
        "question_id": "abc306_e",
        "code_list": [
            "import heapq\n\ndef main():\n    N, K, Q = map(int, input().split())\n    A = [0] * N\n    max_heap = []\n    \n    # Initialize the heap with negative values to simulate a max heap\n    for i in range(N):\n        heapq.heappush(max_heap, (-A[i], i))\n    \n    for _ in range(Q):\n        X, Y = map(int, input().split())\n        X -= 1\n        \n        # Remove the old value from the heap\n        old_value, index = heapq.heappop(max_heap)\n        if A[index] == Y:\n            continue\n        A[index] = Y\n        heapq.heappush(max_heap, (-Y, index))\n        \n        # Calculate the sum of the top K elements\n        current_sum = 0\n        for _ in range(K):\n            if max_heap:\n                current_sum += -heapq.heappop(max_heap)[0]\n            else:\n                break\n        print(current_sum)\n        \n        # Rebuild the heap with the updated values\n        for value, index in max_heap:\n            A[index] = -value\n        max_heap.clear()\n        for i in range(N):\n            heapq.heappush(max_heap, (-A[i], i))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc307_a",
        "code_list": [
            "def main():\n    N = int(input())\n    steps = list(map(int, input().split()))\n    \n    weekly_steps = []\n    for i in range(N):\n        start_index = i * 7\n        end_index = start_index + 7\n        weekly_sum = sum(steps[start_index:end_index])\n        weekly_steps.append(weekly_sum)\n    \n    print(*weekly_steps)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc307_b",
        "code_list": [
            "def is_palindrome(s):\n    return s == s[::-1]\n\ndef main():\n    N = int(input())\n    strings = [input().strip() for _ in range(N)]\n    \n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                concatenated = strings[i] + strings[j]\n                if is_palindrome(concatenated):\n                    print(\"Yes\")\n                    return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc307_c",
        "code_list": [
            "def find_paste_and_cut(A, B, X):\n    H_A, W_A = len(A), len(A[0])\n    H_B, W_B = len(B), len(B[0])\n    H_X, W_X = len(X), len(X[0])\n\n    # Helper function to check if X can be formed by cutting out a subgrid from a given grid\n    def can_form_X(grid, H_X, W_X):\n        for i in range(len(grid) - H_X + 1):\n            for j in range(len(grid[0]) - W_X + 1):\n                if all(grid[i + x][j + y] == '#' for x in range(H_X) for y in range(W_X)):\n                    return True\n        return False\n\n    # Helper function to check if all black squares of A and B are included in any possible cutout\n    def all_black_squares_included(A, B):\n        black_squares = set()\n        for i in range(H_A):\n            for j in range(W_A):\n                if A[i][j] == '#':\n                    black_squares.add((i, j))\n        for i in range(H_B):\n            for j in range(W_B):\n                if B[i][j] == '#':\n                    black_squares.add((i, j))\n        return black_squares\n\n    # Check if all black squares of A and B are included in any possible cutout\n    black_squares = all_black_squares_included(A, B)\n\n    # Try all possible positions to paste A and B on an empty grid\n    for i in range(11):\n        for j in range(11):\n            for k in range(11):\n                for l in range(11):\n                    grid = [['.' for _ in range(W_A + W_B)] for _ in range(H_A + H_B)]\n                    for x in range(H_A):\n                        for y in range(W_A):\n                            grid[x + i][y + j] = A[x][y]\n                    for x in range(H_B):\n                        for y in range(W_B):\n                            grid[x + i][y + k] = B[x][y]\n                    if can_form_X(grid, H_X, W_X):\n                        return \"Yes\"\n    return \"No\"\n\nif __name__ == \"__main__\":\n    H_A, W_A = map(int, input().split())\n    A = [input() for _ in range(H_A)]\n    H_B, W_B = map(int, input().split())\n    B = [input() for _ in range(H_B)]\n    H_X, W_X = map(int, input().split())\n    X = [input() for _ in range(H_X)]\n    print(find_paste_and_cut(A, B, X))"
        ]
    },
    {
        "question_id": "abc307_d",
        "code_list": [
            "def remove_substrings(s):\n    stack = []\n    result = list(s)\n    \n    for i, char in enumerate(result):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start_index = stack.pop()\n                # Remove the substring between the matching parentheses\n                del result[start_index+1:i]\n    \n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input()\n    print(remove_substrings(S))"
        ]
    },
    {
        "question_id": "abc307_e",
        "code_list": [
            "def power_mod(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef count_ways(N, M):\n    mod = 998244353\n    if N == 1:\n        return M\n    if N == 2:\n        return M * (M - 1)\n    \n    # Calculate the result using the formula derived from dynamic programming approach\n    # F(N, M) = (M - 1) * [F(N-1, M) + F(N-2, M)]\n    # F(1, M) = M\n    # F(2, M) = M * (M - 1)\n    first = M\n    second = M * (M - 1)\n    for _ in range(3, N + 1):\n        current = ((M - 1) * (first + second)) % mod\n        first = second\n        second = current\n    \n    return second\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    print(count_ways(N, M))"
        ]
    },
    {
        "question_id": "abc308_a",
        "code_list": [
            "def main():\n    S = list(map(int, input().split()))\n    \n    # Check if all elements are between 100 and 675, inclusive, and are multiples of 25\n    if all(100 <= s <= 675 and s % 25 == 0 for s in S):\n        # Check if the sequence is monotonically non-decreasing\n        if all(S[i] <= S[i + 1] for i in range(len(S) - 1)):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_b",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    colors = [input() for _ in range(N)]\n    prices = {}\n    P0, *Ps = map(int, input().split())\n    \n    for i in range(M):\n        prices[input()] = Ps[i]\n    \n    total_price = sum(prices.get(color, P0) for color in colors)\n    print(total_price)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    people = []\n    \n    for i in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        index += 2\n        success_rate = A / (A + B)\n        people.append((success_rate, -i, i + 1))\n    \n    people.sort(reverse=True)\n    \n    for _, _, person_id in people:\n        print(person_id, end=' ')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_d",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    # Define possible moves: right, down, left, up\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def dfs(x, y, path):\n        if x == H - 1 and y == W - 1:\n            return True\n        \n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == path[(len(path) % 5) + 1]:\n                if dfs(nx, ny, path + grid[nx][ny]):\n                    return True\n        return False\n    \n    if grid[0][0] == 's' and dfs(0, 0, 's'):\n        print('Yes')\n    else:\n        print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    S = input()\n\n    def mex(arr):\n        seen = set(arr)\n        i = 0\n        while i in seen:\n            i += 1\n        return i\n\n    result = 0\n    count = defaultdict(lambda: [0, 0, 0])\n    for i in range(N):\n        if S[i] == 'M':\n            for j in range(i + 1, N):\n                if S[j] == 'E':\n                    for k in range(j + 1, N):\n                        if S[k] == 'X':\n                            result += mex([A[i], A[j], A[k]])\n        else:\n            for j in range(i + 1, N):\n                if S[j] != S[i]:\n                    for k in range(j + 1, N):\n                        if S[k] != S[i]:\n                            count[(S[i], S[j], S[k])][A[i]] += 1\n    for key in count:\n        for num in range(3):\n            if count[key][num] == 0:\n                result += 1\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_f",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, m = data[0], data[1]\n    prices = data[2:2 + n]\n    discounts = []\n    for i in range(m):\n        l, d = data[2 + n + i * 2], data[2 + n + i * 2 + 1]\n        discounts.append((l, d))\n\n    # Sort discounts based on L_i in descending order\n    discounts.sort(reverse=True)\n\n    total_cost = 0\n    used_coupons = [False] * m\n\n    for i in range(n):\n        price = prices[i]\n        # Try to find a suitable coupon for this item\n        for j in range(m):\n            if not used_coupons[j] and discounts[j][0] <= price:\n                total_cost += price - discounts[j][1]\n                used_coupons[j] = True\n                break\n        if not used_coupons[j]:\n            total_cost += price\n\n    print(total_cost)"
        ]
    },
    {
        "question_id": "abc309_a",
        "code_list": [
            "def main():\n    # Read input values for A and B\n    A, B = map(int, input().split())\n    \n    # Define the positions of numbers 1 through 9 on a 3x3 board\n    positions = {\n        1: (0, 0), 2: (0, 1), 3: (0, 2),\n        4: (1, 0), 5: (1, 1), 6: (1, 2),\n        7: (2, 0), 8: (2, 1), 9: (2, 2)\n    }\n    \n    # Get the positions of A and B\n    pos_A = positions[A]\n    pos_B = positions[B]\n    \n    # Check if A and B are adjacent horizontally\n    if pos_A[1] == pos_B[1] and abs(pos_A[0] - pos_B[0]) == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_b",
        "code_list": [
            "def shift_outer_squares(N, grid):\n    # Extract the outer squares into a list\n    outer_squares = []\n    for i in range(N):\n        outer_squares.append(grid[i][0])\n        outer_squares.append(grid[N-1][i])\n        outer_squares.append(grid[N-1-i][N-1])\n        outer_squares.append(grid[0][N-1-i])\n    \n    # Remove duplicates and reverse the list to get the correct order\n    outer_squares = list(dict.fromkeys(outer_squares))\n    outer_squares.reverse()\n\n    # Shift the outer squares clockwise by one\n    shifted_squares = [outer_squares[-1]] + outer_squares[:-1]\n\n    # Place the shifted outer squares back into the grid\n    k = 0\n    for i in range(N):\n        if i == 0:\n            for j in range(N):\n                if j != 0:\n                    grid[i][j] = shifted_squares[k]\n                    k += 1\n        elif i == N-1:\n            for j in range(N-1, -1, -1):\n                if j != N-1:\n                    grid[i][j] = shifted_squares[k]\n                    k += 1\n        elif i < N-1 and i > 0:\n            grid[i][0] = shifted_squares[k]\n            grid[i][N-1] = shifted_squares[k+N-1]\n            k += 1\n\n    return grid\n\ndef main():\n    N = int(input())\n    grid = [list(map(int, input())) for _ in range(N)]\n    result = shift_outer_squares(N, grid)\n    for row in result:\n        print(''.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_c",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    medicines = []\n    for _ in range(N):\n        a, b = map(int, input().split())\n        medicines.append((a, b))\n    \n    current_pills = 0\n    days = 0\n    while True:\n        days += 1\n        for a, b in medicines:\n            if days <= a:\n                current_pills += b\n            else:\n                break\n        if current_pills <= K:\n            print(days)\n            return\n        current_pills -= b\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_d",
        "code_list": [
            "import sys\nfrom collections import deque\n\ndef bfs(graph, start, end):\n    queue = deque([(start, 1)])\n    visited = {start}\n    \n    while queue:\n        current, distance = queue.popleft()\n        if current == end:\n            return distance\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, distance + 1))\n    return float('inf')\n\ndef find_max_path_length(N1, N2, M, edges):\n    # Build the graph\n    graph = [[] for _ in range(N1 + N2 + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Find the shortest path from 1 to N1+N2 without adding any edge\n    shortest_path = bfs(graph, 1, N1 + N2)\n    \n    # Check potential new edges to maximize the path length\n    max_path_length = shortest_path\n    for a, b in edges:\n        if a <= N1 and b > N1:\n            # Remove the edge temporarily\n            graph[a].remove(b)\n            graph[b].remove(a)\n            \n            # Recalculate the shortest path after adding the edge\n            new_path_length = bfs(graph, 1, N1 + N2)\n            \n            # Restore the edge\n            graph[a].append(b)\n            graph[b].append(a)\n            \n            max_path_length = max(max_path_length, new_path_length)\n    \n    return max_path_length\n\ndef main():\n    N1, N2, M = map(int, input().split())\n    edges = [tuple(map(int, line.split())) for line in sys.stdin.readlines()[:M]]\n    print(find_max_path_length(N1, N2, M, edges))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_e",
        "code_list": [
            "def find_parent(i, parent_map):\n    if parent_map[i] == -1:\n        return i\n    return find_parent(parent_map[i], parent_map)\n\ndef union(i, j, parent_map):\n    pi = find_parent(i, parent_map)\n    pj = find_parent(j, parent_map)\n    if pi != pj:\n        parent_map[pj] = pi\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    m = int(data[1])\n    parent_map = [-1] * (n + 1)\n    for i in range(2, n + 1):\n        parent_map[i] = int(data[i - 1])\n\n    start_indices = [2 + i * 2 for i in range(m)]\n    end_indices = [start_indices[i] + 1 for i in range(m)]\n\n    covered_people = set()\n    for i in range(m):\n        x = int(data[start_indices[i]])\n        y = int(data[end_indices[i]])\n        current_person = x\n        while current_person <= n and y > 0:\n            covered_people.add(current_person)\n            if parent_map[current_person] != -1:\n                union(current_person, parent_map[current_person], parent_map)\n            current_person += 1\n            y -= 1\n\n    print(len(covered_people))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_a",
        "code_list": [
            "def main():\n    N, P, Q = map(int, input().split())\n    dishes = list(map(int, input().split()))\n    \n    # Calculate the minimum cost without using the coupon\n    min_cost_without_coupon = P\n    \n    # Calculate the minimum cost using the coupon\n    min_cost_with_coupon = float('inf')\n    for dish in dishes:\n        if Q + dish < min_cost_with_coupon:\n            min_cost_with_coupon = Q + dish\n    \n    # Determine the overall minimum cost\n    min_total_cost = min(min_cost_without_coupon, min_cost_with_coupon)\n    \n    print(min_total_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    products = []\n    for _ in range(N):\n        P, C = map(int, input().split())\n        functions = set(map(int, input().split()))\n        products.append((P, functions))\n    \n    # Check if any product is strictly superior to another\n    for i in range(N):\n        for j in range(i + 1, N):\n            if products[i][0] >= products[j][0]:\n                if products[j][1].issuperset(products[i][1]):\n                    if products[i][0] > products[j][0] or len(products[j][1] - products[i][1]) > 0:\n                        print(\"Yes\")\n                        return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_c",
        "code_list": [
            "from collections import defaultdict\n\ndef reverse_string(s):\n    return s[::-1]\n\ndef count_unique_sticks(N, sticks):\n    unique_sticks = defaultdict(int)\n    \n    for stick in sticks:\n        # Check both the original and reversed string\n        unique_sticks[stick] += 1\n        unique_sticks[reverse_string(stick)] += 1\n    \n    # The number of unique sticks is the number of keys in the dictionary\n    return len(unique_sticks)\n\ndef main():\n    N = int(input().strip())\n    sticks = [input().strip() for _ in range(N)]\n    print(count_unique_sticks(N, sticks))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_d",
        "code_list": [
            "from itertools import combinations\n\ndef count_ways(N, T, M, incompatible_pairs):\n    # Create a graph to represent the incompatibilities\n    graph = {i: [] for i in range(1, N + 1)}\n    for a, b in incompatible_pairs:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, visited, team):\n        if node in visited:\n            return visited[node] == team\n        visited[node] = team\n        for neighbor in graph[node]:\n            if not dfs(neighbor, visited, 3 - team):  # Flip team for neighbors\n                return False\n        return True\n\n    def is_valid_partition(partition):\n        visited = {}\n        for node in partition:\n            if not dfs(node, visited, 1):\n                return False\n        return True\n\n    def count_partitions():\n        count = 0\n        for partition in combinations(range(1, N + 1), T):\n            if is_valid_partition(partition):\n                count += 1\n        return count\n\n    return count_partitions()\n\ndef main():\n    N, T, M = map(int, input().split())\n    incompatible_pairs = [tuple(map(int, input().split())) for _ in range(M)]\n    result = count_ways(N, T, M, incompatible_pairs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_e",
        "code_list": [
            "def nand(a, b):\n    return 1 if a == 1 and b == 1 else 0\n\ndef calculate_nand_sequence(N, S):\n    A = [int(c) for c in S]\n    result = 0\n    \n    # Precompute the prefix NAND values\n    prefix_nand = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_nand[i] = nand(prefix_nand[i - 1], A[i - 1])\n    \n    # Calculate the final result\n    for i in range(N):\n        current_value = A[i]\n        for j in range(i, N):\n            current_value = nand(current_value, A[j])\n            result += current_value\n    \n    return result\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    print(calculate_nand_sequence(N, S))"
        ]
    },
    {
        "question_id": "abc310_f",
        "code_list": [
            "from functools import lru_cache\nfrom math import gcd\n\ndef modular_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        # q is quotient\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    # Make x1 positive\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    \n    MOD = 998244353\n    \n    @lru_cache(None)\n    def dp(i, target):\n        if i == n:\n            return int(target == 0)\n        res = dp(i + 1, target)\n        for k in range(1, A[i] + 1):\n            if k <= target:\n                res += dp(i + 1, target - k)\n                res %= MOD\n        return res\n    \n    total_ways = dp(0, 10)\n    total_possible_outcomes = 1\n    for a in A:\n        total_possible_outcomes *= a\n        total_possible_outcomes %= MOD\n    \n    gcd_val = gcd(total_ways, total_possible_outcomes)\n    total_ways //= gcd_val\n    total_possible_outcomes //= gcd_val\n    \n    inverse = modular_inverse(total_possible_outcomes, MOD)\n    result = (total_ways * inverse) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()"
        ]
    },
    {
        "question_id": "abc311_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    \n    count = [0] * 3  # To keep track of the count of A, B, and C\n    required = 3  # We need all A, B, and C\n    \n    for i, char in enumerate(S):\n        if char == 'A':\n            count[0] += 1\n        elif char == 'B':\n            count[1] += 1\n        else:  # char == 'C'\n            count[2] += 1\n        \n        if min(count) >= 1:\n            break\n    \n    print(i + 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc311_b",
        "code_list": [
            "def find_max_consecutive_free_days(N, D, schedules):\n    max_days = 0\n    for start_day in range(D):\n        current_days = 0\n        for end_day in range(start_day, D):\n            all_free = True\n            for person_schedule in schedules:\n                if person_schedule[end_day] == 'x':\n                    all_free = False\n                    break\n            if all_free:\n                current_days += 1\n                max_days = max(max_days, current_days)\n            else:\n                current_days = 0\n    return max_days\n\nif __name__ == \"__main__\":\n    N, D = map(int, input().split())\n    schedules = [input().strip() for _ in range(N)]\n    print(find_max_consecutive_free_days(N, D, schedules))"
        ]
    },
    {
        "question_id": "abc311_c",
        "code_list": [
            "def find_cycle(N, A):\n    # Initialize the starting point for the cycle search\n    start = 0\n    \n    # Find a starting point that can lead to a cycle\n    while True:\n        if A[start] != start:\n            break\n        start += 1\n    \n    # Follow the edges to find the cycle\n    cycle = [start]\n    next_vertex = A[start]\n    \n    while True:\n        if next_vertex in cycle:\n            break\n        cycle.append(next_vertex)\n        next_vertex = A[next_vertex]\n    \n    return len(cycle), cycle\n\ndef main():\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    \n    M, cycle = find_cycle(N, A)\n    \n    print(M)\n    print(' '.join(map(str, cycle)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc311_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start):\n    n, m = len(grid), len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    count = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        if grid[x][y] == '.':\n            count += 1\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 < nx < n - 1 and 0 < ny < m - 1 and not visited[nx][ny] and grid[nx][ny] != '#':\n                visited[nx][ny] = True\n                queue.append((nx, ny))\n    \n    return count\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    \n    start = (1, 1)\n    print(bfs(grid, start))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc311_e",
        "code_list": [
            "def count_holeless_squares(H, W, N, holes):\n    # Initialize a DP table to store the maximum size of holeless squares ending at each cell\n    dp = [[0] * (W + 1) for _ in range(H + 1)]\n    \n    # Fill the DP table\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if (i, j) not in holes:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n    \n    # Calculate the total number of holeless squares\n    total_holeless_squares = sum(sum(row) for row in dp)\n    \n    return total_holeless_squares\n\ndef main():\n    H, W, N = map(int, input().split())\n    holes = set()\n    for _ in range(N):\n        a, b = map(int, input().split())\n        holes.add((a, b))\n    \n    print(count_holeless_squares(H, W, N, holes))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S == \"ACE\" or S == \"BDF\" or S == \"CEG\" or S == \"DFA\" or S == \"EGB\" or S == \"FAC\" or S == \"GBD\":\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_b",
        "code_list": [
            "def check_tak_code(grid, i, j):\n    # Check the top-left 3x3 region\n    for x in range(3):\n        for y in range(3):\n            if grid[i + x][j + y] != '#':\n                return False\n    \n    # Check the adjacent cells\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    for dx, dy in directions:\n        for x in range(i, i + 9):\n            for y in range(j, j + 9):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx < i + 3 or nx >= i + 6 or ny < j + 3 or ny >= j + 6):\n                    if grid[nx][ny] == '#':\n                        return False\n    return True\n\ndef find_tak_codes(grid):\n    tak_codes = []\n    for i in range(len(grid) - 8):\n        for j in range(len(grid[0]) - 8):\n            if check_tak_code(grid, i, j):\n                tak_codes.append((i + 1, j + 1))\n    return tak_codes\n\ndef main():\n    N, M = map(int, input().split())\n    grid = [input() for _ in range(N)]\n    tak_codes = find_tak_codes(grid)\n    for i, j in tak_codes:\n        print(i, j)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_c",
        "code_list": [
            "def main():\n    import bisect\n\n    N, M = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    B = sorted(map(int, input().split()))\n\n    # Find the minimum X that satisfies the condition\n    left, right = 1, max(A[-1], B[-1])\n    while left < right:\n        mid = (left + right) // 2\n        if sum(a >= mid for a in A) >= sum(b <= mid for b in B):\n            right = mid\n        else:\n            left = mid + 1\n\n    print(left)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    MOD = 998244353\n    S = input().strip()\n    n = len(S)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    stack = deque()\n\n    for i, c in enumerate(S):\n        if c == '(':\n            dp[i + 1] += dp[i]\n            dp[i + 1] %= MOD\n        elif c == ')':\n            if stack and S[stack[-1]] == '(':\n                dp[i + 1] += dp[stack.pop()]\n                dp[i + 1] %= MOD\n            else:\n                while stack and S[stack[-1]] != '(':\n                    dp[i + 1] -= dp[stack.pop()]\n                    dp[i + 1] %= MOD\n                if stack:\n                    dp[i + 1] += dp[stack.pop() + 1]\n                    dp[i + 1] %= MOD\n                stack.append(i)\n        elif c == '?':\n            dp[i + 1] += dp[i]\n            dp[i + 1] %= MOD\n            if stack and S[stack[-1]] == '(':\n                dp[i + 1] += dp[stack.pop() + 1]\n                dp[i + 1] %= MOD\n            stack.append(i)\n\n    print(dp[n])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_e",
        "code_list": [
            "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    cuboids = []\n    start_indices = [0, 3, 6]\n    for i in range(N):\n        cuboid = []\n        for j in range(3):\n            cuboid.append(int(data[start_indices[j] + i * 7]))\n        cuboids.append(cuboid)\n\n    # Create a dictionary to store the faces of each cuboid\n    faces = defaultdict(list)\n    for i in range(N):\n        x1, y1, z1 = cuboids[i]\n        x2, y2, z2 = cuboids[i][1], cuboids[i][3], cuboids[i][5]\n        faces[(x1, y1, z1)].append(i)\n        faces[(x1, y1, z2)].append(i)\n        faces[(x1, y2, z1)].append(i)\n        faces[(x1, y2, z2)].append(i)\n        faces[(x2, y1, z1)].append(i)\n        faces[(x2, y1, z2)].append(i)\n        faces[(x2, y2, z1)].append(i)\n        faces[(x2, y2, z2)].append(i)\n\n    # Count the number of cuboids sharing a face with each cuboid\n    result = []\n    for i in range(N):\n        shared_faces = set(faces[(cuboids[i][0], cuboids[i][1], cuboids[i][2])])\n        for face in faces.values():\n            if i in face:\n                shared_faces &= set(face)\n        result.append(len(shared_faces) - 1)  # Subtract 1 to exclude itself\n\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_f",
        "code_list": [
            "import heapq\n\ndef main():\n    N, M = map(int, input().split())\n    items = []\n    for _ in range(N):\n        T, X = map(int, input().split())\n        items.append((X, T))\n    \n    # Sort items based on happiness in descending order\n    items.sort(reverse=True)\n    \n    # Priority queue to keep track of can openers and their usage limit\n    can_openers = []\n    happiness = 0\n    \n    for X, T in items:\n        if T == 2:\n            # Add can opener to the priority queue\n            heapq.heappush(can_openers, (-X, T))\n        elif T == 1:\n            # Use a can opener if available\n            if can_openers:\n                _, X_opener = heapq.heappop(can_openers)\n                happiness += X + X_opener\n            else:\n                # No can opener available, skip this item\n                continue\n        else:\n            # Pull-tab can, add its happiness directly\n            happiness += X\n        \n        # Ensure we only have up to M items\n        if len(items) - len(can_openers) > M:\n            break\n    \n    print(happiness)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc313_a",
        "code_list": [
            "def main():\n    N = int(input())\n    P = list(map(int, input().split()))\n    \n    max_ability = max(P)\n    current_ability = P[0]\n    \n    # Calculate the minimum non-negative integer x\n    x = max_ability - current_ability\n    \n    print(x)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc313_b",
        "code_list": [
            "def find_strongest_programmer(N, M, relations):\n    # Initialize the graph to represent the superiority relations\n    graph = {i: [] for i in range(1, N + 1)}\n    \n    # Populate the graph with the given relations\n    for A, B in relations:\n        graph[A].append(B)\n    \n    # Function to check if a person is the strongest\n    def is_strongest(person, visited):\n        # Mark the current person as visited\n        visited[person] = True\n        \n        # Check all other persons\n        for other in range(1, N + 1):\n            if not visited[other]:\n                # If the current person is not stronger than another person, return False\n                if other not in graph[person]:\n                    return False\n                # Recursively check the other person\n                if not is_strongest(other, visited.copy()):\n                    return False\n        \n        return True\n    \n    # Try each person to see if they can be the strongest\n    for person in range(1, N + 1):\n        visited = [False] * (N + 1)\n        if is_strongest(person, visited):\n            return person\n    \n    return -1\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    relations = [tuple(map(int, input().split())) for _ in range(M)]\n    print(find_strongest_programmer(N, M, relations))"
        ]
    },
    {
        "question_id": "abc313_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    prefix_sum = [0]\n    for num in A:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    min_val = min(A)\n    max_val = max(A)\n    target = (max_val + min_val) // 2\n    \n    operations = 0\n    for i in range(1, N+1):\n        diff = A[i-1] - target\n        if diff > 0:\n            operations += diff\n            prefix_sum[i] -= diff\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_a",
        "code_list": [
            "import math\n\ndef main():\n    N = int(input())\n    pi_str = str(math.pi)\n    decimal_part = pi_str.split('.')[1]\n    if len(decimal_part) < N:\n        print(f\"{pi_str[:decimal_part.find('.')+1]}{decimal_part[:N]}\")\n    else:\n        print(f\"{pi_str[:decimal_part.find('.')+1+N]}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_b",
        "code_list": [
            "def main():\n    # Read input\n    N = int(input())\n    bets = []\n    for _ in range(N):\n        C_i = int(input())\n        bets.append(set(map(int, input().split())))\n    X = int(input())\n\n    # Find people who bet on X\n    people_betting_on_X = [i + 1 for i, bet_set in enumerate(bets) if X in bet_set]\n\n    # Find the minimum number of bets among those who bet on X\n    min_bets = float('inf')\n    for person in people_betting_on_X:\n        min_bets = min(min_bets, len(bets[person - 1]))\n\n    # Filter people who bet on X with the fewest bets\n    result_people = [person for person in people_betting_on_X if len(bets[person - 1]) == min_bets]\n\n    # Output the result\n    K = len(result_people)\n    print(K)\n    print(*result_people)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_c",
        "code_list": [
            "def main():\n    import collections\n    \n    N, M = map(int, input().split())\n    S = input()\n    C = list(map(int, input().split()))\n    \n    # Create a dictionary to store the positions of each color\n    color_positions = collections.defaultdict(list)\n    for i, c in enumerate(C):\n        color_positions[c].append(i)\n    \n    # Perform right circular shifts for each color\n    for color in range(1, M + 1):\n        positions = color_positions[color]\n        k = len(positions)\n        if k > 1:\n            positions = [positions[-1]] + positions[:-1]\n        \n        # Update the string S based on the new positions\n        for i, pos in enumerate(positions):\n            S = S[:pos - i] + S[pos - i + 1] + S[pos - i], + S[pos - i + 1:]\n    \n    print(S)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = data[1]\n    q = int(data[2])\n    \n    # Initialize a list to store the operations\n    operations = []\n    start_index = 3\n    for _ in range(q):\n        t = int(data[start_index])\n        if t == 1:\n            x = int(data[start_index + 1]) - 1\n            c = data[start_index + 2]\n            operations.append((t, x, c))\n        elif t == 2 or t == 3:\n            operations.append((t,))\n        start_index += 3\n    \n    # Process the operations\n    for op in operations:\n        if op[0] == 1:\n            s = s[:op[1]] + op[2] + s[op[1] + 1:]\n        elif op[0] == 2:\n            s = s.lower()\n        elif op[0] == 3:\n            s = s.upper()\n    \n    print(s)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_e",
        "code_list": [
            "import numpy as np\nfrom scipy.optimize import minimize\n\ndef expected_payment(N, M, costs, counts, values):\n    def objective(x):\n        total_cost = 0\n        for i in range(N):\n            if x[i] > 0:\n                total_cost += x[i] * costs[i]\n        return total_cost\n\n    def constraint(x):\n        total_points = 0\n        for i in range(N):\n            if x[i] > 0:\n                total_points += x[i] * np.mean(values[i])\n        return total_points - M\n\n    constraints = [{'type': 'ineq', 'fun': lambda x: constraint(x)}]\n    bounds = [(0, None) for _ in range(N)]\n    result = minimize(objective, [1]*N, method='SLSQP', bounds=bounds, constraints=constraints)\n    return result.fun\n\ndef main():\n    N, M = map(int, input().split())\n    costs, counts, values = [], [], []\n    for _ in range(N):\n        cost, count = map(int, input().split())\n        values.append(list(map(int, input().split())))\n        costs.append(cost)\n        counts.append(count)\n\n    expected_cost = expected_payment(N, M, costs, counts, values)\n    print(f\"{expected_cost:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_f",
        "code_list": [
            "from collections import defaultdict\nfrom math import gcd\nfrom fractions import Fraction\n\ndef modular_inverse(a, mod):\n    def extended_gcd(a, b):\n        if a == 0:\n            return (b, 0, 1)\n        else:\n            g, x, y = extended_gcd(b % a, a)\n            return (g, y - (b // a) * x, x)\n\n    _, x, _ = extended_gcd(a, mod)\n    return x % mod\n\ndef main():\n    N = int(input())\n    edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Initialize the result array\n    results = [Fraction(0, 1)] * (N + 1)\n    \n    # Depth-first search to calculate the expected values\n    def dfs(node, parent):\n        total_players = 1\n        wins = 0\n        \n        for neighbor in graph[node]:\n            if neighbor != parent:\n                win_prob, num_players = dfs(neighbor, node)\n                wins += win_prob\n                total_players += num_players\n        \n        # Calculate the expected value for the current node\n        prob = Fraction(total_players, 2 * total_players - wins)\n        results[node] = prob - wins * prob\n        \n        return wins + prob, total_players\n    \n    dfs(1, -1)\n    \n    # Print the results modulo 998244353\n    mod = 998244353\n    for i in range(1, N + 1):\n        inv_denom = modular_inverse(results[i].denominator, mod)\n        print((results[i].numerator * inv_denom) % mod, end=' ')\n    print()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = ''.join([char for char in S if char not in 'aeiou'])\n    print(result)"
        ]
    },
    {
        "question_id": "abc315_b",
        "code_list": [
            "def main():\n    M = int(input())\n    days_in_months = list(map(int, input().split()))\n    \n    total_days = sum(days_in_months)\n    middle_day_index = (total_days + 1) // 2\n    \n    current_day = 0\n    for month in range(M):\n        current_day += days_in_months[month]\n        if current_day >= middle_day_index:\n            break\n    \n    # Calculate the exact day within the month\n    day_of_month = current_day - middle_day_index + 1 if current_day > middle_day_index else 1\n    \n    print(month + 1, day_of_month)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    ice_creams = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Dictionary to store the maximum deliciousness for each flavor\n    max_deliciousness = defaultdict(int)\n    # Dictionary to store the maximum deliciousness for each even number\n    max_even_deliciousness = defaultdict(int)\n    \n    for flavor, deliciousness in ice_creams:\n        if flavor not in max_deliciousness or deliciousness > max_deliciousness[flavor]:\n            max_deliciousness[flavor] = deliciousness\n        if deliciousness % 2 == 0 and (deliciousness // 2) not in max_even_deliciousness or deliciousness > max_even_deliciousness[deliciousness // 2]:\n            max_even_deliciousness[deliciousness // 2] = deliciousness\n    \n    # Calculate the maximum satisfaction\n    max_satisfaction = 0\n    for flavor, deliciousness in ice_creams:\n        if flavor in max_deliciousness and max_deliciousness[flavor] != deliciousness:\n            max_satisfaction = max(max_satisfaction, deliciousness + max_deliciousness[flavor])\n        if deliciousness % 2 == 0 and (deliciousness // 2) in max_even_deliciousness and max_even_deliciousness[deliciousness // 2] != deliciousness:\n            max_satisfaction = max(max_satisfaction, deliciousness + max_even_deliciousness[deliciousness // 2] // 2)\n    \n    print(max_satisfaction)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_d",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    while True:\n        # Check rows\n        marked_rows = set()\n        for i in range(H):\n            if len(set(grid[i])) > 1:\n                continue\n            if grid[i].count(grid[i][0]) >= 2:\n                marked_rows.add(i)\n        \n        # Check columns\n        marked_cols = set()\n        for j in range(W):\n            col = ''.join(grid[i][j] for i in range(H))\n            if len(set(col)) > 1:\n                continue\n            if col.count(col[0]) >= 2:\n                marked_cols.add(j)\n        \n        # Remove marked cookies\n        if marked_rows or marked_cols:\n            new_grid = []\n            for i in range(H):\n                if i not in marked_rows:\n                    new_row = ''\n                    for j in range(W):\n                        if j not in marked_cols:\n                            new_row += grid[i][j]\n                    new_grid.append(new_row)\n            grid = new_grid\n        else:\n            break\n    \n    print(sum(len(row) for row in grid))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_e",
        "code_list": [
            "from collections import deque, defaultdict\n\ndef main():\n    N = int(input())\n    graph = defaultdict(list)\n    indegree = [0] * (N + 1)\n    for i in range(1, N + 1):\n        C, *P = map(int, input().split())\n        graph[0].append(i)  # Adding a dummy node 0 as the source\n        indegree[i] = C\n        for p in P:\n            graph[p].append(i)\n            indegree[i] += 1\n\n    queue = deque([node for node in range(1, N + 1) if indegree[node] == 0])\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    print(*result[:-1])  # Exclude book 1\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_f",
        "code_list": [
            "import math\nfrom itertools import combinations\n\ndef calculate_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef find_min_s(N, points):\n    min_s = float('inf')\n    for C in range(N - 1):\n        for combo in combinations(range(2, N), C):\n            distances = [calculate_distance(points[i], points[i + 1]) for i in range(len(points) - 1)]\n            for idx in sorted(combo, reverse=True):\n                del distances[idx - 1]\n            penalty = 2 ** (C - 1) if C > 0 else 0\n            s = sum(distances) + penalty\n            min_s = min(min_s, s)\n    return min_s\n\ndef main():\n    N = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n    result = find_min_s(N, points)\n    print(f\"{result:.15f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc318_a",
        "code_list": [
            "def main():\n    N, M, P = map(int, input().split())\n    # Calculate the last day he can see a full moon within the range [M, N]\n    last_day = M + ((N - M) // P) * P\n    if last_day > N:\n        last_day -= P\n    # Calculate the number of full moon days\n    num_full_moons = (last_day - M) // P + 1\n    print(num_full_moons)"
        ]
    },
    {
        "question_id": "abc318_b",
        "code_list": [
            "def main():\n    import sys\n    from itertools import product\n    \n    def intersect(a1, b1, c1, d1, a2, b2, c2, d2):\n        return max(0, min(b1, b2) - max(a1, a2)) * max(0, min(d1, d2) - max(c1, c2))\n    \n    n = int(input())\n    intervals = [tuple(map(int, line.split())) for _ in range(n)]\n    \n    # Generate all possible points within the bounds\n    x_range = range(min(a for a, _, _, _ in intervals), max(b for _, b, _, _ in intervals) + 1)\n    y_range = range(min(c for _, _, c, _ in intervals), max(d for _, _, _, d in intervals) + 1)\n    \n    # Count the number of overlapping intervals at each point\n    overlap_count = {}\n    for x, y in product(x_range, y_range):\n        count = sum(1 for a, b, c, d in intervals if a <= x <= b and c <= y <= d)\n        overlap_count[(x, y)] = count\n    \n    # Calculate the area covered by one or more sheets\n    area = sum(count > 0 for count in overlap_count.values())\n    \n    print(area)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc318_c",
        "code_list": [
            "def min_cost(N, D, P, F):\n    # Calculate the total fare without any passes\n    total_fare = sum(F)\n    \n    # Calculate the number of passes needed if we buy them in full batches\n    num_batches = (N + D - 1) // D\n    \n    # Calculate the cost if we buy the minimum number of passes\n    pass_cost = num_batches * P\n    \n    # Calculate the cost of buying the minimum number of passes and paying for the remaining days\n    min_cost = pass_cost + sum(sorted(F)[:N - num_batches * D])\n    \n    return min_cost\n\nif __name__ == \"__main__\":\n    N, D, P = map(int, input().split())\n    F = list(map(int, input().split()))\n    print(min_cost(N, D, P, F))"
        ]
    },
    {
        "question_id": "abc318_d",
        "code_list": [
            "from itertools import combinations\n\ndef max_edge_weight(N, weights):\n    # Create a list of all possible edges\n    edges = [(i, j, weights[i-1][j-i+N-1]) for i in range(1, N+1) for j in range(i+1, N+1)]\n    \n    # Sort edges in descending order of weight\n    edges.sort(key=lambda x: -x[2])\n    \n    # Initialize variables to keep track of the maximum weight and the selected edges\n    max_weight = 0\n    selected_edges = []\n    \n    # Try all combinations of edges\n    for r in range(1, N//2 + 1):\n        for combo in combinations(edges, r):\n            # Check if the endpoints of the chosen edges are pairwise distinct\n            if len(set([edge[0] for edge in combo].extend([edge[1] for edge in combo]))) == r * 2:\n                current_weight = sum(edge[2] for edge in combo)\n                if current_weight > max_weight:\n                    max_weight = current_weight\n                    selected_edges = combo\n    \n    return max_weight\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    weights = [list(map(int, input().strip().split())) for _ in range(N)]\n    print(max_edge_weight(N, weights))"
        ]
    },
    {
        "question_id": "abc318_e",
        "code_list": [
            "from collections import defaultdict\n\ndef count_triples():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Dictionary to store the indices of each element\n    index_map = defaultdict(list)\n    for i, num in enumerate(arr):\n        index_map[num].append(i)\n    \n    result = 0\n    for num, indices in index_map.items():\n        if len(indices) >= 2:\n            for i in range(len(indices) - 2):\n                for j in range(i + 1, len(indices) - 1):\n                    k = indices.index(indices[j]) + 1\n                    if k < len(indices) and arr[indices[j]] != arr[indices[k]]:\n                        result += 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    count_triples()"
        ]
    },
    {
        "question_id": "abc319_b",
        "code_list": [
            "def main():\n    N = int(input())\n    result = ['-'] * (N + 1)\n    \n    for i in range(1, 10):\n        for j in range(1, N // i + 1):\n            index = j * i - 1\n            if index <= N and N % (i * j) == 0:\n                if result[index] == '-':\n                    result[index] = str(i)\n                else:\n                    result[index] = min(result[index], str(i))\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc319_c",
        "code_list": [
            "from itertools import permutations\n\ndef calculate_probability(grid):\n    count_valid_permutations = 0\n    total_permutations = 0\n    \n    # Generate all possible permutations of the grid\n    for perm in permutations(range(9)):\n        valid = True\n        \n        # Check vertical lines\n        for col in range(3):\n            if perm[col] == perm[col + 3] and perm[col + 6] != perm[col]:\n                valid = False\n                break\n        \n        # Check horizontal lines\n        for row in range(3):\n            if perm[row] == perm[row + 1] and perm[row + 2] != perm[row]:\n                valid = False\n                break\n        \n        # Check diagonal lines\n        if perm[0] == perm[4] and perm[8] != perm[0]:\n            valid = False\n        if perm[2] == perm[4] and perm[6] != perm[2]:\n            valid = False\n        \n        if valid:\n            count_valid_permutations += 1\n        total_permutations += 1\n    \n    # Calculate the probability\n    probability = count_valid_permutations / total_permutations\n    return probability\n\ndef main():\n    grid = []\n    for _ in range(3):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    probability = calculate_probability(grid)\n    print(f\"{probability:.16f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc319_d",
        "code_list": [
            "def min_window_width(N, M, lengths):\n    # Initialize binary search bounds\n    low, high = max(lengths), sum(lengths) + M - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        lines, current_width = 1, 0\n        \n        for length in lengths:\n            if current_width + length > mid:\n                lines += 1\n                current_width = length\n            else:\n                current_width += length + 1\n        \n        if lines > M:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    lengths = list(map(int, input().split()))\n    print(min_window_width(N, M, lengths))"
        ]
    },
    {
        "question_id": "abc319_e",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef main():\n    # Read input\n    N, X, Y = map(int, input().split())\n    P = [0] + list(map(int, input().split()))\n    T = [0] + list(map(int, input().split()))\n    Q = int(input())\n    queries = list(map(int, input().split()))\n\n    # Precompute all possible bus times for each stop\n    bus_times = [[] for _ in range(N + 1)]\n    for i in range(1, N):\n        p = P[i]\n        t = T[i]\n        l = t\n        while l <= 10**9:\n            bus_times[i].append(l)\n            l += p\n\n    # Function to find the earliest arrival time\n    def earliest_arrival(query_time):\n        current_time = query_time\n        for i in range(1, N):\n            # Find the next bus time after current_time\n            next_bus_time = min(bus_times[i], key=lambda x: abs(x - current_time))\n            current_time = max(next_bus_time, current_time) + T[i]\n        return current_time + Y\n\n    # Process each query\n    results = [earliest_arrival(q) for q in queries]\n\n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc320_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    A, B = map(int, input().split())\n    result = pow(A, B) + pow(B, A)\n    print(result)"
        ]
    },
    {
        "question_id": "abc320_b",
        "code_list": [
            "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_palindromic_substring(s):\n    n = len(s)\n    max_length = 1\n    start = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            if is_palindrome(s[i:j+1]) and (j - i + 1) > max_length:\n                max_length = j - i + 1\n                start = i\n                \n    return max_length\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(longest_palindromic_substring(s))"
        ]
    },
    {
        "question_id": "abc320_c",
        "code_list": [
            "def find_min_time(M, S):\n    # Check if all strings are the same\n    if S[0] == S[1] == S[2]:\n        return 0\n    \n    # Check for each possible time from 0 to M-1\n    for t in range(M):\n        if S[0][t % M] == S[1][t % M] == S[2][t % M]:\n            return t\n    \n    return -1\n\nif __name__ == \"__main__\":\n    M = int(input())\n    S = [input() for _ in range(3)]\n    print(find_min_time(M, S))"
        ]
    },
    {
        "question_id": "abc320_d",
        "code_list": [
            "from collections import defaultdict\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Initialize dictionaries to store the relative positions\n    relative_positions = defaultdict(list)\n    for i in range(M):\n        A = int(data[2 * i * 3 + 2]) - 1\n        B = int(data[2 * i * 3 + 3]) - 1\n        X = int(data[2 * i * 3 + 4])\n        Y = int(data[2 * i * 3 + 5])\n        relative_positions[A].append((B, X, Y))\n        relative_positions[B].append((A, -X, -Y))\n    \n    # Initialize coordinates with None\n    coordinates = [None] * N\n    \n    # Function to update coordinates based on relative position\n    def update_coordinates(person, x, y):\n        if coordinates[person] is None:\n            coordinates[person] = (x, y)\n        else:\n            if coordinates[person][0] != x or coordinates[person][1] != y:\n                print(\"undecidable\")\n                exit()\n    \n    # Start with person 1 at the origin\n    update_coordinates(0, 0, 0)\n    \n    # Process all relative positions\n    for person in range(N):\n        if coordinates[person] is None:\n            for other_person, dx, dy in relative_positions[person]:\n                if coordinates[other_person] is not None:\n                    update_coordinates(person, coordinates[other_person][0] + dx, coordinates[other_person][1] + dy)\n    \n    # Print the coordinates\n    for i in range(N):\n        if coordinates[i] is None:\n            print(\"undecidable\")\n        else:\n            print(coordinates[i][0], coordinates[i][1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc320_e",
        "code_list": [
            "from collections import deque\n\ndef main():\n    N, M = map(int, input().split())\n    events = [list(map(int, input().split())) for _ in range(M)]\n    \n    # Initialize the queue with all people\n    people_queue = deque(range(1, N + 1))\n    # Initialize the result array to store the amount of noodles each person has\n    result = [0] * N\n    \n    current_time = 0\n    for t, w, s in events:\n        # Move people back into the queue if they have returned\n        while people_queue and current_time >= people_queue[0]:\n            people_queue.popleft()\n        \n        # If there are people in the queue, distribute noodles\n        if people_queue:\n            front_person = people_queue[0]\n            result[front_person - 1] += w\n        \n        # Update the current time to the event time\n        current_time = t\n        \n        # Add people back to the queue after the delay\n        people_queue.append(current_time + s)\n    \n    # Process any remaining events\n    while people_queue:\n        front_person = people_queue.popleft()\n        result[front_person - 1] += w\n    \n    # Print the result\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc321_a",
        "code_list": [
            "def is_321_like_number(N):\n    digits = [int(d) for d in str(N)]\n    for i in range(len(digits) - 1):\n        if digits[i] <= digits[i + 1]:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    if is_321_like_number(N):\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        ]
    },
    {
        "question_id": "abc321_b",
        "code_list": [
            "def main():\n    N, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Sort the scores\n    A.sort()\n    \n    # Calculate the current sum without the highest and lowest scores\n    current_sum = sum(A[1:-1])\n    \n    # Calculate the minimum score needed in the last round\n    min_score_needed = X - current_sum\n    \n    # Check if the minimum score needed is valid\n    if min_score_needed < 0:\n        min_score_needed = 0\n    elif min_score_needed > 100:\n        min_score_needed = 100\n    \n    # Check if the minimum score needed is achievable\n    if min_score_needed + current_sum >= X:\n        print(min_score_needed)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc321_c",
        "code_list": [
            "from itertools import combinations\n\ndef generate_321_like_numbers(n):\n    digits = '9876543210'\n    result = []\n    for length in range(1, 11):  # 321-like numbers can have at most 10 digits\n        for combo in combinations(digits, length):\n            num = int(''.join(combo))\n            if num <= n:\n                result.append(num)\n            else:\n                break\n    return sorted(result)\n\ndef find_kth_321_like_number(K):\n    nums = generate_321_like_numbers(10**9)  # Generate all possible 321-like numbers up to a large limit\n    return nums[K - 1]\n\nif __name__ == \"__main__\":\n    K = int(input().strip())\n    print(find_kth_321_like_number(K))"
        ]
    },
    {
        "question_id": "abc321_d",
        "code_list": [
            "def calculate_total_price(N, M, P, A, B):\n    # Sort the arrays A and B\n    A.sort()\n    B.sort()\n    \n    # Initialize the result variable\n    total_price = 0\n    \n    # Iterate through each main dish\n    for i in range(N):\n        # For each main dish, find the number of side dishes that can pair with it\n        # such that the sum of their prices is less than or equal to P\n        count = 0\n        for j in range(M):\n            if A[i] + B[j] <= P:\n                count += 1\n            else:\n                break\n        \n        # Add the contribution of this main dish to the total price\n        total_price += count * A[i]\n    \n    # Add the contribution of each side dish to the total price\n    for j in range(M):\n        if B[j] <= P:\n            total_price += B[j]\n        else:\n            break\n    \n    return total_price\n\nif __name__ == \"__main__\":\n    N, M, P = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(calculate_total_price(N, M, P, A, B))"
        ]
    },
    {
        "question_id": "abc321_e",
        "code_list": [
            "def count_vertices_distance(N, X, K):\n    if K == 0:\n        return 1 if X == 1 else 0\n    \n    # Calculate the number of vertices at distance K from X\n    def dfs(i, k):\n        if k == 0:\n            return 1\n        if i * 2 > N or i * 2 + 1 > N:\n            return 0\n        \n        left = dfs(i * 2, k - 1)\n        right = dfs(i * 2 + 1, k - 1)\n        \n        return left + right\n    \n    return dfs(X, K)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        X = int(data[index + 1])\n        K = int(data[index + 2])\n        index += 3\n        \n        result = count_vertices_distance(N, X, K)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    for i in range(N - 2):\n        if S[i:i+3] == 'ABC':\n            print(i + 1)\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    S = input().strip()\n    T = input().strip()\n\n    # Check if S is a prefix of T\n    is_prefix = T.startswith(S)\n    # Check if S is a suffix of T\n    is_suffix = T.endswith(S)\n\n    # Determine the result based on the conditions\n    if is_prefix and is_suffix:\n        print(0)\n    elif is_prefix and not is_suffix:\n        print(1)\n    elif not is_prefix and is_suffix:\n        print(2)\n    else:\n        print(3)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Initialize the result list\n    result = [0] * N\n\n    # Fill in the result list\n    for i in range(N):\n        if i + 1 in A:\n            result[i] = 0\n        else:\n            for j in range(i + 1, N + 1):\n                if j in A:\n                    result[i] = j - i - 1\n                    break\n\n    # Print the result\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_d",
        "code_list": [
            "import itertools\n\ndef rotate(p):\n    return tuple(zip(*p[::-1]))\n\ndef flip(p):\n    return p[::-1]\n\ndef check_fit(grid, polyomino):\n    for r in range(4):\n        for c in range(4):\n            if grid[r][c] != '.':\n                continue\n            for orientation in itertools.product([0, 1], repeat=r):\n                for flip_orientation in itertools.product([0, 1], repeat=c):\n                    new_polyomino = set()\n                    for dr, dc in polyomino:\n                        new_r, new_c = r + dr, c + dc\n                        if (new_r, new_c) in new_polyomino:\n                            break\n                        if not (0 <= new_r < 4 and 0 <= new_c < 4):\n                            break\n                        if grid[new_r][new_c] != '.':\n                            break\n                        new_polyomino.add((new_r, new_c))\n                    else:\n                        for dr, dc in polyomino:\n                            grid[r + dr][c + dc] = '#'\n                        return True\n                    for dr, dc in polyomino:\n                        grid[r + dr][c + dc] = '.'\n    return False\n\ndef solve():\n    grid = [['.' for _ in range(4)] for _ in range(4)]\n    polyominoes = []\n    for i in range(3):\n        polyomino = []\n        for j in range(4):\n            line = input().strip()\n            for k, char in enumerate(line):\n                if char == '#':\n                    polyomino.append((j, k))\n        polyominoes.append(polyomino)\n    \n    for perm in itertools.permutations(polyominoes):\n        for rotation in itertools.product(range(4), repeat=3):\n            for flip in itertools.product([0, 1], repeat=3):\n                new_grid = [['.' for _ in range(4)] for _ in range(4)]\n                for i, polyomino in enumerate(perm):\n                    for dr, dc in polyomino:\n                        new_r, new_c = (dr + rotation[i]) % 4, (dc + rotation[i]) % 4\n                        if flip[i]:\n                            new_r, new_c = 3 - new_r, 3 - new_c\n                        new_grid[new_r][new_c] = '#'\n                if all(cell == '#' for row in new_grid for cell in row):\n                    return 'Yes'\n    return 'No'\n\nif __name__ == \"__main__\":\n    print(solve())"
        ]
    },
    {
        "question_id": "abc322_e",
        "code_list": [
            "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N, K, P = int(data[0]), int(data[1]), int(data[2])\n    costs = []\n    effects = [[] for _ in range(K)]\n    \n    start = 3\n    for i in range(N):\n        cost = int(data[start])\n        start += 1\n        for j in range(K):\n            effect = int(data[start])\n            start += 1\n            effects[j].append(effect)\n        costs.append(cost)\n    \n    # Generate all possible combinations of development plans\n    all_combinations = []\n    for r in range(1, N + 1):\n        all_combinations.extend(combinations(range(N), r))\n    \n    min_cost = float('inf')\n    for combination in all_combinations:\n        current_cost = sum(costs[i] for i in combination)\n        if current_cost >= min_cost:\n            continue\n        \n        # Check if the combination can achieve the goal\n        achieved = [0] * K\n        for i in combination:\n            for j in range(K):\n                achieved[j] += effects[j][i]\n        \n        if all(x >= P for x in achieved):\n            min_cost = current_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    for i in range(2, 17, 2):\n        if S[i-1] != '0':\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_b",
        "code_list": [
            "def main():\n    N = int(input())\n    wins = [0] * N\n    \n    for i in range(N):\n        S_i = input()\n        for j in range(N):\n            if S_i[j] == 'o':\n                wins[i] += 1\n    \n    ranked_players = sorted(range(N), key=lambda k: (-wins[k], k))\n    \n    for player in ranked_players:\n        print(player + 1, end=' ')"
        ]
    },
    {
        "question_id": "abc323_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    S = [input() for _ in range(N)]\n    \n    # Calculate current scores\n    current_scores = [sum(A[j] for j in range(M) if S[i][j] == 'o') + i for i in range(N)]\n    \n    # Function to calculate minimum problems needed to exceed all others\n    def min_problems_needed(i):\n        solved = [j for j in range(M) if S[i][j] == 'x']\n        for k in range(len(solved)):\n            if current_scores[i] + sum(A[j] for j in solved[:k+1]) > max(current_scores[:i] + current_scores[i+1:]):\n                return k + 1\n        return len(solved)\n    \n    # Output results\n    for i in range(N):\n        print(min_problems_needed(i))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    sizes = []\n    counts = []\n    \n    for _ in range(N):\n        sizes.append(int(data[index]))\n        counts.append(int(data[index + 1]))\n        index += 2\n    \n    min_slimes = 0\n    for i in range(N):\n        if counts[i] % 2 == 1:\n            min_slimes += 1\n    \n    # If there's only one size, we need to calculate the minimum number of slimes\n    if len(sizes) == 1:\n        total_count = counts[0]\n        while total_count > 1:\n            total_count //= 2\n            min_slimes += 1\n        min_slimes += 1\n    else:\n        min_slimes = sum(counts)\n    \n    print(min_slimes)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_e",
        "code_list": [
            "from math import gcd\n\ndef modinv(a, m=998244353):\n    return pow(a, m - 2, m)\n\ndef solve(N, X, T):\n    total_time = sum(T)\n    prob = [0] * N\n    dp = [0] * (total_time + 1)\n    dp[0] = 1\n    \n    for i in range(N):\n        new_dp = [0] * (total_time + 1)\n        for j in range(total_time + 1):\n            if j >= T[i]:\n                new_dp[j] += dp[j - T[i]] * (N - 1) % 998244353\n            new_dp[j] += dp[j]\n            new_dp[j] %= 998244353\n        dp = new_dp\n    \n    for i in range(X + 1, total_time + 1):\n        if i - T[0] >= 0:\n            prob[0] += dp[i - T[0]]\n            prob[0] %= 998244353\n        prob[0] += dp[i]\n        prob[0] %= 998244353\n    \n    for i in range(1, N):\n        for j in range(total_time + 1):\n            if j >= T[i]:\n                prob[i] += dp[j - T[i]] * (N - 1) % 998244353\n                prob[i] %= 998244353\n            prob[i] += dp[j]\n            prob[i] %= 998244353\n    \n    prob[0] = prob[0] * modinv(N) % 998244353\n    for i in range(1, N):\n        prob[i] = prob[i] * modinv(N - 1) % 998244353\n    \n    return prob[0]\n\nif __name__ == \"__main__\":\n    N, X = map(int, input().split())\n    T = list(map(int, input().split()))\n    print(solve(N, X, T))"
        ]
    },
    {
        "question_id": "abc324_a",
        "code_list": [
            "def main():\n    # Read the number of integers N\n    N = int(input().strip())\n    \n    # Read the list of integers A_1, A_2, ..., A_N\n    A = list(map(int, input().strip().split()))\n    \n    # Check if all elements in the list are equal\n    if len(set(A)) == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_b",
        "code_list": [
            "import math\n\ndef main():\n    N = int(input())\n    # Check if N is divisible by 2 and then by 3 until it can't be divided anymore\n    while N % 2 == 0:\n        N //= 2\n    while N % 3 == 0:\n        N //= 3\n    \n    # If after division, N is 1, it means N was only composed of factors 2 and 3\n    if N == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_c",
        "code_list": [
            "def is_transformable(s, t):\n    if len(s) == len(t):\n        return sorted(s) == sorted(t)\n    elif len(s) + 1 == len(t):\n        for i in range(len(s) + 1):\n            if s[:i] + s[i+1:] == t[:-1]:\n                return True\n        return False\n    elif len(s) - 1 == len(t):\n        for i in range(len(s)):\n            if s[:i] + s[i+1:] == t[1:]:\n                return True\n        return False\n    elif len(s) == len(t) - 1:\n        for i in range(len(t)):\n            if s == t[:i] + t[i+1:]:\n                return True\n        return False\n    else:\n        return False\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[1])\n    t_prime = data[2]\n    strings = data[3:]\n    \n    possible_indices = []\n    for i in range(n):\n        if is_transformable(strings[i], t_prime):\n            possible_indices.append(i + 1)\n    \n    print(len(possible_indices))\n    print(' '.join(map(str, possible_indices)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_d",
        "code_list": [
            "import itertools\nimport math\n\ndef is_square(num):\n    return int(math.isqrt(num)) ** 2 == num\n\ndef count_square_numbers(N, S):\n    count = 0\n    for perm in itertools.permutations(range(N)):\n        num = 0\n        for i in range(N):\n            num += int(S[perm[i]]) * (10 ** (N - i - 1))\n        if is_square(num):\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    print(count_square_numbers(N, S))"
        ]
    },
    {
        "question_id": "abc324_e",
        "code_list": [
            "from collections import defaultdict\n\ndef is_subsequence(s, t):\n    t_index = 0\n    for char in s:\n        if t_index < len(t) and char == t[t_index]:\n            t_index += 1\n    return t_index == len(t)\n\ndef count_pairs(N, T, strings):\n    count = 0\n    for i in range(N):\n        for j in range(i, N):\n            concatenated = strings[i] + strings[j]\n            if is_subsequence(concatenated, T):\n                count += 1\n    return count\n\ndef main():\n    N, T = input().split()\n    N = int(N)\n    strings = [input().strip() for _ in range(N)]\n    print(count_pairs(N, T, strings))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_f",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start, end):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if u == end:\n            break\n        if d > dist[u]:\n            continue\n        for v, b, c in graph[u]:\n            new_d = d + c\n            new_b = dist[u] * b + b\n            if new_d * dist[end] < new_b * dist[u]:\n                continue\n            if new_d * dist[end] > new_b * dist[u]:\n                dist[v] = new_b / new_d\n                heapq.heappush(pq, (new_d, v))\n            else:\n                dist[v] = min(dist[v], new_b / new_d)\n                \n    return dist[end]\n\ndef main():\n    N, M = map(int, input().split())\n    graph = defaultdict(list)\n    \n    for _ in range(M):\n        u, v, b, c = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append((v, b, c))\n    \n    result = dijkstra(graph, 0, N - 1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_a",
        "code_list": [
            "def main():\n    S, T = input().split()\n    print(f\"{S} san\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    bases = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(n)]\n    \n    start_time = 9\n    end_time = 18\n    max_employees = 0\n    \n    for i in range(start_time, end_time):\n        current_max = 0\n        for w, x in bases:\n            if x <= i and (x + 1) >= i:\n                current_max += w\n        max_employees = max(max_employees, current_max)\n    \n    print(max_employees)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_c",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    def merge_sensors(grid):\n        merged_grid = [['.' for _ in range(W)] for _ in range(H)]\n        visited = [[False for _ in range(W)] for _ in range(H)]\n        \n        def dfs(x, y):\n            stack = [(x, y)]\n            while stack:\n                cx, cy = stack.pop()\n                if visited[cx][cy]:\n                    continue\n                visited[cx][cy] = True\n                merged_grid[cx][cy] = '#'\n                for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                    nx, ny = cx + dx, cy + dy\n                    if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '#' and not visited[nx][ny]:\n                        stack.append((nx, ny))\n        \n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == '#' and not visited[i][j]:\n                    dfs(i, j)\n        \n        return merged_grid\n    \n    merged_grid = merge_sensors(grid)\n    \n    count = 0\n    for row in merged_grid:\n        count += row.count('#')\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_d",
        "code_list": [
            "from heapq import heappush, heappop\n\ndef max_printable_products(N, printer_times):\n    events = []\n    for i, (T, D) in enumerate(printer_times):\n        events.append((T, i, 'enter'))\n        events.append((T + D - 1, i, 'leave'))\n    \n    events.sort()\n    charge_time = 0\n    printed_count = 0\n    available_time = []\n    \n    for _, product_id, event_type in events:\n        if event_type == 'enter':\n            if not available_time:\n                charge_time += 1\n            else:\n                charge_time = max(0, available_time[0] - _)\n            heappush(available_time, _ + 1)\n            printed_count += 1\n        elif event_type == 'leave':\n            heappop(available_time)\n    \n    return printed_count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    printer_times = [tuple(map(int, input().split())) for _ in range(N)]\n    print(max_printable_products(N, printer_times))"
        ]
    },
    {
        "question_id": "abc325_e",
        "code_list": [
            "import sys\nfrom typing import List\n\ndef dijkstra(n: int, adj_matrix: List[List[int]], car_time: int, train_time: int, train_cost: int) -> int:\n    # Initialize distances with infinity\n    dist = [float('inf')] * n\n    dist[0] = 0\n    \n    # Priority queue to store (distance, city)\n    pq = [(0, 0)]\n    \n    while pq:\n        current_dist, current_city = heapq.heappop(pq)\n        \n        if current_dist > dist[current_city]:\n            continue\n        \n        for next_city, travel_time in enumerate(adj_matrix[current_city]):\n            if travel_time == 0:\n                continue\n            \n            # Calculate time using company car\n            car_time_to_next = travel_time * car_time\n            if current_dist + car_time_to_next < dist[next_city]:\n                dist[next_city] = current_dist + car_time_to_next\n                heapq.heappush(pq, (dist[next_city], next_city))\n            \n            # Calculate time using train\n            train_time_to_next = travel_time * train_time + train_cost\n            if current_dist + train_time_to_next < dist[next_city]:\n                dist[next_city] = current_dist + train_time_to_next\n                heapq.heappush(pq, (dist[next_city], next_city))\n    \n    return dist[-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    car_time = int(data[1])\n    train_time = int(data[2])\n    train_cost = int(data[3])\n    \n    adj_matrix = []\n    for i in range(4, len(data), n):\n        row = list(map(int, data[i:i+n]))\n        adj_matrix.append(row)\n    \n    result = dijkstra(n, adj_matrix, car_time, train_time, train_cost)\n    print(result)\n\nif __name__ == \"__main__\":\n    import heapq\n    main()"
        ]
    },
    {
        "question_id": "abc325_f",
        "code_list": [
            "import sys\nfrom heapq import heappush, heappop\n\ndef main():\n    N = int(input())\n    D = list(map(int, input().split()))\n    L1, C1, K1 = map(int, input().split())\n    L2, C2, K2 = map(int, input().split())\n\n    # Create a min-heap to store the costs of monitoring each section\n    heap = []\n    for d in D:\n        # Calculate the number of type-1 and type-2 sensors needed to monitor the section\n        num_L1 = (d + L1 - 1) // L1\n        num_L2 = (d + L2 - 1) // L2\n        # Calculate the cost for each combination of sensors\n        cost_L1 = num_L1 * C1\n        cost_L2 = num_L2 * C2\n        # Push the cost onto the heap\n        heappush(heap, (cost_L1, cost_L2))\n\n    # Initialize variables to track the number of sensors used and the total cost\n    used_L1 = 0\n    used_L2 = 0\n    total_cost = 0\n\n    while heap:\n        cost_L1, cost_L2 = heappop(heap)\n        if used_L1 < K1 and cost_L1 <= cost_L2:\n            used_L1 += 1\n            total_cost += cost_L1\n        elif used_L2 < K2:\n            used_L2 += 1\n            total_cost += cost_L2\n        else:\n            break\n\n    # Check if all sections are monitored\n    if used_L1 + used_L2 * (L2 / L1) >= sum(D):\n        print(total_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_a",
        "code_list": [
            "def main():\n    X, Y = map(int, input().split())\n    if abs(X - Y) <= 2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_b",
        "code_list": [
            "def find_next_326_like_number(N):\n    for num in range(N, 1000):\n        hundreds = num // 100\n        tens = (num // 10) % 10\n        ones = num % 10\n        if hundreds * tens == ones:\n            return num\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(find_next_326_like_number(N))"
        ]
    },
    {
        "question_id": "abc326_c",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    \n    # Initialize the count of gifts and the starting point\n    count = 0\n    start = 0\n    \n    for i in range(N):\n        if A[i] >= start:\n            count += 1\n            start = A[i] + M\n    \n    print(count)"
        ]
    },
    {
        "question_id": "abc326_d",
        "code_list": [
            "from itertools import permutations\n\ndef solve(N, R, C):\n    # Generate all permutations for the characters A, B, and C\n    perms = list(permutations(['A', 'B', 'C']))\n    \n    # Try to find a valid configuration\n    for perm in perms:\n        grid = [['.' for _ in range(N)] for _ in range(N)]\n        \n        # Place the characters according to the given constraints\n        for i in range(N):\n            grid[i][R.index(perm[i])] = perm[i]\n            grid[grid[i].index(C[i])] = perm[i]\n        \n        # Check if the grid is valid\n        if all(grid[i].count('A') == 1 and grid[i].count('B') == 1 and grid[i].count('C') == 1 for i in range(N)) and \\\n           all([row.count('A') == 1 and row.count('B') == 1 and row.count('C') == 1 for row in zip(*grid)]):\n            return True, grid\n        \n    return False, None\n\ndef main():\n    N = int(input())\n    R = input()\n    C = input()\n    \n    valid, grid = solve(N, R, C)\n    \n    if valid:\n        print(\"Yes\")\n        for row in grid:\n            print(''.join(row))\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_e",
        "code_list": [
            "def modular_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef expected_salary(N, A):\n    mod = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 0\n    for i in range(1, N + 1):\n        dp[i] = sum(A[j] * (i - j) * modular_inverse(i, mod) % mod for j in range(i)) % mod\n    return sum(dp) % mod\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(expected_salary(N, A))"
        ]
    },
    {
        "question_id": "abc327_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    \n    for i in range(N - 1):\n        if S[i] == 'a' and S[i + 1] == 'b' or S[i] == 'b' and S[i + 1] == 'a':\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc327_b",
        "code_list": [
            "import math\n\ndef find_A(B):\n    # Start with the smallest possible value for A\n    A = 1\n    while True:\n        # Calculate A^A\n        power = A ** A\n        # Check if A^A equals B\n        if power == B:\n            return A\n        # If A^A exceeds B, break the loop as increasing A further will only increase A^A more\n        elif power > B:\n            return -1\n        A += 1\n\nif __name__ == \"__main__\":\n    B = int(input().strip())\n    print(find_A(B))"
        ]
    },
    {
        "question_id": "abc327_c",
        "code_list": [
            "def check_sudoku(grid):\n    # Check rows\n    for row in grid:\n        if sorted(row) != list(range(1, 10)):\n            return \"No\"\n    \n    # Check columns\n    for col in range(9):\n        if sorted([grid[row][col] for row in range(9)]) != list(range(1, 10)):\n            return \"No\"\n    \n    # Check 3x3 subgrids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if sorted(subgrid) != list(range(1, 10)):\n                return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    grid = []\n    for _ in range(9):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    print(check_sudoku(grid))"
        ]
    },
    {
        "question_id": "abc327_d",
        "code_list": [
            "def main():\n    import sys\n    \n    def is_good_pair(N, M, A, B):\n        # Create a list to track if a number has been paired with 0 or 1\n        paired = [None] * (N + 1)\n        \n        for i in range(M):\n            if paired[A[i]] is None:\n                paired[A[i]] = 0 if paired[B[i]] is None else 1\n            elif paired[A[i]] == paired[B[i]]:\n                return False\n        \n        return True\n    \n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    if is_good_pair(N, M, A, B):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc327_e",
        "code_list": [
            "import heapq\nfrom math import sqrt\n\ndef calculate_rating(performance, k):\n    numerator = sum((0.9)**(k-i) * performance[i] for i in range(k))\n    denominator = sum((0.9)**(k-i) for i in range(k))\n    return numerator / denominator - 1200 / sqrt(k)\n\ndef max_rating(contests):\n    n = len(contests)\n    max_heap = []\n    total_performance = 0\n    for i in range(n):\n        heapq.heappush(max_heap, (-contests[i], i))\n        total_performance += contests[i]\n        while len(max_heap) > i + 1:\n            _, idx = heapq.heappop(max_heap)\n            total_performance += contests[idx]\n            for j in range(idx + 1, n):\n                heapq.heappush(max_heap, (-contests[j], j))\n            break\n        if len(max_heap) >= i + 1:\n            best_performance = -max_heap[0][0]\n            rating = calculate_rating([best_performance] * (i + 1), i + 1)\n            yield rating, total_performance - best_performance\n\ndef main():\n    n = int(input().strip())\n    performances = list(map(int, input().strip().split()))\n    max_rating_value = -float('inf')\n    for rating, total_performance in max_rating(performances):\n        if rating > max_rating_value:\n            max_rating_value = rating\n    print(f\"{max_rating_value:.15f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc328_a",
        "code_list": [
            "def main():\n    # Read input values\n    N, X = map(int, input().split())\n    scores = list(map(int, input().split()))\n    \n    # Calculate the total score for problems with a score of X or less\n    total_score = sum(score for score in scores if score <= X)\n    \n    # Print the result\n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc328_b",
        "code_list": [
            "def is_repdigit(num):\n    return len(set(str(num))) == 1\n\ndef count_repdigit_dates(N, days):\n    repdigit_count = 0\n    for i in range(1, N + 1):\n        for j in range(1, days[i - 1] + 1):\n            if is_repdigit(i) and is_repdigit(j):\n                repdigit_count += 1\n    return repdigit_count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    days = list(map(int, input().split()))\n    print(count_repdigit_dates(N, days))"
        ]
    },
    {
        "question_id": "abc328_c",
        "code_list": [
            "def count_consecutive_duplicates(N, Q, S, queries):\n    # Initialize the result list to store answers for each query\n    results = []\n    \n    # Iterate through each query\n    for l, r in queries:\n        count = 0\n        # Iterate through the substring from l to r-1\n        for i in range(l, r):\n            # Check if the current character is the same as the next character\n            if S[i] == S[i + 1]:\n                count += 1\n        results.append(count)\n    \n    return results\n\ndef main():\n    # Read input\n    N, Q = map(int, input().split())\n    S = input()\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    # Process queries and print results\n    results = count_consecutive_duplicates(N, Q, S, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc328_d",
        "code_list": [
            "def remove_ABC(S):\n    while 'ABC' in S:\n        S = S.replace('ABC', '', 1)\n    return S\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(remove_ABC(S))"
        ]
    },
    {
        "question_id": "abc328_e",
        "code_list": [
            "from typing import List, Tuple\nimport sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n: int, edges: List[Tuple[int, int, int]], k: int) -> int:\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x: int) -> int:\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x: int, y: int):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    edges.sort(key=lambda x: x[2])\n    total_weight = 0\n    for u, v, w in edges:\n        if find(u - 1) != find(v - 1):\n            union(u - 1, v - 1)\n            total_weight += w\n\n    min_cost = total_weight % k\n    return min_cost\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    edges = []\n    for i in range(3, len(data), 3):\n        u = int(data[i]) - 1\n        v = int(data[i + 1]) - 1\n        w = int(data[i + 2])\n        edges.append((u, v, w))\n\n    result = kruskal(n, edges, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    for i in range(len(S)):\n        print(S[i], end=' ')\n    print()  # Print a newline at the end\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    numbers = list(map(int, data[1:]))\n    \n    max_num = max(numbers)\n    second_max = -1\n    \n    for num in numbers:\n        if num != max_num:\n            if second_max == -1 or num > second_max:\n                second_max = num\n    \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_c",
        "code_list": [
            "def count_repeated_substrings(s):\n    n = len(s)\n    count = 0\n    for i in range(n):\n        length = 1\n        while i + length <= n and s[i] == s[i + length - 1]:\n            count += length\n            length += 1\n    return count\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input().strip()\n    print(count_repeated_substrings(s))"
        ]
    },
    {
        "question_id": "abc329_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    votes = list(map(int, input().split()))\n    \n    # Initialize counters for each candidate\n    counts = defaultdict(int)\n    max_count = 0\n    winners = []\n    \n    for i, vote in enumerate(votes):\n        counts[vote] += 1\n        \n        # Update the maximum count if necessary\n        if counts[vote] > max_count:\n            max_count = counts[vote]\n            winners.append(vote)\n        elif counts[vote] == max_count:\n            # Check if the current candidate has the smallest candidate number\n            if vote < winners[-1]:\n                winners[-1] = vote\n    \n    # Print the winners for each step\n    for winner in winners:\n        print(winner)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_e",
        "code_list": [
            "def can_match_string(N, M, S, T):\n    # Check if each character in T can be matched by sliding windows of size M in S\n    for i in range(N - M + 1):\n        if S[i:i+M] == T:\n            continue\n        else:\n            return False\n    return True\n\ndef main():\n    N, M = map(int, input().split())\n    S = input().strip()\n    T = input().strip()\n    \n    if can_match_string(N, M, S, T):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_f",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    # Read input\n    N, Q = map(int, input().split())\n    colors = list(map(int, input().split()))\n    \n    # Initialize data structures\n    box_contents = defaultdict(set)\n    for i in range(N):\n        box_contents[i+1].add(colors[i])\n    \n    # Process queries\n    for _ in range(Q):\n        a, b = map(int, input().split())\n        # Move all balls from box a to box b\n        box_contents[b].update(box_contents[a])\n        del box_contents[a]\n        \n        # Print the number of different colors in box b\n        print(len(box_contents[b]))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_a",
        "code_list": [
            "def main():\n    # Read input\n    N, L = map(int, input().split())\n    scores = list(map(int, input().split()))\n    \n    # Count how many people passed\n    passed_count = sum(1 for score in scores if score >= L)\n    \n    # Output the result\n    print(passed_count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_b",
        "code_list": [
            "def main():\n    # Read input\n    N, L, R = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Find X_i for each i\n    Xi = [L] * N\n    for i in range(N):\n        if A[i] < L:\n            Xi[i] = L\n        elif A[i] > R:\n            Xi[i] = R\n\n    # Output the result\n    print(*Xi)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_c",
        "code_list": [
            "import math\n\ndef min_difference(D):\n    # Initialize the minimum difference to a large number\n    min_diff = float('inf')\n    \n    # Iterate over possible values of x\n    for x in range(int(math.sqrt(D)) + 1):\n        # Calculate the remaining value after subtracting x^2 from D\n        remaining = D - x * x\n        \n        # Check if the remaining value is a perfect square\n        y = int(math.sqrt(remaining))\n        if y * y == remaining:\n            return 0\n        \n        # Calculate the current difference\n        diff = abs(y * y + x * x - D)\n        \n        # Update the minimum difference if the current one is smaller\n        min_diff = min(min_diff, diff)\n    \n    return min_diff\n\nif __name__ == \"__main__\":\n    D = int(input().strip())\n    print(min_difference(D))"
        ]
    },
    {
        "question_id": "abc330_d",
        "code_list": [
            "from collections import Counter\n\ndef count_triples(N, grid):\n    # Count the number of 'o's in each row and column\n    row_counts = [Counter(row) for row in grid]\n    col_counts = [Counter(col) for col in zip(*grid)]\n    \n    # Calculate the number of valid triples\n    total_triples = 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'o':\n                # Count pairs in the same row but different columns\n                same_row_pairs = (row_counts[i]['o'] - 1) * (N - 1 - col_counts[j]['o'])\n                # Count pairs in the same column but different rows\n                same_col_pairs = (col_counts[j]['o'] - 1) * (N - 1 - row_counts[i]['o'])\n                total_triples += same_row_pairs + same_col_pairs\n    \n    return total_triples // 2  # Each triple is counted twice\n\ndef main():\n    N = int(input().strip())\n    grid = [input().strip() for _ in range(N)]\n    print(count_triples(N, grid))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_e",
        "code_list": [
            "def mex_of_sequence(A):\n    seen = set(A)\n    for i in range(len(A)):\n        if i not in seen:\n            return i\n    return len(A)\n\ndef main():\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    for _ in range(Q):\n        i, x = map(int, input().split())\n        i -= 1  # Adjust index to be 0-based\n        A[i] = x\n        \n        print(mex_of_sequence(A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_a",
        "code_list": [
            "def main():\n    M, D = map(int, input().split())\n    y, m, d = map(int, input().split())\n    \n    # Calculate the total number of days in the given year\n    total_days = (y - 1) * M * D + (m - 1) * D + d\n    \n    # Calculate the next day\n    next_day = total_days % (M * D)\n    \n    # If next_day is 0, it means we have completed a full cycle of the year\n    if next_day == 0:\n        next_day = M * D\n        m += 1\n        if m > M:\n            m = 1\n            y += 1\n    \n    # Extract the new month and day\n    new_d = next_day % D\n    new_m = (next_day // D) + 1\n    \n    # Print the result\n    print(y, new_m, new_d)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_b",
        "code_list": [
            "import sys\n\ndef main():\n    N, S, M, L = map(int, sys.stdin.readline().split())\n    min_cost = float('inf')\n    \n    for i in range(N // 6 + 1):\n        for j in range(N // 8 + 1):\n            for k in range(N // 12 + 1):\n                if 6 * i + 8 * j + 12 * k >= N:\n                    cost = i * S + j * M + k * L\n                    min_cost = min(min_cost, cost)\n    \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    sorted_A = sorted((value, index) for index, value in enumerate(A))\n    result = [0] * N\n    \n    right_count = [0] * N\n    for value, index in sorted_A:\n        right_count[index] = N - index\n    \n    left_sum = 0\n    for value, index in sorted_A[::-1]:\n        right_sum = prefix_sum[N] - prefix_sum[index + 1]\n        result[index] = (right_sum - value * right_count[index]) - left_sum\n        left_sum += value\n    \n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_d",
        "code_list": [
            "def count_black_squares(N, P, queries):\n    # Precompute the prefix sums for rows and columns\n    row_prefix_sums = [[0] * (N + 1) for _ in range(N)]\n    col_prefix_sums = [[0] * (N + 1) for _ in range(N)]\n    \n    # Compute row prefix sums\n    for i in range(N):\n        for j in range(N):\n            row_prefix_sums[i][j + 1] = row_prefix_sums[i][j] + (1 if P[i][j] == 'B' else 0)\n    \n    # Compute column prefix sums\n    for j in range(N):\n        for i in range(N):\n            col_prefix_sums[i][j + 1] = col_prefix_sums[i][j] + (1 if P[i][j] == 'B' else 0)\n    \n    def query(A, B, C, D):\n        # Calculate the number of black squares using prefix sums\n        return (row_prefix_sums[C % N][D % N] - row_prefix_sums[C % N][B % N]) + \\\n               (col_prefix_sums[D % N][C % N] - col_prefix_sums[B % N][C % N]) - \\\n               (row_prefix_sums[A % N][D % N] - row_prefix_sums[A % N][B % N]) - \\\n               (col_prefix_sums[D % N][A % N] - col_prefix_sums[B % N][A % N])\n    \n    # Process each query\n    for A, B, C, D in queries:\n        print(query(A, B, C, D))\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    P = [input() for _ in range(N)]\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    count_black_squares(N, P, queries)"
        ]
    },
    {
        "question_id": "abc331_e",
        "code_list": [
            "def find_most_expensive_set_meal():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    m = int(data[1])\n    l = int(data[2])\n\n    a = []\n    b = []\n    for i in range(3, 3 + n):\n        a.append(int(data[i]))\n    for i in range(3 + n, 3 + n + m):\n        b.append(int(data[i]))\n\n    forbidden_pairs = set()\n    for i in range(l):\n        c = int(data[3 + n + m + i * 2]) - 1\n        d = int(data[3 + n + m + i * 2 + 1]) - 1\n        forbidden_pairs.add((c, d))\n\n    max_price = 0\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in forbidden_pairs:\n                max_price = max(max_price, a[i] + b[j])\n\n    return max_price\n\nif __name__ == \"__main__\":\n    print(find_most_expensive_set_meal())"
        ]
    },
    {
        "question_id": "abc332_a",
        "code_list": [
            "def calculate_total_cost():\n    # Read input\n    N, S, K = map(int, input().split())\n    total_price = 0\n    \n    # Calculate the total price of the products\n    for _ in range(N):\n        P, Q = map(int, input().split())\n        total_price += P * Q\n    \n    # Calculate the final amount to pay\n    if total_price >= S:\n        shipping_fee = 0\n    else:\n        shipping_fee = K\n    \n    total_amount = total_price + shipping_fee\n    print(total_amount)\n\nif __name__ == \"__main__\":\n    calculate_total_cost()"
        ]
    },
    {
        "question_id": "abc332_b",
        "code_list": [
            "def main():\n    K, G, M = map(int, input().split())\n    glass_water = 0\n    mug_water = 0\n    \n    for _ in range(K):\n        if glass_water == G:\n            glass_water = 0\n        elif mug_water < M:\n            if glass_water + mug_water <= G:\n                glass_water += mug_water\n                mug_water = 0\n            else:\n                glass_water += mug_water\n                mug_water = 0\n                glass_water -= (G - glass_water)\n        else:\n            mug_water = 0\n    \n    print(glass_water, mug_water)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc332_c",
        "code_list": [
            "def min_tshirts_to_buy(N, M, S):\n    # Initialize variables to track the number of logo T-shirts needed and the last day a logo T-shirt was worn\n    logo_needed = 0\n    last_worn_day = -1\n    \n    # Iterate through each day in the schedule\n    for i in range(N):\n        if S[i] == '1':  # Going out for a meal\n            if M > 0:  # Use a plain T-shirt if available\n                M -= 1\n            else:\n                logo_needed += 1  # Need a logo T-shirt\n        elif S[i] == '2':  # Attending a competitive programming event\n            logo_needed += 1  # Need a logo T-shirt\n        \n        # Update the last day a logo T-shirt was worn\n        if S[i] == '2':\n            last_worn_day = i\n    \n    # If there are still days left without a logo T-shirt after the last event day, add those days\n    logo_needed += max(0, N - 1 - last_worn_day)\n    \n    return logo_needed\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    S = input().strip()\n    print(min_tshirts_to_buy(N, M, S))"
        ]
    },
    {
        "question_id": "abc332_d",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    H, W = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(H)]\n    B = [list(map(int, input().split())) for _ in range(H)]\n\n    # Convert grids to strings for easier comparison\n    def grid_to_str(grid):\n        return ''.join(' '.join(map(str, row)) for row in grid)\n\n    A_str = grid_to_str(A)\n    B_str = grid_to_str(B)\n\n    # Check if the grids can be made identical\n    if sorted(A_str) != sorted(B_str):\n        print(-1)\n        return\n\n    # Count the frequency of each number in both grids\n    A_count = Counter(sum(A, []))\n    B_count = Counter(sum(B, []))\n\n    # Check if the frequency of each number is the same in both grids\n    if A_count != B_count:\n        print(-1)\n        return\n\n    # Calculate the minimum number of swaps needed\n    def min_swaps(grid):\n        count = Counter()\n        for row in grid:\n            count.update(row)\n            row.sort(key=lambda x: count[x])\n        return sum((row.count(x) - 1) * row.count(x) // 2 for x in set(row))\n\n    min_ops = 0\n    for i in range(H):\n        if A[i] != B[i]:\n            min_ops += min_swaps([A[i], B[i]])\n            A[i], B[i] = B[i], A[i]\n\n    print(min_ops)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc333_a",
        "code_list": [
            "def main():\n    N = int(input())\n    result = str(N) * N\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc333_b",
        "code_list": [
            "def main():\n    # Define the coordinates of the vertices of the pentagon\n    coordinates = {'A': (0, 1), 'B': (0.5 * (1 + 5**0.5), 0), 'C': (1, -1), 'D': (0.5 * (1 - 5**0.5), 0), 'E': (-0.5, 1)}\n    \n    # Read the input\n    S1, S2 = input().split()\n    T1, T2 = input().split()\n    \n    # Calculate the distance between S1 and S2\n    S1_coords = coordinates[S1]\n    S2_coords = coordinates[S2]\n    distance_S1_S2 = ((S1_coords[0] - S2_coords[0])**2 + (S1_coords[1] - S2_coords[1])**2)**0.5\n    \n    # Calculate the distance between T1 and T2\n    T1_coords = coordinates[T1]\n    T2_coords = coordinates[T2]\n    distance_T1_T2 = ((T1_coords[0] - T2_coords[0])**2 + (T1_coords[1] - T2_coords[1])**2)**0.5\n    \n    # Check if the distances are equal\n    if distance_S1_S2 == distance_T1_T2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc333_c",
        "code_list": [
            "def generate_repunits(n):\n    repunits = []\n    current_repunit = 1\n    while len(repunits) < n:\n        repunits.append(current_repunit)\n        current_repunit = current_repunit * 10 + 1\n    return repunits\n\ndef find_nth_sum(n):\n    repunits = generate_repunits(100)  # Generate enough repunits for the problem constraints\n    sums = set()\n    \n    for i in range(len(repunits)):\n        for j in range(i, len(repunits)):\n            for k in range(j, len(repunits)):\n                sums.add(repunits[i] + repunits[j] + repunits[k])\n    \n    sorted_sums = sorted(sums)\n    return str(sorted_sums[n-1])\n\nif __name__ == \"__main__\":\n    N = int(input())\n    print(find_nth_sum(N))"
        ]
    },
    {
        "question_id": "abc333_d",
        "code_list": [
            "def dfs(node, parent, graph):\n    leaves = []\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            leaves.extend(dfs(neighbor, node, graph))\n    if len(leaves) == 0:\n        return [node]\n    return leaves\n\ndef min_operations_to_delete_vertex_1(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    leaves = dfs(1, -1, graph)\n    operations = 0\n    \n    while len(leaves) > 0:\n        new_leaves = []\n        for leaf in leaves:\n            parent = graph[leaf][0]\n            graph[parent].remove(leaf)\n            if len(graph[parent]) == 1:\n                new_leaves.append(parent)\n        leaves = new_leaves\n        operations += 1\n    \n    return operations\n\nif __name__ == \"__main__\":\n    N = int(input())\n    edges = []\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    print(min_operations_to_delete_vertex_1(N, edges))"
        ]
    },
    {
        "question_id": "abc333_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    events = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    # Initialize variables\n    potion_count = defaultdict(int)\n    monster_count = defaultdict(int)\n    max_potions = 0\n    min_max_potions = float('inf')\n    actions = []\n    \n    for i, (t, x) in enumerate(events):\n        if t == 1:\n            potion_count[x] += 1\n            max_potions = max(max_potions, potion_count[x])\n            actions.append(1)\n        else:\n            monster_count[x] += 1\n            if potion_count[x] > 0:\n                potion_count[x] -= 1\n                max_potions = max(max_potions - 1, 0)\n                actions.append(0)\n            else:\n                max_potions = max(max_potions - 1, 0)\n                actions.append(0)\n        \n        # Update min_max_potions\n        if all(potion_count[m] >= monster_count[m] for m in monster_count):\n            min_max_potions = min(min_max_potions, max_potions)\n    \n    if min_max_potions == float('inf'):\n        print(-1)\n    else:\n        print(min_max_potions)\n        print(*actions)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc334_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    B, G = map(int, input().split())\n    if B > G:\n        print(\"Bat\")\n    else:\n        print(\"Glove\")"
        ]
    },
    {
        "question_id": "abc334_b",
        "code_list": [
            "def main():\n    A, M, L, R = map(int, input().split())\n    if M == 0:\n        print(0)\n        return\n    if L > R:\n        print(0)\n        return\n    # Adjust A, L, and R to be within the same period [0, M)\n    A = A % M\n    L = L % M\n    R = R % M\n    if A < L:\n        L -= A\n        R -= A\n        A = 0\n    else:\n        L -= A\n        R -= A\n        A = 0\n    if L < 0:\n        L += M\n    if R < 0:\n        R += M\n    if L > R:\n        print(0)\n        return\n    # Calculate the number of Christmas trees\n    if L == 0:\n        ans = (R // M) + 1\n    else:\n        ans = (R // M) - (L - 1) // M\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc334_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:K+2]))\n    \n    # Calculate the number of socks for each color\n    socks_count = [0] * (N + 1)\n    for i in range(1, N - K + 1):\n        socks_count[i] = 2\n    \n    for a in A:\n        socks_count[a] -= 1\n    \n    # Sort the available colors\n    available_colors = sorted([i for i in range(1, N - K + 1) if socks_count[i] > 0])\n    \n    # Calculate the minimum weirdness\n    weirdness = 0\n    i, j = 0, len(available_colors) - 1\n    while i <= j:\n        if socks_count[available_colors[i]] >= 2:\n            weirdness += abs(available_colors[i] - available_colors[j])\n            socks_count[available_colors[i]] -= 2\n            i += 1\n        elif socks_count[available_colors[j]] >= 2:\n            weirdness += abs(available_colors[i] - available_colors[j])\n            socks_count[available_colors[j]] -= 2\n            j -= 1\n        else:\n            break\n    \n    print(weirdness)"
        ]
    },
    {
        "question_id": "abc334_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, q = data[0], data[1]\n    reindeer_needed = data[2:n+2]\n    queries = data[n+2:]\n\n    # Calculate prefix sums\n    prefix_sums = [0]\n    for r in reindeer_needed:\n        prefix_sums.append(prefix_sums[-1] + r)\n\n    # Process each query\n    for x in queries:\n        # Find the largest index i such that prefix_sums[i] <= x\n        left, right = 0, n + 1\n        while left < right - 1:\n            mid = (left + right) // 2\n            if prefix_sums[mid] <= x:\n                left = mid\n            else:\n                right = mid\n        print(left)"
        ]
    },
    {
        "question_id": "abc334_e",
        "code_list": [
            "from collections import defaultdict\nfrom math import comb\n\ndef count_green_components(grid):\n    def dfs(x, y):\n        if x < 0 or x >= h or y < 0 or y >= w or grid[x][y] != '#':\n            return\n        grid[x][y] = '.'\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(x + dx, y + dy)\n\n    h, w = len(grid), len(grid[0])\n    components = 0\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '#':\n                dfs(i, j)\n                components += 1\n    return components\n\ndef solve():\n    h, w = map(int, input().split())\n    grid = [input() for _ in range(h)]\n    \n    total_red = sum(row.count('.') for row in grid)\n    green_components = count_green_components(grid)\n    \n    mod = 998244353\n    \n    # Calculate the expected value\n    expected_value = green_components\n    for i in range(1, total_red + 1):\n        new_components = green_components + 1 - (grid[i // w][i % w] == '#')\n        expected_value += new_components * comb(total_red, i) * pow(comb(total_red, i), mod - 2, mod)\n        expected_value %= mod\n    \n    print(expected_value)\n\nif __name__ == \"__main__\":\n    solve()"
        ]
    },
    {
        "question_id": "abc335_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    S = S[:-4] + '2024'\n    print(S)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc335_b",
        "code_list": [
            "def generate_triples(N):\n    for x in range(N + 1):\n        for y in range(x + 1):\n            for z in range(y + 1):\n                if x + y + z <= N:\n                    print(f\"{x} {y} {z}\")\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    generate_triples(N)"
        ]
    },
    {
        "question_id": "abc335_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    Q = int(data[1])\n    queries = [(int(data[i * 3 + 2]), data[i * 3 + 3], int(data[i * 3 + 4])) for i in range(Q)]\n\n    # Initialize the positions of the dragon parts\n    positions = [[i, 0] for i in range(1, N + 1)]\n\n    def move_head(direction):\n        if direction == 'U':\n            positions[0][1] += 1\n        elif direction == 'D':\n            positions[0][1] -= 1\n        elif direction == 'R':\n            positions[0][0] += 1\n        elif direction == 'L':\n            positions[0][0] -= 1\n\n    def follow_parts():\n        for i in range(1, N):\n            positions[i][0] = positions[i - 1][0]\n            positions[i][1] = positions[i - 1][1]\n\n    for query_type, direction, part in queries:\n        if query_type == 1:\n            move_head(direction)\n            follow_parts()\n        else:\n            print(positions[part - 1][0], positions[part - 1][1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc335_d",
        "code_list": [
            "def main():\n    N = int(input())\n    # Initialize the grid with zeros\n    grid = [[0] * N for _ in range(N)]\n    \n    # Place Takahashi at the center\n    center = (N // 2, N // 2)\n    grid[center[0]][center[1]] = 'T'\n    \n    # Define the directions for moving to the next cell\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Start from the top-left corner and fill the grid\n    current = 1\n    x, y = 0, 0\n    while current < N * N:\n        grid[x][y] = current\n        dx, dy = directions[current % 4]\n        nx, ny = x + dx, y + dy\n        \n        # Check if the next cell is valid and not taken\n        if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 0:\n            x, y = nx, ny\n        else:\n            # Change direction\n            dx, dy = directions[(current % 4) + 1]\n            nx, ny = x + dx, y + dy\n            x, y = nx, ny\n        \n        current += 1\n    \n    # Fill the last cell with the remaining number\n    grid[x][y] = N * N\n    \n    # Print the grid\n    for row in grid:\n        print(' '.join(str(x) if x != 'T' else 'T' for x in row))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_a",
        "code_list": [
            "def main():\n    N = int(input())\n    dragon_string = 'L' + 'o' * N + 'n' + 'g'\n    print(dragon_string)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_b",
        "code_list": [
            "def main():\n    N = int(input())\n    ctz = 0\n    while N % 2 == 0 and N > 0:\n        ctz += 1\n        N //= 2\n    print(ctz)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_c",
        "code_list": [
            "def main():\n    N = int(input())\n    result = \"\"\n    \n    while N > 0:\n        # Calculate the index for the current digit\n        index = (N - 1) % 5\n        # Determine the current digit based on the index\n        if index == 0:\n            digit = \"0\"\n        elif index == 1:\n            digit = \"2\"\n        elif index == 2:\n            digit = \"4\"\n        elif index == 3:\n            digit = \"6\"\n        else:\n            digit = \"8\"\n        # Prepend the digit to the result\n        result = digit + result\n        # Move to the next group of 5 digits\n        N = (N - 1) // 5\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_d",
        "code_list": [
            "def max_pyramid_sequence_size(N, A):\n    # Count the frequency of each element in the sequence\n    freq = [0] * (max(A) + 1)\n    for num in A:\n        freq[num] += 1\n    \n    # Calculate the maximum possible pyramid size\n    left = 0\n    right = len(A) - 1\n    k = 1\n    while left <= right:\n        if freq[k] > 0:\n            if k <= (len(A) + 1) // 2:\n                left += freq[k]\n            else:\n                right -= freq[k]\n        else:\n            k += 1\n        if left > right:\n            break\n        k += 1\n    \n    return min(k - 1, len(A))\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(max_pyramid_sequence_size(N, A))"
        ]
    },
    {
        "question_id": "abc337_a",
        "code_list": [
            "def main():\n    N = int(input())\n    takahashi_score = 0\n    aoki_score = 0\n    \n    for _ in range(N):\n        X, Y = map(int, input().split())\n        takahashi_score += X\n        aoki_score += Y\n    \n    if takahashi_score > aoki_score:\n        print(\"Takahashi\")\n    elif takahashi_score < aoki_score:\n        print(\"Aoki\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc337_b",
        "code_list": [
            "def is_extended_abc(s):\n    count_a = s.count('A')\n    count_b = s.count('B')\n    count_c = s.count('C')\n    \n    # Check if the counts are multiples of each other\n    if count_a > 0 and count_b > 0 and count_c > 0:\n        if count_a % count_b == 0 and count_b % count_c == 0:\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    if is_extended_abc(s):\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        ]
    },
    {
        "question_id": "abc337_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_front_people(arrangement):\n        n = len(arrangement)\n        front_people = []\n        for i in range(n):\n            if arrangement[i] == -1:\n                front_people.append(i + 1)\n        return front_people\n    \n    def arrange_people(front_people, arrangement):\n        arranged = [0] * n\n        for person in front_people:\n            arranged[person - 1] = person\n        for i in range(n):\n            if arrangement[i] != -1:\n                arranged[arrangement[i] - 1] = i + 1\n        return arranged\n    \n    n = int(input())\n    arrangement = list(map(int, input().split()))\n    \n    front_people = find_front_people(arrangement)\n    arranged_people = arrange_people(front_people, arrangement)\n    \n    print(' '.join(map(str, arranged_people)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc337_d",
        "code_list": [
            "def main():\n    H, W, K = map(int, input().split())\n    grid = [input() for _ in range(H)]\n\n    # Check horizontal sequences\n    min_operations_hor = float('inf')\n    for i in range(H):\n        count_x = 0\n        start = None\n        for j in range(W):\n            if grid[i][j] == 'x':\n                count_x += 1\n                if start is None:\n                    start = j\n            elif count_x >= K:\n                min_operations_hor = min(min_operations_hor, j - start)\n                count_x = 0\n                start = None\n            elif count_x > 0:\n                min_operations_hor = min(min_operations_hor, j - start + 1)\n                count_x = 0\n                start = None\n\n    # Check vertical sequences\n    min_operations_ver = float('inf')\n    for j in range(W):\n        count_x = 0\n        start = None\n        for i in range(H):\n            if grid[i][j] == 'x':\n                count_x += 1\n                if start is None:\n                    start = i\n            elif count_x >= K:\n                min_operations_ver = min(min_operations_ver, i - start)\n                count_x = 0\n                start = None\n            elif count_x > 0:\n                min_operations_ver = min(min_operations_ver, i - start + 1)\n                count_x = 0\n                start = None\n\n    # Calculate minimum operations needed\n    if min_operations_hor == float('inf') and min_operations_ver == float('inf'):\n        print(-1)\n    else:\n        min_operations = min(min_operations_hor, min_operations_ver)\n        print(min_operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc337_e",
        "code_list": [
            "import sys\n\ndef main():\n    # Read the number of bottles\n    N = int(input())\n    \n    # Calculate the minimum number of friends needed\n    M = N.bit_length()\n    \n    # Print the number of friends to call\n    print(M)\n    \n    # Distribute the bottles among the friends\n    for i in range(M):\n        # For the i-th friend, we need to check which bottles are affected\n        # We use a bitmask to determine which bottles to give to the friend\n        # The i-th bit of the bitmask determines if the i-th friend gets the i-th bottle\n        # If the i-th bit is 1, the i-th friend gets the i-th bottle\n        # If the i-th bit is 0, the i-th friend does not get the i-th bottle\n        \n        # Create a bitmask for the i-th friend\n        bitmask = 1 << i\n        \n        # Determine which bottles to give to the i-th friend\n        bottles_for_friend = [j + 1 for j in range(N) if (bitmask & (1 << j)) != 0]\n        \n        # Print the number of bottles and the bottles themselves\n        print(len(bottles_for_friend), *bottles_for_friend)\n    \n    # Read the response from the judge\n    S = input()\n    \n    # Determine the spoiled bottle based on the responses\n    spoiled_bottle = 0\n    for i in range(M):\n        if S[i] == '1':\n            spoiled_bottle |= 1 << i\n    \n    # Print the number of the spoiled juice bottle\n    print(spoiled_bottle)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S[0].isupper() and S[1:].islower():\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_b",
        "code_list": [
            "def main():\n    from collections import Counter\n    \n    # Read input string\n    S = input().strip()\n    \n    # Count the frequency of each character\n    char_count = Counter(S)\n    \n    # Find the maximum frequency\n    max_freq = max(char_count.values())\n    \n    # Filter characters with the maximum frequency\n    max_chars = [char for char, count in char_count.items() if count == max_freq]\n    \n    # Sort the characters alphabetically and pick the first one\n    result = min(max_chars)\n    \n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_c",
        "code_list": [
            "def max_servings(N, Q, A, B):\n    min_A = float('inf')\n    min_B = float('inf')\n    \n    # Find the minimum requirements for making one serving of each dish\n    for i in range(N):\n        if A[i] > 0:\n            min_A = min(min_A, Q[i] // A[i])\n        if B[i] > 0:\n            min_B = min(min_B, Q[i] // B[i])\n    \n    # Calculate the maximum servings based on the minimum requirements\n    return min_A + min_B\n\nif __name__ == \"__main__\":\n    N = int(input())\n    Q = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    print(max_servings(N, Q, A, B))"
        ]
    },
    {
        "question_id": "abc338_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    N = data[0]\n    M = data[1]\n    X = data[2:M + 2]\n\n    # Calculate the initial length of the tour\n    length = 0\n    for i in range(M - 1):\n        if X[i] > X[i + 1]:\n            length += X[i] - X[i + 1]\n        else:\n            length += N - (X[i + 1] - X[i])\n\n    # Calculate the minimum possible length after closing each bridge\n    min_length = length\n    for i in range(M):\n        start = X[i]\n        end = X[(i + 1) % M]\n        if start > end:\n            min_length = min(min_length, length - (start - end))\n        else:\n            min_length = min(min_length, length - (end - start))\n\n    print(min_length)"
        ]
    },
    {
        "question_id": "abc338_e",
        "code_list": [
            "def is_intersecting(N, chords):\n    # Convert the problem into a simpler form by mapping each point to its relative position\n    points = [0] * (2 * N + 1)\n    for i in range(N):\n        A, B = chords[i]\n        points[A] += 1\n        points[B] -= 1\n    \n    # Calculate the cumulative sum of points to determine the relative positions\n    for i in range(1, 2 * N + 1):\n        points[i] += points[i - 1]\n    \n    # Check if any two chords intersect based on their relative positions\n    for i in range(N):\n        A, B = chords[i]\n        for j in range(i + 1, N):\n            C, D = chords[j]\n            if (points[C] > points[A] and points[D] > points[B]) or \\\n               (points[A] > points[C] and points[B] > points[D]):\n                return \"Yes\"\n    return \"No\"\n\ndef main():\n    N = int(input().strip())\n    chords = []\n    for _ in range(N):\n        A, B = map(int, input().strip().split())\n        chords.append((A, B))\n    print(is_intersecting(N, chords))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_f",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    def solve():\n        n, m = map(int, input().split())\n        edges = []\n        for _ in range(m):\n            u, v, w = map(int, input().split())\n            edges.append((u - 1, v - 1, w))\n        \n        # Build adjacency list\n        adj_list = defaultdict(list)\n        for u, v, w in edges:\n            adj_list[u].append((v, w))\n        \n        # Check if a walk exists\n        visited = [False] * n\n        def dfs(u):\n            visited[u] = True\n            for v, _ in adj_list[u]:\n                if not visited[v]:\n                    dfs(v)\n            return all(visited)\n        \n        if not dfs(0):\n            print(\"No\")\n            return\n        \n        # Find the minimum total weight of the edges traversed\n        def min_weight_walk():\n            dp = [[float('inf')] * n for _ in range(1 << n)]\n            dp[0][0] = 0\n            \n            for mask in range(1 << n):\n                for u in range(n):\n                    if mask & (1 << u):\n                        for v, w in adj_list[u]:\n                            next_mask = mask | (1 << v)\n                            dp[next_mask][v] = min(dp[next_mask][v], dp[mask][u] + w)\n            \n            min_weight = float('inf')\n            for u in range(n):\n                min_weight = min(min_weight, dp[(1 << n) - 1][u])\n            return min_weight if min_weight != float('inf') else None\n        \n        result = min_weight_walk()\n        if result is None:\n            print(\"No\")\n        else:\n            print(result)\n    \n    solve()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    parts = S.split('.')\n    last_part = parts[-1]\n    print(last_part)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_b",
        "code_list": [
            "def main():\n    H, W, N = map(int, input().split())\n    grid = [['.' for _ in range(W)] for _ in range(H)]\n    x, y = 0, 0\n    dx, dy = -1, 0  # Initial direction: up\n\n    for _ in range(N):\n        if grid[x][y] == '.':\n            grid[x][y] = '#'\n            dx, dy = dy, -dx  # Rotate 90 degrees clockwise\n        else:\n            grid[x][y] = '.'\n            dx, dy = -dy, dx  # Rotate 90 degrees counterclockwise\n        x, y = (x + dx) % H, (y + dy) % W\n\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    passengers = 0\n    \n    for i in range(1, 2 * n + 1, 2):\n        passengers += int(data[i])\n    \n    print(max(passengers, 0))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(start1, start2, grid):\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = set([start1])\n    queue = deque([(start1, start2, 0)])\n    \n    while queue:\n        (x1, y1), (x2, y2), steps = queue.popleft()\n        \n        if (x1, y1) == (x2, y2):\n            return steps\n        \n        for dx, dy in directions:\n            nx1, ny1 = x1 + dx, y1 + dy\n            nx2, ny2 = x2 + dx, y2 + dy\n            \n            if 0 <= nx1 < n and 0 <= ny1 < n and grid[nx1][ny1] != '#' and (nx1, ny1) not in visited:\n                visited.add((nx1, ny1))\n                queue.append(((nx1, ny1), (x2, y2), steps + 1))\n            \n            if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] != '#' and (nx2, ny2) not in visited:\n                visited.add((nx2, ny2))\n                queue.append(((x1, y1), (nx2, ny2), steps + 1))\n                \n    return -1\n\ndef main():\n    n = int(input())\n    grid = [input().strip() for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'P':\n                start1 = (i, j)\n                break\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'P' and (i, j) != start1:\n                start2 = (i, j)\n                break\n    \n    result = bfs(start1, start2, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_a",
        "code_list": [
            "def main():\n    # Read input from stdin\n    A, B, D = map(int, input().split())\n    \n    # Initialize the current term as the first term\n    current_term = A\n    \n    # Print the terms of the arithmetic sequence\n    while current_term <= B:\n        print(current_term, end=' ')\n        current_term += D\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_b",
        "code_list": [
            "def main():\n    Q = int(input())\n    A = []\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            A.append(query[1])\n        elif query[0] == 2:\n            print(A[-query[1]])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_c",
        "code_list": [
            "def main():\n    N = int(input())\n    total_cost = 0\n    \n    while N >= 2:\n        # Find the highest power of 2 less than or equal to N\n        highest_power_of_2 = 1 << (N.bit_length() - 1)\n        # Calculate the cost for the current operation\n        cost = N - highest_power_of_2\n        # Update the total cost\n        total_cost += cost\n        # Update N to the sum of the two new numbers added to the board\n        N = (N // 2) + ((N + 1) // 2)\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_d",
        "code_list": [
            "def min_time_to_clear_stages(N, stages):\n    # Initialize the dp array where dp[i] represents the minimum time to reach stage i\n    dp = [float('inf')] * (N + 1)\n    dp[1] = 0  # Initial stage takes no time to clear\n    \n    for i in range(1, N):\n        dp[i + 1] = min(dp[i + 1], dp[i] + stages[i][0])  # Option 1: Clear current stage directly\n        if stages[i][1] <= i:  # Check if we can jump to this stage\n            dp[i + 1] = min(dp[i + 1], dp[stages[i][1]] + stages[i][1])  # Option 2: Jump to another stage\n    \n    return dp[N]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    stages = []\n    for _ in range(N - 1):\n        A, B, X = map(int, input().split())\n        stages.append((A, B, X))\n    \n    print(min_time_to_clear_stages(N, stages))"
        ]
    },
    {
        "question_id": "abc340_e",
        "code_list": [
            "def main():\n    import collections\n    \n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    # Initialize the count of operations for each box\n    op_count = [0] * N\n    \n    for b in B:\n        op_count[b] += 1\n    \n    # Calculate the net change in each box\n    net_change = collections.defaultdict(int)\n    for i in range(N):\n        net_change[i] = A[i] + op_count[i]\n    \n    # Apply the operations to determine the final number of balls in each box\n    for b in B:\n        for _ in range(op_count[b]):\n            A[(b + op_count[b]) % N] += 1\n            op_count[(b + op_count[b]) % N] -= 1\n    \n    # Output the result\n    print(' '.join(map(str, A)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_a",
        "code_list": [
            "def main():\n    N = int(input())\n    result = '1' * (N + 1) + '0'\n    print(result[:2 * N + 1:2])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_b",
        "code_list": [
            "def max_currency(N, A, S, T):\n    total_units = sum(A)\n    for i in range(N - 2, -1, -1):\n        if A[i] >= S[i]:\n            A[i + 1] += A[i] - S[i]\n            A[i] = S[i]\n        else:\n            needed = S[i] - A[i]\n            A[i + 1] += A[i]\n            A[i] = 0\n            total_units -= needed\n            if A[i + 1] < S[i + 1]:\n                break\n    return total_units\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    S = [0] * (N - 1)\n    T = [0] * (N - 1)\n    for i in range(N - 1):\n        S[i], T[i] = map(int, input().split())\n    print(max_currency(N, A, S, T))"
        ]
    },
    {
        "question_id": "abc341_c",
        "code_list": [
            "def main():\n    H, W, N = map(int, input().split())\n    T = input()\n    S = [input() for _ in range(H)]\n    \n    directions = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}\n    positions = set()\n    \n    # Initial position must be land and not on the perimeter\n    for i in range(1, H-1):\n        for j in range(1, W-1):\n            if S[i][j] == '.':\n                positions.add((i, j))\n    \n    # Update positions based on the moves\n    for move in T:\n        new_positions = set()\n        for pos in positions:\n            x, y = pos\n            dx, dy = directions[move]\n            nx, ny = x + dx, y + dy\n            if S[nx][ny] == '.' and 1 <= nx < H-1 and 1 <= ny < W-1:\n                new_positions.add((nx, ny))\n        positions = new_positions\n    \n    print(len(positions))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_d",
        "code_list": [
            "def lcm(a, b):\n    from math import gcd\n    return a * b // gcd(a, b)\n\ndef count_divisible(n, m, x):\n    count = 0\n    # Count numbers divisible by n but not by m\n    count += (x // n) - (x // lcm(n, m))\n    # Count numbers divisible by m but not by n\n    count += (x // m) - (x // lcm(n, m))\n    return count\n\ndef find_kth_number(n, m, k):\n    low, high = 1, 10**12\n    while low < high:\n        mid = (low + high) // 2\n        if count_divisible(n, m, mid) >= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    print(find_kth_number(n, m, k))"
        ]
    },
    {
        "question_id": "abc341_e",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    S = input().strip()\n    \n    # Initialize variables\n    flip_points = set()\n    result = []\n    \n    # Process queries\n    for _ in range(Q):\n        query_type, L, R = map(int, input().split())\n        \n        if query_type == 1:\n            # Flip the characters in the range [L-1, R-1]\n            for i in range(L - 1, R):\n                if i % 2 == 0:\n                    flip_points.add(i)\n                else:\n                    flip_points.discard(i)\n        else:\n            # Check if the substring S[L-1:R] is a good string\n            substring = S[L - 1:R]\n            for i in range(len(substring) - 1):\n                if substring[i] == substring[i + 1]:\n                    result.append(\"No\")\n                    break\n            else:\n                result.append(\"Yes\")\n    \n    # Output results\n    for res in result:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_f",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    weights = list(map(int, input().split()))\n    pieces = list(map(int, input().split()))\n\n    # Build adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    # Priority queue to store (weight, vertex, pieces)\n    pq = []\n    for i, (w, p) in enumerate(zip(weights, pieces)):\n        if p > 0:\n            heapq.heappush(pq, (-w, i, p))\n\n    operations = 0\n\n    while pq:\n        w, x, p = heapq.heappop(pq)\n        w = -w\n        if p == 0:\n            continue\n\n        # Find all adjacent vertices with weight less than w\n        adjacent = [(y, adj_list[x]) for y in adj_list[x]]\n        for y, neighbors in adjacent:\n            if weights[y] < w:\n                heapq.heappush(pq, (-weights[y], y, pieces[y]))\n                pieces[y] += 1\n\n        pieces[x] -= 1\n        operations += 1\n\n    print(operations)"
        ]
    },
    {
        "question_id": "abc342_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    count = {}\n    for char in S:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    \n    for i, char in enumerate(S):\n        if count[char] == 1:\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc342_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_query(N, positions, A, B):\n        return positions[A - 1]\n    \n    N = int(input())\n    positions = list(map(int, input().split()))\n    Q = int(input())\n    \n    for _ in range(Q):\n        A, B = map(int, input().split())\n        result = process_query(N, positions, A, B)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc342_c",
        "code_list": [
            "def main():\n    import sys\n    \n    # Read input\n    N = int(input().strip())\n    S = input().strip()\n    Q = int(input().strip())\n    \n    # Initialize a dictionary to store replacements\n    replacements = {}\n    \n    # Process each operation\n    for _ in range(Q):\n        c, d = input().strip().split()\n        replacements[c] = d\n    \n    # Apply all replacements\n    result = ''.join(replacements.get(char, char) for char in S)\n    \n    # Print the final string\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc342_d",
        "code_list": [
            "import math\nfrom collections import Counter\n\ndef is_square(n):\n    return int(math.isqrt(n)) ** 2 == n\n\ndef count_square_pairs(N, A):\n    count = 0\n    factors_count = Counter()\n    \n    for a in A:\n        if a == 0:\n            count += len(A) - 1\n        else:\n            factors = []\n            for i in range(2, int(math.isqrt(a)) + 1):\n                exp = 0\n                while a % i == 0:\n                    a //= i\n                    exp += 1\n                if exp % 2 != 0:\n                    factors.append(i)\n            if a > 1:\n                factors.append(a)\n            \n            for factor in factors:\n                if is_square(a // (factor ** (factor % 2))):\n                    count += factors_count[factor]\n            for factor in factors:\n                factors_count[factor] += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(count_square_pairs(N, A))"
        ]
    },
    {
        "question_id": "abc342_e",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef process_trains(n, m, trains):\n    graph = defaultdict(list)\n    for l, d, k, c, A, B in trains:\n        for t in range(l, l + k * d, d):\n            graph[A].append((B, t + c))\n            graph[B].append((A, t))\n    return graph\n\ndef find_latest_times(n, m, trains):\n    graph = process_trains(n, m, trains)\n    dist = dijkstra(n, graph, n - 1)\n    result = []\n    for i in range(1, n):\n        if dist[i] == float('inf'):\n            result.append(\"Unreachable\")\n        else:\n            result.append(dist[i])\n    return result\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    trains = [tuple(map(int, input().split())) for _ in range(m)]\n    result = find_latest_times(n, m, trains)\n    for r in result:\n        print(r)"
        ]
    },
    {
        "question_id": "abc343_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    result = (A + B) % 10\n    while result == A + B:\n        result = (result + 1) % 10\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_input():\n        return [line.strip() for line in sys.stdin.readlines()]\n    \n    def parse_adjacency_matrix(input_lines):\n        n = int(input_lines[0])\n        adjacency_matrix = []\n        for line in input_lines[1:]:\n            row = list(map(int, line.split()))\n            adjacency_matrix.append(row)\n        return adjacency_matrix\n    \n    def find_neighbors(adjacency_matrix, vertex):\n        neighbors = []\n        for i in range(len(adjacency_matrix[vertex - 1])):\n            if adjacency_matrix[vertex - 1][i] == 1 and i + 1 != vertex:\n                neighbors.append(i + 1)\n        return sorted(neighbors)\n    \n    def print_neighbors(adjacency_matrix):\n        for i in range(1, len(adjacency_matrix) + 1):\n            neighbors = find_neighbors(adjacency_matrix, i)\n            print(' '.join(map(str, neighbors)))\n    \n    input_lines = read_input()\n    adjacency_matrix = parse_adjacency_matrix(input_lines)\n    print_neighbors(adjacency_matrix)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_c",
        "code_list": [
            "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef find_max_palindromic_cube(N):\n    for x in range(int(N**(1/3)), 0, -1):\n        cube = x ** 3\n        if is_palindrome(cube) and cube <= N:\n            return cube\n    return 1\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(find_max_palindromic_cube(N))"
        ]
    },
    {
        "question_id": "abc343_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, T = map(int, input().split())\n    score_changes = defaultdict(list)\n    \n    for _ in range(T):\n        A, B = map(int, input().split())\n        score_changes[A].append(B)\n    \n    times = sorted(score_changes.keys())\n    current_scores = [0] * N\n    score_counts = set()\n    result = []\n    \n    for time in times:\n        for i in score_changes[time]:\n            current_scores[time - 1] += i\n        score_counts.update(current_scores)\n        result.append(len(score_counts))\n    \n    # Handle remaining changes after the last time point\n    for i in range(times[-1], T):\n        for j in range(N):\n            current_scores[j] += 1\n        score_counts.update(current_scores)\n        result.append(len(score_counts))\n    \n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_e",
        "code_list": [
            "def main():\n    V1, V2, V3 = map(int, input().split())\n    \n    # Check if the given volumes can form the required configuration\n    if V1 + 3 * V2 + 6 * V3 != 3 * 7**3:\n        print(\"No\")\n        return\n    \n    # Calculate the total volume of the intersection of all three cubes\n    total_volume = 7**3\n    \n    # Calculate the volume of the intersection of exactly two cubes\n    V2_calculated = (total_volume - V1 - 2 * V3) / 3\n    \n    # Calculate the volume of the intersection of all three cubes\n    V3_calculated = (total_volume - V1 - 2 * V2_calculated) / 6\n    \n    # Check if the calculated volumes match the given volumes\n    if V2_calculated != V2 or V3_calculated != V3:\n        print(\"No\")\n        return\n    \n    # Determine the positions of the cubes\n    a1, b1, c1 = 0, 0, 0\n    a2, b2, c2 = 0, 7, 0\n    a3, b3, c3 = 7, 0, 0\n    \n    # Check if the given positions satisfy the conditions\n    if (V1, V2, V3) == (840, 84, 7):\n        print(\"Yes\")\n        print(a1, b1, c1, a2, b2, c2, a3, b3, c3)\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_d",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    T = sys.stdin.readline().strip()\n    N = int(sys.stdin.readline().strip())\n    \n    # Initialize the DP table\n    dp = {0: 0}\n    for char in T:\n        new_dp = defaultdict(lambda: float('inf'))\n        for state, cost in dp.items():\n            if state % 26 == ord(char) - ord('a'):\n                new_dp[state] = min(new_dp[state], cost)\n            else:\n                new_dp[state + 1] = min(new_dp[state + 1], cost + 1)\n        dp = new_dp\n    \n    # Check if we can form the target string T\n    if dp[ord(T[-1]) - ord('a')] == float('inf'):\n        print(-1)\n    else:\n        print(dp[ord(T[-1]) - ord('a')])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    start = S.find('|')\n    end = S.rfind('|')\n    result = S[:start] + S[end+1:]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_c",
        "code_list": [
            "def main():\n    import sys\n    from itertools import product\n    \n    def read_int():\n        return int(sys.stdin.readline().strip())\n    \n    def read_line():\n        return sys.stdin.readline().strip()\n    \n    def read_list():\n        return list(map(int, sys.stdin.readline().strip().split()))\n    \n    N = read_int()\n    A = read_list()\n    M = read_int()\n    B = read_list()\n    L = read_int()\n    C = read_list()\n    Q = read_int()\n    X = read_list()\n    \n    # Generate all possible sums of elements from A, B, and C\n    sums = set(a + b + c for a, b, c in product(A, B, C))\n    \n    # Check each X_i if it exists in the generated sums\n    for x in X:\n        if x in sums:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_b",
        "code_list": [
            "def main():\n    # Read input until 0 is encountered\n    numbers = []\n    while True:\n        try:\n            num = int(input())\n            if num == 0:\n                break\n            numbers.append(num)\n        except EOFError:\n            break\n    \n    # Print the numbers in reverse order\n    for num in reversed(numbers):\n        print(num)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_e",
        "code_list": [
            "from collections import deque\n\ndef main():\n    # Read input\n    N = int(input())\n    A = list(map(int, input().split()))\n    Q = int(input())\n    \n    # Initialize data structures\n    sequence = deque(A)\n    index_map = {val: idx for idx, val in enumerate(sequence)}\n    \n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            x, y = query[1], query[2]\n            idx = index_map[x]\n            del index_map[x]\n            sequence.insert(idx + 1, y)\n            index_map[y] = idx + 1\n        elif query[0] == 2:\n            x = query[1]\n            idx = index_map[x]\n            del index_map[x]\n            sequence.remove(x)\n    \n    # Output the result\n    print(' '.join(map(str, sequence)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc345_d",
        "code_list": [
            "def can_place_tiles(N, H, W, tiles):\n    # Helper function to check if a tile can fit in the grid at position (x, y)\n    def can_fit(x, y, tile):\n        a, b = tile\n        return x + a <= H and y + b <= W\n    \n    # Helper function to place a tile and mark the grid\n    def place_tile(x, y, tile, orientation, grid):\n        a, b = tile\n        if orientation == 'horizontal':\n            for i in range(a):\n                for j in range(b):\n                    grid[x + i][y + j] = True\n        else:  # vertical\n            for i in range(a):\n                for j in range(b):\n                    grid[x + i][y + j] = True\n    \n    # Helper function to check if the grid is fully covered\n    def is_covered(grid):\n        for row in grid:\n            if False in row:\n                return False\n        return True\n    \n    # Generate all possible tile orientations\n    tiles_orientations = [(a, b), (b, a)] for a, b in tiles\n    \n    # Backtracking function to try placing tiles\n    def backtrack(grid, index):\n        if index == len(tiles):\n            return is_covered(grid)\n        \n        for i in range(H):\n            for j in range(W):\n                if grid[i][j]:\n                    continue\n                for a, b in tiles_orientations[index]:\n                    if can_fit(i, j, (a, b)):\n                        place_tile(i, j, (a, b), 'horizontal', grid)\n                        if backtrack(grid, index + 1):\n                            return True\n                        place_tile(i, j, (a, b), 'vertical', grid)\n                        if backtrack(grid, index + 1):\n                            return True\n                        place_tile(i, j, (a, b), 'horizontal', grid)\n        return False\n    \n    # Initialize the grid\n    grid = [[False for _ in range(W)] for _ in range(H)]\n    \n    # Try to place all tiles\n    return \"Yes\" if backtrack(grid, 0) else \"No\"\n\nif __name__ == \"__main__\":\n    N, H, W = map(int, input().split())\n    tiles = [tuple(map(int, input().split())) for _ in range(N)]\n    print(can_place_tiles(N, H, W, tiles))"
        ]
    },
    {
        "question_id": "abc345_b",
        "code_list": [
            "def main():\n    X = int(input())\n    result = (X + 9) // 10\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_d",
        "code_list": [
            "def min_cost_to_make_good_string(N, S, costs):\n    # Initialize variables to keep track of the minimum cost\n    min_cost = float('inf')\n    current_cost = 0\n    \n    # Iterate through the string to find the minimum cost\n    for i in range(1, N):\n        if S[i] == S[i-1]:\n            # If the characters are the same, we need to change one of them\n            current_cost += min(int(S[i]), int(S[i-1])) * 2\n        else:\n            # If the characters are different, no change is needed\n            current_cost += 0\n        \n        # Update the minimum cost found so far\n        min_cost = min(min_cost, current_cost)\n        \n        # Reset current_cost for the next segment\n        current_cost -= min(int(S[i-1]), int(S[i]))\n    \n    return min_cost\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    costs = list(map(int, input().strip().split()))\n    \n    print(min_cost_to_make_good_string(N, S, costs))"
        ]
    },
    {
        "question_id": "abc346_b",
        "code_list": [
            "def main():\n    # Read input\n    W, B = map(int, input().split())\n    \n    # The repeating pattern of S\n    pattern = \"wbwbwwbwbwbw\"\n    \n    # Calculate the number of times the pattern needs to repeat to cover at least W 'w' and B 'b'\n    # Since the pattern has 12 characters, we need to find how many times it repeats\n    # We also need to check if the required counts fit within the pattern's structure\n    def can_form_substring(W, B):\n        # Count of 'w' and 'b' in the pattern\n        count_w = pattern.count('w')\n        count_b = pattern.count('b')\n        \n        # Check if the counts are non-zero\n        if count_w == 0 or count_b == 0:\n            return False\n        \n        # Calculate the number of full patterns needed\n        full_patterns = (W + B) // 12\n        \n        # Calculate remaining 'w' and 'b' needed after full patterns\n        remaining_w = W % count_w\n        remaining_b = B % count_b\n        \n        # Check if the remaining counts can be formed within the pattern\n        if remaining_w <= count_w and remaining_b <= count_b:\n            return True\n        \n        return False\n    \n    # Check if the substring can be formed\n    if can_form_substring(W, B):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    H, W, M = map(int, data[:3])\n    data = data[3:]\n    \n    row_colors = [0] * (H + 1)\n    col_colors = [0] * (W + 1)\n    color_count = {}\n    \n    for i in range(0, M * 3, 3):\n        T, A, X = int(data[i]), int(data[i+1]), int(data[i+2])\n        \n        if T == 1:\n            if row_colors[A] != 0:\n                old_color = row_colors[A]\n                del color_count[old_color]\n            row_colors[A] = X\n            color_count[X] = color_count.get(X, 0) + W\n        else:\n            if col_colors[A] != 0:\n                old_color = col_colors[A]\n                del color_count[old_color]\n            col_colors[A] = X\n            color_count[X] = color_count.get(X, 0) + H\n    \n    # Adjust counts based on overlaps\n    for i in range(1, H + 1):\n        if row_colors[i] != 0:\n            for j in range(1, W + 1):\n                if col_colors[j] != 0 and col_colors[j] != row_colors[i]:\n                    color_count[row_colors[i]] -= 1\n    \n    # Remove zero counts\n    color_count = {k: v for k, v in color_count.items() if v > 0}\n    \n    K = len(color_count)\n    print(K)\n    \n    for color, count in sorted(color_count.items()):\n        print(color, count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_a",
        "code_list": [
            "def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    for i in range(N - 1):\n        B = A[i] * A[i + 1]\n        print(B, end=' ' if i < N - 2 else '\\n')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_c",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Create a set to store the elements in A\n    A_set = set(A)\n    \n    # Calculate the sum of all numbers from 1 to K\n    total_sum = (K * (K + 1)) // 2\n    \n    # Subtract the sum of elements present in A from the total sum\n    missing_sum = total_sum - sum(A_set)\n    \n    # Print the result\n    print(missing_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc347_c",
        "code_list": [
            "def main():\n    N, A, B = map(int, input().split())\n    D = list(map(int, input().split()))\n    \n    # Calculate the modulo of the difference between the first plan and the start of the week\n    mod = (D[0] - 1) % (A + B)\n    \n    # Check if all plans can fall within the holiday period\n    for i in range(1, N):\n        if ((D[i] - 1) % (A + B)) != mod or ((D[i] - 1) % (A + B)) < A:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc347_a",
        "code_list": [
            "def main():\n    # Read input values\n    N, K = map(int, input().split())\n    \n    # Read the sequence A\n    A = list(map(int, input().split()))\n    \n    # Extract multiples of K and divide them by K\n    quotients = [a // K for a in A if a % K == 0]\n    \n    # Print the quotients in ascending order\n    print(' '.join(map(str, sorted(quotients))))"
        ]
    },
    {
        "question_id": "abc347_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    x_start = 2\n    \n    # Initialize the sequence A and the set S\n    A = [0] * N\n    S = set()\n    \n    # Process each query\n    for i in range(Q):\n        x = int(data[x_start + i])\n        if x in S:\n            S.remove(x)\n        else:\n            S.add(x)\n        \n        # Update the sequence A based on the current size of S\n        for j in S:\n            A[j - 1] += len(S)\n    \n    # Print the final sequence A\n    print(' '.join(map(str, A)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc347_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    n = len(S)\n    unique_substrings = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            unique_substrings.add(S[i:j])\n    \n    print(len(unique_substrings))"
        ]
    },
    {
        "question_id": "abc348_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    bean_dict = defaultdict(list)\n    \n    for _ in range(N):\n        A, C = map(int, input().split())\n        bean_dict[C].append(A)\n    \n    max_min_deliciousness = 0\n    \n    for colors in bean_dict.values():\n        colors.sort(reverse=True)\n        max_min_deliciousness = max(max_min_deliciousness, colors[-1])\n    \n    print(max_min_deliciousness)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_b",
        "code_list": [
            "import math\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef find_farthest_points(points):\n    n = len(points)\n    result = []\n    \n    for i in range(n):\n        max_distance = 0\n        farthest_point_id = i + 1\n        \n        for j in range(n):\n            if i != j:\n                distance = euclidean_distance(points[i], points[j])\n                if distance > max_distance:\n                    max_distance = distance\n                    farthest_point_id = j + 1\n        \n        result.append(farthest_point_id)\n    \n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = [(int(data[i]), int(data[i+1])) for i in range(1, 2*n+1, 2)]\n    \n    result = find_farthest_points(points)\n    for id in result:\n        print(id)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_a",
        "code_list": [
            "def main():\n    N = int(input())\n    result = ''.join(['o' if (i + 1) % 3 != 0 else 'x' for i in range(N)])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start, end, medicines):\n    h, w = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[[False for _ in range(h * w + 1)] for _ in range(w)] for _ in range(h)]\n    \n    def get_key(x, y, e):\n        return f\"{x},{y},{e}\"\n    \n    queue = deque([(start[0], start[1], 0)])\n    visited[start[0]][start[1]][0] = True\n    \n    while queue:\n        x, y, e = queue.popleft()\n        \n        if (x, y) == end:\n            return True\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < h and 0 <= ny < w and grid[nx][ny] != \"#\":\n                if grid[nx][ny] == \"T\":\n                    return True\n                \n                key = get_key(nx, ny, e)\n                if not visited[nx][ny][e]:\n                    visited[nx][ny][e] = True\n                    queue.append((nx, ny, e))\n                \n                for med_x, med_y, med_e in medicines:\n                    if (med_x, med_y) == (nx, ny):\n                        new_e = min(e, med_e)\n                        key = get_key(nx, ny, new_e)\n                        if not visited[nx][ny][new_e]:\n                            visited[nx][ny][new_e] = True\n                            queue.append((nx, ny, new_e))\n    \n    return False\n\ndef main():\n    h, w = map(int, input().split())\n    grid = [input() for _ in range(h)]\n    n = int(input())\n    medicines = []\n    \n    for _ in range(n):\n        r, c, e = map(int, input().split())\n        medicines.append((r - 1, c - 1, e))\n    \n    s_x, s_y = next((i, j) for i in range(h) for j in range(w) if grid[i][j] == \"S\")\n    t_x, t_y = next((i, j) for i in range(h) for j in range(w) if grid[i][j] == \"T\")\n    \n    if bfs(grid, (s_x, s_y), (t_x, t_y), medicines):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_e",
        "code_list": [
            "from collections import defaultdict\n\ndef dfs(node, parent, graph, c, subtree_size, total_edges):\n    subtree_sum = c[node - 1]\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            subtree_sum += dfs(neighbor, node, graph, c, subtree_size, total_edges)\n    subtree_size[node] = subtree_sum\n    return subtree_sum\n\ndef calculate_f(node, parent, graph, c, subtree_size, total_edges):\n    result = subtree_size[node] * 2\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            result += calculate_f(neighbor, node, graph, c, subtree_size, total_edges)\n    return result\n\ndef find_min_f(n, edges, c):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    subtree_size = [0] * (n + 1)\n    total_edges = sum(c) // 2\n    \n    dfs(1, -1, graph, c, subtree_size, total_edges)\n    \n    min_f = float('inf')\n    for i in range(1, n + 1):\n        f_value = calculate_f(i, -1, graph, c, subtree_size, total_edges)\n        min_f = min(min_f, f_value)\n    \n    return min_f\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n    c = list(map(int, input().split()))\n    \n    print(find_min_f(n, edges, c))"
        ]
    },
    {
        "question_id": "abc349_c",
        "code_list": [
            "def is_airport_code(S: str, T: str) -> bool:\n    # Check if T can be formed by taking a subsequence of length 3 from S and converting it to uppercase\n    for i in range(len(S) - 2):\n        for j in range(i + 1, len(S) - 1):\n            for k in range(j + 1, len(S)):\n                if S[i] == T[0] and S[j] == T[1] and S[k] == T[2]:\n                    return True\n    \n    # Check if T can be formed by taking a subsequence of length 2 from S, converting it to uppercase, and appending 'X'\n    for i in range(len(S) - 1):\n        for j in range(i + 1, len(S)):\n            if S[i] == T[0] and S[j] == T[1] and T[2] == 'X':\n                return True\n    \n    return False\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    T = input().strip()\n    print(\"Yes\" if is_airport_code(S, T) else \"No\")"
        ]
    },
    {
        "question_id": "abc349_a",
        "code_list": [
            "def calculate_final_score(N, A):\n    # Calculate the total change in scores for all pairs except the last person\n    total_change = sum(A)\n    # The final score of person N is the negative of the total change\n    final_score_N = -total_change\n    return final_score_N\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(calculate_final_score(N, A))"
        ]
    },
    {
        "question_id": "abc349_b",
        "code_list": [
            "from collections import Counter\n\ndef is_good_string(S):\n    # Count the frequency of each character in the string\n    char_freq = Counter(S)\n    \n    # Count how many characters have the same frequency\n    freq_count = Counter(char_freq.values())\n    \n    # Check the conditions for a good string\n    for freq, count in freq_count.items():\n        if freq > 2 or (freq == 1 and count != 1) or (freq % 2 != 0 and count != 1):\n            return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(is_good_string(S))"
        ]
    },
    {
        "question_id": "abc349_d",
        "code_list": [
            "def find_good_sequences(L, R):\n    def find_min_power_of_two(n):\n        power = 0\n        while n > 0:\n            n >>= 1\n            power += 1\n        return power - 1\n\n    def find_good_sequence(L, R):\n        power = find_min_power_of_two(R - L)\n        start = 2 ** power * (L // (2 ** power))\n        end = min(start + 2 ** power, R)\n        return (start, end)\n\n    result = []\n    current = L\n    while current < R:\n        next_seq = find_good_sequence(current, R)\n        result.append(next_seq)\n        current = next_seq[1]\n\n    return len(result), result\n\ndef main():\n    L, R = map(int, input().split())\n    M, sequences = find_good_sequences(L, R)\n    print(M)\n    for seq in sequences:\n        print(seq[0], seq[1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc349_e",
        "code_list": [
            "def main():\n    # Read input\n    grid = []\n    for _ in range(3):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to check if a player can win in the next move\n    def can_win(grid, player):\n        for i in range(3):\n            for j in range(3):\n                if grid[i][j] == 0:\n                    grid[i][j] = 1 if player == 'T' else -1\n                    if check_win(grid, player):\n                        return True\n                    grid[i][j] = 0\n        return False\n    \n    # Function to check if a player can win in the current state\n    def check_win(grid, player):\n        # Check rows and columns\n        for i in range(3):\n            if sum(grid[i]) == 3 if player == 'T' else sum(grid[i]) == -3:\n                return True\n            if sum(grid[j][i] for j in range(3)) == 3 if player == 'T' else sum(grid[j][i] for j in range(3)) == -3:\n                return True\n        \n        # Check diagonals\n        if sum(grid[i][i] for i in range(3)) == 3 if player == 'T' else sum(grid[i][i] for i in range(3)) == -3:\n            return True\n        if sum(grid[i][2-i] for i in range(3)) == 3 if player == 'T' else sum(grid[i][2-i] for i in range(3)) == -3:\n            return True\n        \n        return False\n    \n    # Main logic\n    if can_win(grid, 'T'):\n        print('Takahashi')\n    elif can_win(grid, 'A'):\n        print('Aoki')\n    else:\n        print('Takahashi')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S[:3] == \"ABC\" and 1 <= int(S[3:]) <= 349 and int(S[3:]) != 316:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_e",
        "code_list": [
            "import math\n\ndef min_expected_cost(N, A, X, Y):\n    # Initialize memoization table\n    memo = {}\n    \n    def dp(n):\n        if n == 0:\n            return 0\n        if n < A:\n            return float('inf')\n        if (n, A, X, Y) in memo:\n            return memo[(n, A, X, Y)]\n        \n        # Calculate the cost of the floor division operation\n        cost_divide = X + dp(math.floor(n / A))\n        \n        # Calculate the expected cost of rolling the die\n        expected_roll = sum(dp(math.floor(n / b)) for b in range(1, 7)) / 6 + Y\n        \n        # Store the result in memoization table\n        memo[(n, A, X, Y)] = min(cost_divide, expected_roll)\n        \n        return memo[(n, A, X, Y)]\n    \n    return dp(N)\n\nif __name__ == \"__main__\":\n    N, A, X, Y = map(int, input().split())\n    print(min_expected_cost(N, A, X, Y))"
        ]
    },
    {
        "question_id": "abc350_b",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    treatments = list(map(int, input().split()))\n    \n    # Initialize the count of teeth\n    teeth_count = N\n    \n    # Process each treatment\n    for treatment in treatments:\n        if teeth_count > 0:\n            # If there is a tooth in the hole, remove it\n            if teeth_count >= treatment:\n                teeth_count -= 1\n            else:\n                # If there is no tooth, grow a new one\n                teeth_count += 1\n    \n    # Output the result\n    print(teeth_count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_int():\n        return int(sys.stdin.readline().strip())\n    \n    def read_line():\n        return sys.stdin.readline().strip().split()\n    \n    def read_list():\n        return list(map(int, read_line()))\n    \n    def swap_elements(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n    \n    N = read_int()\n    A = read_list()\n    \n    operations = []\n    for i in range(N - 1):\n        if A[i] != i + 1:\n            target_index = A.index(i + 1)\n            while target_index > i:\n                operations.append((i, target_index))\n                swap_elements(A, i, target_index)\n                target_index -= 1\n    \n    print(len(operations))\n    for op in operations:\n        print(op[0] + 1, op[1] + 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    graph = defaultdict(set)\n    \n    # Build the graph\n    for _ in range(M):\n        A, B = map(int, input().split())\n        graph[A].add(B)\n        graph[B].add(A)\n    \n    # Count the number of friends each user has\n    degree = [len(graph[i]) for i in range(1, N + 1)]\n    \n    # Calculate the maximum number of operations\n    max_operations = 0\n    for i in range(1, N + 1):\n        for j in graph[i]:\n            for k in graph[j]:\n                if k != i and k not in graph[i]:\n                    max_operations += 1\n    \n    # Each operation is counted twice, so divide by 2\n    max_operations //= 2\n    \n    print(max_operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_a",
        "code_list": [
            "def main():\n    # Read input\n    takahashi_scores = list(map(int, input().split()))\n    aoki_scores = list(map(int, input().split()))\n\n    # Calculate current scores\n    takahashi_total = sum(takahashi_scores)\n    aoki_total = sum(aoki_scores)\n\n    # Determine the minimum runs needed for Aoki to win\n    min_runs_needed = 1 if takahashi_total - aoki_total >= 0 else takahashi_total - aoki_total + 1\n\n    # Output the result\n    print(min_runs_needed)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_b",
        "code_list": [
            "def find_mismatched_cell(N, grid_A, grid_B):\n    for i in range(N):\n        for j in range(N):\n            if grid_A[i][j] != grid_B[i][j]:\n                return i + 1, j + 1\n\nif __name__ == \"__main__\":\n    N = int(input())\n    grid_A = [input() for _ in range(N)]\n    input()  # Skip the empty line between grid A and grid B\n    grid_B = [input() for _ in range(N)]\n    \n    i, j = find_mismatched_cell(N, grid_A, grid_B)\n    print(i, j)"
        ]
    },
    {
        "question_id": "abc351_e",
        "code_list": [
            "from collections import defaultdict, deque\nimport sys\n\ndef bfs(start, end, points):\n    queue = deque([start])\n    visited = set([start])\n    steps = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            x, y = queue.popleft()\n            if (x, y) == end:\n                return steps\n            \n            for dx, dy in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in points and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        steps += 1\n    \n    return float('inf')\n\ndef calculate_distances(points):\n    distances = defaultdict(int)\n    n = len(points)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = bfs(points[i], points[j], points)\n            distances[(points[i], points[j])] = dist\n            distances[(points[j], points[i])] = dist\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = []\n    \n    for i in range(1, n * 2 + 1, 2):\n        points.append((int(data[i]), int(data[i + 1])))\n    \n    distances = calculate_distances(points)\n    \n    result = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            result += distances[(points[i], points[j])]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_f",
        "code_list": [
            "def main():\n    import sys\n    \n    def calculate_expression(N, A):\n        prefix_sum = [0]\n        for a in A:\n            prefix_sum.append(prefix_sum[-1] + a)\n        \n        result = 0\n        for i in range(N):\n            left = i + 1\n            right = N\n            while left < right:\n                mid = (left + right) // 2\n                if A[mid] - A[i] > 0:\n                    right = mid\n                else:\n                    left = mid + 1\n            \n            for j in range(left, N):\n                result += max(A[j] - A[i], 0)\n        \n        return result\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    print(calculate_expression(N, A))"
        ]
    },
    {
        "question_id": "abc351_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_operations(N, A):\n        sequence = []\n        for i in range(N):\n            sequence.append(2 ** A[i])\n            while len(sequence) > 1 and sequence[-1] == sequence[-2]:\n                sequence.pop()\n                sequence.pop()\n                if len(sequence) > 1:\n                    sequence.append(sequence[-1] + sequence[-2])\n        \n        return len(sequence)\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    print(process_operations(N, A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start):\n    H, W = len(grid), len(grid[0])\n    visited = [[False] * W for _ in range(H)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    count = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        count += 1\n        \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and grid[nx][ny] != '#':\n                visited[nx][ny] = True\n                queue.append((nx, ny))\n    \n    return count\n\ndef main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    max_degree_of_freedom = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] != '#':\n                max_degree_of_freedom = max(max_degree_of_freedom, bfs(grid, (i, j)))\n    \n    print(max_degree_of_freedom)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_e",
        "code_list": [
            "from collections import defaultdict\nimport sys\ninput = sys.stdin.read\nsys.setrecursionlimit(10**7)\n\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x, y):\n    x, y = find(x), find(y)\n    if x == y:\n        return False\n    if par[x] > par[y]:\n        x, y = y, x\n    par[x] += par[y]\n    par[y] = x\n    return True\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef size(x):\n    return -par[find(x)]\n\ndef main():\n    N, M = map(int, input().split())\n    par = [-1] * N\n    edges = []\n    \n    for _ in range(M):\n        K, C = map(int, input().split())\n        A = list(map(int, input().split()))\n        for i in range(K):\n            for j in range(i + 1, K):\n                edges.append((C, A[i] - 1, A[j] - 1))\n    \n    edges.sort()\n    total_weight = 0\n    connected_components = N\n    \n    for w, u, v in edges:\n        if same(u, v):\n            continue\n        unite(u, v)\n        total_weight += w\n        connected_components -= 1\n    \n    if connected_components > 1:\n        print(-1)\n    else:\n        print(total_weight)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_a",
        "code_list": [
            "def main():\n    # Read input\n    N, X, Y, Z = map(int, input().split())\n    \n    # Determine if the train stops at station Z\n    if (X < Y and Z >= X and Z <= Y) or (X > Y and (Z >= Y + 1 - (X - Y) or Z <= Y)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_c",
        "code_list": [
            "import heapq\n\ndef main():\n    N = int(input())\n    AB = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    # Calculate the difference between head height and shoulder height for each giant\n    diff = [B - A for A, B in AB]\n    # Use a max heap to keep track of the largest differences\n    max_heap = []\n    for d in diff:\n        heapq.heappush(max_heap, -d)\n    \n    # Calculate the total height by summing up the shoulder heights and adding the largest differences\n    total_height = sum(A for A, B in AB)\n    while len(max_heap) > 1:\n        d1 = -heapq.heappop(max_heap)\n        d2 = -heapq.heappop(max_heap)\n        total_height += d1 + d2\n        heapq.heappush(max_heap, -(d1 + d2))\n    \n    print(total_height)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_b",
        "code_list": [
            "def find_correctly_typed_positions(S, T):\n    # Initialize variables\n    S_index = 0\n    T_index = 0\n    result = []\n\n    # Iterate through the string T\n    while T_index < len(T):\n        if S_index < len(S) and S[S_index] == T[T_index]:\n            # If the current character in S matches the current character in T, add the position to the result\n            result.append(T_index + 1)\n            S_index += 1\n        elif T[T_index] != S[S_index - 1]:\n            # If the current character in T does not match the previous character in S, it means it was mistakenly typed\n            pass\n        T_index += 1\n\n    return result\n\ndef main():\n    S = input().strip()\n    T = input().strip()\n    result = find_correctly_typed_positions(S, T)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_d",
        "code_list": [
            "from collections import defaultdict\n\ndef find_min_gap(N, K, P):\n    # Create a dictionary to store the positions of each number in the permutation\n    pos = defaultdict(list)\n    for i, num in enumerate(P):\n        pos[num].append(i)\n\n    min_gap = float('inf')\n    # Iterate through each possible starting position for the subsequence\n    for start in range(1, K + 1):\n        end = start + K - 1\n        # Check if the subsequence of length K starting from pos[start] contains K consecutive numbers\n        if len(pos[P[start]]) == 1:\n            continue\n        for i in range(len(pos[P[start]]) - 1):\n            if pos[P[start]][i] + K - 1 >= N:\n                break\n            if pos[P[start]][i + 1] - pos[P[start]][i] == K:\n                min_gap = min(min_gap, pos[P[start]][i + 1] - pos[P[start]][i] - K + 1)\n                break\n\n    return min_gap\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    P = list(map(int, input().split()))\n    print(find_min_gap(N, K, P))"
        ]
    },
    {
        "question_id": "abc353_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def f(x, y):\n        return (x + y) % 100000000\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = (prefix_sum[i - 1] + a[i - 1]) % 100000000\n    \n    result = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            result += f(a[i], a[j])\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_b",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    started_count = 0\n    empty_seats = K\n    \n    while A:\n        if empty_seats < A[0]:\n            started_count += 1\n            empty_seats = K\n        else:\n            empty_seats -= A[0]\n            A.pop(0)\n            if empty_seats == K:\n                started_count += 1\n    \n    print(started_count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_a",
        "code_list": [
            "def main():\n    # Read input\n    N = int(input())\n    heights = list(map(int, input().split()))\n    \n    # Check if any building is taller than the first one\n    for i in range(1, N):\n        if heights[i] > heights[0]:\n            print(i + 1)\n            return\n    \n    # If no building is taller, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_e",
        "code_list": [
            "def longest_common_prefix_length(s1, s2):\n    min_len = min(len(s1), len(s2))\n    for i in range(min_len):\n        if s1[i] != s2[i]:\n            return i\n    return min_len\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    strings = data[1:]\n    \n    total_sum = 0\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            total_sum += longest_common_prefix_length(strings[i], strings[j])\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_d",
        "code_list": [
            "def f(x, y):\n    return int(str(x) + str(y))\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    mod = 998244353\n    total_sum = 0\n    \n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            total_sum += f(A[i], A[j]) % mod\n    \n    print(total_sum % mod)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    users = []\n    for i in range(1, n * 2 + 1, 2):\n        users.append((data[i], int(data[i + 1])))\n\n    # Sort users based on lexicographical order of their names\n    users.sort(key=lambda x: x[0])\n\n    # Calculate the sum of ratings\n    total_rating = sum(user[1] for user in users)\n\n    # Find the winner's index\n    winner_index = total_rating % n\n\n    # Print the winner's username\n    print(users[winner_index][0])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_a",
        "code_list": [
            "def main():\n    H = int(input())\n    i = 0\n    while (1 << i) - 1 < H:\n        i += 1\n    print(i)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = []\n    b = []\n    for i in range(1, n * 2 + 1, 2):\n        a.append(int(data[i]))\n        b.append(int(data[i + 1]))\n    \n    same_a = 0\n    same_b = 0\n    diff_a = set(a)\n    diff_b = set(b)\n    \n    for i in range(n):\n        if a[i] in diff_b:\n            same_a += 1\n        if b[i] in diff_a:\n            same_b += 1\n    \n    total_same = same_a + same_b\n    total_diff = n - total_same\n    \n    if (total_same % 2 == 0 and total_diff % 2 != 0) or (total_same % 2 != 0 and total_diff % 2 == 0):\n        print(\"Takahashi\")\n    else:\n        print(\"Aoki\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    strengths = []\n    costs = []\n    indices = []\n    \n    for i in range(1, n * 2 + 1, 2):\n        strengths.append(int(data[i]))\n        costs.append(int(data[i + 1]))\n        indices.append(i // 2 + 1)\n    \n    # Sort by cost, then by strength\n    sorted_indices = [x for _, x in sorted(zip(costs, indices))]\n    strengths = [strengths[i] for i in sorted_indices]\n    costs = [costs[i] for i in sorted_indices]\n    \n    result = []\n    stack = []\n    \n    for i in range(n):\n        while stack and strengths[stack[-1]] < strengths[i] and costs[stack[-1]] > costs[i]:\n            stack.pop()\n        if not stack or strengths[stack[-1]] != strengths[i] or costs[stack[-1]] != costs[i]:\n            stack.append(i)\n    \n    result = [sorted_indices[i] for i in stack]\n    print(len(result))\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_d",
        "code_list": [
            "def main():\n    A, B, C, D = map(int, input().split())\n    # Calculate the area of the rectangle\n    width = C - A\n    height = D - B\n    \n    # Determine the color of the bottom-left corner (A, B)\n    color = (A + B) % 2\n    \n    # Determine the color of the top-right corner (C, D)\n    color_C_D = (C + D) % 2\n    \n    # Determine the color of the bottom-right corner (C, B)\n    color_C_B = (C + B) % 2\n    \n    # Determine the color of the top-left corner (A, D)\n    color_A_D = (A + D) % 2\n    \n    # Calculate the area of black regions based on the colors\n    if color == 0:\n        if color_C_D == 0:\n            if color_C_B == 0:\n                if color_A_D == 0:\n                    black_area = (width * height + 1) // 2\n                else:\n                    black_area = (width * height - 1) // 2\n            else:\n                if color_A_D == 0:\n                    black_area = (width * height + 1) // 2\n                else:\n                    black_area = (width * height - 1) // 2\n        else:\n            if color_C_B == 0:\n                if color_A_D == 0:\n                    black_area = (width * height + 1) // 2\n                else:\n                    black_area = (width * height - 1) // 2\n            else:\n                if color_A_D == 0:\n                    black_area = (width * height + 1) // 2\n                else:\n                    black_area = (width * height - 1) // 2\n    else:\n        if color_C_D == 0:\n            if color_C_B == 0:\n                if color_A_D == 0:\n                    black_area = (width * height - 1) // 2\n                else:\n                    black_area = (width * height + 1) // 2\n            else:\n                if color_A_D == 0:\n                    black_area = (width * height - 1) // 2\n                else:\n                    black_area = (width * height + 1) // 2\n        else:\n            if color_C_B == 0:\n                if color_A_D == 0:\n                    black_area = (width * height - 1) // 2\n                else:\n                    black_area = (width * height + 1) // 2\n            else:\n                if color_A_D == 0:\n                    black_area = (width * height - 1) // 2\n                else:\n                    black_area = (width * height + 1) // 2\n    \n    # Print twice the area of black regions\n    print(black_area * 2)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_e",
        "code_list": [
            "import sys\n\ndef query(i, j):\n    print(f'? {i} {j}', flush=True)\n    return int(sys.stdin.readline().strip())\n\ndef solve(N, L, R):\n    def get_sum(start, end):\n        if start > end:\n            return 0\n        if start == end:\n            return query(0, start)\n        \n        i = 0\n        while 2**i * (j + 1) <= 2**N:\n            i += 1\n        i -= 1\n        \n        j = (start + 2**i - 1) // (2**i)\n        l = 2**i * j\n        r = 2**i * (j + 1) - 1\n        \n        if l >= start and r <= end:\n            return query(i, j)\n        elif l < start and r <= end:\n            return get_sum(start, r) + get_sum(l, end)\n        elif l >= start and r > end:\n            return get_sum(start, end)\n        else:\n            return get_sum(start, l - 1) + get_sum(r + 1, end)\n    \n    total_sum = get_sum(L, R)\n    print(f'! {total_sum % 100}', flush=True)\n\nif __name__ == \"__main__\":\n    N, L, R = map(int, input().split())\n    solve(N, L, R)"
        ]
    },
    {
        "question_id": "abc355_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Combine and sort A and B\n    C = sorted(A + B)\n\n    # Check for consecutive elements from A in C\n    for i in range(len(C) - 1):\n        if C[i] in A and C[i + 1] in A:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_c",
        "code_list": [
            "def main():\n    N, T = map(int, input().split())\n    grid = [[0] * N for _ in range(N)]\n    marked_rows = [0] * N\n    marked_cols = [0] * N\n    marked_diags = [0] * 2\n    \n    def mark_cell(i, j):\n        nonlocal marked_rows, marked_cols, marked_diags\n        grid[i][j] = 1\n        marked_rows[i] += 1\n        marked_cols[j] += 1\n        if i == j:\n            marked_diags[0] += 1\n        if i + j == N - 1:\n            marked_diags[1] += 1\n    \n    def check_bingo():\n        return any(marked_rows[i] == N for i in range(N)) or \\\n               any(marked_cols[j] == N for j in range(N)) or \\\n               marked_diags[0] == N or marked_diags[1] == N\n    \n    for turn, num in enumerate(map(int, input().split()), start=1):\n        i, j = divmod(num - 1, N)\n        mark_cell(i, j)\n        if check_bingo():\n            print(turn)\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    suspects = [1, 2, 3]\n    suspects.remove(A)\n    suspects.remove(B)\n    \n    if len(suspects) == 1:\n        print(suspects[0])\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_d",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_input():\n        return sys.stdin.read().splitlines()\n    \n    def parse_intervals(input_lines):\n        N = int(input_lines[0])\n        intervals = []\n        for line in input_lines[1:]:\n            l, r = map(int, line.split())\n            intervals.append((l, r))\n        return intervals\n    \n    def count_intersecting_pairs(intervals):\n        count = 0\n        for i in range(len(intervals)):\n            for j in range(i + 1, len(intervals)):\n                if intervals[i][0] < intervals[j][1] and intervals[j][0] < intervals[i][1]:\n                    count += 1\n        return count\n    \n    input_lines = read_input()\n    intervals = parse_intervals(input_lines)\n    result = count_intersecting_pairs(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "3334",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:\n        total_apples = sum(apple)\n        capacity.sort(reverse=True)\n        boxes_used = 0\n        \n        for box_capacity in capacity:\n            if total_apples <= 0:\n                break\n            total_apples -= box_capacity\n            boxes_used += 1\n        \n        return boxes_used"
        ]
    },
    {
        "question_id": "3351",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:\n        # Sort the happiness array in descending order\n        happiness.sort(reverse=True)\n        total_happiness = 0\n        \n        for i in range(k):\n            # Decrease the happiness value by the number of remaining selections\n            adjusted_happiness = max(0, happiness[i] - i)\n            total_happiness += adjusted_happiness\n        \n        return total_happiness"
        ]
    },
    {
        "question_id": "3356",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def shortestSubstrings(self, arr: List[str]) -> List[str]:\n        from collections import defaultdict\n        \n        # Function to generate all substrings of a string\n        def generate_substrings(s):\n            return {s[i:j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)}\n        \n        # Dictionary to store substrings of each string and their occurrences\n        substr_dict = defaultdict(set)\n        for i, s in enumerate(arr):\n            substr_dict[i] = generate_substrings(s)\n        \n        # Set to keep track of unique substrings across all strings\n        all_substrings = set()\n        for substrs in substr_dict.values():\n            all_substrings.update(substrs)\n        \n        # Filter out substrings that appear in more than one string\n        unique_substrings = {substr: idx for idx, substr_set in substr_dict.items() for substr in substr_set if len({idx for idx, substrs in substr_dict.items() if substr in substrs}) == 1}\n        \n        # Find the shortest and lexicographically smallest unique substring for each string\n        result = []\n        for i, s in enumerate(arr):\n            min_len = float('inf')\n            min_str = \"\"\n            for substr in substr_dict[i]:\n                if substr in unique_substrings and len(substr) < min_len:\n                    min_len = len(substr)\n                    min_str = substr\n                elif substr in unique_substrings and len(substr) == min_len and substr < min_str:\n                    min_str = substr\n            result.append(min_str)\n        \n        return result"
        ]
    },
    {
        "question_id": "3313",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumStrength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n        \n        for i in range(1, n + 1):\n            for j in range(1, min(i, k) + 1):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if i >= j:\n                    for m in range(j):\n                        dp[i][j] = max(dp[i][j], dp[i - (j - m)][m] + (prefix_sum[i] - prefix_sum[i - (j - m)]) * ((k - j + 1) * (-1) ** (m + 1)))\n        \n        return dp[n][k]"
        ]
    },
    {
        "question_id": "3353",
        "code_list": [
            "class Solution:\n    def isSubstringPresent(self, s: str) -> bool:\n        reverse_s = s[::-1]\n        for i in range(len(s) - 1):\n            if s[i:i+2] in reverse_s:\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3337",
        "code_list": [
            "class Solution:\n    def countSubstrings(self, s: str, c: str) -> int:\n        count = s.count(c)\n        return (count * (count + 1)) // 2"
        ]
    },
    {
        "question_id": "3360",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumDeletions(self, word: str, k: int) -> int:\n        char_freq = Counter(word)\n        max_freq = max(char_freq.values())\n        deletions = float('inf')\n        \n        for target_freq in range(max_freq, -1, -1):\n            current_deletions = 0\n            for freq in char_freq.values():\n                if freq > target_freq:\n                    current_deletions += freq - target_freq\n                    if current_deletions > deletions:\n                        break\n            else:\n                deletions = min(deletions, current_deletions + (max_freq - target_freq) * len(char_freq))\n        \n        return deletions"
        ]
    },
    {
        "question_id": "3327",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:\n        n = len(nums)\n        ones = [i for i, num in enumerate(nums) if num == 1]\n        m = len(ones)\n        if m < k:\n            return -1\n        \n        dp = [[float('inf')] * (k + 1) for _ in range(m + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, m + 1):\n            for j in range(k + 1):\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + abs(ones[i - 1] - ones[i - 2]))\n                if j < k and i < m:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n                if maxChanges > 0 and j < k and i < m:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1 + abs(ones[i - 1] - ones[i]))\n                    maxChanges -= 1\n        \n        return dp[m][k]"
        ]
    },
    {
        "question_id": "3349",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maximumLengthSubstring(self, s: str) -> int:\n        char_count = defaultdict(int)\n        left = 0\n        max_length = 0\n        \n        for right in range(len(s)):\n            char_count[s[right]] += 1\n            \n            while char_count[s[right]] > 2:\n                char_count[s[left]] -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3328",
        "code_list": [
            "class Solution:\n    def minOperations(self, k: int) -> int:\n        if k == 1:\n            return 0\n        \n        min_operations = float('inf')\n        \n        for i in range(1, k):\n            # Calculate the number of operations needed to reach at least k\n            # i is the target value after increasing some elements\n            # (k - 1) // i gives the number of duplications needed\n            # i - 1 gives the number of increments needed to reach i\n            operations = (k - 1) // i + (i - 1)\n            min_operations = min(min_operations, operations)\n        \n        return min_operations"
        ]
    },
    {
        "question_id": "3363",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:\n        id_count = Counter()\n        ans = []\n        for i in range(len(nums)):\n            id_count[nums[i]] += freq[i]\n            if id_count[nums[i]] == 0:\n                del id_count[nums[i]]\n            ans.append(max(id_count.values()) if id_count else 0)\n        return ans"
        ]
    },
    {
        "question_id": "3376",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:\n        n, m = len(wordsContainer), len(wordsQuery)\n        ans = [-1] * m\n        \n        for i in range(m):\n            query = wordsQuery[i]\n            max_len, min_len, idx = -1, float('inf'), -1\n            \n            for j in range(n):\n                container = wordsContainer[j]\n                if container.endswith(query):\n                    curr_len = len(container)\n                    if curr_len > max_len or (curr_len == max_len and len(container) < min_len):\n                        max_len = curr_len\n                        min_len = len(container)\n                        idx = j\n            \n            ans[i] = idx\n        \n        return ans"
        ]
    },
    {
        "question_id": "3371",
        "code_list": [
            "class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n        sum_of_digits = sum(int(digit) for digit in str(x))\n        if x % sum_of_digits == 0:\n            return sum_of_digits\n        else:\n            return -1"
        ]
    },
    {
        "question_id": "3374",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        i = 0\n        \n        while i < n:\n            j = i + 1\n            # Check for alternating subarray\n            while j < n and nums[j-1] != nums[j]:\n                j += 1\n            \n            # Number of alternating subarrays ending at j-1\n            length = j - i\n            count += length * (length + 1) // 2\n            i = j\n        return count"
        ]
    },
    {
        "question_id": "3344",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        n = len(points)\n        max_distances = []\n        \n        # Calculate all pairwise Manhattan distances\n        for i in range(n):\n            max_distance = 0\n            for j in range(i + 1, n):\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                max_distance = max(max_distance, dist)\n            max_distances.append(max_distance)\n        \n        # Find the minimum possible maximum distance after removing one point\n        min_max_distance = float('inf')\n        for i in range(n):\n            min_max_distance = min(min_max_distance, max(max_distances[:i] + max_distances[i+1:]))\n        \n        return min_max_distance"
        ]
    },
    {
        "question_id": "3372",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return len(nums)\n        \n        max_length = 1\n        current_length = 1\n        \n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            elif nums[i] < nums[i - 1]:\n                current_length = 2\n            else:\n                current_length = 1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3346",
        "code_list": [
            "from string import ascii_lowercase\n\nclass Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n        n = len(s)\n        result = list(s)\n        \n        for i in range(n):\n            char = s[i]\n            index = ascii_lowercase.index(char)\n            \n            # Calculate the minimum distance to change to 'a'\n            min_distance_to_a = (index + 26 - i) % 26\n            \n            # If we can change to 'a' within the remaining k\n            if k >= min_distance_to_a:\n                result[i] = 'a'\n                k -= min_distance_to_a\n            else:\n                # Otherwise, calculate the new character\n                new_index = (index - k) % 26\n                result[i] = ascii_lowercase[new_index]\n                break  # No need to continue as we found the first valid character\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "3387",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        mid_index = n // 2\n        \n        if nums[mid_index] == k:\n            return 0\n        \n        operations = 0\n        if nums[mid_index] < k:\n            # Increase elements up to the median index\n            for i in range(mid_index, n):\n                if nums[i] > k:\n                    break\n                operations += abs(nums[i] - k)\n        else:\n            # Decrease elements up to the median index\n            for i in range(mid_index, -1, -1):\n                if nums[i] < k:\n                    break\n                operations += abs(nums[i] - k)\n        \n        return operations"
        ]
    },
    {
        "question_id": "3361",
        "code_list": [
            "class Solution:\n    def findLatestTime(self, s: str) -> str:\n        # Function to determine if a digit can be placed at a given position\n        def can_place_digit(digit, pos):\n            if pos == 0:\n                return digit in ['0', '1']\n            elif pos == 1:\n                return digit in ['0', '1', '2', '3']\n            elif pos == 3:\n                return digit in ['0', '1', '2', '3', '4', '5']\n            elif pos == 4:\n                return digit in ['0', '1', '2', '3', '4', '5', '9']\n        \n        # Iterate from the last character to the first\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == '?':\n                # Determine the maximum digit that can be placed at this position\n                if i == 0 or i == 1:\n                    s = s[:i] + ('1' if s[i+1] in ['0', '1', '2', '3'] else '2') + s[i+1:]\n                elif i == 3:\n                    s = s[:i] + ('5' if s[i+1] in ['0', '1', '2', '3', '4'] else '9') + s[i+1:]\n                elif i == 4:\n                    s = s[:i] + ('9' if s[i-1] in ['0', '1'] else '3') + s[i+1:]\n                break\n        \n        return s"
        ]
    },
    {
        "question_id": "3373",
        "code_list": [
            "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nclass Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        primes = [i for i, num in enumerate(nums) if is_prime(num)]\n        if len(primes) < 2:\n            return 0\n        return max(primes) - min(primes)"
        ]
    },
    {
        "question_id": "3375",
        "code_list": [
            "from heapq import heappush, heappop\n\nclass Solution:\n    def findKthSmallest(self, coins: List[int], k: int) -> int:\n        heap = []\n        for coin in coins:\n            heappush(heap, coin)\n        \n        while k > 1:\n            smallest = heappop(heap)\n            while heap and heap[0] == smallest:\n                heappop(heap)\n            heappush(heap, smallest + smallest)\n            k -= 1\n        \n        return heappop(heap)"
        ]
    },
    {
        "question_id": "3364",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:\n        n, m = len(nums), len(andValues)\n        if n < m:\n            return -1\n        \n        # Function to check if we can form subarrays with given andValues\n        def can_form_subarrays():\n            target_and = andValues[-1]\n            for i in range(m-1):\n                target_and &= andValues[i]\n            \n            # Check if the first subarray can be formed\n            if nums[0] & target_and != andValues[0]:\n                return False\n            \n            current_and = nums[0]\n            start_index = 0\n            for i in range(1, n):\n                current_and &= nums[i]\n                if current_and == andValues[0]:\n                    start_index = i\n                    break\n            else:\n                return False\n            \n            # Form subarrays from the second one\n            prev_and = current_and\n            for i in range(1, m):\n                current_and = nums[start_index]\n                for j in range(start_index, n):\n                    current_and &= nums[j]\n                    if current_and == andValues[i]:\n                        start_index = j + 1\n                        break\n                else:\n                    return False\n                if current_and != prev_and:\n                    prev_and = current_and\n                else:\n                    return False\n            \n            return True\n        \n        if not can_form_subarrays():\n            return -1\n        \n        # Calculate the minimum possible sum of the values of the subarrays\n        subarray_values = []\n        current_and = nums[0]\n        start_index = 0\n        for i in range(1, n):\n            current_and &= nums[i]\n            if current_and == andValues[0]:\n                subarray_values.append(sum(nums[start_index:i+1]))\n                start_index = i + 1\n                current_and = nums[i]\n        subarray_values.append(sum(nums[start_index:]))\n        \n        return sum(subarray_values)"
        ]
    },
    {
        "question_id": "3367",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfEncryptedInt(self, nums: List[int]) -> int:\n        def encrypt(x: int) -> int:\n            max_digit = max(str(x))\n            return int(max_digit * len(str(x)))\n        \n        return sum(encrypt(num) for num in nums)"
        ]
    },
    {
        "question_id": "3306",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        marked = set()\n        min_heap = [(nums[i], i) for i in range(len(nums))]\n        heapq.heapify(min_heap)\n        total_sum = sum(nums)\n        result = []\n        \n        for index, k in queries:\n            if index not in marked:\n                marked.add(index)\n                total_sum -= nums[index]\n            while k > 0 and min_heap:\n                value, idx = heapq.heappop(min_heap)\n                if idx not in marked:\n                    marked.add(idx)\n                    total_sum -= value\n                    k -= 1\n            result.append(total_sum)\n        \n        return result"
        ]
    },
    {
        "question_id": "3354",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimizeStringValue(self, s: str) -> str:\n        # Count the frequency of each character in the string\n        char_count = Counter(s)\n        # List to store the characters to be used for replacement\n        replacements = []\n        # Result string\n        result = ''\n        \n        for char in s:\n            if char == '?':\n                # Find the character with the minimum frequency\n                min_char = 'a'\n                min_count = float('inf')\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if char_count[c] < min_count:\n                        min_char = c\n                        min_count = char_count[c]\n                # Add the chosen character to the result and the replacements list\n                result += min_char\n                replacements.append(min_char)\n                # Increment the count of the chosen character\n                char_count[min_char] += 1\n            else:\n                result += char\n        \n        # Sort the replacements list to get the lexicographically smallest string\n        replacements.sort()\n        # Replace '?' with sorted characters\n        for i, char in enumerate(replacements):\n            result = result[:i] + char + result[i+1:]\n        \n        return result"
        ]
    },
    {
        "question_id": "3345",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def sumOfPower(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Sort the array to optimize the solution\n        nums.sort()\n        n = len(nums)\n        dp = defaultdict(int)\n        dp[0] = 1  # Base case: empty subsequence has power 1\n        \n        total_power = 0\n        for num in nums:\n            new_dp = defaultdict(int)\n            for current_sum, count in dp.items():\n                new_sum = current_sum + num\n                if new_sum <= k:\n                    new_dp[new_sum] += count\n                    if new_sum == k:\n                        total_power = (total_power + count) % MOD\n            dp = new_dp\n        \n        return total_power"
        ]
    },
    {
        "question_id": "3381",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        min_length = float('inf')\n        \n        for start in range(n):\n            current_or = 0\n            for end in range(start, n):\n                current_or |= nums[end]\n                if current_or >= k:\n                    min_length = min(min_length, end - start + 1)\n                    break\n        \n        return min_length if min_length != float('inf') else -1"
        ]
    },
    {
        "question_id": "3355",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumLevels(self, possible: List[int]) -> int:\n        total_points = sum(1 if p == 1 else -1 for p in possible)\n        alice_points = 0\n        min_levels = float('inf')\n        \n        for i in range(len(possible) - 1):\n            alice_points += 2 * (possible[i] - 0.5)\n            bob_points = total_points - alice_points\n            if alice_points > bob_points:\n                min_levels = i + 1\n                break\n        \n        return min_levels if min_levels != float('inf') else -1"
        ]
    },
    {
        "question_id": "3316",
        "code_list": [
            "from typing import List\nimport itertools\n\nclass Solution:\n    def sumOfPowers(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        \n        def min_abs_diff(subseq):\n            return sum(abs(a - b) for a, b in itertools.combinations(subseq, 2))\n        \n        total_sum = 0\n        for subseq in itertools.combinations(nums, k):\n            total_sum += min_abs_diff(subseq)\n        \n        return total_sum % MOD"
        ]
    },
    {
        "question_id": "3379",
        "code_list": [
            "class Solution:\n    def scoreOfString(self, s: str) -> int:\n        return sum(abs(ord(s[i]) - ord(s[i+1])) for i in range(len(s)-1))"
        ]
    },
    {
        "question_id": "3382",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int]) -> int:\n        max_val = max(nums)\n        count_max = sum(1 for num in nums if num == max_val)\n        result = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == max_val:\n                left = 1\n                right = 1\n                for j in range(i + 1, len(nums)):\n                    if nums[j] == max_val:\n                        right += 1\n                    else:\n                        break\n                for k in range(i - 1, -1, -1):\n                    if nums[k] == max_val:\n                        left += 1\n                    else:\n                        break\n                result += left * right\n        \n        return result"
        ]
    },
    {
        "question_id": "3408",
        "code_list": [
            "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        seen_lower = set()\n        seen_upper = set()\n        \n        for char in word:\n            if char.islower():\n                seen_lower.add(char)\n            elif char.isupper():\n                seen_upper.add(char.lower())\n        \n        return len(seen_lower & seen_upper)"
        ]
    },
    {
        "question_id": "3397",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        for i in range(len(nums1)):\n            x = nums2[i] - nums1[i]\n            if all(nums1[j] + x == nums2[j] for j in range(len(nums1))):\n                return x"
        ]
    },
    {
        "question_id": "3394",
        "code_list": [
            "class Solution:\n    def minEnd(self, n: int, x: int) -> int:\n        # Precompute the maximum value that can be achieved with n-1 operations on x\n        max_val = x\n        for i in range(n - 1):\n            max_val |= (max_val << 1)\n        \n        return max_val"
        ]
    },
    {
        "question_id": "3362",
        "code_list": [
            "from typing import List\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def medianOfUniquenessArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = [0] * (n + 1)\n        last_occurrence = [-1] * (n + 1)\n        for i, num in enumerate(nums):\n            count[i + 1] = count[i] + (last_occurrence[num] != i)\n            last_occurrence[num] = i\n        \n        unique_counts = set()\n        for i in range(n + 1):\n            for j in range(i, n + 1):\n                unique_counts.add(len(set(nums[i:j])))\n        \n        unique_counts = sorted(unique_counts)\n        mid = (len(unique_counts) - 1) // 2\n        return unique_counts[mid]"
        ]
    },
    {
        "question_id": "3396",
        "code_list": [
            "class Solution:\n    def isValid(self, word: str) -> bool:\n        vowels = set('aeiouAEIOU')\n        consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n        if len(word) < 3:\n            return False\n        \n        has_vowel = any(char in vowels for char in word)\n        has_consonant = any(char in consonants for char in word)\n        has_only_valid_chars = all(char.isdigit() or char.isalpha() for char in word)\n        \n        return has_vowel and has_consonant and has_only_valid_chars"
        ]
    },
    {
        "question_id": "3384",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n        n = len(word)\n        prefix_count = [Counter() for _ in range(k)]\n        \n        # Count character frequencies in each segment of length k\n        for i in range(n):\n            prefix_count[i % k][word[i]] += 1\n        \n        # Check if the first k characters can form a k-periodic string\n        target = prefix_count[0].copy()\n        for i in range(1, k):\n            if prefix_count[i] != target:\n                return -1  # Not possible to make k-periodic\n        \n        # Calculate the minimum operations needed\n        operations = 0\n        for i in range(k):\n            current = prefix_count[i]\n            for char, count in current.items():\n                if target[char] > count:\n                    operations += target[char] - count\n        \n        return operations"
        ]
    },
    {
        "question_id": "3395",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minAnagramLength(self, s: str) -> int:\n        count_s = Counter(s)\n        unique_chars = set(s)\n        min_length = float('inf')\n        \n        for char in unique_chars:\n            current_count = count_s[char]\n            while current_count > 0:\n                is_valid = True\n                for i in range(len(s)):\n                    if s[i] == char:\n                        current_count -= 1\n                        if current_count < 0:\n                            is_valid = False\n                            break\n                        temp_count = count_s.copy()\n                        temp_count[s[i]] -= 1\n                        if all(temp_count[letter] >= 0 for letter in unique_chars):\n                            min_length = min(min_length, len(s) - i)\n                            break\n                if is_valid:\n                    break\n        \n        return min_length if min_length != float('inf') else len(s)"
        ]
    },
    {
        "question_id": "3402",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Calculate prefix sums for both costs\n        prefix_cost1 = [0]\n        prefix_cost2 = [0]\n        for num in nums:\n            prefix_cost1.append(prefix_cost1[-1] + num)\n            prefix_cost2.append(prefix_cost2[-1] + num * (num - 1) // 2)\n        \n        # Function to calculate cost to make all elements equal to target\n        def calculate_cost(target):\n            cost = 0\n            for i, num in enumerate(nums):\n                diff = abs(num - target)\n                if diff == 0:\n                    continue\n                cost += (prefix_cost1[i] + (prefix_cost1[-1] - prefix_cost1[i + 1]) * diff) % MOD * cost1\n                cost += (prefix_cost2[i] + (prefix_cost2[-1] - prefix_cost2[i + 1]) * diff) % MOD * cost2\n            return cost % MOD\n        \n        # Find the minimum cost among all possible targets\n        min_cost = float('inf')\n        for num in set(nums):\n            min_cost = min(min_cost, calculate_cost(num))\n        \n        return min_cost"
        ]
    },
    {
        "question_id": "3398",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canMakeSquare(self, grid: List[List[str]]) -> bool:\n        # Check each 2x2 sub-square in the grid\n        for i in range(2):\n            for j in range(2):\n                # Count the number of 'B's and 'W's in the current 2x2 sub-square\n                count_B = sum(grid[x][y] == 'B' for x in range(i, i + 2) for y in range(j, j + 2))\n                count_W = sum(grid[x][y] == 'W' for x in range(i, i + 2) for y in range(j, j + 2))\n                # If there is at most one cell that needs to be changed to make the sub-square uniform\n                if abs(count_B - count_W) <= 1:\n                    return True\n        return False"
        ]
    },
    {
        "question_id": "3388",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        count = 0\n        \n        # Counting ones in each row and column\n        row_ones = [sum(row) for row in grid]\n        col_ones = [sum(grid[row][col] for row in range(rows)) for col in range(cols)]\n        \n        # Iterate over each cell in the grid\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    # Check rows above and below\n                    for k in range(i):\n                        if grid[k][j] == 1:\n                            count += row_ones[i] - 1 - (grid[i][j] + grid[k][j] == 2)\n                    for k in range(i + 1, rows):\n                        if grid[k][j] == 1:\n                            count += row_ones[i] - 1 - (grid[i][j] + grid[k][j] == 2)\n                    \n                    # Check columns left and right\n                    for k in range(j):\n                        if grid[i][k] == 1:\n                            count += col_ones[j] - 1 - (grid[i][j] + grid[i][k] == 2)\n                    for k in range(j + 1, cols):\n                        if grid[i][k] == 1:\n                            count += col_ones[j] - 1 - (grid[i][j] + grid[i][k] == 2)\n        \n        return count // 2"
        ]
    },
    {
        "question_id": "3406",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(zero, one, length):\n            if zero < 0 or one < 0:\n                return 0\n            if length > limit:\n                return 0\n            if zero == 0 and one == 0:\n                return 1\n            if zero == 0:\n                return dfs(zero, one - 1, length + 1)\n            if one == 0:\n                return dfs(zero - 1, one, length + 1)\n            return (dfs(zero - 1, one, length + 1) + dfs(zero, one - 1, length + 1)) % MOD\n        \n        return (dfs(zero, one, 0) + dfs(one, zero, 0)) % MOD"
        ]
    },
    {
        "question_id": "3412",
        "code_list": [
            "class Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        s_indices = {char: idx for idx, char in enumerate(s)}\n        t_indices = {char: idx for idx, char in enumerate(t)}\n        \n        permutation_difference = sum(abs(s_indices[char] - t_indices[char]) for char in s)\n        return permutation_difference"
        ]
    },
    {
        "question_id": "3383",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:\n        n = len(energy)\n        dp = [0] * n\n        dp[0] = energy[0]\n        for i in range(1, n):\n            dp[i] = energy[i]\n            if (i + k) < n:\n                dp[i] += dp[i - k]\n            dp[i] = max(dp[i], dp[i - 1])\n        return dp[-1]"
        ]
    },
    {
        "question_id": "3429",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:\n        for i in range(len(nums) - 1):\n            if (nums[i] % 2) == (nums[i + 1] % 2):\n                return False\n        return True"
        ]
    },
    {
        "question_id": "3416",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:\n        total_diff = 0\n        num_length = len(str(nums[0]))  # All numbers have the same length\n        \n        for i in range(num_length):\n            digit_sum = 0\n            for num in nums:\n                digit_sum += (num // (10 ** i)) % 10\n            total_diff += digit_sum * (len(nums) - digit_sum)\n        \n        return total_diff"
        ]
    },
    {
        "question_id": "3414",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def waysToReachStair(self, k: int) -> int:\n        @lru_cache(None)\n        def dp(stair):\n            if stair == 0:\n                return 1\n            if stair < 0:\n                return 0\n            ways = 0\n            # Go down to stair i - 1\n            ways += dp(stair - 1)\n            # Go up to stair i + 2^jump\n            for jump in range(32):  # 2^31 > 10^9, so we only need to check up to 32\n                ways += dp(stair + (1 << jump))\n            return ways\n        \n        return dp(k)"
        ]
    },
    {
        "question_id": "3446",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if nums1[i] % (nums2[j] * k) == 0:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3451",
        "code_list": [
            "class Solution:\n    def compressedString(self, word: str) -> str:\n        comp = \"\"\n        i = 0\n        while i < len(word):\n            char = word[i]\n            count = 0\n            while i < len(word) and word[i] == char:\n                i += 1\n                count += 1\n            comp += str(count) + char\n        return comp"
        ]
    },
    {
        "question_id": "3423",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        \n        def max_sum_subsequence(arr):\n            incl = 0\n            excl = 0\n            for num in arr:\n                new_excl = max(incl, excl)\n                incl = excl + num\n                excl = new_excl\n            return max(incl, excl)\n        \n        total_sum = 0\n        for pos, val in queries:\n            # Calculate the sum before the change\n            if pos > 0:\n                left_sum = sum(nums[:pos])\n            else:\n                left_sum = 0\n            \n            if pos < len(nums) - 1:\n                right_sum = sum(nums[pos+1:])\n            else:\n                right_sum = 0\n            \n            # Calculate the sum excluding the current position\n            exclude_current = left_sum + right_sum\n            \n            # Update the value at the given position\n            nums[pos] = val\n            \n            # Calculate the sum including the current position\n            include_current = max_sum_subsequence(nums)\n            \n            # Add the result of the current query to the total sum\n            total_sum += max(include_current, exclude_current)\n            total_sum %= MOD\n        \n        return total_sum"
        ]
    },
    {
        "question_id": "3403",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumSubstringsInPartition(self, s: str) -> int:\n        count = Counter()\n        partitions = 0\n        \n        for char in s:\n            count[char] += 1\n            if all(count[letter] > 0 for letter in count):\n                partitions += 1\n                count.clear()\n        \n        return partitions"
        ]
    },
    {
        "question_id": "3411",
        "code_list": [
            "from typing import List\nimport math\n\nclass Solution:\n    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:\n        MOD = 10**5\n        \n        # Function to get the powerful array for a given number\n        def get_powerful_array(n):\n            powerful_array = []\n            while n > 0:\n                if n & 1:\n                    powerful_array.append(1)\n                n >>= 1\n                if n > 0:\n                    powerful_array.append(2)\n            return powerful_array\n        \n        # Precompute the powerful arrays up to a certain limit\n        max_val = int(math.log2(10**15)) + 1\n        powerful_arrays = [get_powerful_array(i) for i in range(max_val)]\n        \n        # Precompute the prefix products modulo MOD\n        prefix_products = [[1] * len(arr) for arr in powerful_arrays]\n        for i in range(len(powerful_arrays)):\n            for j in range(1, len(powerful_arrays[i])):\n                prefix_products[i][j] = (prefix_products[i][j-1] * powerful_arrays[i][j]) % MOD\n        \n        def get_product(start, end):\n            index = min(start, end)\n            result = 1\n            while index < len(powerful_arrays) and start <= index <= end:\n                result = (result * prefix_products[index][end - index]) % MOD\n                index += 1\n            return result\n        \n        results = []\n        for q in queries:\n            from_i, to_i, mod_i = q\n            result = get_product(from_i, to_i)\n            results.append(result % mod_i)\n        \n        return results"
        ]
    },
    {
        "question_id": "3428",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def duplicateNumbersXOR(self, nums: List[int]) -> int:\n        xor_result = 0\n        seen_once = set()\n        seen_twice = set()\n        \n        for num in nums:\n            if num in seen_once:\n                seen_once.remove(num)\n                seen_twice.add(num)\n            else:\n                seen_once.add(num)\n        \n        for num in seen_twice:\n            xor_result ^= num\n        \n        return xor_result"
        ]
    },
    {
        "question_id": "3420",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:\n        # Create a dictionary to store the indices of each occurrence of x\n        occurrence_indices = {}\n        for i, num in enumerate(nums):\n            if num == x:\n                if x not in occurrence_indices:\n                    occurrence_indices[x] = []\n                occurrence_indices[x].append(i)\n        \n        # Initialize the result list\n        result = []\n        \n        # Process each query\n        for query in queries:\n            if x in occurrence_indices and len(occurrence_indices[x]) >= query:\n                result.append(occurrence_indices[x][query - 1])\n            else:\n                result.append(-1)\n        \n        return result"
        ]
    },
    {
        "question_id": "abc356_a",
        "code_list": [
            "def reverse_subsequence(N, L, R):\n    # Initialize the sequence A\n    A = list(range(1, N + 1))\n    \n    # Reverse the subsequence from index L to R\n    A[L-1:R] = reversed(A[L-1:R])\n    \n    # Return the modified sequence\n    return A\n\ndef main():\n    # Read input from stdin\n    N, L, R = map(int, input().split())\n    \n    # Get the modified sequence\n    result = reverse_subsequence(N, L, R)\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_d",
        "code_list": [
            "def popcount(x):\n    count = 0\n    while x:\n        count += x & 1\n        x >>= 1\n    return count\n\ndef main():\n    N, M = map(int, input().split())\n    MOD = 998244353\n    \n    # Precompute the number of 1s in each bit position of M\n    bit_counts = [0] * 61\n    for i in range(61):\n        if M >> i & 1:\n            bit_counts[i] = 1\n    \n    # Calculate the result using dynamic programming\n    dp = [[0] * (N + 1) for _ in range(61)]\n    dp[0][0] = 1\n    for i in range(61):\n        for j in range(N + 1):\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n                dp[i][j] %= MOD\n            if i < 60 and j < N:\n                dp[i + 1][j] += dp[i][j] * bit_counts[i]\n                dp[i + 1][j] %= MOD\n    \n    print(dp[60][N])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Count frequency of each element\n    freq = defaultdict(int)\n    for num in A:\n        freq[num] += 1\n    \n    # Calculate the result\n    result = 0\n    for i in range(1, max(A) + 1):\n        if i in freq:\n            for j in range(i + 1, max(A) + 1):\n                if j in freq:\n                    count_i = freq[i]\n                    count_j = freq[j]\n                    result += (count_i * count_j * (j // i))\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_c",
        "code_list": [
            "from itertools import product\n\ndef main():\n    N, M, K = map(int, input().split())\n    tests = [list(map(int, input().split())) for _ in range(M)]\n    \n    # Generate all possible combinations of keys being real or dummies\n    valid_combinations = 0\n    \n    for combination in product([0, 1], repeat=N):\n        if sum(combination) < K:\n            continue\n        \n        # Check if the current combination contradicts any test results\n        valid = True\n        for C, keys, result in tests:\n            real_keys = [k for k, is_real in zip(keys, combination) if is_real]\n            if len(real_keys) >= K and result == 'x':\n                valid = False\n                break\n            if len(real_keys) < K and result == 'o':\n                valid = False\n                break\n        \n        if valid:\n            valid_combinations += 1\n    \n    print(valid_combinations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    X = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Check if goals are met\n    for i in range(M):\n        total = sum(X[j][i] for j in range(N))\n        if total < A[i]:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc357_c",
        "code_list": [
            "def print_carpet(N):\n    def generate_carpet(size):\n        if size == 1:\n            return ['#']\n        prev_carpet = generate_carpet(size // 3)\n        result = []\n        for row in prev_carpet:\n            result.append('#' * size)\n            result.append('#' + '.' * (size - 2) + '#')\n        result.append('#' * size)\n        return result\n    \n    carpet = generate_carpet(3 ** N)\n    for row in carpet:\n        print(row)\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print_carpet(N)"
        ]
    },
    {
        "question_id": "abc357_a",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    H = list(map(int, input().split()))\n    \n    # Initialize the count of aliens who can disinfect all their hands\n    count = 0\n    \n    # Iterate through each alien\n    for h in H:\n        # Check if there is enough disinfectant to disinfect all the hands of the current alien\n        if M >= h:\n            M -= h  # Use up the required amount of disinfectant\n            count += 1  # Increment the count of aliens who can disinfect all their hands\n        else:\n            break  # If there is not enough disinfectant, stop checking further\n    \n    # Print the result\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc357_d",
        "code_list": [
            "def modular_concatenation(N):\n    MOD = 998244353\n    \n    # Function to compute (base^exp) % mod using iterative method\n    def power(base, exp, mod):\n        result = 1\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp //= 2\n        return result\n    \n    # Function to compute the sum of digits of N\n    def digit_sum(N):\n        return sum(int(digit) for digit in str(N))\n    \n    # Convert N to string to handle large numbers\n    N_str = str(N)\n    len_N = len(N_str)\n    \n    # Calculate the sum of digits of N\n    sum_digits = digit_sum(N)\n    \n    # Calculate the result using properties of modular arithmetic\n    result = (power(10, N * len_N - len_N * (N - 1), MOD) * sum_digits) % MOD\n    \n    return result\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(modular_concatenation(N))"
        ]
    },
    {
        "question_id": "abc357_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    upper_count = sum(1 for char in S if char.isupper())\n    lower_count = len(S) - upper_count\n    \n    if upper_count > lower_count:\n        print(S.lower())\n    else:\n        print(S.upper())\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc357_e",
        "code_list": [
            "def count_reachable_pairs(N, a):\n    # Initialize the count of reachable pairs\n    count = 0\n    \n    # Initialize the parent array to store the parent of each node\n    parent = [0] * (N + 1)\n    \n    # Initialize the size array to store the size of each component\n    size = [1] * (N + 1)\n    \n    # Build the parent array\n    for i in range(1, N + 1):\n        parent[a[i - 1]] = i\n    \n    # Traverse the graph using DFS to calculate the size of each component\n    def dfs(node):\n        nonlocal count\n        for next_node in range(1, N + 1):\n            if parent[next_node] == node:\n                size[node] += dfs(next_node)\n                count += size[next_node]\n        return size[node]\n    \n    # Start DFS from the root node (node 1)\n    dfs(1)\n    \n    return count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = list(map(int, input().split()))\n    print(count_reachable_pairs(N, a))"
        ]
    },
    {
        "question_id": "abc358_e",
        "code_list": [
            "from math import comb\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef count_strings(K, C):\n    @lru_cache(None)\n    def dp(k, remaining):\n        if k == 0:\n            return 1\n        total = 0\n        for i in range(26):\n            if remaining[i] > 0:\n                new_remaining = list(remaining)\n                new_remaining[i] -= 1\n                total += dp(k - 1, tuple(new_remaining))\n                total %= MOD\n        return total\n    \n    result = 0\n    for i in range(1, K + 1):\n        remaining = [c for c in C]\n        result += dp(i, tuple(remaining))\n        result %= MOD\n    \n    return result\n\nif __name__ == \"__main__\":\n    K = int(input().strip())\n    C = list(map(int, input().strip().split()))\n    print(count_strings(K, C))"
        ]
    },
    {
        "question_id": "abc358_c",
        "code_list": [
            "def min_stands_to_visit(N, M, stands):\n    # Create a set for each stand to keep track of flavors available\n    available_flavors = [set() for _ in range(N)]\n    \n    # Populate the sets with available flavors\n    for i in range(N):\n        for j in range(M):\n            if stands[i][j] == 'o':\n                available_flavors[i].add(j)\n    \n    # Find the minimum number of stands needed to cover all flavors\n    from itertools import combinations\n    \n    def covers_all_flavors(stand_combination):\n        all_flavors_covered = set(range(M))\n        for stand in stand_combination:\n            all_flavors_covered &= available_flavors[stand]\n        return len(all_flavors_covered) == M\n    \n    # Iterate over all possible combinations of stands\n    for r in range(1, N + 1):\n        for combination in combinations(range(N), r):\n            if covers_all_flavors(combination):\n                return r\n    \n    return N  # Fallback, should not reach here due to problem constraints\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    stands = [input() for _ in range(N)]\n    print(min_stands_to_visit(N, M, stands))"
        ]
    },
    {
        "question_id": "abc358_b",
        "code_list": [
            "def main():\n    # Read input\n    N, A = map(int, input().split())\n    T = list(map(int, input().split()))\n\n    # Initialize variables\n    current_time = 0\n    queue = []\n\n    # Process each person's arrival\n    for t in T:\n        # Add the current time to the queue if it's not empty\n        if queue:\n            current_time = max(current_time, queue[-1]) + A\n        else:\n            current_time += A\n\n        # Update the queue with the new arrival time\n        queue.append(current_time)\n\n        # Output the result for the current person\n        print(queue[-1])\n\n        # Remove all completed processes from the queue\n        while queue and queue[0] <= t:\n            queue.pop(0)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc358_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, m = data[0], data[1]\n    prices = data[2:2 * n + 2:2]\n    candies = data[3:2 * n + 2:2]\n\n    # Sort the boxes based on their price-to-candy ratio in descending order\n    boxes = sorted(zip(prices, candies), key=lambda x: x[1] / x[0], reverse=True)\n\n    # Initialize variables\n    total_cost = 0\n    selected_boxes = [False] * n\n    required_candies = data[2 * n + 2:2 * n + 2 + m]\n\n    for i in range(m):\n        found = False\n        for j in range(n):\n            if not selected_boxes[j] and boxes[j][1] >= required_candies[i]:\n                selected_boxes[j] = True\n                total_cost += boxes[j][0]\n                found = True\n                break\n        if not found:\n            print(-1)\n            return\n\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc358_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    S, T = input().split()\n    if S == \"AtCoder\" and T == \"Land\":\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        ]
    },
    {
        "question_id": "abc359_c",
        "code_list": [
            "def main():\n    S_x, S_y = map(int, input().split())\n    T_x, T_y = map(int, input().split())\n\n    # Calculate the difference in coordinates\n    dx = abs(S_x - T_x)\n    dy = abs(S_y - T_y)\n\n    # Determine the parity of the sum of coordinates for both start and target points\n    S_parity = (S_x + S_y) % 2\n    T_parity = (T_x + T_y) % 2\n\n    # If the parities match, the minimum toll is the Manhattan distance\n    if S_parity == T_parity:\n        toll = abs(dx - dy)\n    else:\n        # If the parities don't match, we need to consider the extra toll due to tile boundaries\n        # The extra toll is the maximum of the differences in x and y coordinates\n        toll = max(dx, dy)\n\n    print(toll)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc359_b",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Count occurrences of each color\n    color_counts = Counter(A)\n    \n    # Check for each color if there is exactly one person between the two people wearing that color\n    count = 0\n    for color in range(1, N + 1):\n        if color_counts[color] != 2:\n            continue\n        index1 = A.index(color) + 1\n        A.remove(color)\n        index2 = A.index(color) + 1\n        if abs(index1 - index2) == 3:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc359_e",
        "code_list": [
            "def main():\n    import sys\n    \n    def solve(N, H):\n        A = [0] * (N + 1)\n        result = []\n        \n        for i in range(1, N + 1):\n            steps = 0\n            while True:\n                steps += 1\n                A[0] += 1\n                if A[i - 1] > A[i] and A[i - 1] > H[i - 1]:\n                    A[i - 1] -= 1\n                    A[i] += 1\n                if A[i] > 0:\n                    result.append(steps)\n                    break\n        \n        return ' '.join(map(str, result))\n    \n    N = int(input())\n    H = list(map(int, input().split()))\n    \n    print(solve(N, H))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc359_a",
        "code_list": [
            "def main():\n    N = int(input())\n    takahashi_count = 0\n    for _ in range(N):\n        S_i = input()\n        if S_i == \"Takahashi\":\n            takahashi_count += 1\n    print(takahashi_count)"
        ]
    },
    {
        "question_id": "abc359_d",
        "code_list": [
            "from itertools import product\n\ndef is_good_string(s, k):\n    n = len(s)\n    for i in range(n - k + 1):\n        sub = s[i:i+k]\n        if sub == sub[::-1]:\n            return False\n    return True\n\ndef count_good_strings(n, k, s):\n    mod = 998244353\n    q = s.count('?')\n    if q == 0:\n        return int(is_good_string(s, k))\n    \n    # Generate all possible combinations of A and B for the '?' characters\n    patterns = [''.join(pattern) for pattern in product('AB', repeat=q)]\n    count = 0\n    \n    for pattern in patterns:\n        new_s = s.replace('?', pattern[0], 1)\n        for i in range(1, q):\n            new_s = new_s.replace('?', pattern[i], 1)\n        if is_good_string(new_s, k):\n            count += 1\n    \n    return count % mod\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    s = input().strip()\n    print(count_good_strings(n, k, s))"
        ]
    },
    {
        "question_id": "abc360_c",
        "code_list": [
            "import sys\nfrom collections import Counter\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    boxes = [int(data[i]) for i in range(1, 2 * n + 1, 2)]\n    weights = [int(data[i]) for i in range(2, 2 * n + 1, 2)]\n    \n    # Count the frequency of each box\n    box_count = Counter(boxes)\n    \n    # Calculate the cost to move items to their respective boxes\n    total_cost = 0\n    for i in range(n):\n        target_box = i + 1\n        if box_count[target_box] > 1:\n            # Find the item with the minimum weight in the current box\n            min_weight = min(weights[j] for j in range(n) if boxes[j] == target_box)\n            # Calculate the cost to move this item to its correct box\n            total_cost += min_weight\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc360_b",
        "code_list": [
            "def main():\n    S, T = input().split()\n    n, m = len(S), len(T)\n    \n    for w in range(1, n):\n        for c in range(1, w + 1):\n            if c > n - w:\n                break\n            substrings = [S[i:i+w] for i in range(0, n, w)]\n            result = ''.join(substrings[i][c-1] if len(substrings[i]) >= c else '' for i in range(len(substrings)))\n            if result == T:\n                print('Yes')\n                return\n    print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc360_e",
        "code_list": [
            "def modular_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef solve(N, K):\n    mod = 998244353\n    inv = [1] * (K + 1)\n    for i in range(1, K + 1):\n        inv[i] = modular_inverse(i, mod)\n    \n    dp = [0] * (K + 1)\n    dp[0] = 1\n    for k in range(K):\n        for i in range(k + 1):\n            dp[i] = (dp[i] * (N - k - 1) + dp[i + 1]) % mod\n    \n    ans = sum(dp[i] * (i + 1) * inv[K - i] for i in range(K + 1)) % mod\n    return ans\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    print(solve(N, K))"
        ]
    },
    {
        "question_id": "abc360_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    rice_index = S.index('R')\n    miso_index = S.index('M')\n    \n    if rice_index < miso_index:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc360_d",
        "code_list": [
            "def count_passing_pairs(N, T, S, X):\n    # Initialize lists to store positions and times when ants change direction\n    positions = []\n    times = []\n    \n    # Process ants moving to the right (facing positive direction)\n    for i in range(N):\n        if S[i] == '1':\n            positions.append(X[i])\n            times.append((X[i] + T + 0.1) / 2)\n    \n    # Process ants moving to the left (facing negative direction)\n    for i in range(N):\n        if S[i] == '0':\n            positions.append(X[i])\n            times.append((X[i] - T - 0.1) / 2)\n    \n    # Sort positions and times\n    positions.sort()\n    times.sort()\n    \n    # Count the number of passing pairs\n    count = 0\n    for i in range(len(positions)):\n        for j in range(i + 1, len(positions)):\n            if times[i] < times[j]:\n                count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    N, T = map(int, input().split())\n    S = input()\n    X = list(map(int, input().split()))\n    print(count_passing_pairs(N, T, S, X))"
        ]
    },
    {
        "question_id": "abc361_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    N = int(input())\n    S = input()\n    T = input()\n\n    # Initialize the state with the initial configuration\n    state = [0] * (N + 2)\n    for i in range(N):\n        if S[i] == 'B':\n            state[i + 1] = 1\n\n    # Target state\n    target_state = [0] * (N + 2)\n    for i in range(N):\n        if T[i] == 'B':\n            target_state[i + 1] = 1\n\n    # Use BFS to find the minimum number of moves\n    queue = deque([(state, 0)])\n    visited = set([tuple(state)])\n\n    while queue:\n        current_state, steps = queue.popleft()\n        if current_state == target_state:\n            print(steps)\n            return\n\n        # Try to move pairs of stones\n        for i in range(1, N + 1):\n            if current_state[i] == 1 and current_state[i + 1] == 1:\n                new_state = current_state[:]\n                new_state[i] = 0\n                new_state[i + 1] = 0\n                for j in range(1, N + 3):\n                    if new_state[j] == 0:\n                        new_state[j] = 1\n                        new_state[j + 1] = 1\n                        if tuple(new_state) not in visited:\n                            visited.add(tuple(new_state))\n                            queue.append((new_state, steps + 1))\n                        new_state[j] = 0\n                        new_state[j + 1] = 0\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc361_b",
        "code_list": [
            "def check_intersection():\n    # Read input\n    a, b, c, d, e, f = map(int, input().split())\n    g, h, i, j, k, l = map(int, input().split())\n\n    # Check for intersection along each axis\n    x_intersect = max(a, g) < min(d, j)\n    y_intersect = max(b, h) < min(e, k)\n    z_intersect = max(c, i) < min(f, l)\n\n    # If there is an intersection along all three axes, the volumes intersect\n    if x_intersect and y_intersect and z_intersect:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    check_intersection()"
        ]
    },
    {
        "question_id": "abc361_a",
        "code_list": [
            "def main():\n    # Read input\n    N, K, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Insert X after the K-th element\n    B = A[:K] + [X] + A[K:]\n    \n    # Print the result\n    print(' '.join(map(str, B)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc361_f",
        "code_list": [
            "def main():\n    import math\n    \n    def count_special_numbers(N):\n        count = 0\n        for b in range(2, int(math.log2(N)) + 2):\n            a = 2\n            while True:\n                power = a ** b\n                if power > N:\n                    break\n                count += 1\n                a += 1\n        return count\n    \n    N = int(input())\n    print(count_special_numbers(N))"
        ]
    },
    {
        "question_id": "abc361_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    \n    min_val = [a[0]] * n\n    max_val = [a[-1]] * n\n    \n    for i in range(1, n):\n        min_val[i] = min(min_val[i-1], a[i])\n        max_val[n-i-1] = max(max_val[n-i], a[n-i-1])\n    \n    ans = float('inf')\n    for i in range(k-1, n):\n        ans = min(ans, max_val[i] - min_val[i-k+1])\n    \n    print(ans)"
        ]
    },
    {
        "question_id": "abc361_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    edges = []\n    for i in range(1, len(data), 3):\n        u = int(data[i]) - 1\n        v = int(data[i + 1]) - 1\n        w = int(data[i + 2])\n        edges.append((u, v, w))\n    \n    # Build the tree using DFS to find the diameter\n    def dfs(u, parent):\n        nonlocal diameter, farthest_node\n        max_dist = 0\n        for v, w in graph[u]:\n            if v != parent:\n                dist = dfs(v, u) + w\n                if dist > max_dist:\n                    max_dist = dist\n                    farthest_node = v\n        return max_dist\n    \n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    diameter = 0\n    farthest_node = 0\n    dfs(0, -1)\n    diameter = dfs(farthest_node, -1)\n    \n    # Calculate the minimum travel distance\n    min_distance = sum(w for _, _, w in edges) - diameter\n    print(min_distance)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_d",
        "code_list": [
            "import heapq\n\ndef dijkstra(N, edges, A):\n    # Initialize distances\n    dist = [float('inf')] * (N + 1)\n    dist[1] = A[1]\n    \n    # Priority queue to store (distance, node)\n    pq = [(A[1], 1)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        \n        if d > dist[u]:\n            continue\n        \n        for v, w in edges[u]:\n            new_dist = d + w + A[v]\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n    \n    return dist[2:]\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    edges = [[] for _ in range(N + 1)]\n    \n    for _ in range(M):\n        U, V, B = map(int, input().split())\n        edges[U].append((V, B))\n        edges[V].append((U, B))\n    \n    result = dijkstra(N, edges, A)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_e",
        "code_list": [
            "def main():\n    from collections import defaultdict\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    mod = 998244353\n\n    def count_arithmetic_subsequences(nums):\n        n = len(nums)\n        dp = [defaultdict(int) for _ in range(n)]\n        ans = [0] * (n + 1)\n\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                dp[i][diff] += dp[j][diff] + 1\n            ans[i + 1] = sum(dp[i].values()) % mod\n\n        return ans[1:]\n\n    n = int(input())\n    A = list(map(int, input().split()))\n\n    result = count_arithmetic_subsequences(A)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_int():\n        return int(input())\n    \n    def read_ints():\n        return list(map(int, input().split()))\n    \n    def solve(N, intervals):\n        total_sum = sum(R - L + 1 for L, R in intervals)\n        target = -sum(L for L, _ in intervals)\n        \n        if target < 0 or abs(target) > total_sum:\n            print(\"No\")\n            return\n        \n        X = [0] * N\n        remaining_target = target\n        \n        for i, (L, R) in enumerate(intervals):\n            if remaining_target == 0:\n                break\n            \n            if remaining_target > 0:\n                add_val = min(remaining_target, R - L + 1)\n                X[i] += add_val\n                remaining_target -= add_val\n            \n            if remaining_target < 0:\n                add_val = max(remaining_target, -(R - L + 1))\n                X[i] += add_val\n                remaining_target -= add_val\n        \n        if remaining_target != 0:\n            print(\"No\")\n            return\n        \n        print(\"Yes\")\n        print(*X)\n    \n    N = read_int()\n    intervals = [read_ints() for _ in range(N)]\n    \n    solve(N, intervals)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_a",
        "code_list": [
            "def main():\n    R, G, B = map(int, input().split())\n    C = input()\n    \n    if C == \"Red\":\n        print(min(G, B))\n    elif C == \"Green\":\n        print(min(R, B))\n    else:\n        print(min(R, G))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_b",
        "code_list": [
            "import math\n\ndef main():\n    # Read input coordinates\n    x_A, y_A = map(int, input().split())\n    x_B, y_B = map(int, input().split())\n    x_C, y_C = map(int, input().split())\n\n    # Calculate squared lengths of sides\n    AB_squared = (x_B - x_A)**2 + (y_B - y_A)**2\n    BC_squared = (x_C - x_B)**2 + (y_C - y_B)**2\n    CA_squared = (x_C - x_A)**2 + (y_C - y_A)**2\n\n    # Check if any angle is a right angle\n    if AB_squared + BC_squared == CA_squared or \\\n       AB_squared + CA_squared == BC_squared or \\\n       BC_squared + CA_squared == AB_squared:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_a",
        "code_list": [
            "def main():\n    R = int(input())\n    current_display = (R + 99) // 100\n    next_display = current_display + 1\n    \n    target_rating = next_display * 100 - 100\n    min_increase = target_rating - R\n    \n    print(min_increase)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_f",
        "code_list": [
            "def main():\n    import math\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def find_palindrome(n):\n        for i in range(int(math.sqrt(n)), 0, -1):\n            if n % i == 0:\n                quotient = n // i\n                str_i = str(i)\n                str_quotient = str(quotient)\n                \n                # Check if both parts are palindromes and start with a digit\n                if is_palindrome(str_i) and is_palindrome(str_quotient) and str_i[0] != '0' and str_quotient[0] != '0':\n                    return f\"{str_i}*{str_quotient}\"\n        \n        return \"-1\"\n    \n    N = int(input())\n    result = find_palindrome(N)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_b",
        "code_list": [
            "def main():\n    N, T, P = map(int, input().split())\n    hair_lengths = list(map(int, input().split()))\n    \n    # Count how many people already have hair length >= T\n    initial_count = sum(1 for length in hair_lengths if length >= T)\n    \n    if initial_count >= P:\n        print(0)\n    else:\n        # Calculate the number of days needed to reach P people with hair length >= T\n        days = 0\n        for i in range(N):\n            if hair_lengths[i] < T:\n                days += (T - hair_lengths[i])\n                initial_count += 1\n            if initial_count >= P:\n                break\n        \n        # If we haven't reached P people yet, calculate the remaining days\n        if initial_count < P:\n            days += (T - min(hair_lengths)) * (P - initial_count)\n        \n        print(days)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_c",
        "code_list": [
            "from itertools import permutations\n\ndef count_valid_permutations(N, K, S):\n    # Generate all unique permutations of the string S\n    unique_perms = set(permutations(S))\n    \n    valid_count = 0\n    \n    # Check each permutation\n    for perm in unique_perms:\n        perm_str = ''.join(perm)\n        # Check if the permutation contains a palindrome of length K\n        for i in range(N - K + 1):\n            is_palindrome = True\n            for j in range(K // 2):\n                if perm_str[i + j] != perm_str[i + K - 1 - j]:\n                    is_palindrome = False\n                    break\n            if is_palindrome:\n                break\n        else:\n            # If no palindrome of length K is found, increment the count\n            valid_count += 1\n    \n    return valid_count\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    S = input().strip()\n    print(count_valid_permutations(N, K, S))"
        ]
    },
    {
        "question_id": "abc363_d",
        "code_list": [
            "def generate_palindrome(n):\n    def reverse(s):\n        return s[::-1]\n\n    def is_palindrome(s):\n        return s == reverse(s)\n\n    def generate_even_length_palindromes(length):\n        half = '1' + '0' * ((length - 2) // 2)\n        for i in range(10 ** ((length - 2) // 2)):\n            num = int(half[:((length - 2) // 2)] + str(i).zfill(((length - 2) // 2)) + reverse(half[:((length - 2) // 2)]))\n            yield num\n\n    def generate_odd_length_palindromes(length):\n        half = '1' + '0' * ((length - 1) // 2)\n        for i in range(10 ** ((length - 1) // 2)):\n            num = int(half[:((length - 1) // 2)] + str(i) + reverse(half[:((length - 1) // 2)]))\n            yield num\n\n    count = 0\n    length = 1\n    while True:\n        if length % 2 == 0:\n            for p in generate_even_length_palindromes(length):\n                count += 1\n                if count == n:\n                    return p\n        else:\n            for p in generate_odd_length_palindromes(length):\n                count += 1\n                if count == n:\n                    return p\n        length += 1\n\ndef main():\n    import sys\n    n = int(sys.stdin.readline().strip())\n    print(generate_palindrome(n))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_e",
        "code_list": [
            "def main():\n    # Read input\n    H, W, Y = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(H)]\n    \n    def simulate(year):\n        sea_level = year\n        queue = []\n        visited = [[False] * W for _ in range(H)]\n        \n        # Initialize the queue with all sections adjacent to the sea\n        for i in range(H):\n            for j in range(W):\n                if A[i][j] <= sea_level:\n                    queue.append((i, j))\n                    visited[i][j] = True\n        \n        while queue:\n            new_queue = []\n            for i, j in queue:\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < H and 0 <= nj < W and not visited[ni][nj] and A[ni][nj] <= sea_level:\n                        new_queue.append((ni, nj))\n                        visited[ni][nj] = True\n            queue = new_queue\n        \n        # Calculate the remaining area\n        remaining_area = sum(1 for i in range(H) for j in range(W) if not visited[i][j])\n        return remaining_area\n    \n    # Simulate for each year\n    for year in range(Y + 1):\n        result = simulate(year)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_b",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    Si, Sj = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    X = input()\n\n    i, j = Si - 1, Sj - 1\n\n    for move in X:\n        if move == 'L' and j > 0 and grid[i][j-1] == '.':\n            j -= 1\n        elif move == 'R' and j < W - 1 and grid[i][j+1] == '.':\n            j += 1\n        elif move == 'U' and i > 0 and grid[i-1][j] == '.':\n            i -= 1\n        elif move == 'D' and i < H - 1 and grid[i+1][j] == '.':\n            i += 1\n\n    print(i + 1, j + 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_e",
        "code_list": [
            "def main():\n    from itertools import permutations\n\n    N, X, Y = map(int, input().split())\n    AB = [tuple(map(int, input().split())) for _ in range(N)]\n\n    max_dishes = 0\n    for perm in permutations(AB):\n        total_sweetness = 0\n        total_saltiness = 0\n        for sweetness, saltiness in perm:\n            total_sweetness += sweetness\n            total_saltiness += saltiness\n            if total_sweetness > X or total_saltiness > Y:\n                break\n        else:\n            max_dishes = max(max_dishes, len(perm))\n\n    print(max_dishes)"
        ]
    },
    {
        "question_id": "abc364_f",
        "code_list": [
            "import sys\nfrom typing import List\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    edges = []\n    \n    start_index = 2\n    for _ in range(q):\n        l = int(data[start_index])\n        r = int(data[start_index + 1])\n        c = int(data[start_index + 2])\n        for j in range(l, r + 1):\n            edges.append((n + _, j, c))\n        start_index += 3\n    \n    # Union-Find structure\n    parent = list(range(n + q + 1))\n    size = [1] * (n + q + 1)\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if size[rootX] < size[rootY]:\n                rootX, rootY = rootY, rootX\n            parent[rootY] = rootX\n            size[rootX] += size[rootY]\n    \n    # Sort edges by cost\n    edges.sort(key=lambda x: x[2])\n    \n    total_cost = 0\n    components = n + q + 1\n    \n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            total_cost += w\n            components -= 1\n    \n    if components > 1:\n        print(-1)\n    else:\n        print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_d",
        "code_list": [
            "def main():\n    import sys\n    from heapq import heappush, heappop\n    \n    def find_kth_distance(a, b, k):\n        min_heap = []\n        for ai in a:\n            distance = abs(ai - b)\n            if len(min_heap) < k:\n                heappush(min_heap, distance)\n            elif distance < max_heap[0]:\n                heappushpop(min_heap, distance)\n        \n        return max_heap[0]\n    \n    N, Q = map(int, input().split())\n    a = list(map(int, input().split()))\n    results = []\n    \n    for _ in range(Q):\n        b, k = map(int, input().split())\n        results.append(find_kth_distance(a, b, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n = data[0]\n    x = data[1]\n    y = data[2]\n    a = data[3:3*n+3:3]\n    b = data[4:3*n+3:3]\n    \n    # Calculate prefix sums for sweetness and saltiness\n    sweetness = [0] * (n + 1)\n    saltiness = [0] * (n + 1)\n    for i in range(n):\n        sweetness[i + 1] = sweetness[i] + a[i]\n        saltiness[i + 1] = saltiness[i] + b[i]\n    \n    # Binary search for the maximum number of dishes that can be eaten\n    def can_eat(k):\n        if k == 0:\n            return True\n        if sweetness[k] > x or saltiness[k] > y:\n            return False\n        for i in range(k - 1):\n            if sweetness[k] - sweetness[i] > x or saltiness[k] - saltiness[i] > y:\n                continue\n            if can_eat(i):\n                return True\n        return False\n    \n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_eat(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    print(left)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_a",
        "code_list": [
            "def can_eat_all_dishes():\n    N = int(input())\n    dishes = [input() for _ in range(N)]\n    \n    for i in range(1, N):\n        if dishes[i] == 'sweet' and dishes[i - 1] == 'sweet':\n            print('No')\n            return\n    print('Yes')\n\nif __name__ == \"__main__\":\n    can_eat_all_dishes()"
        ]
    },
    {
        "question_id": "abc365_b",
        "code_list": [
            "def main():\n    # Read input\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n\n    # Find the maximum element\n    max_element = max(A)\n    # Remove the maximum element to find the second largest\n    A.remove(max_element)\n    # The new maximum element is the second largest in the original list\n    second_largest_index = A.index(max(A)) + 1\n\n    # Print the index of the second largest element\n    print(second_largest_index)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc365_a",
        "code_list": [
            "def main():\n    Y = int(input())\n    if Y % 400 == 0:\n        print(366)\n    elif Y % 100 == 0:\n        print(365)\n    elif Y % 4 == 0:\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc365_e",
        "code_list": [
            "def main():\n    import sys\n    \n    def count_set_bits(n):\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    # Calculate prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(N):\n        prefix_xor[i + 1] = prefix_xor[i] ^ A[i]\n    \n    # Initialize result\n    result = 0\n    \n    # Iterate over all possible subarrays\n    for i in range(N):\n        for j in range(i + 1, N):\n            xor_value = prefix_xor[j + 1] ^ prefix_xor[i]\n            result += xor_value\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc365_d",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n\n    # Count the occurrences of each move\n    count_R = S.count('R')\n    count_P = S.count('P')\n    count_S = S.count('S')\n\n    # Determine the maximum number of wins for Takahashi\n    max_wins = 0\n    if count_R > 0:\n        max_wins += min(count_P, count_S)\n    if count_P > 0:\n        max_wins += min(count_R, count_S)\n    if count_S > 0:\n        max_wins += min(count_R, count_P)\n\n    # Adjust for the condition that Takahashi never loses\n    for i in range(N - 1):\n        if S[i] == 'R' and S[i + 1] != 'S':\n            max_wins -= 1\n        elif S[i] == 'P' and S[i + 1] != 'R':\n            max_wins -= 1\n        elif S[i] == 'S' and S[i + 1] != 'P':\n            max_wins -= 1\n\n    print(max_wins)"
        ]
    },
    {
        "question_id": "abc365_c",
        "code_list": [
            "def find_max_subsidy(N, M, A):\n    def is_possible(x):\n        return sum(min(x, a) for a in A) <= M\n    \n    if max(A) <= M:\n        return \"infinite\"\n    \n    left, right = 0, max(A)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if is_possible(mid):\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(find_max_subsidy(N, M, A))"
        ]
    },
    {
        "question_id": "3426",
        "code_list": [
            "class Solution:\n    def minimumChairs(self, s: str) -> int:\n        max_chairs_needed = 0\n        current_chairs = 0\n        \n        for event in s:\n            if event == 'E':\n                current_chairs += 1\n                max_chairs_needed = max(max_chairs_needed, current_chairs)\n            else:\n                current_chairs -= 1\n        \n        return max_chairs_needed"
        ]
    },
    {
        "question_id": "3430",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:\n        # Sort meetings based on their start time\n        meetings.sort(key=lambda x: x[0])\n        available_days = 0\n        \n        # Initialize the last meeting's end time to -1\n        last_meeting_end = -1\n        \n        for start, end in meetings:\n            # If the current meeting starts after the last meeting ends, there is a gap\n            if start > last_meeting_end:\n                available_days += start - last_meeting_end - 1\n            # Update the last meeting's end time to the max of current meeting's end or previous end\n            last_meeting_end = max(end, last_meeting_end)\n        \n        # Add the remaining days after the last meeting\n        available_days += days - last_meeting_end - 1\n        \n        return available_days"
        ]
    },
    {
        "question_id": "3436",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        min_diff = float('inf')\n        current_or = 0\n        \n        for i in range(len(nums)):\n            current_or |= nums[i]\n            if current_or >= k:\n                min_diff = min(min_diff, abs(current_or - k))\n            for j in range(i):\n                current_or ^= nums[j]\n                if current_or >= k:\n                    min_diff = min(min_diff, abs(current_or - k))\n        \n        return min_diff"
        ]
    },
    {
        "question_id": "3450",
        "code_list": [
            "class Solution:\n    def numberOfChild(self, n: int, k: int) -> int:\n        # The ball starts at position 0 and moves right initially\n        position = 0\n        # The initial direction is right (1), which means moving to the right\n        direction = 1\n        \n        for _ in range(k):\n            # If the ball reaches the end and needs to reverse direction\n            if position == 0 and direction == -1 or position == n - 1 and direction == 1:\n                direction *= -1\n            # Move the ball according to the current direction\n            position += direction\n        \n        # Since positions are 0-indexed, we need to adjust the result to be 1-indexed\n        return position + 1"
        ]
    },
    {
        "question_id": "3422",
        "code_list": [
            "class Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:\n        MOD = 10**9 + 7\n        # Initialize the array with 1s\n        a = [1] * n\n        \n        # Update the array for k seconds\n        for _ in range(k):\n            for i in range(1, n):\n                a[i] = (a[i] + a[i-1]) % MOD\n        \n        # Return the last element of the array\n        return a[-1]"
        ]
    },
    {
        "question_id": "3442",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        rewardValues.sort()\n        total_reward = 0\n        for value in rewardValues:\n            if value > total_reward:\n                total_reward += value\n        return total_reward"
        ]
    },
    {
        "question_id": "3421",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        count = 0\n        mod_values = {}\n        for hour in hours:\n            complement = (24 - hour % 24) % 24\n            if complement in mod_values:\n                count += mod_values[complement]\n            mod_values[hour % 24] = mod_values.get(hour % 24, 0) + 1\n        return count"
        ]
    },
    {
        "question_id": "3437",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalDamage(self, power: List[int]) -> int:\n        power.sort()\n        n = len(power)\n        dp = [0] * (n + 4)  # Extra padding to handle edge cases\n        \n        for i in range(n):\n            # Calculate the maximum damage we can get by skipping the current spell\n            skip_damage = dp[i]\n            # Calculate the maximum damage we can get by casting the current spell\n            cast_damage = max(dp[i+1], dp[i+2], dp[i+3]) + power[i]\n            # Update the dp array\n            dp[i+4] = max(skip_damage, cast_damage)\n        \n        return dp[n+3]"
        ]
    },
    {
        "question_id": "3438",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + (nums[i] > max(nums[max(0, i-1)], nums[min(i+1, n-1)]))\n        \n        result = []\n        for query in queries:\n            if query[0] == 1:\n                l, r = query[1], query[2]\n                result.append(prefix_sum[r + 1] - prefix_sum[l])\n            elif query[0] == 2:\n                index, val = query[1], query[2]\n                nums[index] = val\n                prefix_sum = [0] * (n + 1)\n                for i in range(n):\n                    prefix_sum[i + 1] = prefix_sum[i] + (nums[i] > max(nums[max(0, i-1)], nums[min(i+1, n-1)]))\n        return result"
        ]
    },
    {
        "question_id": "3471",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumAverage(self, nums: List[int]) -> float:\n        nums.sort()\n        averages = []\n        for _ in range(len(nums) // 2):\n            min_element = nums.pop(0)\n            max_element = nums.pop(-1)\n            averages.append((min_element + max_element) / 2)\n        return min(averages)"
        ]
    },
    {
        "question_id": "3461",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        left, right, top, bottom = [cols] * rows, [-1] * rows, [rows] * cols, [-1] * cols\n        \n        # Find the leftmost and rightmost 1s for each row\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == 1:\n                    left[r] = min(left[r], c)\n                    right[r] = max(right[r], c)\n        \n        # Find the topmost and bottommost 1s for each column\n        for c in range(cols):\n            for r in range(rows):\n                if grid[r][c] == 1:\n                    top[c] = min(top[c], r)\n                    bottom[c] = max(bottom[c], r)\n        \n        min_area = float('inf')\n        for r1 in range(rows):\n            for r2 in range(r1, rows):\n                if bottom[cols-1] - top[0] + 1 < r2 - r1 + 1:  # Early stopping if no more 1s can fit\n                    break\n                for c1 in range(cols):\n                    for c2 in range(c1, cols):\n                        if right[r1] >= c2 and right[r2] >= c2 and left[r1] <= c1 and left[r2] <= c1:\n                            if top[c1] <= r1 and bottom[c2] >= r2:\n                                area = (r2 - r1 + 1) * (c2 - c1 + 1)\n                                min_area = min(min_area, area)\n                                break\n        return min_area"
        ]
    },
    {
        "question_id": "3464",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        max_cost = dp[0]\n        \n        for i in range(1, n):\n            # Calculate the cost of the current subarray ending at index i\n            current_cost = nums[i] * (-1) ** (i - 0)\n            if i == 1:\n                # For the first two elements, we can either take them together or split them\n                dp[i] = max(nums[0] + nums[1], nums[1])\n            else:\n                # For subsequent elements, we consider the previous subarray's cost and the current element\n                dp[i] = max(dp[i-1] + current_cost, current_cost)\n            \n            max_cost = max(max_cost, dp[i])\n        \n        return max_cost"
        ]
    },
    {
        "question_id": "3469",
        "code_list": [
            "class Solution:\n    def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n        total_balls = red + blue\n        for height in range(min(red, blue, total_balls), 0, -1):\n            if (height * (height + 1)) // 2 <= min(red, blue):\n                return height\n        return 0"
        ]
    },
    {
        "question_id": "3490",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        # Dictionary to store the length of the longest valid subsequence ending with a specific remainder\n        dp = {0: 1, 1: 1}\n        max_length = 1\n        \n        for num in nums:\n            new_dp = {}\n            for prev_remainder, length in dp.items():\n                current_remainder = (prev_remainder + num) % 2\n                if current_remainder in new_dp:\n                    new_dp[current_remainder] = max(new_dp[current_remainder], length + 1)\n                else:\n                    new_dp[current_remainder] = length + 1\n                max_length = max(max_length, new_dp[current_remainder])\n            dp = new_dp\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3439",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def dfs(node, parent, graph, visited):\n            visited.add(node)\n            max_dist = 0\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    dist = dfs(neighbor, node, graph, visited)\n                    if neighbor in graph2[node]:\n                        max_dist = max(max_dist, dist)\n                    else:\n                        max_dist = max(max_dist, dist + 1)\n            return max_dist\n        \n        # Build graphs for both trees\n        graph1, graph2 = defaultdict(list), defaultdict(list)\n        for u, v in edges1:\n            graph1[u].append(v)\n            graph1[v].append(u)\n        for u, v in edges2:\n            graph2[u].append(v)\n            graph2[v].append(u)\n        \n        # Find the diameter of each tree\n        def find_diameter(graph):\n            start_node = next(iter(graph))\n            visited = set()\n            max_dist = dfs(start_node, -1, graph, visited)\n            farthest_node = None\n            for node in visited:\n                if farthest_node is None or len(dfs(node, -1, graph, set())) > len(dfs(farthest_node, -1, graph, set())):\n                    farthest_node = node\n            visited.clear()\n            return dfs(farthest_node, -1, graph, visited)\n        \n        diameter1 = find_diameter(graph1)\n        diameter2 = find_diameter(graph2)\n        \n        # Try to merge nodes from both trees\n        min_diameter = float('inf')\n        for i in range(len(edges1)):\n            for j in range(len(edges2)):\n                if edges1[i][0] in graph2[edges2[j][0]]:\n                    new_graph1 = graph1.copy()\n                    new_graph1[edges1[i][0]].remove(edges1[i][1])\n                    new_graph1[edges1[i][1]].remove(edges1[i][0])\n                    new_graph1[edges2[j][0]].append(edges1[i][1])\n                    new_graph1[edges1[i][1]].append(edges2[j][0])\n                    \n                    new_graph2 = graph2.copy()\n                    new_graph2[edges2[j][0]].remove(edges2[j][1])\n                    new_graph2[edges2[j][1]].remove(edges2[j][0])\n                    new_graph2[edges1[i][0]].append(edges2[j][1])\n                    new_graph2[edges2[j][1]].append(edges1[i][0])\n                    \n                    diameter = max(find_diameter(new_graph1), find_diameter(new_graph2))\n                    min_diameter = min(min_diameter, diameter)\n        \n        return min_diameter"
        ]
    },
    {
        "question_id": "3468",
        "code_list": [
            "class Solution:\n    def getEncryptedString(self, s: str, k: int) -> str:\n        encrypted_string = \"\"\n        for char in s:\n            # Find the index of the current character in the alphabet\n            index = ord(char) - ord('a')\n            # Calculate the new index after shifting by k positions\n            new_index = (index + k) % 26\n            # Convert back to character and append to the result\n            encrypted_string += chr(new_index + ord('a'))\n        return encrypted_string"
        ]
    },
    {
        "question_id": "3453",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def validStrings(self, n: int) -> List[str]:\n        if n == 1:\n            return [\"0\", \"1\"]\n        \n        valid_strings = [\"0\", \"1\"]\n        for _ in range(2, n + 1):\n            new_valid_strings = set()\n            for s in valid_strings:\n                new_strings = [\"0\" + s, \"1\" + s]\n                for ns in new_strings:\n                    if all(ns[i:i+2].count(\"1\") >= 1 for i in range(len(ns) - 1)):\n                        new_valid_strings.add(ns)\n            valid_strings = list(new_valid_strings)\n        \n        return valid_strings"
        ]
    },
    {
        "question_id": "3492",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n        count = 0\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if grid[i - 1][j - 1] == 'X':\n                    prefix_sum[i][j] = prefix_sum[i][j - 1] + 1\n                else:\n                    prefix_sum[i][j] = prefix_sum[i][j - 1]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if grid[i - 1][j - 1] != 'X':\n                    continue\n                x_count, y_count = 0, 0\n                for k in range(i, 0, -1):\n                    x_count += prefix_sum[k][j]\n                    y_count += prefix_sum[k][j] - prefix_sum[k][j - 1]\n                    if x_count == y_count:\n                        count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3482",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        # Create a dictionary to store the indices of words that contain each character\n        char_indices = {char: [] for char in set(target)}\n        for i, word in enumerate(words):\n            for char in set(word):\n                if char in char_indices:\n                    char_indices[char].append(i)\n        \n        # Initialize the result with the cost of appending all characters from the first word\n        result = float('inf')\n        for i in char_indices[target[0]]:\n            result = min(result, costs[i])\n        \n        # Use dynamic programming to find the minimum cost\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        \n        for i in range(1, len(target) + 1):\n            for j in range(i):\n                if target[j:i] in words:\n                    idx = char_indices[target[j:i]].index(words.index(target[j:i]))\n                    dp[i] = min(dp[i], dp[j] + costs[idx])\n                else:\n                    for k in char_indices[target[j]]:\n                        if words[k].startswith(target[j:i]):\n                            dp[i] = min(dp[i], dp[j] + costs[k])\n        \n        # Return the result if it's not infinity, otherwise return -1\n        return result if result != float('inf') else -1"
        ]
    },
    {
        "question_id": "3484",
        "code_list": [
            "class Solution:\n    def getSmallestString(self, s: str) -> str:\n        n = len(s)\n        result = list(s)\n        \n        for i in range(n):\n            # Find the smallest character with the same parity on the right side\n            min_char = '9'\n            min_index = -1\n            for j in range(i + 1, n):\n                if int(s[j]) < int(min_char) and (int(s[j]) % 2 == int(s[i]) % 2):\n                    min_char = s[j]\n                    min_index = j\n            \n            # If we found a smaller character with the same parity, perform the swap\n            if min_index != -1:\n                result[i], result[min_index] = result[min_index], result[i]\n                break\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "3494",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n        # Add the initial dimensions to the respective cut lists\n        horizontalCut = [0] + sorted(horizontalCut) + [m]\n        verticalCut = [0] + sorted(verticalCut) + [n]\n        \n        # Calculate the total cost for horizontal cuts\n        total_cost = sum(horizontalCut[i+1] - horizontalCut[i] for i in range(len(horizontalCut) - 1))\n        \n        # Calculate the total cost for vertical cuts\n        for i in range(len(verticalCut) - 1):\n            total_cost += verticalCut[i+1] - verticalCut[i]\n        \n        return total_cost"
        ]
    },
    {
        "question_id": "3508",
        "code_list": [
            "class Solution:\n    def minChanges(self, n: int, k: int) -> int:\n        # Convert n and k to their binary representations without the '0b' prefix\n        bin_n = bin(n)[2:]\n        bin_k = bin(k)[2:]\n        \n        # Pad the shorter binary string with leading zeros to match the length of the longer one\n        max_len = max(len(bin_n), len(bin_k))\n        bin_n = bin_n.zfill(max_len)\n        bin_k = bin_k.zfill(max_len)\n        \n        # Count the number of positions where the bits differ\n        diff_count = sum(1 for b_n, b_k in zip(bin_n, bin_k) if b_n != b_k)\n        \n        # If all bits of n are 1 and k has at least one 0, it's impossible to make them equal\n        if all(b == '1' for b in bin_n) and '0' in bin_k:\n            return -1\n        \n        return diff_count"
        ]
    },
    {
        "question_id": "3462",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def doesAliceWin(self, s: str) -> bool:\n        # Count the number of vowels in the string\n        vowel_count = sum(1 for char in s if char in 'aeiou')\n        \n        # If the total number of vowels is odd, Alice can always win\n        # because she goes first and can always find a substring with an odd number of vowels\n        # until the last move when the remaining string has exactly one vowel\n        return vowel_count % 2 != 0"
        ]
    },
    {
        "question_id": "3493",
        "code_list": [
            "class Solution:\n    def maxOperations(self, s: str) -> int:\n        count = 0\n        ones = s.count('1')\n        zeros = s.count('0')\n        \n        # If there are more zeros than ones, we can always find a pair (1, 0)\n        if zeros >= ones:\n            return ones\n        \n        # Otherwise, we need to consider the positions of 1s and 0s\n        i = 0\n        while i < len(s):\n            if s[i] == '1':\n                j = i + 1\n                while j < len(s) and s[j] != '0':\n                    j += 1\n                if j < len(s):\n                    count += 1\n                    s = s[:i] + s[i+1:j] + s[i] + s[j+1:]\n                    i = j\n                else:\n                    break\n            else:\n                i += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3454",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        # Calculate the difference between corresponding elements of nums and target\n        diff = [abs(nums[i] - target[i]) for i in range(len(nums))]\n        # Sum up all the differences to get the total number of operations needed\n        return sum(diff)"
        ]
    },
    {
        "question_id": "3515",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single_digit_sum = sum(num for num in nums if 0 < num < 10)\n        double_digit_sum = sum(num for num in nums if 10 <= num <= 99)\n        \n        # If the sum of double-digit numbers is greater than or equal to the sum of single-digit numbers,\n        # Alice can always choose all double-digit numbers to win.\n        if double_digit_sum >= single_digit_sum:\n            return True\n        \n        # If there are no double-digit numbers, Alice can only choose single-digit numbers.\n        if not double_digit_sum:\n            return False\n        \n        # If the sum of single-digit numbers is greater, Alice needs to ensure she can pick enough to win.\n        # Since the maximum single-digit number is 9, Alice can always pick at least one more single-digit number\n        # than Bob if the difference is at least 10.\n        return single_digit_sum - double_digit_sum > 9"
        ]
    },
    {
        "question_id": "3507",
        "code_list": [
            "from math import sqrt\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        def is_prime(n: int) -> bool:\n            if n < 2:\n                return False\n            for i in range(2, int(sqrt(n)) + 1):\n                if n % i == 0:\n                    return False\n            return True\n        \n        non_special_count = 0\n        for x in range(l, r + 1):\n            proper_divisors = [i for i in range(1, x) if x % i == 0]\n            if len(proper_divisors) != 2:\n                non_special_count += 1\n        return non_special_count"
        ]
    },
    {
        "question_id": "3479",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        zero_count = s.count('0')\n        one_count = n - zero_count\n        dominant_substrings = 0\n        \n        for i in range(n):\n            if s[i] == '0':\n                zero_count -= 1\n            while zero_count * zero_count < one_count:\n                if s[i] == '0':\n                    zero_count += 1\n                i += 1\n                if i >= n:\n                    break\n            dominant_substrings += (n - i)\n        \n        return dominant_substrings"
        ]
    },
    {
        "question_id": "3478",
        "code_list": [
            "import math\n\nclass Solution:\n    def canReachCorner(self, xCorner: int, yCorner: int, circles: List[List[int]]) -> bool:\n        # Convert circles to a set for O(1) look-up time\n        circle_set = {(x, y) for x, y, r in circles}\n        \n        # Check if the starting point (0, 0) is blocked\n        if (0, 0) in circle_set:\n            return False\n        \n        # Check if the ending point (xCorner, yCorner) is blocked\n        if (xCorner, yCorner) in circle_set:\n            return False\n        \n        # Function to check if a point is within a circle's boundary\n        def is_within_circle(x, y, cx, cy, r):\n            return (x - cx) ** 2 + (y - cy) ** 2 <= r ** 2\n        \n        # Function to check if a line segment intersects with a circle\n        def line_segment_intersects_circle(x1, y1, x2, y2, cx, cy, r):\n            A = x2 - x1\n            B = y2 - y1\n            C = cx - x1\n            D = cy - y1\n            \n            dot = A * C + B * D\n            len_sq = A ** 2 + B ** 2\n            param = (-dot) / len_sq if len_sq > 0 else 0\n            \n            if param < 0:\n                return is_within_circle(x1, y1, cx, cy, r)\n            elif param > 1:\n                return is_within_circle(x2, y2, cx, cy, r)\n            \n            x = x1 + param * A\n            y = y1 + param * B\n            return is_within_circle(x, y, cx, cy, r)\n        \n        # Function to check if a point is on the boundary of the rectangle\n        def is_on_boundary(x, y):\n            return x == 0 or x == xCorner or y == 0 or y == yCorner\n        \n        # Function to check if a point is inside the rectangle\n        def is_inside_rectangle(x, y):\n            return 0 <= x <= xCorner and 0 <= y <= yCorner\n        \n        # Function to check if a path exists from (0, 0) to (xCorner, yCorner)\n        def dfs(x, y):\n            if (x, y) in visited:\n                return False\n            visited.add((x, y))\n            \n            if x == xCorner and y == yCorner:\n                return True\n            \n            # Check all 8 possible directions (up, down, left, right, and diagonals)\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_inside_rectangle(nx, ny) and not is_within_circle(nx, ny, x, y, 1e-9) and dfs(nx, ny):\n                    return True\n            \n            return False\n        \n        visited = set()\n        return dfs(0, 0)"
        ]
    },
    {
        "question_id": "3517",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the graph with direct connections\n        graph = {i: set(range(i + 1, n)) for i in range(n - 1)}\n        graph[n - 1] = set()\n        \n        # Initialize the result list\n        result = []\n        \n        # Function to perform BFS and find the shortest path\n        def bfs(start, end):\n            queue = deque([(start, 0)])\n            visited = set([start])\n            \n            while queue:\n                current, distance = queue.popleft()\n                \n                if current == end:\n                    return distance\n                \n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, distance + 1))\n            \n            return float('inf')\n        \n        # Process each query\n        for u, v in queries:\n            # Add the new road to the graph\n            graph[u].add(v)\n            graph[v].add(u)\n            \n            # Calculate the shortest path from 0 to n-1\n            shortest_path = bfs(0, n - 1)\n            \n            # Append the result to the list\n            result.append(shortest_path)\n        \n        return result"
        ]
    },
    {
        "question_id": "3527",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfAlternatingGroups(self, colors: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(colors)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + (colors[i] != colors[(i + 1) % n])\n        \n        def count_groups(size: int) -> int:\n            count = 0\n            i = 0\n            while i < n:\n                if prefix_sum[i + size] - prefix_sum[i] == size - 1:\n                    count += 1\n                    i += size\n                else:\n                    i += 1\n            return count\n        \n        result = []\n        for q in queries:\n            if q[0] == 1:\n                result.append(count_groups(q[1]))\n            elif q[0] == 2:\n                colors[q[1]] ^= 1  # Toggle the color\n                result.append(count_groups(q[1]))\n        \n        return result"
        ]
    },
    {
        "question_id": "3533",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:\n        # Initial position of the snake\n        i, j = 0, 0\n        \n        # Mapping of commands to direction changes\n        directions = {\n            \"UP\": (-1, 0),\n            \"DOWN\": (1, 0),\n            \"LEFT\": (0, -1),\n            \"RIGHT\": (0, 1)\n        }\n        \n        # Process each command\n        for command in commands:\n            di, dj = directions[command]\n            # Calculate new position while ensuring it stays within bounds\n            ni, nj = i + di, j + dj\n            if 0 <= ni < n and 0 <= nj < n:\n                i, j = ni, nj\n        \n        # Return the final position as a single integer\n        return i * n + j"
        ]
    },
    {
        "question_id": "3535",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        def count_non_decreasing(nums):\n            count = 1\n            current_sum = nums[0]\n            total_pairs = 0\n            for i in range(1, len(nums)):\n                if nums[i] >= current_sum:\n                    count += 1\n                    current_sum = nums[i]\n                else:\n                    total_pairs += (count * (count + 1)) // 2\n                    count = 1\n                    current_sum = nums[i]\n            total_pairs += (count * (count + 1)) // 2\n            return total_pairs\n        \n        def count_non_increasing(nums):\n            count = 1\n            current_sum = nums[0]\n            total_pairs = 0\n            for i in range(1, len(nums)):\n                if nums[i] <= current_sum:\n                    count += 1\n                    current_sum = nums[i]\n                else:\n                    total_pairs += (count * (count + 1)) // 2\n                    count = 1\n                    current_sum = nums[i]\n            total_pairs += (count * (count + 1)) // 2\n            return total_pairs\n        \n        total_pairs = 0\n        for i in range(len(nums)):\n            temp = nums[i]\n            nums[i] = 0\n            total_pairs += count_non_decreasing(nums) * count_non_increasing(nums)\n            nums[i] = temp\n        \n        return total_pairs % MOD"
        ]
    },
    {
        "question_id": "3447",
        "code_list": [
            "class Solution:\n    def clearDigits(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char.isdigit():\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(char)\n        return ''.join(stack)"
        ]
    },
    {
        "question_id": "3413",
        "code_list": [
            "from heapq import heappush, heappop\n\nclass Solution:\n    def findWinningPlayer(self, skills: List[int], k: int) -> int:\n        max_heap = []\n        for i, skill in enumerate(skills):\n            heappush(max_heap, (-skill, i))\n        \n        current_winner = None\n        consecutive_wins = 0\n        \n        while max_heap:\n            opponent_skill, opponent_index = heappop(max_heap)\n            if current_winner is None or current_winner == opponent_index:\n                current_winner = opponent_index\n                consecutive_wins += 1\n                if consecutive_wins == k:\n                    return current_winner\n            else:\n                consecutive_wins = 1\n                current_winner = opponent_index\n            \n            # Push the next opponent into the heap\n            next_opponent_skill = -heappop(max_heap)[0]\n            if next_opponent_skill > skills[opponent_index]:\n                heappush(max_heap, (-next_opponent_skill, opponent_index))\n            else:\n                heappush(max_heap, (opponent_skill, opponent_index))\n                heappush(max_heap, (-next_opponent_skill, next_opponent_skill))\n        \n        return current_winner"
        ]
    },
    {
        "question_id": "3456",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][0] = 1  # Base case: any single number can form a valid subsequence of length 1\n            \n            for j in range(i - 1, -1, -1):\n                diff = 0\n                while j >= 0 and nums[j] == nums[i]:\n                    diff += 1\n                    j -= 1\n                \n                for m in range(k + 1):\n                    if m - diff >= 0:\n                        dp[i][m] = max(dp[i][m], dp[j][m - diff] + diff)\n                    else:\n                        break\n        \n        return max(dp[n-1])"
        ]
    },
    {
        "question_id": "3476",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        count = [0] * 3\n        for num in nums:\n            count[num % 3] += 1\n        \n        if count[1] == 0 and count[2] == 0:\n            return 0\n        \n        min_ops = float('inf')\n        if count[1] > 0 and count[2] > 0:\n            min_ops = min(min_ops, (count[1] + count[2]) // 3 * 3 + abs(count[1] - count[2]))\n        elif count[1] > 0:\n            min_ops = min(min_ops, count[1] // 3 * 3 + count[2])\n        elif count[2] > 0:\n            min_ops = min(min_ops, count[2] // 3 * 3 + count[1])\n        \n        return min_ops"
        ]
    },
    {
        "question_id": "3475",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[-1] * 3 for _ in range(n)]\n        \n        def dfs(index, prev_flips):\n            if index == n:\n                return 0 if prev_flips == 3 else float('inf')\n            if dp[index][prev_flips] != -1:\n                return dp[index][prev_flips]\n            \n            # Option 1: Do nothing\n            res = dfs(index + 1, prev_flips)\n            \n            # Option 2: Flip the current element and the next two elements\n            if index < n - 2:\n                if nums[index] == 1:\n                    res = min(res, dfs(index + 3, (prev_flips + 1) % 3) + 1)\n                else:\n                    res = min(res, dfs(index + 3, (prev_flips + 1) % 3))\n            \n            dp[index][prev_flips] = res\n            return res\n        \n        result = dfs(0, 0)\n        return result if result != float('inf') else -1"
        ]
    },
    {
        "question_id": "3460",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        \n        # Sort requirements based on end index\n        requirements.sort()\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for end, cnt in requirements:\n            new_dp = [0] * (n + 1)\n            for i in range(n):\n                if dp[i] == 0:\n                    continue\n                # Calculate the number of ways to place the remaining numbers\n                for j in range(i + 1, n):\n                    if cnt >= 0:\n                        new_dp[j] += dp[i]\n                        new_dp[j] %= MOD\n                        cnt -= 1\n                    else:\n                        break\n            dp = new_dp\n        \n        return dp[n] % MOD"
        ]
    },
    {
        "question_id": "3463",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfAlternatingGroups(self, colors: List[int]) -> int:\n        n = len(colors)\n        count = 0\n        \n        for i in range(n):\n            if (colors[i] != colors[(i - 1) % n] and colors[i] != colors[(i + 1) % n]):\n                count += 1\n                \n        return count"
        ]
    },
    {
        "question_id": "3264",
        "code_list": [
            "from typing import List\nimport bisect\n\nclass Solution:\n    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:\n        enemyEnergies.sort()\n        n = len(enemyEnergies)\n        dp = [0] * (n + 1)\n        for i in range(n):\n            # Calculate the maximum points if we use the current enemy\n            max_points = 0\n            j = bisect.bisect_left(enemyEnergies, currentEnergy - enemyEnergies[i])\n            if j > 0:\n                max_points = max(max_points, dp[j - 1] + 1)\n            k = bisect.bisect_right(enemyEnergies, currentEnergy + enemyEnergies[i])\n            if k < n:\n                max_points = max(max_points, dp[k] + 1)\n            dp[i + 1] = max(dp[i], max_points)\n        return dp[n]"
        ]
    },
    {
        "question_id": "3466",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        prefix_and = 0\n        freq = {0: 1}\n        \n        for num in nums:\n            prefix_and &= num\n            if prefix_and < k:\n                prefix_and = 0\n            count += freq.get(prefix_and & k, 0)\n            freq[prefix_and] = freq.get(prefix_and, 0) + 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3511",
        "code_list": [
            "class Solution:\n    def losingPlayer(self, x: int, y: int) -> str:\n        # Calculate the remainder when the total number of coins is divided by 2\n        remainder = (x * 75 + y * 10) % 2\n        \n        # If the remainder is 0, Bob loses; otherwise, Alice loses\n        return \"Bob\" if remainder == 0 else \"Alice\""
        ]
    },
    {
        "question_id": "3455",
        "code_list": [
            "class Solution:\n    def minimumLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            if stack and stack[-1] == char:\n                stack.pop()\n            else:\n                stack.append(char)\n        return len(stack)"
        ]
    },
    {
        "question_id": "3498",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        half_n = n // 2\n        dp = [float('inf')] * (half_n + 1)\n        dp[0] = 0\n        \n        # Group indices by their positions relative to the center\n        groups = [defaultdict(int) for _ in range(k)]\n        for i in range(half_n):\n            groups[i % k][nums[i]] += 1\n            groups[(k - i - 1) % k][nums[half_n + i]] += 1\n        \n        # Calculate the maximum frequency of each group\n        max_freq = [max(group.values(), default=0) for group in groups]\n        \n        for i in range(1, half_n + 1):\n            for j in range(k):\n                for num in range(k + 1):\n                    cost = abs(num - nums[i - 1])\n                    if j == (i - 1) % k:\n                        cost -= 1\n                    dp[i] = min(dp[i], dp[i - 1] + cost)\n            \n            for j in range(k):\n                for num in range(k + 1):\n                    cost = abs(num - nums[half_n + i - 1])\n                    if j == (k - (i - 1) - 1) % k:\n                        cost -= 1\n                    dp[i] = min(dp[i], dp[i - 1] + cost)\n        \n        return dp[half_n]"
        ]
    },
    {
        "question_id": "3519",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def winningPlayerCount(self, n: int, pick: List[List[int]]) -> int:\n        color_count = defaultdict(int)\n        winning_players = 0\n        \n        for player, color in pick:\n            color_count[color] += 1\n            if color_count[color] > player:\n                winning_players += 1\n        \n        return winning_players"
        ]
    },
    {
        "question_id": "3526",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minFlips(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        all_ones = (1 << n) - 1\n        \n        # Helper function to check if a row is palindromic\n        def is_palindromic(row):\n            return row == row[::-1]\n        \n        # Helper function to count flips needed to make a row palindromic\n        def count_flips_to_palindromic(row):\n            original = row[:]\n            for i in range(n // 2):\n                if row[i] != row[n - 1 - i]:\n                    row[i], row[n - 1 - i] = 1 - row[i], 1 - row[n - 1 - i]\n            return sum(original[i] != row[i] for i in range(n))\n        \n        # Convert each row to its binary representation\n        rows = [sum((1 << j) * val for j, val in enumerate(row)) for row in grid]\n        \n        # Calculate the minimum flips needed to make all rows palindromic\n        min_flips_rows = sum(count_flips_to_palindromic(row) for row in rows)\n        \n        # Transpose the grid to work with columns\n        transposed_grid = list(zip(*grid))\n        \n        # Convert each column to its binary representation\n        cols = [sum((1 << j) * val for j, val in enumerate(col)) for col in transposed_grid]\n        \n        # Calculate the minimum flips needed to make all columns palindromic\n        min_flips_cols = sum(count_flips_to_palindromic(col) for col in cols)\n        \n        # Return the minimum of the two scenarios\n        return min(min_flips_rows, min_flips_cols)"
        ]
    },
    {
        "question_id": "3532",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def timeTaken(self, edges: List[List[int]]) -> List[int]:\n        # Build the graph\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Function to perform DFS and calculate the time taken\n        def dfs(node, parent, time):\n            nonlocal max_time\n            max_time = max(max_time, time)\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node, time + 1)\n        \n        # Calculate the maximum time for each node\n        result = []\n        for i in range(len(edges) + 1):\n            max_time = 0\n            dfs(i, -1, 0)\n            result.append(max_time)\n        \n        return result"
        ]
    },
    {
        "question_id": "abc366_f",
        "code_list": [
            "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    for i in range(2, len(data), 2):\n        A = int(data[i])\n        B = int(data[i+1])\n        functions.append((A, B))\n    \n    max_value = 0\n    \n    def calculate_value(p):\n        current_value = 1\n        for index in p:\n            A, B = functions[index-1]\n            current_value = A * current_value + B\n        return current_value\n    \n    from itertools import permutations\n    \n    for perm in permutations(range(1, N+1), K):\n        max_value = max(max_value, calculate_value(perm))\n    \n    print(max_value)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_b",
        "code_list": [
            "def convert_to_vertical_text(n, strings):\n    # Find the maximum length of the strings\n    max_length = max(len(s) for s in strings)\n    \n    # Initialize the vertical strings list with empty strings\n    vertical_strings = [''] * max_length\n    \n    # Iterate over each character position\n    for i in range(max_length):\n        # Collect characters from each string at the current position\n        chars = []\n        for j in range(n):\n            if i < len(strings[j]):\n                chars.append(strings[j][i])\n            else:\n                chars.append('*')\n        \n        # Construct the vertical string for the current position\n        vertical_strings[i] = ''.join(chars)\n    \n    return vertical_strings\n\ndef main():\n    n = int(input())\n    strings = [input().strip() for _ in range(n)]\n    \n    vertical_strings = convert_to_vertical_text(n, strings)\n    \n    # Print the result\n    for vertical_string in vertical_strings:\n        print(vertical_string)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n, d = data[0], data[1]\n    points = [(data[i*2+2], data[i*2+3]) for i in range(n)]\n    \n    # Sort points by x-coordinate, then by y-coordinate\n    points.sort()\n    \n    def count_points(x, y):\n        cnt = 0\n        for px, py in points:\n            cnt += abs(px - x) + abs(py - y)\n        return cnt\n    \n    # Binary search to find the range of valid x values\n    left_x, right_x = -d, d\n    while left_x < right_x - 1:\n        mid_x = (left_x + right_x) // 2\n        if count_points(mid_x, 0) <= d:\n            left_x = mid_x\n        else:\n            right_x = mid_x\n    \n    # Binary search to find the range of valid y values\n    left_y, right_y = -d, d\n    while left_y < right_y - 1:\n        mid_y = (left_y + right_y) // 2\n        if count_points(0, mid_y) <= d:\n            left_y = mid_y\n        else:\n            right_y = mid_y\n    \n    # Count the number of valid (x, y) pairs\n    result = 0\n    for x in range(left_x, right_x + 1):\n        for y in range(left_y, right_y + 1):\n            if count_points(x, y) <= d:\n                result += 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_d",
        "code_list": [
            "def main():\n    import numpy as np\n    \n    # Read input\n    N = int(input())\n    A = []\n    for _ in range(N):\n        row = list(map(int, input().split()))\n        A.extend(row)\n    \n    Q = int(input())\n    queries = []\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, input().split())\n        queries.append((Lx - 1, Rx - 1, Ly - 1, Ry - 1, Lz - 1, Rz - 1))\n    \n    # Convert A to a 3D array\n    A_3d = np.array(A).reshape(N, N, N)\n    \n    # Process each query\n    for Lx, Rx, Ly, Ry, Lz, Rz in queries:\n        result = np.sum(A_3d[Lx:Rx+1, Ly:Ry+1, Lz:Rz+1])\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_a",
        "code_list": [
            "def main():\n    N, T, A = map(int, input().split())\n    remaining_votes = N - (T + A)\n    if T > A + remaining_votes:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_c",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    Q = int(input())\n    operations = []\n    \n    for _ in range(Q):\n        operation = list(map(int, input().split()))\n        operations.append(operation)\n    \n    ball_counts = Counter()\n    result = []\n    \n    for op in operations:\n        if op[0] == 1:\n            ball_counts[op[1]] += 1\n        elif op[0] == 2:\n            ball_counts[op[1]] -= 1\n            if ball_counts[op[1]] == 0:\n                del ball_counts[op[1]]\n        else:\n            result.append(len(ball_counts))\n    \n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_g",
        "code_list": [
            "from collections import defaultdict\n\ndef solve(N, M, edges):\n    # Build the adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Initialize the result array with zeros\n    result = [0] * N\n\n    # Function to check if a vertex can have a valid value\n    def dfs(vertex, parent, xor_sum):\n        # Calculate the required value for the current vertex\n        required_value = xor_sum ^ 0\n        result[vertex] = required_value\n        for neighbor in adj_list[vertex]:\n            if neighbor != parent:\n                dfs(neighbor, vertex, required_value)\n\n    # Start DFS from the first vertex\n    dfs(1, -1, 0)\n\n    # Check if the solution is valid\n    for vertex in range(1, N + 1):\n        xor_sum = 0\n        for neighbor in adj_list[vertex]:\n            if result[neighbor] != 0:\n                xor_sum ^= result[neighbor]\n        if xor_sum != 0:\n            return \"No\"\n\n    return \"Yes\\n\" + \" \".join(str(x) for x in result)\n\ndef main():\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    print(solve(N, M, edges))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_e",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    X = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    # Find the cycle or fixed point in the permutation\n    visited = [False] * (N + 1)\n    cycle_length = 0\n    current = 1\n    while not visited[current]:\n        visited[current] = True\n        current = X[current - 1]\n        cycle_length += 1\n\n    # If there's no cycle, K operations have no effect\n    if cycle_length == 0:\n        print(*A)\n        return\n\n    # Reduce K to the equivalent number of operations within one cycle\n    K %= cycle_length\n\n    # Perform the operations up to the reduced K\n    for _ in range(K):\n        for i in range(N):\n            A[i], A[X[i] - 1] = A[X[i] - 1], A[i]\n\n    print(*A)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_f",
        "code_list": [
            "from collections import Counter\n\ndef can_rearrange_subsequence(N, Q, A, B, queries):\n    def check_subsequence(A_subseq, B_subseq):\n        return Counter(A_subseq) == Counter(B_subseq)\n    \n    for l, r, L, R in queries:\n        A_subseq = A[l-1:r]\n        B_subseq = B[L-1:R]\n        if check_subsequence(A_subseq, B_subseq):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\ndef main():\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    can_rearrange_subsequence(N, Q, A, B, queries)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_a",
        "code_list": [
            "def main():\n    A, B, C = map(int, input().split())\n    # Check if A is within the wake-up period or crosses midnight\n    if B <= A < C or (A >= C and A < 24 and B < C):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_g",
        "code_list": [
            "from collections import defaultdict\nfrom math import pow\n\nMOD = 998244353\n\ndef solve(N, M, K, A):\n    def xor_sum(xor_val, length):\n        if length % M == 0:\n            return pow(xor_val, K, MOD)\n        else:\n            return 0\n\n    def dfs(index, current_xor, length):\n        if index == N:\n            return xor_sum(current_xor, length)\n\n        # Include current element\n        include = dfs(index + 1, current_xor ^ A[index], length + 1)\n        # Exclude current element\n        exclude = dfs(index + 1, current_xor, length)\n\n        return (include + exclude) % MOD\n\n    return dfs(0, 0, 0)\n\nif __name__ == \"__main__\":\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(solve(N, M, K, A))"
        ]
    },
    {
        "question_id": "abc367_b",
        "code_list": [
            "def main():\n    X = float(input())\n    X_str = f\"{X:.3f}\"\n    if X_str[-1] == '0':\n        X_str = X_str.rstrip('0')\n    if X_str[-1] == '.':\n        X_str = X_str[:-1]\n    print(X_str)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_d",
        "code_list": [
            "from math import gcd\nfrom collections import Counter\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Calculate prefix sum modulo M\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = (prefix_sum[i - 1] + A[i - 1]) % M\n    \n    # Count occurrences of each prefix sum modulo M\n    count = Counter(prefix_sum)\n    \n    # Calculate the number of valid pairs\n    result = 0\n    for freq in count.values():\n        result += freq * (freq - 1) // 2\n    \n    # Add pairs where both start and end at the same rest area\n    result += count[0] * (count[0] - 1) // 2\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_c",
        "code_list": [
            "from itertools import product\n\ndef find_sequences(N, K, R):\n    sequences = []\n    for comb in product(*[range(1, R[i]+1) for i in range(N)]):\n        if sum(comb) % K == 0:\n            sequences.append(comb)\n    return sorted(sequences)\n\ndef main():\n    N, K = map(int, input().split())\n    R = list(map(int, input().split()))\n    sequences = find_sequences(N, K, R)\n    print(len(sequences))\n    for seq in sequences:\n        print(' '.join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_g",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def process_queries(data):\n        n = data[0]\n        A = data[1:n+1]\n        B = data[n+1:2*n+1]\n        queries = data[2*n+1:]\n\n        class QueryProcessor:\n            def __init__(self, A, B):\n                self.A = A\n                self.B = B\n                self.N = len(A)\n                self.A_updates = [False] * (4 * self.N)\n                self.B_updates = [False] * (4 * self.N)\n                self.A_tree = [0] * (4 * self.N)\n                self.B_tree = [0] * (4 * self.N)\n\n            def update_A(self, node, start, end, idx, val):\n                if start == end:\n                    self.A_tree[node] = val\n                    return\n                mid = (start + end) // 2\n                if idx <= mid:\n                    self.update_A(2 * node, start, mid, idx, val)\n                else:\n                    self.update_A(2 * node + 1, mid + 1, end, idx, val)\n                self.A_tree[node] = max(self.A_tree[2 * node], self.A_tree[2 * node + 1])\n\n            def update_B(self, node, start, end, idx, val):\n                if start == end:\n                    self.B_tree[node] = val\n                    return\n                mid = (start + end) // 2\n                if idx <= mid:\n                    self.update_B(2 * node, start, mid, idx, val)\n                else:\n                    self.update_B(2 * node + 1, mid + 1, end, idx, val)\n                self.B_tree[node] = max(self.B_tree[2 * node], self.B_tree[2 * node + 1])\n\n            def query(self, node, start, end, l, r):\n                if l > end or r < start:\n                    return 0\n                if l <= start and end <= r:\n                    return self.A_tree[node] + self.B_tree[node]\n                mid = (start + end) // 2\n                left_sum = self.query(2 * node, start, mid, l, r)\n                right_sum = self.query(2 * node + 1, mid + 1, end, l, r)\n                return max(left_sum, right_sum)\n\n            def process_query(self, query_type, i, x):\n                if query_type == 1:\n                    self.A_updates[i] = True\n                    self.A[i] = x\n                elif query_type == 2:\n                    self.B_updates[i] = True\n                    self.B[i] = x\n                else:\n                    l, r = i - 1, x - 1\n                    return self.query(1, 0, self.N - 1, l, r)\n\n            def apply_updates(self):\n                for i in range(self.N):\n                    if self.A_updates[i]:\n                        self.update_A(1, 0, self.N - 1, i, self.A[i])\n                        self.A_updates[i] = False\n                    if self.B_updates[i]:\n                        self.update_B(1, 0, self.N - 1, i, self.B[i])\n                        self.B_updates[i] = False\n\n        processor = QueryProcessor(A, B)\n        query_count = len(queries) // 3\n        results = []\n        for i in range(query_count):\n            query_type, l, r = queries[i * 3:i * 3 + 3]\n            result = processor.process_query(query_type, l, r)\n            results.append(result)\n        for result in results:\n            print(result)\n\n    process_queries(data)"
        ]
    },
    {
        "question_id": "abc368_a",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Take K cards from the bottom and place them on top\n    bottom_cards = A[-K:]\n    top_cards = A[:-K]\n    new_stack = bottom_cards + top_cards\n\n    # Print the result\n    print(' '.join(map(str, new_stack)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    operations = 0\n    \n    while len([x for x in A if x > 0]) > 1:\n        A.sort(reverse=True)\n        A[0] -= 1\n        A[1] -= 1\n        operations += 1\n    \n    print(operations)"
        ]
    },
    {
        "question_id": "abc368_f",
        "code_list": [
            "def main():\n    import math\n    \n    def count_divisors(n):\n        count = 0\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                if i * i == n:\n                    count += 1\n                else:\n                    count += 2\n        return count\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    xor_result = 0\n    for num in A:\n        divisors_count = count_divisors(num)\n        if divisors_count % 2 == 0:\n            xor_result ^= 1\n        else:\n            xor_result ^= 0\n    \n    if xor_result:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def calculate_attacks(n, healths):\n        total_attacks = 0\n        for health in healths:\n            if health % 3 == 0:\n                total_attacks += health // 3\n            elif health % 3 == 1:\n                total_attacks += (health + 2) // 3\n            else:\n                total_attacks += (health + 1) // 3\n        return total_attacks\n    \n    n = int(input())\n    healths = list(map(int, input().split()))\n    \n    result = calculate_attacks(n, healths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_d",
        "code_list": [
            "from collections import defaultdict\n\ndef find_root(parent, node):\n    while parent[node] != node:\n        node = parent[node]\n    return node\n\ndef union_set(parent, rank, x, y):\n    rootX = find_root(parent, x)\n    rootY = find_root(parent, y)\n    if rank[rootX] > rank[rootY]:\n        parent[rootY] = rootX\n    elif rank[rootX] < rank[rootY]:\n        parent[rootX] = rootY\n    else:\n        parent[rootY] = rootX\n        rank[rootX] += 1\n\ndef min_vertices_in_tree(N, edges, V):\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n    \n    # Union-Find to group connected components\n    for u, v in edges:\n        union_set(parent, rank, u, v)\n    \n    # Find the root of each specified vertex\n    roots = set()\n    for v in V:\n        roots.add(find_root(parent, v))\n    \n    # If all specified vertices are already in one component, return the size of that component\n    if len(roots) == 1:\n        return len(V)\n    \n    # Otherwise, find the minimum number of vertices needed to cover all specified vertices\n    min_vertices = float('inf')\n    for v in V:\n        root_v = find_root(parent, v)\n        min_vertices = min(min_vertices, len(V) - sum(1 for v in V if find_root(parent, v) != root_v) + 1)\n    \n    return min_vertices\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    edges = []\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    V = list(map(int, input().split()))\n    \n    print(min_vertices_in_tree(N, edges, V))"
        ]
    },
    {
        "question_id": "abc368_e",
        "code_list": [
            "import heapq\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef solve(N, M, X1, edges):\n    # Build the graph\n    graph = [[] for _ in range(N)]\n    for A, B, S, T in edges:\n        A -= 1\n        B -= 1\n        graph[A].append((B, T - S))\n    \n    # Run Dijkstra's algorithm to get the shortest path distances\n    dist = dijkstra(N, graph, 0)\n    \n    # Calculate the delays\n    delays = [0] * M\n    for i, (A, B, S, T) in enumerate(edges):\n        A -= 1\n        B -= 1\n        delays[i] = max(0, dist[B] - (T - S) + X1)\n    \n    return delays[1:]\n\nif __name__ == \"__main__\":\n    N, M, X1 = map(int, input().split())\n    edges = []\n    for i in range(M):\n        A, B, S, T = map(int, input().split())\n        edges.append((A, B, S, T))\n    result = solve(N, M, X1, edges)\n    print(\" \".join(map(str, result)))"
        ]
    },
    {
        "question_id": "abc369_d",
        "code_list": [
            "def max_experience_points(N, A):\n    # Initialize variables to keep track of the maximum experience points\n    even_max = 0\n    odd_max = 0\n    total_even = 0\n    total_odd = 0\n    \n    for i in range(N):\n        if i % 2 == 0:\n            # Even-indexed (0-based) position\n            total_even += A[i]\n            even_max = max(even_max, total_even)\n        else:\n            # Odd-indexed (0-based) position\n            total_odd += A[i]\n            odd_max = max(odd_max, total_odd)\n    \n    # The maximum experience points is the sum of the maximum values for even and odd positions\n    return even_max + odd_max\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(max_experience_points(N, A))"
        ]
    },
    {
        "question_id": "abc369_g",
        "code_list": [
            "import sys\nfrom typing import List\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    edges = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        U, V, L = map(int, input().split())\n        U -= 1\n        V -= 1\n        edges[U].append((V, L))\n        edges[V].append((U, L))\n\n    def dfs(node: int, parent: int) -> (int, int):\n        dist, max_dist = 0, 0\n        for child, length in edges[node]:\n            if child != parent:\n                d, md = dfs(child, node)\n                dist += d + length\n                max_dist = max(max_dist, md + length)\n        return dist, max_dist\n\n    def solve(K: int) -> int:\n        if K == 1:\n            return 2 * dfs(0, -1)[0]\n\n        # Calculate the diameter of the tree\n        def find_diameter() -> int:\n            _, diameter = dfs(0, -1)\n            return diameter\n\n        diameter = find_diameter()\n\n        # Calculate the sum of distances from the farthest node to all other nodes\n        def calculate_sum_of_distances() -> int:\n            dist, _ = dfs(0, -1)\n            return dist\n\n        sum_of_distances = calculate_sum_of_distances()\n\n        # Calculate the minimum possible score\n        min_score = sum_of_distances + diameter\n\n        return min_score\n\n    for K in range(1, N + 1):\n        print(solve(K))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc369_c",
        "code_list": [
            "def count_arithmetic_progressions(N, A):\n    def count_from_start(i):\n        d = None\n        count = 1\n        for j in range(i + 1, N):\n            if d is None:\n                d = A[j] - A[i]\n            elif A[j] - A[j - 1] != d:\n                break\n            else:\n                count += 1\n        return count\n    \n    total_count = 0\n    for i in range(N):\n        total_count += count_from_start(i)\n    \n    return total_count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(count_arithmetic_progressions(N, A))"
        ]
    },
    {
        "question_id": "abc369_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    count = 0\n    \n    # Calculate the possible values of x\n    if A != B:\n        # Case 1: A, B, x form an arithmetic sequence with common difference (B - A)\n        x1 = A + (B - A) * 2\n        x2 = B + (A - B) * 2\n        \n        # Check if x1 and x2 are within the valid range\n        if x1 >= min(A, B) and x1 <= max(A, B):\n            count += 1\n        if x2 >= min(A, B) and x2 <= max(A, B):\n            count += 1\n            \n        # Case 2: A, x, B form an arithmetic sequence with common difference (B - A) / 2\n        x3 = A + (B - A)\n        x4 = B + (A - B)\n        \n        # Check if x3 and x4 are within the valid range\n        if x3 >= min(A, B) and x3 <= max(A, B):\n            count += 1\n        if x4 >= min(A, B) and x4 <= max(A, B):\n            count += 1\n    \n    else:\n        # If A and B are the same, the only possible value for x is A or B itself\n        count = 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc369_b",
        "code_list": [
            "def min_fatigue_level(N, actions):\n    # Initialize positions and fatigue level\n    left_hand_pos = 0\n    right_hand_pos = 0\n    fatigue_level = 0\n    \n    # Process each action\n    for i in range(N):\n        key, hand = actions[i]\n        \n        # Calculate the distance to move the appropriate hand\n        if hand == 'L':\n            if left_hand_pos == 0:\n                left_hand_pos = key\n            else:\n                fatigue_level += abs(key - left_hand_pos)\n                left_hand_pos = key\n        elif hand == 'R':\n            if right_hand_pos == 0:\n                right_hand_pos = key\n            else:\n                fatigue_level += abs(key - right_hand_pos)\n                right_hand_pos = key\n    \n    return fatigue_level\n\nif __name__ == \"__main__\":\n    N = int(input())\n    actions = []\n    for _ in range(N):\n        A, S = input().split()\n        actions.append((int(A), S))\n    \n    print(min_fatigue_level(N, actions))"
        ]
    },
    {
        "question_id": "abc369_e",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start, end, used_edges):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if u == end:\n            return d\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if (u, v) in used_edges or (v, u) in used_edges:\n                continue\n            new_dist = d + w\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n    return float('inf')\n\ndef solve(N, M, edges, Q, queries):\n    graph = defaultdict(list)\n    for u, v, t in edges:\n        graph[u-1].append((v-1, t))\n        graph[v-1].append((u-1, t))\n    \n    def min_time(query):\n        used_edges = set()\n        for edge in query:\n            used_edges.add((edge, edges[edge-1][0], edges[edge-1][1]))\n            used_edges.add((edges[edge-1][0], edge, edges[edge-1][1]))\n        \n        min_dist = dijkstra(graph, 0, N-1, used_edges)\n        return min_dist\n    \n    results = []\n    for query in queries:\n        results.append(min_time(query))\n    \n    return results\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        u, v, t = map(int, input().split())\n        edges.append((u, v, t))\n    \n    Q = int(input())\n    queries = []\n    for _ in range(Q):\n        K = int(input())\n        query = list(map(int, input().split()))\n        queries.append(query)\n    \n    results = solve(N, M, edges, Q, queries)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc370_a",
        "code_list": [
            "def main():\n    L, R = map(int, input().split())\n    if (L + R) == 1:\n        print(\"Yes\")\n    elif (L + R) == 2:\n        print(\"Invalid\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_g",
        "code_list": [
            "from math import sqrt\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef is_good(n):\n    def get_divisors_sum(n):\n        if n == 1:\n            return 1\n        divisors_sum = 1 + n\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    return get_divisors_sum(n) % 3 == 0\n\n@lru_cache(None)\ndef count_good_sequences(n, m):\n    if m == 1:\n        return sum(is_good(i) for i in range(1, n + 1))\n    \n    total = 0\n    for i in range(1, n + 1):\n        if is_good(i):\n            total += count_good_sequences(n // i, m - 1)\n            total %= MOD\n    return total\n\ndef main():\n    N, M = map(int, input().split())\n    print(count_good_sequences(N, M))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_c",
        "code_list": [
            "def main():\n    # Read input strings S and T\n    S = input().strip()\n    T = input().strip()\n\n    # Initialize the result array X\n    X = []\n\n    # Iterate through each character position\n    for i in range(len(S)):\n        # If characters at position i are different\n        if S[i] != T[i]:\n            # Append all intermediate states to X\n            while len(X) <= i:\n                X.append(X[-1][:i] + S[i])\n            break\n\n    # Append the final state T to X\n    X.append(T)\n\n    # Output the length of X\n    print(len(X))\n\n    # Output each element of X\n    for x in X:\n        print(x)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    H, W, Q = map(int, input().split())\n    walls = defaultdict(lambda: defaultdict(bool))\n    \n    # Initialize walls\n    for i in range(H):\n        for j in range(W):\n            walls[i][j] = True\n    \n    for _ in range(Q):\n        R, C = map(int, input().split())\n        R -= 1\n        C -= 1\n        \n        if walls[R][C]:\n            walls[R][C] = False\n        else:\n            # Destroy walls in the specified directions\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                r, c = R + dr, C + dc\n                while 0 <= r < H and 0 <= c < W and walls[r][c]:\n                    walls[r][c] = False\n                    r += dr\n                    c += dc\n    \n    # Count remaining walls\n    remaining_walls = sum(walls.values(), defaultdict(bool)).values().count(True)\n    print(remaining_walls)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_e",
        "code_list": [
            "from collections import defaultdict\n\ndef count_divisions(N, K, A):\n    MOD = 998244353\n    prefix_sum = [0]\n    for num in A:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, K + 1):\n        for j in range(N + 1):\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n                dp[i][j] %= MOD\n            if j >= i and prefix_sum[j] - prefix_sum[j - i] == K:\n                dp[i][j] -= dp[i - 1][j - i]\n                dp[i][j] = (dp[i][j] + MOD) % MOD\n    \n    result = 0\n    for j in range(N + 1):\n        result += dp[K][j]\n        result %= MOD\n    \n    return result\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(count_divisions(N, K, A))"
        ]
    },
    {
        "question_id": "abc370_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def parse_input():\n        return [line.strip() for line in sys.stdin.readlines()]\n    \n    def parse_matrix(input_lines):\n        matrix = []\n        for line in input_lines[1:]:\n            row = list(map(int, line.split()))\n            matrix.append(row)\n        return matrix\n    \n    def find_final_element(n, matrix):\n        current_element = 1\n        for i in range(n):\n            for j in range(i + 1):\n                current_element = matrix[i][j] if i >= j else matrix[j][i]\n        return current_element\n    \n    input_lines = parse_input()\n    n = int(input_lines[0])\n    matrix = parse_matrix(input_lines)\n    \n    final_element = find_final_element(n, matrix)\n    print(final_element)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_f",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def solve(N, K, A):\n        prefix_sum = [0]\n        for a in A:\n            prefix_sum.append(prefix_sum[-1] + a)\n\n        min_w = (prefix_sum[-1] + K - 1) // K\n        left = 0\n        right = N + 1\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid, N, K, prefix_sum):\n                left = mid + 1\n            else:\n                right = mid\n\n        ans = left - 1\n        cut_lines = 0\n        for i in range(1, N + 1):\n            if prefix_sum[i] > ans * K and prefix_sum[i - 1] <= ans * K:\n                cut_lines += 1\n\n        print(ans, N - cut_lines)\n\n    def check(mid, N, K, prefix_sum):\n        count = 0\n        for i in range(1, N + 1):\n            if prefix_sum[i] > mid * K and prefix_sum[i - 1] <= mid * K:\n                count += 1\n        return count >= K\n\n    N, K = data[0], data[1]\n    A = data[2:N + 2]\n    solve(N, K, A)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_b",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    families = [False] * N  # Track if a family has had its earliest born male child named Taro\n    \n    for _ in range(M):\n        A, B = map(str, input().split())\n        A = int(A) - 1  # Convert family index to 0-based index\n        \n        if B == 'M' and not families[A]:\n            print('Yes')\n            families[A] = True  # Mark this family as having named its earliest born male child\n        else:\n            print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    x_coords = list(map(int, data[1:n+1]))\n    p_values = list(map(int, data[n+1:2*n+1]))\n    q = int(data[2*n+1])\n\n    # Create a prefix sum array for the number of villagers\n    prefix_sum = [0]\n    for p in p_values:\n        prefix_sum.append(prefix_sum[-1] + p)\n\n    # Process each query\n    for _ in range(q):\n        l, r = map(int, data[2*n+2:])\n        left_index = bisect_left(x_coords, l)\n        right_index = bisect_right(x_coords, r)\n        result = prefix_sum[right_index] - prefix_sum[left_index]\n        print(result)\n\nfrom bisect import bisect_left, bisect_right"
        ]
    },
    {
        "question_id": "abc371_g",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_cycle(start, permutation):\n        cycle = []\n        current = start\n        while True:\n            cycle.append(current)\n            next_pos = permutation[current - 1]\n            if next_pos == start:\n                break\n            current = next_pos\n        return cycle\n    \n    def apply_permutation(cycle, array):\n        new_array = list(array)\n        for i, pos in enumerate(cycle):\n            new_array[pos - 1] = array[cycle[(i + 1) % len(cycle)] - 1]\n        return new_array\n    \n    n = int(input())\n    permutation = list(map(int, input().split()))\n    array = list(map(int, input().split()))\n    \n    # Find cycles\n    cycles = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            cycle = find_cycle(i, permutation)\n            cycles.append(cycle)\n            for pos in cycle:\n                visited[pos] = True\n    \n    # Apply each cycle to the array\n    for cycle in cycles:\n        array = apply_permutation(cycle, array)\n    \n    # Output the result\n    print(' '.join(map(str, array)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_f",
        "code_list": [
            "def min_movements(N, X, Q, tasks):\n    # Initialize prefix sum array for positions\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + X[i]\n    \n    # Sort tasks based on T_i\n    tasks.sort(key=lambda x: x[0])\n    \n    # Initialize result and current position\n    result = 0\n    current_position = 0\n    \n    # Process each task\n    for task in tasks:\n        person_index = task[0] - 1\n        target_position = task[1]\n        \n        # Calculate the distance to move the person\n        distance = abs(target_position - current_position)\n        \n        # Calculate the minimum movements needed\n        if person_index == 0:\n            result += distance\n        elif person_index == N - 1:\n            result += distance + prefix_sum[N] - prefix_sum[person_index + 1]\n        else:\n            result += min(distance + prefix_sum[person_index + 1] - prefix_sum[0],\n                          distance + prefix_sum[N] - prefix_sum[person_index + 1])\n        \n        # Update current position\n        current_position = target_position\n    \n    return result\n\nif __name__ == \"__main__\":\n    N = int(input())\n    X = list(map(int, input().split()))\n    Q = int(input())\n    tasks = []\n    for _ in range(Q):\n        T, G = map(int, input().split())\n        tasks.append((T, G))\n    \n    print(min_movements(N, X, Q, tasks))"
        ]
    },
    {
        "question_id": "abc371_c",
        "code_list": [
            "import itertools\nfrom typing import List\n\ndef min_cost_to_isomorph(G_edges: List[List[int]], H_edges: List[List[int]], costs: List[List[int]]) -> int:\n    N = len(costs)\n    # Convert edges to adjacency matrix representation\n    G_adj = [[0] * N for _ in range(N)]\n    for u, v in G_edges:\n        G_adj[u - 1][v - 1] = 1\n        G_adj[v - 1][u - 1] = 1\n    \n    H_adj = [[0] * N for _ in range(N)]\n    for a, b in H_edges:\n        H_adj[a - 1][b - 1] = 1\n        H_adj[b - 1][a - 1] = 1\n    \n    # Generate all permutations of vertex labels\n    perms = list(itertools.permutations(range(N)))\n    \n    min_cost = float('inf')\n    for perm in perms:\n        current_cost = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if G_adj[i][j] != H_adj[perm[i]][perm[j]]:\n                    current_cost += costs[i][j]\n        min_cost = min(min_cost, current_cost)\n    \n    return min_cost\n\ndef main():\n    N = int(input())\n    MG = int(input())\n    G_edges = [list(map(int, input().split())) for _ in range(MG)]\n    MH = int(input())\n    H_edges = [list(map(int, input().split())) for _ in range(MH)]\n    costs = [list(map(int, input().split())) for _ in range(N - 1)]\n    \n    result = min_cost_to_isomorph(G_edges, H_edges, costs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Initialize the result\n    result = 0\n    \n    # Dictionary to keep track of the last occurrence of each value\n    last_occurrence = defaultdict(int)\n    \n    for i in range(N):\n        # For each element, calculate the contribution to the result\n        for j in range(i, N):\n            value = A[j]\n            # Update the last occurrence of the current value\n            last_occurrence[value] = j + 1\n            \n            # The number of distinct values in the subsequence A[i:j+1]\n            distinct_count = len(last_occurrence)\n            \n            # Add the distinct count to the result\n            result += distinct_count\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_a",
        "code_list": [
            "def main():\n    S_AB, S_AC, S_BC = input().split()\n    \n    # Determine the order based on the given conditions\n    if (S_AB == '<' and S_AC == '<') or (S_AB == '>' and S_AC == '>'):\n        if S_BC == '<':\n            middle_brother = 'B'\n        else:\n            middle_brother = 'A'\n    elif (S_AB == '<' and S_AC == '>') or (S_AB == '>' and S_AC == '<'):\n        if S_BC == '<':\n            middle_brother = 'C'\n        else:\n            middle_brother = 'B'\n    else:\n        if S_BC == '<':\n            middle_brother = 'A'\n        else:\n            middle_brother = 'C'\n    \n    print(middle_brother)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_e",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef main():\n    N, Q = map(int, input().split())\n    graph = defaultdict(list)\n    answers = []\n\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            u, v = query[1], query[2]\n            graph[u].append(v)\n            graph[v].append(u)\n        else:\n            v, k = query[1], query[2]\n            connected_vertices = graph[v]\n            if len(connected_vertices) < k:\n                answers.append(-1)\n            else:\n                # Use a min heap to get the k-th largest element\n                min_heap = []\n                for vertex in connected_vertices:\n                    heapq.heappush(min_heap, vertex)\n                    if len(min_heap) > k:\n                        heapq.heappop(min_heap)\n                answers.append(min_heap[0])\n\n    for answer in answers:\n        print(answer)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_c",
        "code_list": [
            "def count_ABC_substrings(s):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == 'ABC':\n            count += 1\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    q = int(data[1])\n    s = data[2]\n    queries = [(int(data[i*2+3]), data[i*2+4]) for i in range(q)]\n\n    current_s = s\n    for x, c in queries:\n        current_s = current_s[:x-1] + c + current_s[x:]\n        print(count_ABC_substrings(current_s))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    heights = list(map(int, data[1:n+1]))\n    right_max = [0] * n\n    \n    stack = []\n    for i in range(n - 1, -1, -1):\n        while stack and heights[stack[-1]] <= heights[i]:\n            stack.pop()\n        if stack:\n            right_max[i] = stack[-1]\n        stack.append(i)\n    \n    result = []\n    for i in range(n):\n        result.append(right_max[i] - i - 1)\n    \n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_g",
        "code_list": [
            "from math import gcd\n\ndef solve_case(N, AB):\n    # Calculate the greatest common divisor of all A[i] and B[i]\n    g = AB[0][0]\n    for a, b in AB:\n        g = gcd(g, a)\n        if g == 1:\n            break\n    \n    # If the GCD is 1, then there are no solutions\n    if g == 1:\n        return 0\n    \n    # Find the maximum value of C[i] / GCD\n    max_c = max(c // g for a, b, c in AB)\n    \n    # Count the number of valid (x, y) pairs\n    count = 0\n    for c in range(1, max_c + 1):\n        # Solve the inequality a*x + b*y < c*g\n        # This is equivalent to finding the number of integer points below the line a*x + b*y = c*g\n        # Using the formula for the number of lattice points under a line\n        count += c * (c - 1) // 2\n    \n    return count\n\ndef main():\n    T = int(input())\n    results = []\n    for _ in range(T):\n        N = int(input())\n        AB = [tuple(map(int, input().split())) for _ in range(N)]\n        results.append(solve_case(N, AB))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_f",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M, K = map(int, input().split())\n    edges = defaultdict(list)\n    for _ in range(M):\n        X, Y = map(int, input().split())\n        edges[X].append(Y)\n\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N)]\n    dp[0][0] = 1\n\n    for k in range(K):\n        for v in range(N):\n            if v + 1 <= N:\n                dp[v][k + 1] += dp[(v + 1) % N][k]\n                dp[v][k + 1] %= MOD\n            if v - 1 >= 0:\n                dp[v][k + 1] += dp[(v - 1) % N][k]\n                dp[v][k + 1] %= MOD\n            for next_v in edges[v]:\n                dp[next_v - 1][k + 1] += dp[v][k]\n                dp[next_v - 1][k + 1] %= MOD\n\n    print(dp[0][K])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = S.replace('.', '')\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_a",
        "code_list": [
            "def main():\n    count = 0\n    for i in range(1, 13):\n        S_i = input().strip()\n        if len(S_i) == i:\n            count += 1\n    print(count)"
        ]
    },
    {
        "question_id": "abc373_b",
        "code_list": [
            "def calculate_min_distance(S):\n    # Initialize the starting position of the finger\n    current_position = 0\n    total_distance = 0\n    \n    # Iterate through each character in the alphabet\n    for char in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n        # Find the index of the current character in the permutation string S\n        target_position = S.index(char)\n        # Calculate the distance moved and add it to the total distance\n        total_distance += abs(current_position - target_position)\n        # Update the current position to the target position\n        current_position = target_position\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(calculate_min_distance(S))"
        ]
    },
    {
        "question_id": "abc373_f",
        "code_list": [
            "import heapq\n\ndef main():\n    N, W = map(int, input().split())\n    items = []\n    for _ in range(N):\n        w, v = map(int, input().split())\n        items.append((w, v))\n    \n    # Calculate the maximum number of items we can take for each type\n    max_items = [min(W // w, 10**10) for w, _ in items]\n    \n    # Calculate the happiness for each possible number of items\n    happiness = [(v * k - k * k, k) for _, v in items for k in range(1, min(max_items[items.index((_, v))], 100) + 1)]\n    \n    # Sort the happiness in descending order\n    happiness.sort(reverse=True)\n    \n    # Use a priority queue to keep track of the best combination of items\n    pq = []\n    total_weight = 0\n    total_happiness = 0\n    \n    for h, k in happiness:\n        if total_weight + k * items[h % len(items)][0] <= W:\n            heapq.heappush(pq, h)\n            total_weight += k * items[h % len(items)][0]\n            total_happiness += h\n        elif pq and h > pq[0]:\n            total_happiness += h - heapq.heappop(pq)\n            heapq.heappush(pq, h)\n    \n    print(total_happiness)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_g",
        "code_list": [
            "from typing import List\n\ndef orientation(p: tuple, q: tuple, r: tuple) -> int:\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef do_segments_intersect(p1: tuple, q1: tuple, p2: tuple, q2: tuple) -> bool:\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef find_permutation(N: int, P: List[tuple], Q: List[tuple]) -> List[int]:\n    def dfs(index: int, path: List[int]):\n        if index == N:\n            if all(not do_segments_intersect(P[path[i]], Q[path[i]], P[path[j]], Q[path[j]]) for i in range(N) for j in range(i + 1, N)):\n                return path\n            return None\n\n        result = None\n        for next_index in range(N):\n            if next_index not in path:\n                new_path = path + [next_index]\n                result = dfs(index + 1, new_path)\n                if result:\n                    return result\n        return result\n\n    return dfs(0, [])\n\ndef main():\n    N = int(input())\n    P = [tuple(map(int, input().split())) for _ in range(N)]\n    Q = [tuple(map(int, input().split())) for _ in range(N)]\n\n    result = find_permutation(N, P, Q)\n    if result is None:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n = data[0]\n    start = 1\n    end = n * 2\n    \n    a = data[start:end:n]\n    b = data[end-1:end+n:n]\n    \n    max_a = max(a)\n    max_b = max(b)\n    \n    print(max_a + max_b)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_e",
        "code_list": [
            "from typing import List\n\ndef calculate_additional_votes(N: int, M: int, K: int, A: List[int]) -> List[int]:\n    total_votes = sum(A)\n    remaining_votes = K - total_votes\n    \n    # Sort candidates in descending order of current votes\n    A.sort(reverse=True)\n    \n    # Initialize result list\n    C = [0] * N\n    \n    # Calculate the maximum number of votes that can be distributed among the top (M-1) candidates\n    max_votes_for_others = (M - 1) * (total_votes + remaining_votes + 1)\n    \n    for i in range(N):\n        # Calculate the minimum additional votes needed for candidate i to secure victory\n        min_votes_needed = max(0, (max_votes_for_others - total_votes + A[i] + M - 1) // (M - 1) - A[i])\n        \n        # Check if the candidate can secure victory with the remaining votes\n        if remaining_votes >= min_votes_needed:\n            C[i] = min_votes_needed\n            remaining_votes -= min_votes_needed\n        else:\n            C[i] = -1\n    \n    return C\n\nif __name__ == \"__main__\":\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    result = calculate_additional_votes(N, M, K, A)\n    print(\" \".join(map(str, result)))"
        ]
    },
    {
        "question_id": "arc181_d",
        "code_list": [
            "from typing import List\n\ndef count_inversions(arr: List[int]) -> int:\n    inversions = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions\n\ndef process_operations(n: int, perm: List[int], m: int, operations: List[int]) -> List[int]:\n    result = []\n    current_perm = perm[:]\n    \n    for op in operations:\n        for k in range(2, op + 1):\n            for i in range(k - 1):\n                if current_perm[i] > current_perm[i + 1]:\n                    current_perm[i], current_perm[i + 1] = current_perm[i + 1], current_perm[i]\n        result.append(count_inversions(current_perm))\n    \n    return result\n\ndef main():\n    n = int(input().strip())\n    perm = list(map(int, input().strip().split()))\n    m = int(input().strip())\n    operations = list(map(int, input().strip().split()))\n    \n    result = process_operations(n, perm, m, operations)\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc181_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def generate_grid(N, P, Q):\n        # Initialize the grid with zeros\n        grid = [['0'] * N for _ in range(N)]\n        \n        # Function to update the grid based on the current state\n        def update_grid(i, j, val):\n            grid[i][j] = str(val)\n            return grid\n        \n        # Function to check if the current grid satisfies the conditions\n        def check_conditions():\n            # Check rows\n            for k in range(N):\n                row = ''.join(grid[k])\n                if not (row < ''.join(grid[P[k]-1]) for k in range(N)):\n                    return False\n            # Check columns\n            for k in range(N):\n                col = ''.join(grid[j][k] for j in range(N))\n                if not (col < ''.join(grid[Q[k]-1][i] for i in range(N)) for k in range(N)):\n                    return False\n            return True\n        \n        # Fill the grid\n        for i in range(N):\n            for j in range(N):\n                # Try to set the value to 1 and check if it satisfies the conditions\n                if check_conditions():\n                    grid = update_grid(i, j, 1)\n                else:\n                    grid = update_grid(i, j, 0)\n        \n        # Return the filled grid as a string\n        return '\\n'.join([''.join(row) for row in grid])\n    \n    # Read input\n    N = int(input().strip())\n    P = list(map(int, input().strip().split()))\n    Q = list(map(int, input().strip().split()))\n    \n    # Generate and print the grid\n    print(generate_grid(N, P, Q))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc181_b",
        "code_list": [
            "def main():\n    t = int(input())\n    for _ in range(t):\n        S = input().strip()\n        X = input().strip()\n        Y = input().strip()\n\n        # Find the first differing position between X and Y\n        diff_pos = -1\n        for i in range(min(len(X), len(Y))):\n            if X[i] != Y[i]:\n                diff_pos = i\n                break\n\n        # If there's no difference, any T will work\n        if diff_pos == -1:\n            print(\"Yes\")\n            continue\n\n        # Check if the differing part in X and Y can be matched by some T\n        if X[diff_pos:] == Y[diff_pos:]:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc181_a",
        "code_list": [
            "def min_operations_to_sort(permutation):\n    n = len(permutation)\n    operations = 0\n    \n    # Iterate from the end of the list to the beginning\n    for i in range(n - 1, 0, -1):\n        # If the current element is out of place\n        if permutation[i] != i + 1:\n            # Find the position where the current element should be\n            correct_pos = permutation.index(i + 1)\n            \n            # Perform the operation to move the current element to its correct position\n            if correct_pos < i:\n                # Sort the subarray up to the correct position\n                permutation[:correct_pos + 1] = sorted(permutation[:correct_pos + 1])\n                # Sort the subarray after the correct position\n                permutation[correct_pos + 1:i + 1] = sorted(permutation[correct_pos + 1:i + 1])\n                operations += 2\n            else:\n                # Sort the subarray up to the correct position\n                permutation[:correct_pos + 1] = sorted(permutation[:correct_pos + 1])\n                operations += 1\n    \n    return operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        permutation = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = min_operations_to_sort(permutation.copy())\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc182_d",
        "code_list": [
            "def min_operations_to_make_good_sequences_equal(N, M, A, B):\n    def distance_modular(a, b, m):\n        return min((a - b) % m, (b - a) % m)\n\n    operations = 0\n    for i in range(N):\n        operations += distance_modular(A[i], B[i], M)\n\n    # Check if the sequences can be made equal without breaking the good sequence property\n    for i in range(1, N):\n        if (A[i] - A[i - 1]) % M != (B[i] - B[i - 1]) % M:\n            return -1\n\n    return operations\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(min_operations_to_make_good_sequences_equal(N, M, A, B))"
        ]
    },
    {
        "question_id": "arc182_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    N, M, C, K = data[0], data[1], data[2], data[3]\n    A = data[4:4 + N]\n\n    # Find the minimum value of (C * k + A[i]) % M for each i\n    min_values = [min((C * k + a) % M for a in A) for k in range(K)]\n\n    # Sum up the minimum values\n    result = sum(min_values)\n\n    print(result)"
        ]
    },
    {
        "question_id": "arc182_a",
        "code_list": [
            "from functools import lru_cache\n\ndef main():\n    N, Q = map(int, input().split())\n    operations = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    # Sort operations based on P_i\n    operations.sort(key=lambda x: x[0])\n    \n    @lru_cache(None)\n    def dp(index, prev):\n        if index == Q:\n            return 1\n        \n        p, v = operations[index]\n        ways = 0\n        \n        # Option 1: Replace S_1, S_2, ..., S_{P_i} with V_i\n        if p > 1 and prev < v:\n            ways += dp(index + 1, v)\n        \n        # Option 2: Replace S_{P_i}, S_{P_i+1}, ..., S_N with V_i\n        if prev < v:\n            ways += dp(index + 1, v)\n        \n        return ways % 998244353\n    \n    print(dp(0, 0))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc182_c",
        "code_list": [
            "from math import sqrt\nfrom collections import Counter\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\n@lru_cache(None)\ndef divisors_count(n):\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    count = 1\n    for val in factor_counts.values():\n        count *= (val + 1)\n    return count\n\ndef main():\n    N, M = map(int, input().split())\n    total_sequences = M ** N\n    total_score = 0\n    \n    for x in range(1, M + 1):\n        for y in range(x, M + 1):\n            for z in range(y, M + 1):\n                for w in range(z, M + 1):\n                    for v in range(w, M + 1):\n                        for u in range(v, M + 1):\n                            for t in range(u, M + 1):\n                                for s in range(t, M + 1):\n                                    for r in range(s, M + 1):\n                                        for q in range(r, M + 1):\n                                            for p in range(q, M + 1):\n                                                for o in range(p, M + 1):\n                                                    for n in range(o, M + 1):\n                                                        for m in range(n, M + 1):\n                                                            for l in range(m, M + 1):\n                                                                for k in range(l, M + 1):\n                                                                    for j in range(k, M + 1):\n                                                                        for i in range(j, M + 1):\n                                                                            for h in range(i, M + 1):\n                                                                                for g in range(h, M + 1):\n                                                                                    for f in range(g, M + 1):\n                                                                                        for e in range(f, M + 1):\n                                                                                            for d in range(e, M + 1):\n                                                                                                for c in range(d, M + 1):\n                                                                                                    for b in range(c, M + 1):\n                                                                                                        for a in range(b, M + 1):\n                                                                                                            current_product = a * b * c * d * e * f * g * h * i * j * k * l * m * n * o * p * q * r * s * t * u * v * w * x * y * z\n                                                                                                            total_score += divisors_count(current_product)\n    \n    print(total_score % MOD)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc183_b",
        "code_list": [
            "def can_transform(A, B, K):\n    N = len(A)\n    # Create a dictionary to store the positions of each element in B\n    pos_B = {}\n    for i in range(N):\n        if B[i] not in pos_B:\n            pos_B[B[i]] = []\n        pos_B[B[i]].append(i)\n    \n    # Check if the elements in A can be transformed into B\n    for i in range(N):\n        if A[i] not in pos_B:\n            return \"No\"\n        \n        # Get the positions of the current element in B\n        target_positions = pos_B[A[i]]\n        \n        # Binary search to find the closest position within the allowed range\n        left, right = 0, len(target_positions) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if abs(i - target_positions[mid]) <= K:\n                break\n            elif i < target_positions[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        # If no valid position is found within the range, return \"No\"\n        if left > right and abs(i - target_positions[left]) > K and abs(i - target_positions[right]) > K:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        print(can_transform(A, B, K))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc183_c",
        "code_list": [
            "from typing import List\n\ndef count_valid_permutations(n: int, m: int, conditions: List[List[int]]) -> int:\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for _, x, _ in conditions:\n        dp[x] = 0\n    \n    for l, r, x in conditions:\n        temp_dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if i != x:\n                temp_dp[i] = (temp_dp[i - 1] + dp[i]) % MOD\n        for i in range(l, r + 1):\n            if i != x:\n                dp[i] = temp_dp[i - 1]\n    \n    return sum(dp) % MOD\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    conditions = [list(map(int, input().split())) for _ in range(m)]\n    print(count_valid_permutations(n, m, conditions))"
        ]
    },
    {
        "question_id": "arc183_a",
        "code_list": [
            "from math import comb\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n\ndef inverse_factorial(n, mod):\n    inv = [1] * (n + 1)\n    inv[0] = 1\n    for i in range(1, n + 1):\n        inv[i] = mod - (mod // i) * inv[mod % i] % mod\n    fact = [1] * (n + 1)\n    ifact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    ifact[n] = pow(fact[n], mod - 2, mod)\n    for i in range(n - 1, 1, -1):\n        ifact[i] = ifact[i + 1] * (i + 1) % mod\n    return fact, ifact\n\ndef inverse_comb(n, k, mod):\n    fact, ifact = inverse_factorial(n + 1, mod)\n    return ifact[k] * ifact[n - k] % mod\n\ndef nth_good_sequence(N, K, n):\n    mod = 10**9 + 7\n    fact, ifact = inverse_factorial(N * K + 1, mod)\n    sequence = []\n    remaining = n - 1\n    for i in range(1, N + 1):\n        count = min(K, remaining // (N - i))\n        sequence.append(i * count)\n        remaining -= count\n    return sequence\n\ndef main():\n    N, K = map(int, input().split())\n    S = (comb(N * K, K) + 1) // 2\n    result = nth_good_sequence(N, K, S)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc183_d",
        "code_list": [
            "def find_leaves(n, edges):\n    # Build the adjacency list representation of the tree\n    adj_list = {i: [] for i in range(1, n + 1)}\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Function to perform DFS and find leaves\n    def dfs(node, parent):\n        leaves = []\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                leaves.extend(dfs(neighbor, node))\n        if len(leaves) == 0:\n            return [node]\n        return leaves\n\n    # Find all leaves\n    leaves = set()\n    for i in range(1, n + 1):\n        if len(adj_list[i]) == 1:\n            leaves.add(i)\n\n    # Sort leaves based on their depth in the tree\n    def get_depth(node, parent, depth):\n        max_depth = depth\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                max_depth = max(max_depth, get_depth(neighbor, node, depth + 1))\n        return max_depth\n\n    leaf_depths = {}\n    for leaf in leaves:\n        leaf_depths[leaf] = get_depth(leaf, None, 0)\n\n    sorted_leaves = sorted(leaves, key=lambda x: leaf_depths[x], reverse=True)\n\n    # Perform operations to maximize the score\n    operations = []\n    while len(sorted_leaves) > 1:\n        leaf1 = sorted_leaves.pop(0)\n        leaf2 = sorted_leaves.pop(0)\n        operations.append((leaf1, leaf2))\n\n    return operations\n\ndef main():\n    n = int(input().strip())\n    edges = []\n    for _ in range(n // 2):\n        u, v = map(int, input().strip().split())\n        edges.append((u, v))\n\n    operations = find_leaves(n, edges)\n    for op in operations:\n        print(op[0], op[1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "3026",
        "code_list": [
            "from typing import Set\n\nclass Solution:\n    def minimumPossibleSum(self, n: int, target: int) -> int:\n        used = set()\n        total_sum = 0\n        current_num = 1\n        \n        while len(used) < n:\n            if target - current_num not in used:\n                total_sum += current_num\n                used.add(current_num)\n            current_num += 1\n        \n        return total_sum % (10**9 + 7)"
        ]
    },
    {
        "question_id": "3543",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int) -> int:\n        def isValidSubstring(sub: str, k: int) -> bool:\n            zero_count, one_count = sub.count('0'), sub.count('1')\n            return zero_count <= k or one_count <= k\n        \n        count = 0\n        n = len(s)\n        for i in range(n):\n            zero_count, one_count = 0, 0\n            for j in range(i, n):\n                if s[j] == '0':\n                    zero_count += 1\n                else:\n                    one_count += 1\n                if zero_count > k and one_count > k:\n                    break\n                if isValidSubstring(s[i:j+1], k):\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3525",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        dp = [[0] * 2 for _ in range(n)]\n        \n        # Initialize the first hour\n        dp[0][0] = energyDrinkA[0]\n        dp[0][1] = energyDrinkB[0]\n        \n        for i in range(1, n):\n            # Case 1: Continue with energy drink A\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1]) + energyDrinkA[i]\n            # Case 2: Switch to energy drink B\n            dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + energyDrinkB[i]\n        \n        return max(dp[n-1][0], dp[n-1][1])"
        ]
    },
    {
        "question_id": "3552",
        "code_list": [
            "class Solution:\n    def largestPalindrome(self, n: int, k: int) -> str:\n        if n == 1:\n            return '9' if k != 1 else '8'\n        \n        upper_limit = 10**n - 1\n        lower_limit = 10**(n-1)\n        \n        for i in range(upper_limit, lower_limit, -1):\n            palindrome = int(str(i) + str(i)[::-1])\n            if palindrome % k == 0:\n                return str(palindrome)\n        \n        return ''"
        ]
    },
    {
        "question_id": "3555",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:\n        n = len(nums)\n        result = [0] * k\n        \n        for i in range(k):\n            min_val_index = nums.index(min(nums))\n            result[i] = nums[min_val_index] * multiplier\n            nums[min_val_index] = float('inf')\n        \n        return result"
        ]
    },
    {
        "question_id": "3534",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def is_almost_equal(num1, num2):\n            str_num1, str_num2 = str(num1), str(num2)\n            if len(str_num1) != len(str_num2):\n                return False\n            diff_count = 0\n            for i in range(len(str_num1)):\n                if str_num1[i] != str_num2[i]:\n                    diff_count += 1\n                    if diff_count > 2:\n                        return False\n            return True\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3553",
        "code_list": [
            "class Solution:\n    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:\n        # Function to determine the color of the square based on its coordinates\n        def get_color(col, row):\n            # Convert column letter to index (a=0, b=1, ..., h=7)\n            col_index = ord(col) - ord('a')\n            # Convert row number to index (1=0, 2=1, ..., 8=7)\n            row_index = int(row) - 1\n            # Calculate the sum of indices\n            sum_indices = col_index + row_index\n            # If the sum is even, the square is black; if odd, the square is white\n            return sum_indices % 2 == 0\n        \n        # Get the color of both squares\n        color1 = get_color(coordinate1[0], coordinate1[1])\n        color2 = get_color(coordinate2[0], coordinate2[1])\n        \n        # Return True if both colors are the same, False otherwise\n        return color1 == color2"
        ]
    },
    {
        "question_id": "3495",
        "code_list": [
            "import heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        result = []\n        obstacles = []\n        \n        for x, y in queries:\n            # Calculate the distance of the new obstacle from the origin\n            distance = abs(x) + abs(y)\n            heapq.heappush(obstacles, (distance, x, y))\n            \n            # Maintain only the k nearest obstacles\n            if len(obstacles) > k:\n                heapq.heappop(obstacles)\n            \n            # Determine the k-th nearest obstacle\n            if len(obstacles) == k:\n                _, _, _ = obstacles[0]  # Ignore the coordinates, we only care about the distance\n                result.append(distance)\n            else:\n                result.append(-1)\n        \n        return result"
        ]
    },
    {
        "question_id": "3563",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n        rows = len(grid)\n        cols = len(grid[0])\n        max_score = 0\n        \n        # Create a list to keep track of the maximum score for each row\n        max_values = [0] * rows\n        \n        for col in range(cols):\n            current_row_scores = []\n            for row in range(rows):\n                if grid[row][col] > max_values[row]:\n                    current_row_scores.append(grid[row][col])\n                    max_values[row] = grid[row][col]\n            # Sort the scores in descending order to pick the maximum unique value\n            current_row_scores.sort(reverse=True)\n            max_score += current_row_scores[0]\n        \n        return max_score"
        ]
    },
    {
        "question_id": "3551",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSubarrayXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        from functools import reduce\n        from operator import xor\n        \n        def max_xor_in_range(start, end):\n            trie = {}\n            max_xor = 0\n            \n            # Build the Trie with the prefix of the range\n            prefix = 0\n            for i in range(start, end + 1):\n                num = nums[i]\n                node = trie\n                for j in range(31, -1, -1):\n                    bit = (num >> j) & 1\n                    if bit not in node:\n                        node[bit] = {}\n                    node = node[bit]\n                prefix ^= num\n            \n            # Find the maximum XOR value\n            max_xor = 0\n            for i in range(start, end + 1):\n                num = nums[i]\n                node = trie\n                current_xor = 0\n                for j in range(31, -1, -1):\n                    bit = (num >> j) & 1\n                    opposite_bit = 1 - bit\n                    if opposite_bit in node:\n                        current_xor |= (1 << j)\n                        node = node[opposite_bit]\n                    else:\n                        node = node[bit]\n                max_xor = max(max_xor, current_xor ^ prefix)\n            \n            return max_xor\n        \n        return [max_xor_in_range(l, r) for l, r in queries]"
        ]
    },
    {
        "question_id": "3567",
        "code_list": [
            "class Solution:\n    def convertDateToBinary(self, date: str) -> str:\n        year, month, day = date.split('-')\n        binary_year = bin(int(year))[2:]\n        binary_month = bin(int(month))[2:]\n        binary_day = bin(int(day))[2:]\n        \n        # Ensure each part has enough digits by padding with leading zeros\n        binary_year = binary_year.zfill(15)\n        binary_month = binary_month.zfill(4)\n        binary_day = binary_day.zfill(5)\n        \n        return f\"{binary_year}-{binary_month}-{binary_day}\""
        ]
    },
    {
        "question_id": "3485",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxPossibleScore(self, start: List[int], d: int) -> int:\n        # Sort the start array\n        start.sort()\n        \n        # Initialize the minimum gap with a large value\n        min_gap = float('inf')\n        \n        # Iterate through the sorted start array\n        for i in range(len(start)):\n            # Check if the current element minus i*d is non-negative\n            if start[i] - i * d >= 0:\n                # Calculate the gap between the current element and the previous one\n                gap = start[i] - (start[i-1] if i > 0 else 0)\n                # Update the minimum gap\n                min_gap = min(min_gap, gap)\n        \n        # Return the maximum possible score\n        return min_gap"
        ]
    },
    {
        "question_id": "3528",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def findMaximumScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_heap = []\n        left = [0] * n\n        right = [0] * n\n        \n        # Calculate left max values\n        for i in range(n):\n            while max_heap and nums[i] > nums[max_heap[0][1]]:\n                _, idx = heapq.heappop(max_heap)\n                left[idx] = nums[i]\n            heapq.heappush(max_heap, (-nums[i], i))\n        \n        # Calculate right max values\n        for i in reversed(range(n)):\n            while max_heap and nums[i] >= nums[max_heap[0][1]]:\n                _, idx = heapq.heappop(max_heap)\n                right[idx] = nums[i]\n            heapq.heappush(max_heap, (-nums[i], i))\n        \n        # Initialize result with the first element's contribution\n        res = nums[0] * (n - 1)\n        for i in range(1, n - 1):\n            if left[i] == 0:\n                continue\n            res = max(res, (i - left[i]) * nums[i] + (right[i] - i) * nums[i])\n        \n        return res"
        ]
    },
    {
        "question_id": "3560",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:\n        # Helper function to calculate the minimum moves from knight to a pawn\n        def min_moves(x1, y1, x2, y2):\n            queue = [(x1, y1, 0)]\n            visited = set([(x1, y1)])\n            while queue:\n                x, y, steps = queue.pop(0)\n                if x == x2 and y == y2:\n                    return steps\n                for dx, dy in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append((nx, ny, steps + 1))\n            return float('inf')\n        \n        # Create a list of distances from knight to each pawn\n        distances = [min_moves(kx, ky, x, y) for x, y in positions]\n        \n        # Sort distances in descending order\n        distances.sort(reverse=True)\n        \n        # Initialize dp array to store the maximum moves\n        dp = [0] * len(positions)\n        \n        # Fill dp array\n        for i in range(len(positions)):\n            for j in range(i):\n                if distances[j] > distances[i]:\n                    dp[i] = max(dp[i], dp[j] + distances[i])\n        \n        # Return the maximum moves Alice can achieve\n        return max(dp) + distances[0]"
        ]
    },
    {
        "question_id": "3518",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def maxScore(self, a: List[int], b: List[int]) -> int:\n        # Create a min heap based on the absolute values of elements in b\n        min_heap = []\n        for index, value in enumerate(b):\n            heapq.heappush(min_heap, (abs(value), index))\n        \n        # Extract the 4 smallest indices from the heap\n        smallest_indices = [heapq.heappop(min_heap)[1] for _ in range(4)]\n        \n        # Sort the smallest indices based on the actual values in b to get the largest negative values\n        smallest_indices.sort(key=lambda x: b[x])\n        \n        # Calculate the score using the corresponding values from a and b\n        score = sum(a[i] * b[index] for i, index in enumerate(smallest_indices))\n        \n        return score"
        ]
    },
    {
        "question_id": "3559",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        word_set = set(words)\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        \n        for i in range(1, len(target) + 1):\n            for j in range(i):\n                if target[j:i] in word_set:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1"
        ]
    },
    {
        "question_id": "3522",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            if subarray == sorted(subarray) and all(subarray[j] + 1 == subarray[j+1] for j in range(len(subarray)-1)):\n                results.append(max(subarray))\n            else:\n                results.append(-1)\n        return results"
        ]
    },
    {
        "question_id": "3550",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        rows, cols = [0] * m, [0] * n\n        \n        # Calculate the sum of each row and column\n        for i in range(m):\n            for j in range(n):\n                rows[i] += board[i][j]\n                cols[j] += board[i][j]\n        \n        # Find the top 3 largest row sums and their indices\n        top_rows = sorted(range(m), key=lambda i: -rows[i])[:3]\n        \n        # Find the top 3 largest column sums and their indices\n        top_cols = sorted(range(n), key=lambda j: -cols[j])[:3]\n        \n        # Check if we can place rooks without attacking each other\n        if top_rows[0] != top_rows[1] and top_rows[0] != top_rows[2] and top_rows[1] != top_rows[2]:\n            if top_cols[0] != top_cols[1] and top_cols[0] != top_cols[2] and top_cols[1] != top_cols[2]:\n                # Place rooks in the top 3 rows and columns\n                max_sum = 0\n                for r in top_rows:\n                    for c in top_cols:\n                        max_sum += board[r][c]\n                return max_sum\n            else:\n                # Try placing rooks in the top 2 rows and the third column\n                max_sum = 0\n                for r in top_rows[:2]:\n                    for c in top_cols[2:]:\n                        max_sum = max(max_sum, max_sum + board[r][c] - board[top_rows[2]][top_cols[2]])\n                return max_sum\n        else:\n            # Try placing rooks in the top 2 columns and the third row\n            max_sum = 0\n            for r in top_rows[2:]:\n                for c in top_cols[:2]:\n                    max_sum = max(max_sum, max_sum + board[r][c] - board[top_rows[2]][top_cols[2]])\n            return max_sum"
        ]
    },
    {
        "question_id": "3568",
        "code_list": [
            "class Solution:\n    def generateKey(self, num1: int, num2: int, num3: int) -> int:\n        # Convert numbers to strings and pad with leading zeros to ensure they are at least 4 digits long\n        num1_str = f\"{num1:04d}\"\n        num2_str = f\"{num2:04d}\"\n        num3_str = f\"{num3:04d}\"\n        \n        # Initialize the key as a string\n        key_str = \"\"\n        \n        # Iterate through each digit position (1 to 4)\n        for i in range(4):\n            # Find the minimum digit among the current positions of num1, num2, and num3\n            min_digit = min(int(num1_str[i]), int(num2_str[i]), int(num3_str[i]))\n            # Append the minimum digit to the key string\n            key_str += str(min_digit)\n        \n        # Convert the key string to an integer and return it\n        return int(key_str)"
        ]
    },
    {
        "question_id": "3540",
        "code_list": [
            "class Solution:\n    def stringHash(self, s: str, k: int) -> str:\n        result = \"\"\n        for i in range(0, len(s), k):\n            substring = s[i:i + k]\n            hash_sum = sum((ord(char) - ord('a')) for char in substring)\n            hashedChar = hash_sum % 26\n            result += chr(hashedChar + ord('a'))\n        return result"
        ]
    },
    {
        "question_id": "3548",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def countGoodIntegers(self, n: int, k: int) -> int:\n        if n == 1:\n            return 1 if k < 10 else 0\n        \n        # Calculate the number of good integers\n        def count_good(n, k):\n            if n == 2:\n                # Count numbers with even digits\n                return sum(comb(9, i) * (i % 2 == 0) for i in range(1, 10))\n            elif n % 2 == 0:\n                # Even length palindromes\n                half_len = n // 2\n                return sum(comb(9, i) * comb(half_len - 1, i // 2) * (i % 2 == 0) for i in range(1, 10))\n            else:\n                # Odd length palindromes\n                half_len = n // 2\n                return sum(comb(9, i) * comb(half_len - 1, i // 2) * (i % 2 == 0) for i in range(1, 10)) * 9\n        \n        # Check divisibility by k\n        def is_divisible_by_k(n, k):\n            return n % k == 0\n        \n        total_good = 0\n        for num in range(10**(n-1), 10**n):\n            str_num = str(num)\n            if len(str_num) != n or '0' in str_num[1:]:\n                continue\n            if is_divisible_by_k(int(str_num), k):\n                total_good += 1\n        \n        return total_good"
        ]
    },
    {
        "question_id": "3531",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minDamage(self, power: int, damage: List[int], health: List[int]) -> int:\n        n = len(damage)\n        # Calculate the total damage each enemy can do before they die\n        total_damage = [(health[i] // damage[i]) * damage[i] for i in range(n)]\n        # Calculate the remaining health after the total damage is done\n        remaining_health = [health[i] % damage[i] for i in range(n)]\n        # Sort the enemies based on the damage they can do in descending order\n        sorted_enemies = sorted(zip(total_damage, remaining_health, damage), reverse=True)\n        total_damage_dealt_to_bob = 0\n        \n        for i in range(n):\n            if power >= sorted_enemies[i][0]:\n                total_damage_dealt_to_bob += sorted_enemies[i][0]\n                power -= sorted_enemies[i][0]\n            else:\n                # If Bob's power is not enough to finish the current enemy, calculate the damage dealt\n                time_to_kill = sorted_enemies[i][0] / power\n                total_damage_dealt_to_bob += power * time_to_kill\n                break\n        \n        # Add the remaining health of the last enemy to the total damage dealt to Bob\n        total_damage_dealt_to_bob += sorted_enemies[-1][1]\n        \n        return total_damage_dealt_to_bob"
        ]
    },
    {
        "question_id": "3558",
        "code_list": [
            "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        \n        def is_safe(x, y, current_health):\n            return 0 <= x < m and 0 <= y < n and (grid[x][y] == 0 or current_health - grid[x][y] > 0)\n        \n        queue = deque([(0, 0, health)])\n        visited = set([(0, 0)])\n        \n        while queue:\n            x, y, current_health = queue.popleft()\n            if (x, y) == (m - 1, n - 1):\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in visited or not is_safe(nx, ny, current_health):\n                    continue\n                visited.add((nx, ny))\n                queue.append((nx, ny, max(current_health - grid[nx][ny], 1)))\n        \n        return False"
        ]
    },
    {
        "question_id": "3575",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def maxValue(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        max_val = 0\n        \n        @lru_cache(None)\n        def dfs(index, mask, k):\n            nonlocal max_val\n            if index == n or k == 0:\n                return 0\n            \n            # Option 1: Skip the current element\n            skip = dfs(index + 1, mask, k)\n            \n            # Option 2: Include the current element in the sequence\n            include = (mask & nums[index]) ^ dfs(index + 1, mask | nums[index], k - 1)\n            \n            max_val = max(max_val, include)\n            return max(skip, include)\n        \n        dfs(0, 0, k)\n        return max_val"
        ]
    },
    {
        "question_id": "3571",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def maxPathLength(self, coordinates: List[List[int]], k: int) -> int:\n        n = len(coordinates)\n        dp = [1] * n\n        max_heap = [(-coordinates[k][0] - coordinates[k][1], k)]\n        visited = set([k])\n        \n        while max_heap:\n            _, idx = heapq.heappop(max_heap)\n            if idx in visited:\n                continue\n            visited.add(idx)\n            \n            for next_idx in range(n):\n                if next_idx in visited or coordinates[next_idx][0] <= coordinates[idx][0] or coordinates[next_idx][1] <= coordinates[idx][1]:\n                    continue\n                dp[next_idx] = max(dp[next_idx], dp[idx] + 1)\n                heapq.heappush(max_heap, (-coordinates[next_idx][0] - coordinates[next_idx][1], next_idx))\n        \n        return max(dp)"
        ]
    },
    {
        "question_id": "3541",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:\n        banned_set = set(bannedWords)\n        seen_banned = set()\n        for word in message:\n            if word in banned_set:\n                seen_banned.add(word)\n                if len(seen_banned) >= 2:\n                    return True\n        return False"
        ]
    },
    {
        "question_id": "3496",
        "code_list": [
            "from typing import List\nimport bisect\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        # Sort worker times in descending order to prioritize faster workers\n        workerTimes.sort(reverse=True)\n        \n        # Initialize the result with the maximum time required by any single worker\n        result = max(workerTimes)\n        \n        # Calculate the cumulative time for each worker to handle multiple reductions\n        cumulative_time = 0\n        for i, time in enumerate(workerTimes):\n            cumulative_time += time\n            # Find the position where the cumulative time would exceed the remaining height\n            pos = bisect.bisect_left(workerTimes, (mountainHeight - i) / (cumulative_time + 1))\n            if pos < len(workerTimes):\n                result = max(result, workerTimes[pos])\n        \n        return result"
        ]
    },
    {
        "question_id": "3573",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        count_word2 = Counter(word2)\n        valid_count = 0\n        \n        for i in range(len1 - len2 + 1):\n            if word1[i] == word2[0]:\n                temp_count = count_word2.copy()\n                for j in range(len2):\n                    if word1[i + j] != word2[j]:\n                        break\n                    temp_count[word1[i + j]] -= 1\n                    if all(v <= 0 for v in temp_count.values()):\n                        valid_count += 1\n                        break\n        \n        return valid_count"
        ]
    },
    {
        "question_id": "3600",
        "code_list": [
            "class Solution:\n    def kthCharacter(self, k: int) -> str:\n        word = \"a\"\n        while len(word) < k:\n            # Calculate the number of characters to add in this iteration\n            num_chars_to_add = min(k - len(word), 26)\n            # Generate the new string by adding the next characters\n            word += chr(ord('a') + (ord(word[-1]) - ord('a') + 1) % 26) * num_chars_to_add\n        return word[k - 1]"
        ]
    },
    {
        "question_id": "3570",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def countOfSubstrings(self, word: str, k: int) -> int:\n        vowels = set('aeiou')\n        n = len(word)\n        total_vowels = sum(1 for char in word if char in vowels)\n        if total_vowels < 5 or total_vowels * (k + 1) > n + 1:\n            return 0\n        \n        def has_all_vowels(sub):\n            return all(vowel in sub for vowel in vowels)\n        \n        count = 0\n        for i in range(n):\n            if word[i] not in vowels:\n                continue\n            sub_count = Counter()\n            for j in range(i, n):\n                sub_count[word[j]] += 1\n                if has_all_vowels(sub_count) and (j - i + 1 - total_vowels) == k:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3579",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxGoodNumber(self, nums: List[int]) -> int:\n        # Convert each number to its binary representation without '0b' prefix\n        binary_nums = [bin(num)[2:] for num in nums]\n        # Concatenate the binary representations in descending order\n        concatenated_binary = ''.join(sorted(binary_nums, reverse=True))\n        # Convert the concatenated binary string back to an integer\n        return int(concatenated_binary, 2)"
        ]
    },
    {
        "question_id": "3583",
        "code_list": [
            "from typing import List\nfrom math import gcd\nfrom collections import Counter\n\nclass Solution:\n    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        gcd_pairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                gcd_pairs.append(gcd(nums[i], nums[j]))\n        gcd_pairs.sort()\n        \n        # Count frequency of each gcd value\n        freq = Counter(gcd_pairs)\n        \n        # Precompute prefix sums for binary search\n        prefix_sums = [0]\n        for val in gcd_pairs:\n            prefix_sums.append(prefix_sums[-1] + freq[val])\n        \n        # Function to perform binary search on prefix sums\n        def binary_search(target):\n            left, right = 0, len(prefix_sums) - 1\n            while left < right:\n                mid = (left + right) // 2\n                if prefix_sums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n        \n        result = []\n        for q in queries:\n            idx = binary_search(q + 1)\n            result.append(gcd_pairs[idx - 1])\n        return result"
        ]
    },
    {
        "question_id": "3606",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minElement(self, nums: List[int]) -> int:\n        def sum_of_digits(n: int) -> int:\n            return sum(int(digit) for digit in str(n))\n        \n        nums = [sum_of_digits(num) for num in nums]\n        return min(nums)"
        ]
    },
    {
        "question_id": "3510",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        n = len(maximumHeight)\n        if len(set(maximumHeight)) < n:\n            return -1\n        \n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + maximumHeight[i]\n        \n        max_sum = -1\n        for target_height in range(1, max(maximumHeight) + 1):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if (mid * (mid + 1) // 2) * target_height >= prefix_sum[mid + 1]:\n                    right = mid\n                else:\n                    left = mid + 1\n            \n            if (left * (left + 1) // 2) * target_height < prefix_sum[left + 1]:\n                continue\n            \n            current_sum = 0\n            for i in range(left + 1):\n                current_sum += min(target_height, maximumHeight[i])\n            for i in range(left + 1, n):\n                current_sum += max(0, target_height - (prefix_sum[i + 1] - prefix_sum[left + 1]) // (i - left))\n            \n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3584",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def validSequence(self, word1: str, word2: str) -> List[int]:\n        n, m = len(word1), len(word2)\n        i, j, changed = 0, 0, False\n        \n        result = []\n        while i < n and j < m:\n            if word1[i] == word2[j]:\n                result.append(i)\n                i += 1\n                j += 1\n            else:\n                if not changed:\n                    if ord(word1[i]) > ord(word2[j]):\n                        # Try to change word1[i] to match word2[j]\n                        if i + 1 < n and word1[i + 1] == word2[j]:\n                            i += 1\n                        else:\n                            i += 1\n                            changed = True\n                    else:\n                        # Try to change word2[j] to match word1[i]\n                        if j + 1 < m and word2[j + 1] == word1[i]:\n                            j += 1\n                        else:\n                            i += 1\n                            changed = True\n                else:\n                    i += 1\n        \n        # Check if we have covered all characters in word2\n        if j != m:\n            return []\n        \n        return result"
        ]
    },
    {
        "question_id": "3580",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minStartingIndex(self, s: str, pattern: str) -> int:\n        len_s, len_p = len(s), len(pattern)\n        if len_p > len_s:\n            return -1\n        \n        def is_almost_equal(sub: str, p: str) -> bool:\n            diff_count = sum(1 for a, b in zip(sub, p) if a != b)\n            return diff_count <= 1\n        \n        min_index = float('inf')\n        for i in range(len_s - len_p + 1):\n            if is_almost_equal(s[i:i+len_p], pattern):\n                min_index = min(min_index, i)\n        \n        return min_index if min_index != float('inf') else -1"
        ]
    },
    {
        "question_id": "abc374_c",
        "code_list": [
            "def min_max_people(N, K):\n    # Sort the list of department sizes in descending order\n    K.sort(reverse=True)\n    \n    # Initialize the sum of the first half and the second half\n    sum_A = sum(K[:N//2])\n    sum_B = sum(K[N//2:])\n    \n    # Calculate the difference between the two sums\n    diff = abs(sum_A - sum_B)\n    \n    # Try to minimize the maximum sum by redistributing the smallest department\n    for i in range(N % 2, N):\n        new_sum_A = sum_A - K[i] + K[N//2]\n        new_sum_B = sum_B + K[i] - K[N//2]\n        new_diff = abs(new_sum_A - new_sum_B)\n        \n        if new_diff < diff:\n            diff = new_diff\n            sum_A, sum_B = new_sum_A, new_sum_B\n    \n    return max(sum_A, sum_B)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    K = list(map(int, input().split()))\n    print(min_max_people(N, K))"
        ]
    },
    {
        "question_id": "abc374_f",
        "code_list": [
            "import heapq\n\ndef min_dissatisfaction(N, K, X, T):\n    # Initialize variables\n    day = 0\n    shipments = []\n    total_dissatisfaction = 0\n    \n    for t in T:\n        # Skip days until the current order can be shipped\n        while shipments and shipments[0] < t:\n            heapq.heappop(shipments)\n            day += X\n        \n        # Add the current order's shipping day to the heap\n        heapq.heappush(shipments, day)\n        # Calculate dissatisfaction for the current order\n        total_dissatisfaction += day - t\n        # Move to the next available shipping day\n        day += X\n    \n    return total_dissatisfaction\n\nif __name__ == \"__main__\":\n    N, K, X = map(int, input().split())\n    T = list(map(int, input().split()))\n    print(min_dissatisfaction(N, K, X, T))"
        ]
    },
    {
        "question_id": "abc374_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    T = input().strip()\n    \n    len_S, len_T = len(S), len(T)\n    min_len = min(len_S, len_T)\n    \n    for i in range(min_len):\n        if S[i] != T[i]:\n            print(i + 1)\n            return\n    \n    if len_S != len_T:\n        print(max(len_S, len_T))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc374_d",
        "code_list": [
            "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\ndef min_time_to_print(N, S, T, segments):\n    def calculate_time(segment):\n        start_x, start_y, end_x, end_y = segment\n        dist = distance(start_x, start_y, end_x, end_y)\n        travel_time = dist / T\n        non_travel_time = dist / S - travel_time\n        return travel_time + non_travel_time\n\n    # Sort segments based on their starting points\n    segments.sort(key=lambda x: (x[0], x[1]))\n\n    total_time = 0\n    current_x, current_y = 0, 0\n\n    for i in range(N):\n        start_x, start_y, end_x, end_y = segments[i]\n\n        # Calculate the time to move to the start point\n        move_time = distance(current_x, current_y, start_x, start_y) / S\n        total_time += move_time\n\n        # Calculate the time to print the segment\n        total_time += calculate_time([start_x, start_y, end_x, end_y])\n\n        # Update the current position to the end point\n        current_x, current_y = end_x, end_y\n\n    return total_time\n\nif __name__ == \"__main__\":\n    N, S, T = map(int, input().split())\n    segments = []\n    for _ in range(N):\n        A, B, C, D = map(int, input().split())\n        segments.append((A, B, C, D))\n    \n    result = min_time_to_print(N, S, T, segments)\n    print(f\"{result:.15f}\")"
        ]
    },
    {
        "question_id": "abc374_g",
        "code_list": [
            "def main():\n    from collections import defaultdict\n\n    def build_suffix_array(s):\n        n = len(s)\n        sa = [i for i in range(n)]\n        sa.sort(key=lambda x: s[x:])\n        return sa\n\n    def lcp_array(s, sa):\n        n = len(s)\n        rank = [0] * n\n        for i in range(n):\n            rank[sa[i]] = i\n        k = 0\n        lcp = [0] * (n - 1)\n        for i in range(n):\n            if rank[i] == n - 1:\n                k = 0\n                continue\n            j = sa[rank[i] + 1]\n            while i + k < n and j + k < n and s[i + k] == s[j + k]:\n                k += 1\n            lcp[rank[i]] = k\n            if k:\n                k -= 1\n        return lcp\n\n    def find_min_strings(products):\n        n = len(products)\n        suffixes = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                suffixes.add(products[i] + products[j])\n                suffixes.add(products[j] + products[i])\n        suffixes = sorted(suffixes)\n\n        sa = build_suffix_array(''.join(suffixes))\n        lcp = lcp_array(''.join(suffixes), sa)\n\n        min_strings = []\n        current_string = ''\n        for i in range(n):\n            if not current_string or lcp[sa[i]] > 0:\n                if current_string:\n                    min_strings.append(current_string)\n                current_string = products[i]\n            else:\n                current_string += products[i]\n        if current_string:\n            min_strings.append(current_string)\n\n        return len(min_strings)\n\n    N = int(input())\n    products = [input().strip() for _ in range(N)]\n    print(find_min_strings(products))"
        ]
    },
    {
        "question_id": "abc374_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S.endswith('san'):\n        print('Yes')\n    else:\n        print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc374_e",
        "code_list": [
            "import sys\nfrom typing import List\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    X = int(data[1])\n    \n    index = 2\n    machines = []\n    for _ in range(N):\n        A = int(data[index])\n        P = int(data[index + 1])\n        B = int(data[index + 2])\n        Q = int(data[index + 3])\n        machines.append((A, P, B, Q))\n        index += 4\n    \n    def check(capacity: int) -> bool:\n        total_cost = 0\n        for A, P, B, Q in machines:\n            if A >= capacity:\n                continue\n            if B >= capacity:\n                units = (capacity - 1 + A) // A\n                cost = units * P\n                if cost > X:\n                    return False\n                total_cost += cost\n            else:\n                units = (capacity - 1 + B) // B\n                cost = units * Q\n                if cost > X:\n                    return False\n                total_cost += cost\n        return total_cost <= X\n    \n    low, high = 0, min(A + B for A, _, B, _ in machines)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if check(mid):\n            low = mid\n        else:\n            high = mid - 1\n    \n    print(low)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc375_e",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    N = int(input())\n    teams = [[], [], []]\n    strengths = [0, 0, 0]\n\n    for _ in range(N):\n        A, B = map(int, input().split())\n        teams[A-1].append(B)\n        strengths[A-1] += B\n\n    total_strength = sum(strengths)\n\n    if total_strength % 3 != 0:\n        print(-1)\n        return\n\n    target_strength = total_strength // 3\n\n    def check_possible(team1, team2, team3):\n        if team1 == target_strength and team2 == target_strength and team3 == target_strength:\n            return True\n        return False\n\n    min_switches = float('inf')\n\n    for i in range(1, N+1):\n        for comb in combinations(range(N), i):\n            new_teams = [teams[0][:], teams[1][:], teams[2][:]]\n            for index in comb:\n                new_teams[new_teams[0][index]-1].remove(new_teams[0][index])\n                new_teams[new_teams[1][index]-1].append(new_teams[0][index])\n                new_teams[new_teams[1][index]-1][-1] -= new_teams[0][index]\n                new_teams[new_teams[1][index]-1][-1] += new_teams[0][index]\n                new_teams[0].pop(index)\n\n            team1, team2, team3 = sorted([sum(new_teams[0]), sum(new_teams[1]), sum(new_teams[2])])\n\n            if check_possible(team1, team2, team3):\n                min_switches = min(min_switches, i)\n\n    if min_switches == float('inf'):\n        print(-1)\n    else:\n        print(min_switches)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc375_b",
        "code_list": [
            "import math\n\ndef calculate_total_cost():\n    N = int(input())\n    points = [(0, 0)] + [tuple(map(int, input().split())) for _ in range(N)] + [(0, 0)]\n    total_cost = 0.0\n    \n    for i in range(1, N + 2):\n        x1, y1 = points[i - 1]\n        x2, y2 = points[i]\n        distance = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n        total_cost += distance\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    calculate_total_cost()"
        ]
    },
    {
        "question_id": "abc375_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def flip_colors(grid):\n        n = len(grid)\n        for i in range(n // 2):\n            for x in range(i + 1, n - i):\n                y = n - 1 - x\n                grid[i][n - 1 - y], grid[y][n - 1 - i] = grid[y][n - 1 - i], grid[i][n - 1 - y]\n        \n    def print_grid(grid):\n        for row in grid:\n            print(''.join(row))\n    \n    n = int(input())\n    grid = [list(input().strip()) for _ in range(n)]\n    \n    flip_colors(grid)\n    print_grid(grid)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc375_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    count = 0\n    for i in range(N - 2):\n        if S[i] == '#' and S[i + 1] == '.' and S[i + 2] == '#':\n            count += 1\n    print(count)"
        ]
    },
    {
        "question_id": "abc375_d",
        "code_list": [
            "def count_palindrome_triples(S):\n    n = len(S)\n    count = 0\n    \n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            if S[i] == S[j]:\n                for k in range(j + 1, n):\n                    if S[j] == S[k] and S[i] == S[k]:\n                        count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(count_palindrome_triples(S))"
        ]
    },
    {
        "question_id": "abc375_g",
        "code_list": [
            "import heapq\n\ndef dijkstra(n, edges, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in edges[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef solve(N, M, roads):\n    # Calculate the shortest distance when all roads are passable\n    all_dist = dijkstra(N, {i: [] for i in range(N)}, 0)\n    \n    # Check each road\n    results = []\n    for i in range(M):\n        # Create a graph without the current road\n        new_edges = {i: [] for i in range(N)}\n        for j in range(M):\n            if j != i:\n                new_edges[roads[j][0]].append((roads[j][1], roads[j][2]))\n                new_edges[roads[j][1]].append((roads[j][0], roads[j][2]))\n        \n        # Calculate the shortest distance without the current road\n        new_dist = dijkstra(N, new_edges, 0)\n        \n        # Check if the distances are different\n        if all_dist[N-1] != new_dist[N-1]:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    roads = []\n    for _ in range(M):\n        A, B, C = map(int, input().split())\n        roads.append((A-1, B-1, C))\n    \n    results = solve(N, M, roads)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc375_f",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef main():\n    n, m, q = map(int, input().split())\n    roads = defaultdict(list)\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        roads[a-1].append((b-1, c))\n        roads[b-1].append((a-1, c))\n    \n    closed_roads = set()\n    results = {}\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            i = query[1] - 1\n            if (roads[query[1]-1][i][0], roads[query[1]-1][i][1]) not in closed_roads:\n                closed_roads.add((query[1]-1, i+1))\n                del roads[query[1]-1][i]\n        else:\n            x, y = query[1] - 1, query[2] - 1\n            if (x, y) in results:\n                print(results[(x, y)])\n                continue\n            \n            new_roads = roads.copy()\n            for road in closed_roads:\n                if road in new_roads[x]:\n                    new_roads[x].remove(road)\n                if road[::-1] in new_roads[y]:\n                    new_roads[y].remove(road[::-1])\n            \n            dist = dijkstra(new_roads, x)\n            result = dist[y] if dist[y] != float('inf') else -1\n            results[(x, y)] = result\n            print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_b",
        "code_list": [
            "def min_operations_to_follow_instructions(N, Q):\n    # Initialize the positions of the left and right hands\n    l_pos = 1\n    r_pos = 2\n    \n    # Dictionary to store the minimum operations needed to reach each position\n    min_ops = {1: 0, 2: 0}\n    \n    # Function to calculate the minimum operations to move to a new position\n    def min_ops_to_move(current_pos, target_pos):\n        if current_pos == target_pos:\n            return 0\n        elif abs(current_pos - target_pos) <= 1:\n            return 1\n        else:\n            return 2\n    \n    total_ops = 0\n    \n    for _ in range(Q):\n        H, T = input().split()\n        T = int(T)\n        \n        if H == 'L':\n            # Calculate the minimum operations to move the left hand to T\n            if r_pos != T:\n                ops = min_ops_to_move(l_pos, T)\n                total_ops += ops\n                l_pos = T\n            else:\n                # If the right hand is already at T, no need to move the left hand\n                pass\n        else:\n            # Calculate the minimum operations to move the right hand to T\n            if l_pos != T:\n                ops = min_ops_to_move(r_pos, T)\n                total_ops += ops\n                r_pos = T\n            else:\n                # If the left hand is already at T, no need to move the right hand\n                pass\n    \n    return total_ops\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    print(min_operations_to_follow_instructions(N, Q))"
        ]
    },
    {
        "question_id": "abc376_d",
        "code_list": [
            "from collections import defaultdict, deque\n\ndef find_min_cycle_length(n, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n    \n    # Initialize distances and visited sets\n    dist = [-1] * (n + 1)\n    dist[1] = 0\n    visited = set([1])\n    \n    # BFS to find the shortest cycle containing vertex 1\n    queue = deque([1])\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if dist[neighbor] == -1:  # If not visited\n                dist[neighbor] = dist[current] + 1\n                queue.append(neighbor)\n                visited.add(neighbor)\n            elif neighbor in visited:  # Cycle detected\n                return dist[neighbor] + 1\n    \n    return -1\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    print(find_min_cycle_length(n, edges))"
        ]
    },
    {
        "question_id": "abc376_g",
        "code_list": [
            "from collections import defaultdict\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve_case():\n    n = int(input())\n    parent = list(map(int, input().split()))\n    prob = list(map(int, input().split()))\n    mod = 998244353\n    \n    # Calculate the total probability\n    total_prob = sum(prob)\n    \n    # Calculate the expected value for each node\n    expected = [0] * (n + 1)\n    stack = [(0, 0)]\n    while stack:\n        node, depth = stack.pop()\n        if node != 0:\n            expected[node] = (expected[parent[node]] + prob[node]) % mod\n        for child in range(n):\n            if parent[child] == node:\n                stack.append((child, depth + 1))\n    \n    # Calculate the expected number of operations\n    result = 0\n    for i in range(1, n + 1):\n        result += expected[i]\n        result %= mod\n    \n    print(result)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        solve_case()\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_a",
        "code_list": [
            "def main():\n    N, C = map(int, input().split())\n    T = list(map(int, input().split()))\n    last_candy_time = -C  # Initialize to a time before any button press\n    candies_received = 0\n    \n    for t in T:\n        if t - last_candy_time >= C:\n            candies_received += 1\n            last_candy_time = t\n    \n    print(candies_received)"
        ]
    },
    {
        "question_id": "abc376_f",
        "code_list": [
            "def min_operations_to_follow_instructions(N, Q):\n    # Initialize the positions of the left and right hands\n    left_hand = 1\n    right_hand = 2\n    \n    # Dictionary to store the minimum operations needed to reach each part\n    min_ops = {1: 0, 2: 0}\n    \n    for _ in range(Q):\n        H, T = input().split()\n        T = int(T)\n        \n        # Calculate the minimum operations to move the specified hand to T\n        if H == 'L':\n            if right_hand != T:\n                min_ops[T] = min(min_ops.get(T, float('inf')), min_ops[left_hand] + abs(T - left_hand) + 1)\n            else:\n                min_ops[T] = min_ops[left_hand]\n        else:\n            if left_hand != T:\n                min_ops[T] = min(min_ops.get(T, float('inf')), min_ops[right_hand] + abs(T - right_hand) + 1)\n            else:\n                min_ops[T] = min_ops[right_hand]\n        \n        # Update the positions of the hands based on the minimum operations\n        if H == 'L':\n            left_hand = T\n        else:\n            right_hand = T\n    \n    # Calculate the total minimum operations required to follow all instructions\n    total_ops = sum(min_ops.values())\n    \n    return total_ops\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    print(min_operations_to_follow_instructions(N, Q))"
        ]
    },
    {
        "question_id": "abc376_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def find_min_box_size(N, A, B):\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) // 2\n            placed_toys = [False] * N\n            for i in range(N - 1):\n                if B[i] >= mid:\n                    continue\n                count = 0\n                for j in range(i + 1, N):\n                    if B[j] >= mid and not placed_toys[j]:\n                        count += 1\n                        placed_toys[j] = True\n                if count == 0:\n                    return -1\n                if count > 1:\n                    return -1\n            count = 0\n            for i in range(N):\n                if not placed_toys[i]:\n                    count += 1\n            if count == 0:\n                return mid\n            elif count == 1:\n                return mid + 1\n            else:\n                return -1\n        return mid\n\n    N = data[0]\n    A = data[1:N + 1]\n    B = data[N + 1:2 * N]\n\n    result = find_min_box_size(N, A, B)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_e",
        "code_list": [
            "from heapq import heappush, heappop\n\ndef min_expression_value(N, K, A, B):\n    # Calculate the prefix sums of B to quickly calculate the sum of any subarray\n    prefix_sum_B = [0]\n    for b in B:\n        prefix_sum_B.append(prefix_sum_B[-1] + b)\n    \n    # Initialize variables\n    max_A = max(A)\n    min_value = float('inf')\n    \n    # Use a max heap to keep track of the largest elements in the current window\n    max_heap = []\n    for i in range(K):\n        heappush(max_heap, -A[i])\n    \n    # Calculate the initial value of the expression\n    current_sum_B = prefix_sum_B[K] - prefix_sum_B[0]\n    current_value = -max_heap[0] * current_sum_B\n    \n    # Slide the window across the array\n    for i in range(K, N):\n        # Update the max heap with the new element\n        heappush(max_heap, -A[i])\n        # Remove the element that is no longer in the window\n        removed_element = -heappop(max_heap)\n        # Update the sum of B for the current window\n        current_sum_B += B[i] - B[i - K]\n        # Update the value of the expression\n        current_value = min(current_value, removed_element * current_sum_B)\n    \n    return current_value\n\ndef main():\n    T = int(input())\n    results = []\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        result = min_expression_value(N, K, A, B)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_c",
        "code_list": [
            "def count_safe_squares(N, M, pieces):\n    # Initialize a set to keep track of all squares that can be captured\n    captured_squares = set()\n    \n    # Add all possible capturing positions for each piece\n    for a, b in pieces:\n        if a + 2 <= N and b + 1 <= N:\n            captured_squares.add((a + 2, b + 1))\n        if a + 1 <= N and b + 2 <= N:\n            captured_squares.add((a + 1, b + 2))\n        if a - 1 >= 1 and b + 2 <= N:\n            captured_squares.add((a - 1, b + 2))\n        if a - 2 >= 1 and b + 1 <= N:\n            captured_squares.add((a - 2, b + 1))\n        if a - 2 >= 1 and b - 1 >= 1:\n            captured_squares.add((a - 2, b - 1))\n        if a - 1 >= 1 and b - 2 >= 1:\n            captured_squares.add((a - 1, b - 2))\n        if a + 1 <= N and b - 2 >= 1:\n            captured_squares.add((a + 1, b - 2))\n        if a + 2 <= N and b - 1 >= 1:\n            captured_squares.add((a + 2, b - 1))\n    \n    # Calculate the total number of empty squares\n    total_empty_squares = N * N\n    \n    # Subtract the number of captured squares from the total\n    safe_squares = total_empty_squares - len(captured_squares)\n    \n    return safe_squares\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    pieces = [tuple(map(int, input().split())) for _ in range(M)]\n    print(count_safe_squares(N, M, pieces))"
        ]
    },
    {
        "question_id": "abc377_b",
        "code_list": [
            "def count_safe_squares():\n    # Initialize the board with the given input\n    board = [input().strip() for _ in range(8)]\n    \n    # Counters for safe squares in each row and column\n    row_safe_counts = [0] * 8\n    col_safe_counts = [0] * 8\n    \n    # Calculate the number of safe squares in each row and column\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == '.':\n                row_safe_counts[i] += 1\n                col_safe_counts[j] += 1\n    \n    # Calculate the total number of safe squares\n    total_safe_squares = sum(row_safe_counts[i] * col_safe_counts[j] for i in range(8) for j in range(8) if board[i][j] == '.')\n    \n    return total_safe_squares\n\nif __name__ == \"__main__\":\n    print(count_safe_squares())"
        ]
    },
    {
        "question_id": "abc377_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    # Check if the characters in S can be rearranged to form 'ABC'\n    if sorted(S) == list('ABC'):\n        print('Yes')\n    else:\n        print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_g",
        "code_list": [
            "from collections import defaultdict\n\ndef lcs(s, t):\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n\ndef main():\n    N = int(input())\n    strings = [input() for _ in range(N)]\n    \n    # Calculate LCS for all pairs of strings\n    lcs_table = defaultdict(int)\n    for i in range(N):\n        for j in range(i):\n            lcs_table[(i, j)] = lcs(strings[i], strings[j])\n    \n    # DP table to store minimum costs\n    dp = [0] * N\n    for i in range(N):\n        dp[i] = len(strings[i])  # Initial cost to delete all characters\n        \n        # Update cost based on LCS with previous strings\n        for j in range(i):\n            dp[i] = min(dp[i], dp[j] + len(strings[i]) - lcs_table[(i, j)])\n    \n    # Print results\n    for cost in dp:\n        print(cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_f",
        "code_list": [
            "def count_safe_squares(N, M, pieces):\n    # Initialize sets to keep track of rows, columns, and diagonals\n    rows = set()\n    cols = set()\n    diag1 = set()  # i + j = constant\n    diag2 = set()  # i - j = constant\n    \n    # Populate the sets with occupied positions\n    for a, b in pieces:\n        rows.add(a)\n        cols.add(b)\n        diag1.add(a + b)\n        diag2.add(a - b)\n    \n    # Calculate the number of safe squares\n    total_squares = N * N\n    occupied_squares = len(rows) + len(cols) + len(diag1) + len(diag2) - 3 * M\n    return total_squares - occupied_squares\n\ndef main():\n    N, M = map(int, input().split())\n    pieces = [tuple(map(int, input().split())) for _ in range(M)]\n    print(count_safe_squares(N, M, pieces))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_e",
        "code_list": [
            "def find_cycle_length(n, k, perm):\n    # Initialize the visited array to keep track of visited elements\n    visited = [False] * n\n    cycle_lengths = []\n    \n    for i in range(n):\n        if not visited[i]:\n            cycle_start = i\n            current = i\n            cycle_length = 0\n            \n            while not visited[current]:\n                visited[current] = True\n                current = perm[current]\n                cycle_length += 1\n            \n            cycle_lengths.append((cycle_start, cycle_length))\n    \n    # Apply the operation K times\n    for start, length in cycle_lengths:\n        k %= length\n        if k == 0:\n            k = length\n        \n        current = start\n        for _ in range(k - 1):\n            current = perm[current]\n        \n        new_start = current\n        \n        for _ in range(length - k):\n            perm[start], start = perm[new_start], new_start\n            new_start = perm[new_start]\n    \n    return perm\n\ndef main():\n    n, k = map(int, input().split())\n    perm = list(map(int, input().split()))\n    \n    result = find_cycle_length(n, k, perm)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_d",
        "code_list": [
            "def count_valid_pairs(N, M, intervals):\n    events = []\n    for L, R in intervals:\n        events.append((L, 'start'))\n        events.append((R + 1, 'end'))\n    \n    events.sort()\n    active_intervals = 0\n    invalid_intervals = 0\n    \n    for pos, event_type in events:\n        if event_type == 'start':\n            active_intervals += 1\n            if active_intervals == N:\n                invalid_intervals += 1\n        else:\n            active_intervals -= 1\n    \n    valid_intervals = (M + 1) * M // 2 - invalid_intervals\n    return valid_intervals\n\ndef main():\n    N, M = map(int, input().split())\n    intervals = [tuple(map(int, input().split())) for _ in range(N)]\n    result = count_valid_pairs(N, M, intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_e",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Initialize prefix sum array\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = (prefix_sum[i] + A[i]) % M\n\n    # Count occurrences of each remainder\n    count = [0] * M\n    for val in prefix_sum:\n        count[val] += 1\n\n    # Calculate the result using the formula derived from the problem statement\n    result = 0\n    for i in range(M):\n        for j in range(i, M):\n            result += count[i] * count[j] * (j - i)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    H, W, K = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[[False] * (K + 1) for _ in range(W)] for _ in range(H)]\n    queue = deque([(i, j, 0) for i in range(H) for j in range(W) if grid[i][j] == '.'])\n    ways = 0\n    \n    while queue:\n        x, y, move_count = queue.popleft()\n        if move_count == K:\n            ways += 1\n            continue\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '.' and not visited[nx][ny][move_count + 1]:\n                visited[nx][ny][move_count + 1] = True\n                queue.append((nx, ny, move_count + 1))\n                \n    print(ways)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_b",
        "code_list": [
            "def find_next_collection_day(N, garbage_schedule, Q, queries):\n    results = []\n    for query in queries:\n        t, d = query\n        q, r = garbage_schedule[t - 1]\n        # Calculate the next collection day\n        next_day = d + ((r - d) % q)\n        results.append(next_day)\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    garbage_schedule = [(int(data[i]), int(data[i+1])) for i in range(2, 2*N+1, 2)]\n    Q = int(data[2*N+1])\n    queries = [(int(data[i]), int(data[i+1])) for i in range(2*N+2, 2*N+2+Q)]\n\n    results = find_next_collection_day(N, garbage_schedule, Q, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_f",
        "code_list": [
            "from collections import defaultdict\n\ndef dfs(node, parent, degrees, tree):\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            degrees[neighbor] += degrees[node]\n            dfs(neighbor, node, degrees, tree)\n\ndef count_valid_graphs(n, edges):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    leaves = [node for node in range(1, n + 1) if len(tree[node]) == 1]\n    while len(leaves) > 2:\n        new_leaves = []\n        for leaf in leaves:\n            parent = tree[leaf][0]\n            degrees = defaultdict(int)\n            degrees[parent] += 2\n            dfs(parent, leaf, degrees, tree)\n            if degrees[parent] % 2 == 0:\n                return 0\n            for neighbor in tree[parent]:\n                if neighbor != leaf:\n                    tree[neighbor].remove(parent)\n                    if len(tree[neighbor]) == 1:\n                        new_leaves.append(neighbor)\n            tree[parent].clear()\n        leaves = new_leaves\n    \n    if len(leaves) == 2:\n        return 1\n    elif len(leaves) == 3:\n        return 3\n    else:\n        return 0\n\ndef main():\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    print(count_valid_graphs(n, edges))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_g",
        "code_list": [
            "from math import comb\n\ndef main():\n    A, B, M = map(int, input().split())\n    if A > B:\n        A, B = B, A\n    if A == B:\n        ans = comb((A - 1) * B, A - 1) % M\n    else:\n        ans = 0\n        for k in range(1, B):\n            ans += comb(B - 1, k) * pow(A, B - k - 1, M) * comb((A - 1) * (B - k), A - 1) % M\n            ans %= M\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_a",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    # Read input\n    colors = list(map(int, input().split()))\n    \n    # Count the occurrences of each color\n    color_counts = Counter(colors)\n    \n    # Calculate the maximum number of operations\n    max_operations = sum((count // 2) for count in color_counts.values())\n    \n    # Print the result\n    print(max_operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    b = [-1] * n\n    \n    last_seen = {}\n    for i in range(n):\n        if a[i] in last_seen:\n            b[i] = last_seen[a[i]]\n        last_seen[a[i]] = i\n    \n    print(*b)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_b",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    S = input()\n    max_strawberries = 0\n    i = 0\n    while i <= N - K:\n        count = 0\n        for j in range(i, i + K):\n            if S[j] == 'O':\n                count += 1\n            else:\n                break\n        if count == K:\n            max_strawberries += 1\n            i += K\n        else:\n            i += 1\n    print(max_strawberries)"
        ]
    },
    {
        "question_id": "abc379_e",
        "code_list": [
            "def main():\n    import sys\n    \n    def calculate_sum(N, S):\n        total_sum = 0\n        for i in range(N):\n            current_value = 0\n            for j in range(i, N):\n                current_value = current_value * 10 + int(S[j])\n                total_sum += current_value\n        return total_sum\n    \n    N = int(input())\n    S = input().strip()\n    \n    result = calculate_sum(N, S)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    X = list(map(int, data[2:2*M:2]))\n    A = list(map(int, data[3:2*M:2]))\n    \n    total_stones = sum(A)\n    if total_stones != N:\n        print(-1)\n        return\n    \n    positions = [0] * (N + 1)\n    for i in range(M):\n        positions[X[i]] += A[i]\n    \n    current_position = 1\n    operations = 0\n    for i in range(1, N + 1):\n        if positions[i] > 0:\n            needed_stones = positions[i]\n            while needed_stones > 0:\n                if current_position < i:\n                    current_position += 1\n                    operations += 1\n                else:\n                    needed_stones -= 1\n                    current_position -= 1\n                    operations += 1\n            current_position = i\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    Q = int(input())\n    events = []\n    for _ in range(Q):\n        events.append(list(map(int, input().split())))\n    \n    # Process events\n    current_day = 0\n    plants = deque()\n    \n    for event in events:\n        if event[0] == 1:\n            plants.append((current_day, 0))\n        elif event[0] == 2:\n            current_day += event[1]\n        else:\n            harvested_count = 0\n            while plants and plants[0][0] <= current_day:\n                _, height = plants.popleft()\n                if height < event[1]:\n                    break\n                harvested_count += 1\n            print(harvested_count)"
        ]
    },
    {
        "question_id": "abc379_g",
        "code_list": [
            "from functools import lru_cache\n\ndef main():\n    H, W = map(int, input().split())\n    S = [input() for _ in range(H)]\n    \n    @lru_cache(None)\n    def dfs(i, j, prev):\n        if i == H:\n            return 1\n        res = 0\n        if j == W:\n            return dfs(i + 1, 0, -1)\n        if S[i][j] == '?':\n            for d in '123':\n                if d != prev:\n                    res += dfs(i, j + 1, d)\n        else:\n            if S[i][j] != prev:\n                res += dfs(i, j + 1, S[i][j])\n        return res % 998244353\n    \n    print(dfs(0, 0, -1))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_f",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    H = list(map(int, input().split()))\n    \n    # Precompute the next taller building for each building\n    next_taller = [-1] * N\n    stack = []\n    for i in range(N - 1, -1, -1):\n        while stack and H[stack[-1]] <= H[i]:\n            stack.pop()\n        if stack:\n            next_taller[i] = stack[-1]\n        stack.append(i)\n    \n    # Process each query\n    for _ in range(Q):\n        l, r = map(int, input().split())\n        l -= 1\n        r -= 1\n        \n        count = 0\n        for j in range(r + 1, N):\n            if next_taller[j] == -1 or next_taller[j] >= r:\n                break\n            if H[next_taller[j]] > H[j]:\n                continue\n            if next_taller[next_taller[j]] == -1 or next_taller[next_taller[j]] >= r:\n                count += 1\n            else:\n                break\n        \n        print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_a",
        "code_list": [
            "def main():\n    N = int(input())\n    a = N // 100\n    b = (N // 10) % 10\n    c = N % 10\n    print(b * 100 + c * 10 + a, c * 100 + a * 10 + b)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, Q = map(int, input().split())\n    color_to_cells = defaultdict(list)\n    for i in range(1, N + 1):\n        color_to_cells[i].append(i)\n    \n    def repaint(x, c):\n        stack = [x]\n        while stack:\n            current = stack.pop()\n            for neighbor in (current - 1, current + 1):\n                if 1 <= neighbor <= N and color[neighbor] == color[current]:\n                    stack.append(neighbor)\n                    color[neighbor] = c\n            for cell in color_to_cells[color[current]]:\n                if cell != current:\n                    color_to_cells[color[current]].remove(cell)\n                    color_to_cells[c].append(cell)\n    \n    def count_color(c):\n        return len(color_to_cells[c])\n    \n    color = [i for i in range(1, N + 1)]\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            repaint(query[1], query[2])\n        else:\n            print(count_color(query[1]))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_f",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    L = int(data[2])\n    \n    A = list(map(int, data[3:N+3]))\n    B = list(map(int, data[N+3:N+M+3]))\n    C = list(map(int, data[N+M+3:]))\n    \n    # Combine all cards and sort them\n    all_cards = sorted(A + B + C)\n    \n    # Function to count the number of valid moves for a player\n    def count_valid_moves(cards, table):\n        return sum(1 for card in cards if any(table_card < card for table_card in table))\n    \n    # Count the number of valid moves for both players\n    takahashi_moves = count_valid_moves(A, all_cards)\n    aoki_moves = count_valid_moves(B, all_cards)\n    \n    # Determine the winner based on the number of valid moves\n    if takahashi_moves > aoki_moves:\n        print(\"Takahashi\")\n    else:\n        print(\"Aoki\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_c",
        "code_list": [
            "def move_1_block(N, K, S):\n    # Find the positions of the 1-blocks\n    blocks = []\n    start = None\n    for i in range(N):\n        if S[i] == '1':\n            if start is None:\n                start = i\n        elif start is not None:\n            blocks.append((start, i - 1))\n            start = None\n    \n    # If there's no end yet, add the last block\n    if start is not None:\n        blocks.append((start, N - 1))\n    \n    # Extract the parts of the string before and after the K-th block\n    before = S[:blocks[K-2][1]]\n    block_to_move = S[blocks[K-2][1]+1:blocks[K-1][0]]\n    after = S[blocks[K-1][1]+1:]\n    \n    # Construct the new string\n    T = before + '1' * len(block_to_move) + '0' * len(block_to_move) + after\n    \n    return T\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    S = input().strip()\n    result = move_1_block(N, K, S)\n    print(result)"
        ]
    },
    {
        "question_id": "abc380_d",
        "code_list": [
            "def transform_string(S):\n    # Perform the transformation operation 100 times or until the pattern stabilizes\n    for _ in range(100):\n        T = []\n        for char in S:\n            if char.isupper():\n                T.append(char.lower())\n            else:\n                T.append(char.upper())\n        S += ''.join(T)\n    return S\n\ndef find_kth_char(S, K):\n    # Since the string stabilizes after a few iterations, we can use a pattern to find the k-th character\n    pattern = \"aBAbAbaBAbaBaBAb\"\n    index = (K - 1) % len(pattern)\n    return pattern[index]\n\ndef main():\n    S = input().strip()\n    Q = int(input().strip())\n    K_values = list(map(int, input().strip().split()))\n\n    transformed_S = transform_string(S)\n    result = [find_kth_char(transformed_S, K) for K in K_values]\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_a",
        "code_list": [
            "def main():\n    N = int(input())\n    count_1 = 0\n    count_2 = 0\n    count_3 = 0\n    \n    for digit in str(N):\n        if digit == '1':\n            count_1 += 1\n        elif digit == '2':\n            count_2 += 1\n        elif digit == '3':\n            count_3 += 1\n    \n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_g",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef main():\n    N, K = map(int, input().split())\n    P = list(map(int, input().split()))\n\n    # Calculate the initial inversion number\n    inv_count = sum(P[i] > P[j] for i in range(N) for j in range(i + 1, N))\n\n    # Calculate the expected change in inversion number\n    expected_change = 0\n    for i in range(K, N + 1):\n        expected_change += (i - K) * (K - 1) // 2\n        expected_change -= (N - i) * (K - 1) // 2\n        expected_change += (i - K) * (K - 1) // 2 * (K - 1)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 1)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 2)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 2)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 3)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 3)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 4)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 4)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 5)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 5)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 6)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 6)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 7)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 7)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 8)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 8)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 9)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 9)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 10)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 10)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 11)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 11)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 12)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 12)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 13)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 13)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 14)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 14)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 15)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 15)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 16)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 16)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 17)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 17)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 18)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 18)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 19)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 19)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 20)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 20)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 21)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 21)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 22)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 22)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 23)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 23)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 24)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 24)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 25)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 25)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 26)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 26)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 27)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 27)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 28)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 28)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 29)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 29)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 30)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 30)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 31)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 31)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 32)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 32)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 33)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 33)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 34)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 34)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 35)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 35)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 36)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 36)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 37)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 37)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 38)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 38)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 39)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 39)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 40)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 40)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 41)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 41)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 42)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 42)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 43)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 43)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 44)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 44)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 45)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 45)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 46)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 46)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 47)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 47)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 48)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 48)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 49)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 49)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 50)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 50)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 51)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 51)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 52)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 52)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 53)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 53)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 54)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 54)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 55)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 55)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 56)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 56)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 57)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 57)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 58)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 58)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 59)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 59)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 60)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 60)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 61)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 61)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 62)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 62)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 63)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 63)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 64)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 64)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 65)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 65)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 66)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 66)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 67)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 67)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 68)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 68)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 69)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 69)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 70)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 70)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 71)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 71)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 72)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 72)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 73)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 73)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 74)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 74)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 75)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 75)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 76)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 76)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 77)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 77)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 78)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 78)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 79)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 79)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 80)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 80)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 81)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 81)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 82)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 82)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 83)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 83)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 84)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 84)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 85)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 85)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 86)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 86)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 87)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 87)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 88)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 88)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 89)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 89)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 90)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 90)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 91)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 91)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 92)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 92)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 93)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 93)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 94)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 94)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 95)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 95)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 96)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 96)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 97)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 97)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 98)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 98)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 99)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 99)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 100)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 100)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 101)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 101)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 102)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 102)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 103)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 103)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 104)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 104)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 105)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 105)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 106)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 106)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 107)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 107)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 108)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 108)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 109)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 109)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 110)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 110)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 111)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 111)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 112)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 112)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 113)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 113)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 114)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 114)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 115)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 115)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 116)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 116)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 117)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 117)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 118)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 118)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 119)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 119)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 120)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 120)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 121)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 121)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 122)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 122)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 123)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 123)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 124)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 124)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 125)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 125)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 126)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 126)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 127)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 127)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 128)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 128)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 129)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 129)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 130)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 130)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 131)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 131)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 132)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 132)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 133)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 133)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 134)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 134)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 135)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 135)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 136)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 136)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 137)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 137)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 138)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 138)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 139)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 139)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 140)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 140)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 141)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 141)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 142)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 142)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 143)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 143)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 144)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 144)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 145)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 145)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 146)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 146)\n        expected_change += (i - K) * (K - 1) // 2 * (K - 147)\n        expected_change -= (N - i) * (K - 1) // 2 * (K - 147)\n        expected_change += (i - K) * (K -"
        ]
    },
    {
        "question_id": "abc380_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = []\n    i = 1\n    while i < len(S):\n        count = 0\n        while i < len(S) and S[i] != '|':\n            count += 1\n            i += 1\n        result.append(count)\n        i += 1\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc381_a",
        "code_list": [
            "def is_11_22_string(N, S):\n    # Check if the length of the string is odd\n    if N % 2 == 0:\n        return False\n    \n    mid_index = (N + 1) // 2\n    \n    # Check the first half of the string\n    for i in range(mid_index - 1):\n        if S[i] != '1':\n            return False\n    \n    # Check the middle character\n    if S[mid_index - 1] != '/':\n        return False\n    \n    # Check the second half of the string\n    for i in range(mid_index, N):\n        if S[i] != '2':\n            return False\n    \n    return True\n\ndef main():\n    N = int(input().strip())\n    S = input().strip()\n    if is_11_22_string(N, S):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc381_e",
        "code_list": [
            "def find_max_1122_subsequence_length(N, S, queries):\n    def is_1122_subsequence(subseq):\n        mid = len(subseq) // 2\n        if subseq[:mid].count('1') != mid - 1 or subseq[mid] != '/' or subseq[mid+1:].count('2') != mid:\n            return False\n        return True\n\n    def max_1122_length(L, R):\n        substring = S[L-1:R]\n        max_len = 0\n        for i in range(len(substring)):\n            for j in range(i, len(substring)):\n                if is_1122_subsequence(substring[i:j+1]):\n                    max_len = max(max_len, j - i + 1)\n        return max_len\n\n    results = []\n    for L, R in queries:\n        results.append(max_1122_length(L, R))\n    return results\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    S = input().strip()\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    results = find_max_1122_subsequence_length(N, S, queries)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc381_b",
        "code_list": [
            "from collections import Counter\n\ndef is_1122_string(S):\n    # Check if the length of S is even\n    if len(S) % 2 != 0:\n        return False\n    \n    # Count the occurrences of each character\n    char_count = Counter(S)\n    \n    # Check if each character appears exactly zero or two times\n    for count in char_count.values():\n        if count not in [0, 2]:\n            return False\n    \n    # Check if the (2i-1)-th and 2i-th characters are equal for each i\n    for i in range(1, len(S) // 2 + 1):\n        if S[2 * i - 2] != S[2 * i - 1]:\n            return False\n    \n    return True\n\ndef main():\n    S = input().strip()\n    if is_1122_string(S):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc381_c",
        "code_list": [
            "def find_max_1122_substring_length(N, S):\n    max_length = 0\n    current_length = 0\n    is_start = False\n    \n    for i in range(N):\n        if S[i] == '1':\n            if not is_start:\n                is_start = True\n            current_length += 1\n        elif S[i] == '/':\n            if is_start:\n                mid_index = (current_length + 1) // 2\n                if current_length >= mid_index * 2 + 1 and S[i - mid_index:i + 1] == ('1' * mid_index + '/' + '2' * mid_index):\n                    max_length = max(max_length, current_length)\n                is_start = False\n                current_length = 0\n        else:  # S[i] == '2'\n            if is_start:\n                mid_index = (current_length + 1) // 2\n                if current_length >= mid_index * 2 + 1 and S[i - mid_index:i + 1] == ('1' * mid_index + '/' + '2' * mid_index):\n                    max_length = max(max_length, current_length)\n                is_start = False\n                current_length = 0\n    \n    return max_length\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input().strip()\n    print(find_max_1122_substring_length(N, S))"
        ]
    },
    {
        "question_id": "abc381_d",
        "code_list": [
            "from collections import defaultdict\n\ndef find_max_length_subarray(A):\n    n = len(A)\n    max_length = 0\n    last_seen = defaultdict(lambda: -1)\n    \n    for i in range(n):\n        num = A[i]\n        if last_seen[num] != -1 and (i - last_seen[num]) % 2 == 0:\n            max_length = max(max_length, i - last_seen[num])\n        else:\n            last_seen[num] = i\n    \n    return max_length * 2\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(find_max_length_subarray(A))"
        ]
    },
    {
        "question_id": "abc382_d",
        "code_list": [
            "def generate_sequences(N, M):\n    def backtrack(start, current_sequence):\n        if len(current_sequence) == N:\n            if current_sequence[-1] <= M:\n                result.append(current_sequence[:])\n            return\n        for next_val in range(start + 1, min(start + 11, M + 1)):\n            current_sequence.append(next_val)\n            backtrack(next_val, current_sequence)\n            current_sequence.pop()\n\n    result = []\n    for start in range(1, 11):\n        current_sequence = [start]\n        backtrack(start, current_sequence)\n\n    return result\n\ndef main():\n    N, M = map(int, input().split())\n    sequences = generate_sequences(N, M)\n    print(len(sequences))\n    for seq in sequences:\n        print(\" \".join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_a",
        "code_list": [
            "def main():\n    N, D = map(int, input().split())\n    S = input()\n    # Count the number of cookies\n    cookies = S.count('@')\n    # The number of empty boxes will be the total boxes minus the number of cookies\n    empty_boxes = N - min(cookies, D)\n    print(empty_boxes)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_b",
        "code_list": [
            "def main():\n    N, D = map(int, input().split())\n    S = input()\n\n    # Find the positions of all cookies\n    cookies = [i + 1 for i, char in enumerate(S) if char == '@']\n\n    # Determine which boxes will still have cookies after D days\n    result = ['.' for _ in range(N)]\n    for i in range(D):\n        if cookies[i] <= N:\n            result[cookies[i] - 1] = '@'\n\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_f",
        "code_list": [
            "def main():\n    H, W, N = map(int, input().split())\n    bars = []\n    for _ in range(N):\n        R, C, L = map(int, input().split())\n        bars.append((R, C, L))\n    \n    # Since the time is very large (10^100), we can determine the final position of each bar\n    # based on the height of the grid and the length of the bar.\n    for R, C, L in bars:\n        # Calculate the number of steps needed for the bar to reach the bottom\n        # or the end of its movement due to the grid's height.\n        steps = min(H - R, L)\n        # The final row position after moving down by the calculated steps\n        final_row = R + steps\n        print(final_row)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_g",
        "code_list": [
            "def calculate_min_moves(K, S_x, S_y, T_x, T_y):\n    # Calculate the tile indices for start and target points\n    S_i, S_j = S_x // K, S_y // K\n    T_i, T_j = T_x // K, T_y // K\n    \n    # Adjust S_x and S_y to be within the tile boundaries\n    S_x -= S_i * K\n    S_y -= S_j * K\n    T_x -= T_i * K\n    T_y -= T_j * K\n    \n    # Determine the type of tiles based on parity\n    S_parity = (S_i + S_j) % 2\n    T_parity = (T_i + T_j) % 2\n    \n    # Calculate the distance in terms of tiles\n    if S_parity == T_parity:\n        # Same parity\n        dist_x = abs(S_x - T_x)\n        dist_y = abs(S_y - T_y)\n        return max(dist_x, dist_y)\n    else:\n        # Different parity\n        # Calculate the shortest path considering the edge crossing\n        dist_x = min(abs(S_x - T_x), K - abs(S_x - T_x))\n        dist_y = min(abs(S_y - T_y), K - abs(S_y - T_y))\n        return dist_x + dist_y\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        K = int(data[index])\n        S_x = int(data[index + 1])\n        S_y = int(data[index + 2])\n        T_x = int(data[index + 3])\n        T_y = int(data[index + 4])\n        index += 5\n        \n        result = calculate_min_moves(K, S_x, S_y, T_x, T_y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Initialize the result array with -1\n    result = [-1] * M\n\n    # Iterate over each sushi\n    for j in range(M):\n        sushi_deliciousness = B[j]\n        # Check each person from the highest to the lowest gourmet level\n        for i in range(N - 1, -1, -1):\n            if A[i] <= sushi_deliciousness:\n                # Update the result for this sushi\n                result[j] = i + 1\n                # Mark this person as taken\n                A[i] = 0\n                break\n\n    # Print the results\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc383_c",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, h, w, d):\n    visited = [[False] * w for _ in range(h)]\n    queue = deque()\n    \n    # Initialize the queue with all humidifiers\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'H':\n                queue.append((i, j))\n                visited[i][j] = True\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    distance = 0\n    \n    while queue and distance <= d:\n        level_size = len(queue)\n        \n        for _ in range(level_size):\n            x, y = queue.popleft()\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < h and 0 <= ny < w and not visited[nx][ny] and grid[nx][ny] != '#':\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n        \n        distance += 1\n    \n    count = 0\n    for i in range(h):\n        for j in range(w):\n            if visited[i][j] and grid[i][j] == '.':\n                count += 1\n    \n    return count\n\ndef main():\n    h, w, d = map(int, input().split())\n    grid = [input().strip() for _ in range(h)]\n    \n    print(bfs(grid, h, w, d))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc383_a",
        "code_list": [
            "def main():\n    N = int(input())\n    water_level = 0\n    for _ in range(N):\n        T, V = map(int, input().split())\n        water_level += V - (T - water_level)\n        water_level = max(0, water_level)\n    print(water_level)"
        ]
    },
    {
        "question_id": "abc383_e",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > max(d, w):\n                dist[v] = max(d, w)\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef build_graph(edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    return graph\n\ndef min_path_sum(n, m, k, edges, a, b):\n    graph = build_graph(edges)\n    dist = [dijkstra(graph, i) for i in range(n)]\n    \n    def f(x, y):\n        return dist[x][y]\n    \n    b_perm = list(b)\n    min_sum = float('inf')\n    \n    for perm in itertools.permutations(b_perm):\n        current_sum = sum(f(a[i]-1, perm[i]-1) for i in range(k))\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        edges.append((u, v, w))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    print(min_path_sum(n, m, k, edges, a, b))"
        ]
    },
    {
        "question_id": "abc383_b",
        "code_list": [
            "def find_max_humidified_cells(H, W, D, grid):\n    def is_within_distance(cell1, cell2):\n        return abs(cell1[0] - cell2[0]) + abs(cell1[1] - cell2[1]) <= D\n    \n    def count_humidified_cells(humidifiers, grid):\n        humidified = set(humidifiers)\n        for humidifier in humidifiers:\n            for i in range(max(0, humidifier[0] - D), min(H, humidifier[0] + D + 1)):\n                for j in range(max(0, humidifier[1] - D), min(W, humidifier[1] + D + 1)):\n                    if grid[i][j] == '.':\n                        humidified.add((i, j))\n        return len(humidified)\n    \n    max_humidified = 0\n    floor_cells = [(i, j) for i in range(H) for j in range(W) if grid[i][j] == '.']\n    \n    for i in range(len(floor_cells)):\n        for j in range(i + 1, len(floor_cells)):\n            humidifiers = [floor_cells[i], floor_cells[j]]\n            max_humidified = max(max_humidified, count_humidified_cells(humidifiers, grid))\n    \n    return max_humidified\n\ndef main():\n    H, W, D = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    print(find_max_humidified_cells(H, W, D, grid))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc383_d",
        "code_list": [
            "import math\n\ndef count_numbers_with_nine_divisors(N):\n    count = 0\n    # Iterate through possible base values\n    for base in range(2, int(math.pow(N, 1/8)) + 1):\n        if N % (base ** 8) == 0:\n            count += 1\n        if N % (base ** 4) == 0:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(count_numbers_with_nine_divisors(N))"
        ]
    },
    {
        "question_id": "abc384_b",
        "code_list": [
            "def calculate_rating(N, R, contests):\n    for i in range(N):\n        D, A = contests[i]\n        if D == 1:\n            if 1600 <= R <= 2799:\n                R += A\n        else:\n            if 1200 <= R <= 2399:\n                R += A\n    return R\n\nif __name__ == \"__main__\":\n    N, R = map(int, input().split())\n    contests = [list(map(int, input().split())) for _ in range(N)]\n    print(calculate_rating(N, R, contests))"
        ]
    },
    {
        "question_id": "abc384_d",
        "code_list": [
            "from itertools import accumulate\n\ndef find_subsequence(N, S, A):\n    # Calculate prefix sums\n    prefix_sums = [0] + list(accumulate(A))\n    \n    # Create a set to store prefix sums modulo N\n    mod_set = set()\n    \n    # Iterate through the prefix sums\n    for i in range(N + 1):\n        mod_val = prefix_sums[i] % N\n        mod_set.add(mod_val)\n        \n        # Check if there exists a prefix sum such that the difference is equal to S modulo N\n        if (prefix_sums[i] - S) % N in mod_set:\n            return \"Yes\"\n    \n    return \"No\"\n\nif __name__ == \"__main__\":\n    N, S = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(find_subsequence(N, S, A))"
        ]
    },
    {
        "question_id": "abc384_g",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def get_prefix_sum(arr):\n        prefix_sum = [0]\n        for num in arr:\n            prefix_sum.append(prefix_sum[-1] + num)\n        return prefix_sum\n\n    N = data[0]\n    A = data[1:N+1]\n    B = data[N+1:2*N+1]\n    X = data[2*N+1:2*N+K+1]\n    Y = data[2*N+K+1:]\n\n    prefix_sum_A = get_prefix_sum(A)\n    prefix_sum_B = get_prefix_sum(B)\n\n    results = []\n    for x, y in zip(X, Y):\n        sum_AB = prefix_sum_A[x] - prefix_sum_A[0] * y\n        sum_BA = prefix_sum_B[y] - prefix_sum_B[0] * x\n        result = sum_AB + sum_BA\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_a",
        "code_list": [
            "def main():\n    # Read input\n    N, c1, c2 = input().split()\n    S = input()\n    \n    # Replace every character of S that is not c1 with c2\n    result = ''.join(c2 if c != c1 else c for c in S)\n    \n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_e",
        "code_list": [
            "import heapq\nfrom collections import deque\n\ndef main():\n    H, W, X = map(int, input().split())\n    P, Q = map(int, input().split())\n    S = [list(map(int, input().split())) for _ in range(H)]\n    \n    # Initialize the queue with the starting position\n    queue = deque([(P-1, Q-1, S[P-1][Q-1])])\n    visited = set([(P-1, Q-1)])\n    max_strength = S[P-1][Q-1]\n    \n    while queue:\n        r, c, current_strength = queue.popleft()\n        \n        # Check all 4 possible directions\n        for dr, dc in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            \n            # Check if the new position is within bounds and not visited\n            if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in visited:\n                new_strength = current_strength + S[nr][nc]\n                \n                # Check if the new slime's strength is less than 1/X of the current slime's strength\n                if S[nr][nc] < current_strength / X:\n                    max_strength = max(max_strength, new_strength)\n                    visited.add((nr, nc))\n                    queue.append((nr, nc, new_strength))\n    \n    print(max_strength)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_f",
        "code_list": [
            "def f(x):\n    while x % 2 == 0:\n        x //= 2\n    return x\n\ndef main():\n    import collections\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Count occurrences of each number\n    count = collections.Counter(A)\n    \n    # Calculate the contribution of each pair (i, j)\n    total_sum = 0\n    for i in range(N):\n        for j in range(i, N):\n            total_sum += f(A[i] + A[j])\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_c",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    # Read input scores\n    scores = list(map(int, input().split()))\n    \n    # Generate all possible participant names\n    participants = [''.join(p) for i in range(1, 6) for p in combinations('ABCDE', i)]\n    \n    # Calculate scores for each participant\n    participant_scores = {participant: sum(scores[ord(char) - ord('A')] for char in participant) for participant in participants}\n    \n    # Sort participants by score and then lexicographically\n    sorted_participants = sorted(participant_scores.items(), key=lambda x: (-x[1], x[0]))\n    \n    # Print the names of participants in order of their obtained scores\n    for participant, _ in sorted_participants:\n        print(participant)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_f",
        "code_list": [
            "from bisect import bisect_left\n\ndef main():\n    N = int(input())\n    buildings = []\n    for _ in range(N):\n        X, H = map(int, input().split())\n        buildings.append((X, H))\n    \n    # Sort buildings based on their X coordinates\n    buildings.sort()\n    \n    # Calculate the slopes between consecutive buildings\n    slopes = []\n    for i in range(1, N):\n        dx = buildings[i][0] - buildings[i-1][0]\n        dy = buildings[i][1] - buildings[i-1][1]\n        if dx == 0:\n            continue\n        slopes.append(dy / dx)\n    \n    # Find the maximum slope\n    max_slope = max(slopes) if slopes else 0\n    \n    # Check if it's possible to see all buildings from height 0\n    if max_slope == 0:\n        print(-1)\n    else:\n        # Calculate the maximum height at coordinate 0 from which it is not possible to see all buildings\n        max_height = (buildings[1][1] - buildings[0][1]) / (buildings[1][0] - buildings[0][0])\n        for i in range(1, N-1):\n            dx = buildings[i+1][0] - buildings[i-1][0]\n            dy = buildings[i+1][1] - buildings[i-1][1]\n            if dx == 0:\n                continue\n            slope = dy / dx\n            if slope > max_slope:\n                max_height = (buildings[i+1][1] - buildings[i-1][1]) / (buildings[i+1][0] - buildings[i-1][0])\n        \n        print(max_height)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_a",
        "code_list": [
            "def main():\n    A, B, C = map(int, input().split())\n    total_sum = A + B + C\n    \n    # If the total sum is odd, it's impossible to divide it into equal parts\n    if total_sum % 2 != 0:\n        print(\"No\")\n    else:\n        target_sum = total_sum // 2\n        \n        # Check if we can form a subset that sums up to target_sum\n        dp = [False] * (target_sum + 1)\n        dp[0] = True\n        \n        for num in [A, B, C]:\n            for i in range(target_sum, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]\n        \n        if dp[target_sum]:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_c",
        "code_list": [
            "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    N = int(input())\n    H = list(map(int, input().split()))\n    \n    max_buildings = 1\n    \n    for i in range(N):\n        heights = []\n        current_height = H[i]\n        count = 1\n        \n        for j in range(i + 1, N):\n            if H[j] == current_height:\n                count += 1\n            else:\n                break\n        \n        if count > max_buildings:\n            max_buildings = count\n        \n        for k in range(i - 1, -1, -1):\n            if H[k] == current_height:\n                count += 1\n            else:\n                break\n        \n        if count > max_buildings:\n            max_buildings = count\n        \n        for l in range(i + 1, N):\n            if H[l] == current_height:\n                count += 1\n            else:\n                break\n        \n        if count > max_buildings:\n            max_buildings = count\n    \n    print(max_buildings)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_d",
        "code_list": [
            "def main():\n    # Read input\n    N, M, Sx, Sy = map(int, input().split())\n    houses = [tuple(map(int, input().split())) for _ in range(N)]\n    commands = [input().split() for _ in range(M)]\n\n    # Initialize current position\n    x, y = Sx, Sy\n    visited_houses = set()\n\n    # Process commands\n    for command, value in commands:\n        value = int(value)\n        if command == 'U':\n            y += value\n        elif command == 'D':\n            y -= value\n        elif command == 'L':\n            x -= value\n        elif command == 'R':\n            x += value\n\n        # Check if any house was passed through\n        for house in houses:\n            if (x, y) == house:\n                visited_houses.add(house)\n\n    # Output the final position and number of distinct houses visited\n    print(x, y, len(visited_houses))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_e",
        "code_list": [
            "def dfs(node, parent, graph):\n    children = []\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            children.append(dfs(neighbor, node, graph))\n    if len(children) == 0:\n        return 0, 0, 0  # leaf, x, y\n    elif len(children) == 1:\n        leaf, x, y = children[0]\n        return leaf + 1, x, y\n    else:\n        max_x = -1\n        max_y = -1\n        second_max_y = -1\n        total_leaves = 0\n        for leaf, x, y in children:\n            total_leaves += leaf\n            if x > max_x:\n                second_max_y = max_y\n                max_y = y\n                max_x = x\n            elif x > max_y:\n                second_max_y = y\n        if max_x == -1:  # only one child, which is a leaf\n            return total_leaves + 1, -1, -1\n        if max_y == -1:  # all children have the same x value\n            return total_leaves, max_x, -1\n        if second_max_y == -1:  # only two children, both have the same x value\n            return total_leaves, max_x, max_y\n        return total_leaves, max_x, max_y + second_max_y\n\ndef min_deletions_to_snowflake_tree(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    _, x, y = dfs(0, -1, graph)\n    if x == -1 or y == -1:\n        return 0\n    return n - (x + 1 + y)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = [tuple(map(int, input().split())) for _ in range(n-1)]\n    print(min_deletions_to_snowflake_tree(n, edges))"
        ]
    },
    {
        "question_id": "abc385_b",
        "code_list": [
            "def main():\n    H, W, X, Y = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    T = input()\n\n    visited_houses = set()\n    current_x, current_y = X - 1, Y - 1\n\n    for direction in T:\n        next_x, next_y = current_x, current_y\n        if direction == 'U' and current_x > 0 and grid[current_x - 1][current_y] != '#':\n            next_x -= 1\n        elif direction == 'D' and current_x < H - 1 and grid[current_x + 1][current_y] != '#':\n            next_x += 1\n        elif direction == 'L' and current_y > 0 and grid[current_x][current_y - 1] != '#':\n            next_y -= 1\n        elif direction == 'R' and current_y < W - 1 and grid[current_x][current_y + 1] != '#':\n            next_y += 1\n\n        if grid[next_x][next_y] == '@':\n            visited_houses.add((next_x, next_y))\n\n        current_x, current_y = next_x, next_y\n\n    print(current_x + 1, current_y + 1, len(visited_houses))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc386_e",
        "code_list": [
            "from collections import Counter\nimport heapq\n\ndef main():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Convert each number to its binary representation and count the number of 1s at each bit position\n    bit_counts = [0] * 60\n    for num in A:\n        for i in range(60):\n            if num & (1 << i):\n                bit_counts[i] += 1\n    \n    # Calculate the target number of 1s for each bit position based on the combination formula\n    target_counts = [min(bit_counts[i], K - bit_counts[i]) for i in range(60)]\n    \n    # Construct the maximum XOR value by setting the appropriate bits\n    max_xor = 0\n    for i in range(60):\n        if target_counts[i] > 0:\n            max_xor |= (1 << i)\n            target_counts[i] -= 1\n    \n    # Use a min heap to keep track of the current XOR values and their counts\n    heap = []\n    for num in A:\n        xor_val = 0\n        for i in range(60):\n            if num & (1 << i):\n                xor_val |= (1 << i)\n        \n        # Update the heap with the new XOR value\n        if len(heap) < K:\n            heapq.heappush(heap, (xor_val, num))\n        else:\n            if xor_val > heap[0][0]:\n                heapq.heapreplace(heap, (xor_val, num))\n    \n    # Calculate the final maximum XOR value\n    while heap:\n        _, num = heapq.heappop(heap)\n        max_xor ^= num\n    \n    print(max_xor)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc386_a",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    A, B, C, D = map(int, input().split())\n    cards = [A, B, C, D]\n    counts = Counter(cards)\n    \n    # Check if any pair already has three cards\n    for value, count in counts.items():\n        if count == 3:\n            # Check if we can add one more card to make a full house\n            for other_value in counts:\n                if other_value != value and (counts[other_value] == 1 or counts[other_value] == 2):\n                    print(\"Yes\")\n                    return\n    \n    # Check if we can add a card to make a pair of three and another pair of two\n    for value, count in counts.items():\n        if count == 1:\n            for other_value in counts:\n                if other_value != value and counts[other_value] >= 2:\n                    print(\"Yes\")\n                    return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc386_d",
        "code_list": [
            "def can_color_grid(N, M, colored_cells):\n    # Initialize sets to keep track of the constraints for rows and columns\n    row_constraints = [set(range(N + 1)) for _ in range(N)]\n    col_constraints = [set(range(N + 1)) for _ in range(N)]\n    \n    # Process the pre-colored cells\n    for x, y, color in colored_cells:\n        if color == 'B':\n            row_constraints[x - 1].remove(y)\n            col_constraints[y - 1].remove(x)\n    \n    # Check if there's any conflict in constraints\n    for row in row_constraints:\n        if len(row) == 0:\n            return False\n    for col in col_constraints:\n        if len(col) == 0:\n            return False\n    \n    # Check if the constraints are consistent\n    for row in row_constraints:\n        if any(col in row for col in col_constraints[col] for col in col_constraints[col]):\n            return False\n    \n    return True\n\ndef main():\n    N, M = map(int, input().split())\n    colored_cells = []\n    for _ in range(M):\n        x, y, c = input().split()\n        x, y = int(x), int(y)\n        colored_cells.append((x, y, c))\n    \n    if can_color_grid(N, M, colored_cells):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc386_c",
        "code_list": [
            "def can_transform(K, S, T):\n    if len(S) > len(T):\n        # If S is longer than T, we need at least as many insertions as the difference in lengths\n        if len(S) - len(T) > K:\n            return \"No\"\n    elif len(S) < len(T):\n        # If T is longer than S, we need at most one deletion and insertions to match the lengths\n        if len(T) - len(S) > K:\n            return \"No\"\n    \n    # Find the longest common subsequence (LCS)\n    lcs = 0\n    dp = [[0] * (len(T) + 1) for _ in range(len(S) + 1)]\n    for i in range(1, len(S) + 1):\n        for j in range(1, len(T) + 1):\n            if S[i - 1] == T[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                lcs = max(lcs, dp[i][j])\n    \n    # Calculate the number of operations needed\n    operations_needed = len(S) - lcs + len(T) - lcs\n    \n    # Check if the operations needed are within the allowed limit\n    if operations_needed <= K:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nif __name__ == \"__main__\":\n    K = int(input().strip())\n    S = input().strip()\n    T = input().strip()\n    print(can_transform(K, S, T))"
        ]
    },
    {
        "question_id": "abc386_b",
        "code_list": [
            "def min_button_presses(S):\n    # Initialize the dp array where dp[i] represents the minimum number of button presses to display the first i characters of S\n    dp = [float('inf')] * (len(S) + 1)\n    dp[0] = 0  # Base case: no presses needed for an empty string\n    \n    # Iterate through each character in the string S\n    for i in range(1, len(S) + 1):\n        # Try to form the current character using single digit or double digit\n        for j in range(i):\n            if int(S[j:i]) <= 99:  # Check if the substring can be formed using one or two digits\n                dp[i] = min(dp[i], dp[j] + 1)\n    \n    return dp[-1]\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(min_button_presses(S))"
        ]
    },
    {
        "question_id": "abc386_f",
        "code_list": [
            "def can_transform(k, s, t):\n    m, n = len(s), len(t)\n    i, j = 0, 0\n    \n    # Find the longest common subsequence\n    while i < m and j < n:\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n    \n    lcs_length = j\n    \n    # Calculate the number of insertions and deletions needed\n    insertions = n - lcs_length\n    deletions = m - lcs_length\n    \n    # Total operations required\n    total_operations = insertions + deletitions\n    \n    # Check if the total operations are within the allowed limit\n    return total_operations <= k\n\nif __name__ == \"__main__\":\n    k = int(input().strip())\n    s = input().strip()\n    t = input().strip()\n    \n    result = \"Yes\" if can_transform(k, s, t) else \"No\"\n    print(result)"
        ]
    },
    {
        "question_id": "arc184_d",
        "code_list": [
            "from typing import List\n\ndef count_possible_sets(N: int, points: List[List[int]]) -> int:\n    MOD = 998244353\n    \n    def dfs(index: int, mask: int, x_max: int, y_max: int) -> int:\n        if index == N:\n            return 1\n        \n        count = 0\n        for i in range(N):\n            if mask & (1 << i) == 0:\n                if (points[i][0] < x_max and points[i][1] < y_max) or (points[i][0] > x_max and points[i][1] > y_max):\n                    continue\n                count += dfs(index + 1, mask | (1 << i), max(x_max, points[i][0]), max(y_max, points[i][1]))\n                count %= MOD\n        \n        return count\n    \n    return dfs(0, 0, 0, 0)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    points = [list(map(int, input().split())) for _ in range(N)]\n    print(count_possible_sets(N, points))"
        ]
    },
    {
        "question_id": "arc184_c",
        "code_list": [
            "def count_mountain_folds(N, A):\n    # Initialize variables\n    max_count = 0\n    dp = [0] * (2**100)\n    \n    # Precompute the number of mountain folds for each possible position\n    for i in range(1, 2**100):\n        for j in A:\n            if i + j < 2**100:\n                dp[i + j] += 1\n    \n    # Find the maximum value of f(i)\n    for i in range(2**100 - A[-1] - 1):\n        max_count = max(max_count, dp[i])\n    \n    return max_count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(count_mountain_folds(N, A))"
        ]
    },
    {
        "question_id": "arc184_e",
        "code_list": [
            "from collections import defaultdict\nfrom typing import List\n\ndef main():\n    N, M = map(int, input().split())\n    sequences = [list(map(int, input().split())) for _ in range(N)]\n    \n    def transform(seq):\n        return [(sum(seq[:i+1]) % 2) for i in range(M)]\n    \n    def find_min_steps(seq1, seq2):\n        steps = 0\n        for i in range(M):\n            if seq1[i] != seq2[i]:\n                steps += 1\n                for j in range(i, M):\n                    seq1[j] = (seq1[j] + 1) % 2\n        return steps\n    \n    memo = defaultdict(lambda: -1)\n    def dp(seq):\n        if tuple(seq) in memo:\n            return memo[tuple(seq)]\n        min_steps = float('inf')\n        for i in range(M):\n            new_seq = seq[:]\n            for j in range(i, M):\n                new_seq[j] = (new_seq[j] + 1) % 2\n            min_steps = min(min_steps, 1 + dp(new_seq))\n        memo[tuple(seq)] = min_steps\n        return min_steps\n    \n    total_steps = 0\n    for i in range(N):\n        transformed_seq = transform(sequences[i])\n        for j in range(i, N):\n            transformed_seq_j = transform(sequences[j])\n            if transformed_seq == transformed_seq_j:\n                total_steps += dp(transformed_seq)\n            else:\n                total_steps += find_min_steps(transformed_seq, transformed_seq_j)\n    \n    print(total_steps % 998244353)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc185_c",
        "code_list": [
            "def find_triplet(N, X, A):\n    for i in range(N - 2):\n        for j in range(i + 1, N - 1):\n            for k in range(j + 1, N):\n                if A[i] + A[j] + A[k] == X:\n                    return i + 1, j + 1, k + 1\n    return -1\n\ndef main():\n    N, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    result = find_triplet(N, X, A)\n    if result == -1:\n        print(result)\n    else:\n        print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc185_e",
        "code_list": [
            "from math import gcd\nfrom collections import defaultdict\nfrom functools import reduce\n\nMOD = 998244353\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    def get_primes(n):\n        primes = []\n        while n % 2 == 0:\n            primes.append(2)\n            n //= 2\n        f = 3\n        while f * f <= n:\n            if n % f == 0:\n                primes.append(f)\n                n //= f\n            else:\n                f += 2\n        if n != 1:\n            primes.append(n)\n        return primes\n\n    def count_factors(x, primes):\n        return sum(x % p == 0 for p in primes)\n\n    primes = set()\n    for num in a:\n        primes.update(get_primes(num))\n\n    factor_count = defaultdict(int)\n    for prime in primes:\n        for num in a:\n            factor_count[prime] += num % prime == 0\n\n    result = [0] * n\n    for i in range(n):\n        current_score = 0\n        for prime in primes:\n            if a[i] % prime == 0:\n                current_score += factor_count[prime]\n        for j in range(i + 1, n):\n            if a[j] % a[i] == 0:\n                current_score += 1\n            elif a[i] % a[j] == 0:\n                current_score -= 1\n        result[i] = (result[i - 1] + current_score) % MOD\n\n    print(*result, sep='\\n')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc185_b",
        "code_list": [
            "def can_make_non_decreasing(N, A):\n    # Check if the sequence can be made non-decreasing\n    for i in range(1, N):\n        if A[i] < A[i-1]:\n            return False\n    return True\n\ndef solve_test_case():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Check if the sequence is already non-decreasing\n    if can_make_non_decreasing(N, A):\n        print(\"Yes\")\n        return\n    \n    # Check if it's possible to make the sequence non-decreasing\n    for i in range(N-1):\n        for j in range(i+1, N):\n            A[i] += 1\n            A[j] -= 1\n            if can_make_non_decreasing(N, A):\n                print(\"Yes\")\n                return\n            A[i] -= 1\n            A[j] += 1\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    T = int(input())\n    for _ in range(T):\n        solve_test_case()"
        ]
    },
    {
        "question_id": "arc185_d",
        "code_list": [
            "def main():\n    from math import gcd\n\n    def modinv(a, m=998244353):\n        return pow(a, m - 2, m)\n\n    def solve(N, M):\n        MOD = 998244353\n        dp = [0] * (N * M + 1)\n        dp[0] = 1\n        for i in range(1, N * M + 1):\n            if i < N:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = (dp[i - 1] + dp[max(i - N, 0)]) % MOD\n            if i < N or i % N == 0:\n                dp[i] = (dp[i] + MOD - dp[i - 1]) % MOD\n            dp[i] = (dp[i] * modinv(i + 1)) % MOD\n        return sum(dp) % MOD\n\n    N, M = map(int, input().split())\n    print(solve(N, M))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_a",
        "code_list": [
            "def is_possible(N, K):\n    total_elements = N * N\n    # If K is greater than the total number of elements, it's impossible\n    if K > total_elements:\n        return False\n    # If K is less than the sum of N (rows) and N (columns) minus 1 (for the overlap),\n    # it's also impossible because fixing more than this would violate the row/column sum condition\n    if K < N + N - 1:\n        return False\n    # Check if K can be achieved by fixing some elements while maintaining the row and column sum conditions\n    # We need to check if K can be formed by adding elements in a way that doesn't violate the conditions\n    # This can be done by checking if K - (N - 1) is divisible by (N - 1)\n    # This ensures that we can fix enough elements without violating the row and column sum conditions\n    if (K - (N - 1)) % (N - 1) == 0:\n        return True\n    return False\n\ndef main():\n    N, Q = map(int, input().split())\n    results = []\n    for _ in range(Q):\n        K = int(input())\n        results.append(\"Yes\" if is_possible(N, K) else \"No\")\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_d",
        "code_list": [
            "from functools import lru_cache\n\nMOD = 998244353\n\n@lru_cache(None)\ndef count_polish_sequences(n):\n    if n == 0:\n        return 1\n    total = 0\n    for i in range(n + 1):\n        total += count_polish_sequences(i) * count_polish_sequences(n - i)\n        total %= MOD\n    return total\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    for i in range(N):\n        for j in range(A[i] + 1):\n            if i + j < N:\n                dp[i + j] += dp[i]\n                dp[i + j] %= MOD\n    \n    result = sum(dp[N:]) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_b",
        "code_list": [
            "from typing import List\n\ndef count_valid_permutations(N: int, A: List[int]) -> int:\n    MOD = 998244353\n    dp = [1] * (N + 1)\n    stack = []\n    \n    for i in range(1, N + 1):\n        while stack and A[stack[-1]] < A[i]:\n            stack.pop()\n        if stack:\n            dp[i] = dp[stack[-1]]\n        stack.append(i)\n        \n        for j in range(A[i], i):\n            dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[N]\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(count_valid_permutations(N, A))"
        ]
    },
    {
        "question_id": "arc186_e",
        "code_list": [
            "from collections import defaultdict\nfrom math import comb\n\nMOD = 998244353\n\ndef count_sequences(N, M, K, X):\n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(M + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, M + 1):\n        for j in range(K + 1):\n            for k in range(1, K + 1):\n                if k != X[i - 1]:\n                    dp[i][j] += dp[i - 1][j]\n                    dp[i][j] %= MOD\n    \n    # Calculate the total number of valid sequences\n    total_sequences = pow(K, N, MOD)\n    \n    # Subtract invalid sequences\n    for i in range(1, M + 1):\n        for j in range(1, K + 1):\n            if j != X[i - 1]:\n                total_sequences -= dp[M][i] * pow(K - 1, N - i, MOD)\n                total_sequences %= MOD\n    \n    return (total_sequences + MOD) % MOD\n\ndef main():\n    N, M, K = map(int, input().split())\n    X = list(map(int, input().split()))\n    print(count_sequences(N, M, K, X))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_c",
        "code_list": [
            "import heapq\n\ndef solve_test_case(N, M, boxes):\n    # Sort boxes by cost per unit capacity in descending order\n    boxes.sort(key=lambda x: -x[1] / x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    box_types = [0] * M\n    \n    for V, P in boxes:\n        # Calculate the cost per unit capacity\n        cost_per_unit = P / V\n        \n        # Find the type of ball that can be stored in the current box\n        best_ball_type = -1\n        for i in range(M):\n            if box_types[i] < V and (best_ball_type == -1 or box_types[i] > box_types[best_ball_type]):\n                best_ball_type = i\n        \n        # If no suitable ball type found, break the loop\n        if best_ball_type == -1:\n            break\n        \n        # Update the box type count\n        box_types[best_ball_type] += V\n        \n        # Add the cost of the box to the total cost\n        total_cost += P\n    \n    return total_cost\n\ndef main():\n    T = int(input())\n    results = []\n    for _ in range(T):\n        N, M = map(int, input().split())\n        boxes = []\n        for _ in range(N):\n            V, P = map(int, input().split())\n            boxes.append((V, P))\n        \n        result = solve_test_case(N, M, boxes)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc187_b",
        "code_list": [
            "from collections import defaultdict\nfrom math import comb\n\ndef main():\n    N, M = map(int, input().split())\n    B = list(map(int, input().split()))\n    \n    # Count the number of -1s and their positions\n    neg_count = B.count(-1)\n    neg_positions = [i for i, x in enumerate(B) if x == -1]\n    \n    # Initialize dp array to store the number of ways to form each connected component size\n    dp = [0] * (neg_count + 1)\n    dp[0] = 1\n    \n    # Calculate the number of ways to form connected components\n    for i in range(1, neg_count + 1):\n        dp[i] = dp[i - 1] * M % 998244353\n    \n    # Function to calculate the number of ways to form the graph with given constraints\n    def calculate_ways(pos):\n        if pos == 0:\n            return 1\n        ways = 0\n        for i in range(neg_count + 1):\n            ways += dp[i] * comb(neg_count, i) % 998244353\n            ways %= 998244353\n        return ways\n    \n    # Calculate the total number of ways to form the graph\n    total_ways = 0\n    for mask in range(1 << neg_count):\n        count = bin(mask).count('1')\n        if count % 2 == 0:\n            total_ways += calculate_ways(count)\n        else:\n            total_ways -= calculate_ways(count)\n        total_ways %= 998244353\n    \n    print(total_ways)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc188_c",
        "code_list": [
            "from collections import defaultdict\n\ndef find_confused_villagers(N, M, testimonies):\n    # Create a graph to represent the relationships between villagers\n    graph = defaultdict(list)\n    for A, B, C in testimonies:\n        graph[A].append((B, C))\n        graph[B].append((A, 1 - C))  # Opposite of C because B's perspective\n\n    def dfs(v, status, visited):\n        visited[v] = True\n        for u, c in graph[v]:\n            if visited[u]:\n                continue\n            if status == 'H':\n                if c == 0:  # Honest villager says B is honest\n                    if not dfs(u, 'H', visited):\n                        return False\n                else:  # Honest villager says B is a liar\n                    if dfs(u, 'L', visited):\n                        return False\n            else:  # Liar villager says B is honest\n                if c == 1:  # Liar says B is honest, but B is actually a liar\n                    if dfs(u, 'L', visited):\n                        return False\n                else:  # Liar says B is a liar, but B is actually honest\n                    if not dfs(u, 'H', visited):\n                        return False\n        return True\n\n    for confused in range(1 << N):  # Try all possible sets of confused villagers\n        visited = [False] * (N + 1)\n        for v in range(1, N + 1):\n            if confused & (1 << (v - 1)):\n                if not dfs(v, 'L', visited):  # Confused liar\n                    break\n            else:\n                if not dfs(v, 'H', visited):  # Not confused, honest\n                    break\n        else:\n            return [str(int(confused & (1 << (v - 1)))) for v in range(1, N + 1)]\n    return -1\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    testimonies = [tuple(map(int, input().split())) for _ in range(M)]\n    result = find_confused_villagers(N, M, testimonies)\n    print(''.join(result))"
        ]
    },
    {
        "question_id": "arc188_b",
        "code_list": [
            "def can_color_all_points(N, K):\n    # If K is 1 or N-1, Alice can always color all points black\n    if K == 1 or K == N - 1:\n        return \"Yes\"\n    \n    # If N is even, Alice can always color all points black\n    if N % 2 == 0:\n        return \"Yes\"\n    \n    # If N is odd and K is not equal to N//2, Bob can block Alice from coloring all points black\n    if K != N // 2:\n        return \"No\"\n    \n    # If N is odd and K is equal to N//2, Alice can still color all points black\n    return \"Yes\"\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N, K = map(int, input().split())\n        print(can_color_all_points(N, K))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc188_d",
        "code_list": [
            "from math import comb\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Create a set of unique elements in A and B excluding -1\n    unique_elements = set(A + [x for x in B if x != -1])\n    M = len(unique_elements)\n\n    # If the number of unique elements is less than 2N, return 0\n    if M < 2 * N:\n        print(0)\n        return\n\n    # Calculate the number of valid permutations\n    result = comb(M - 1, N - 1) % 998244353\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc188_a",
        "code_list": [
            "MOD = 998244353\n\ndef is_good_string(s):\n    stack = []\n    for char in s:\n        if char == 'A':\n            if len(stack) >= 2 and stack[-1] == 'B' and stack[-2] == 'C':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == 'B':\n            if len(stack) >= 2 and stack[-1] == 'C' and stack[-2] == 'A':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == 'C':\n            if len(stack) >= 2 and stack[-1] == 'A' and stack[-2] == 'B':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == '?':\n            stack.append('?')\n    return len(stack) == 0\n\ndef count_good_substrings(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if is_good_string(substring):\n                count += 1\n    return count\n\ndef solve(n, k, s):\n    dp = [[[0] * (k + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n    for i in range(n):\n        for j in range(i + 1):\n            for l in range(k + 1):\n                if s[i] == '?':\n                    for c in 'ABC':\n                        new_j = j + (c != '?')\n                        new_l = l + (is_good_string(s[:i] + c + s[i + 1:]) and c != '?')\n                        dp[i + 1][new_j][new_l] += dp[i][j][l]\n                        dp[i + 1][new_j][new_l] %= MOD\n                else:\n                    new_j = j + (s[i] != '?')\n                    new_l = l + (is_good_string(s[:i] + s[i] + s[i + 1:]) and s[i] != '?')\n                    dp[i + 1][new_j][new_l] += dp[i][j][l]\n                    dp[i + 1][new_j][new_l] %= MOD\n    return sum(dp[n][j][k] for j in range(n + 1)) % MOD\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    s = input().strip()\n    print(solve(n, k, s))"
        ]
    },
    {
        "question_id": "arc189_a",
        "code_list": [
            "from math import comb\n\ndef count_sequences(N, A):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(1, N + 1):\n        if A[i - 1] == A[0]:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = dp[i - 1] + dp[i - 2]\n        dp[i] %= MOD\n    return dp[N]\n\ndef main():\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(count_sequences(N, A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc189_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n\n    # Create inverse mappings for P and Q\n    inv_P = [0] * (N + 1)\n    inv_Q = [0] * (N + 1)\n    for i in range(1, N + 1):\n        inv_P[P[i - 1]] = i\n        inv_Q[Q[i - 1]] = i\n\n    # Initialize the count of operations\n    operations = 0\n\n    # Check if we can empty all boxes except the X-th one\n    for i in range(N):\n        if i + 1 != X:\n            # If there are balls in the i-th box, we need to move them\n            if A[i] or B[i]:\n                # Find the target boxes for red and blue balls\n                target_red = inv_P[i + 1]\n                target_blue = inv_Q[i + 1]\n\n                # If both targets are the same as the current box, we cannot empty this box\n                if target_red == i + 1 and target_blue == i + 1:\n                    print(-1)\n                    return\n\n                # Move balls to their respective targets\n                if A[i] and target_red != X:\n                    A[target_red - 1] += A[i]\n                    operations += 1\n                if B[i] and target_blue != X:\n                    B[target_blue - 1] += B[i]\n                    operations += 1\n\n    # Check if all boxes except the X-th one are empty\n    for i in range(N):\n        if i + 1 != X and (A[i] or B[i]):\n            print(-1)\n            return\n\n    print(operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc189_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def process_slimes(n, slimes):\n        stack = []\n        for i in range(n):\n            while stack and slimes[stack[-1]] < slimes[i]:\n                mid = stack.pop()\n                if stack:\n                    left = stack[-1]\n                    slimes[left] += slimes[mid]\n                else:\n                    slimes[i] += slimes[mid]\n            stack.append(i)\n        \n        max_size = [slimes[i] for i in range(n)]\n        for i in reversed(range(n)):\n            while stack and slimes[stack[-1]] < slimes[i]:\n                mid = stack.pop()\n                max_size[i] = max(max_size[i], slimes[i] + max_size[mid])\n            stack.append(i)\n        \n        return ' '.join(map(str, max_size))\n\n    n = data[0]\n    slimes = data[1:]\n    print(process_slimes(n, slimes))"
        ]
    },
    {
        "question_id": "arc189_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    x = data[1:]\n    midpoints = []\n    for i in range(n - 3):\n        midpoints.append((x[i] + x[i + 3]) / 2)\n\n    # Sort midpoints to find the median\n    midpoints.sort()\n\n    # Calculate the minimum sum of coordinates\n    min_sum = sum(x)\n    if n % 2 == 0:\n        min_sum -= midpoints[n // 2 - 1] + midpoints[n // 2]\n    else:\n        min_sum -= 2 * midpoints[n // 2]\n\n    print(min_sum)"
        ]
    },
    {
        "question_id": "3610",
        "code_list": [
            "from collections import Counter\nfrom heapq import nlargest\n\nclass Solution:\n    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:\n        result = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            freq_counter = Counter(subarray)\n            top_x_elements = nlargest(x, freq_counter.items(), key=lambda item: (item[1], item[0]))\n            top_x_values = [item[0] for item in top_x_elements]\n            x_sum = sum([freq_counter[num] * num for num in top_x_values])\n            result.append(x_sum)\n        return result"
        ]
    },
    {
        "question_id": "3588",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countWinningSequences(self, s: str) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(i, prev):\n            if i == len(s):\n                return 1\n            \n            count = 0\n            for choice in 'FW':\n                if prev != choice:\n                    count += dp(i + 1, choice)\n                    count %= MOD\n            \n            return count\n        \n        result = 0\n        for i, move in enumerate(s):\n            if move == 'F':\n                result += dp(i + 1, 'W')\n            elif move == 'W':\n                result += dp(i + 1, 'E')\n            else:\n                result += dp(i + 1, 'F')\n            result %= MOD\n        \n        return result"
        ]
    },
    {
        "question_id": "3566",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def stringSequence(self, target: str) -> List[str]:\n        result = [\"a\"]\n        for char in target:\n            if char == 'a':\n                result.append(\"aa\")\n            else:\n                prev_char_index = ord(result[-1]) - ord('a')\n                new_char_index = ord(char) - ord('a')\n                steps = new_char_index - prev_char_index\n                if steps > 0:\n                    result.extend(['a'] * (steps - 1))\n                result.append(char)\n        return result"
        ]
    },
    {
        "question_id": "3502",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def numberOfSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        count = 0\n        \n        for i in range(n):\n            char_count = Counter()\n            for j in range(i, n):\n                char_count[s[j]] += 1\n                if all(v >= k for v in char_count.values()):\n                    count += 1\n                    \n        return count"
        ]
    },
    {
        "question_id": "3607",
        "code_list": [
            "from math import sqrt\nfrom typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def find_proper_divisors(n):\n            divisors = []\n            for i in range(2, int(sqrt(n)) + 1):\n                if n % i == 0:\n                    divisors.append(i)\n                    if i != n // i:\n                        divisors.append(n // i)\n            return sorted(divisors)\n\n        def gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n\n        dp = [float('inf')] * (len(nums) + 1)\n        dp[0] = 0\n        for i in range(len(nums)):\n            for d in find_proper_divisors(nums[i]):\n                prev_index = bisect_left(dp, dp[i] + 1)\n                dp[prev_index] = min(dp[prev_index], dp[i] + 1)\n            if i > 0 and nums[i] < nums[i - 1]:\n                return -1\n            if i > 0 and nums[i] % nums[i - 1] != 0:\n                nums[i] = lcm(nums[i - 1], nums[i])\n        return dp[-2]"
        ]
    },
    {
        "question_id": "3603",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def findAnswer(self, parent: List[int], s: str) -> List[bool]:\n        n = len(parent)\n        graph = defaultdict(list)\n        \n        # Build the tree graph\n        for i in range(1, n):\n            graph[parent[i]].append(i)\n        \n        def dfs(x: int) -> None:\n            nonlocal dfsStr\n            for y in sorted(graph[x]):\n                dfs(y)\n            dfsStr += s[x]\n        \n        def is_palindrome(s: str) -> bool:\n            return s == s[::-1]\n        \n        answer = []\n        for i in range(n):\n            dfsStr = ''\n            dfs(i)\n            answer.append(is_palindrome(dfsStr))\n        \n        return answer"
        ]
    },
    {
        "question_id": "3593",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0] ** 2\n        \n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        \n        def max_factor_score(nums):\n            max_score = 0\n            for i in range(n):\n                current_gcd = nums[i]\n                current_lcm = nums[i]\n                for j in range(i + 1, n):\n                    current_gcd = gcd(current_gcd, nums[j])\n                    current_lcm = lcm(current_lcm, nums[j])\n                max_score = max(max_score, current_gcd * current_lcm)\n            return max_score\n        \n        # Check the score with each element removed\n        scores = []\n        for i in range(n):\n            new_nums = nums[:i] + nums[i+1:]\n            scores.append(max_factor_score(new_nums))\n        \n        # Also check the original score without removing any element\n        scores.append(max_factor_score(nums))\n        \n        return max(scores)"
        ]
    },
    {
        "question_id": "3629",
        "code_list": [
            "class Solution:\n    def lengthAfterTransformations(self, s: str, t: int) -> int:\n        MOD = 10**9 + 7\n        \n        # Function to calculate the length after one transformation\n        def transform_length(c: str) -> int:\n            if c == 'z':\n                return 2\n            return ord(c) - ord('a') + 1\n        \n        # Initial length of the string\n        initial_length = len(s)\n        \n        # Calculate the effective number of transformations needed\n        effective_transforms = t % 26  # Since the pattern repeats every 26 characters\n        \n        # Calculate the final length after the effective number of transformations\n        final_length = initial_length + effective_transforms * (transform_length('z') - 1)\n        \n        # Return the final length modulo 10^9 + 7\n        return final_length % MOD"
        ]
    },
    {
        "question_id": "3608",
        "code_list": [
            "from math import gcd\nfrom collections import defaultdict\nfrom itertools import combinations\n\nclass Solution:\n    def subsequencePairCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Function to calculate the GCD of all numbers in a subsequence\n        def gcd_of_subsequence(subseq):\n            if not subseq:\n                return 0\n            result = subseq[0]\n            for num in subseq[1:]:\n                result = gcd(result, num)\n            return result\n        \n        # Count occurrences of each number\n        count_map = defaultdict(int)\n        for num in nums:\n            count_map[num] += 1\n        \n        # Generate all possible subsequences and their GCDs\n        subseq_gcd_count = defaultdict(int)\n        for r in range(1, len(nums) + 1):\n            for subseq in combinations(nums, r):\n                subseq_gcd = gcd_of_subsequence(subseq)\n                subseq_gcd_count[subseq_gcd] += 1\n        \n        # Calculate the number of valid pairs\n        total_pairs = 0\n        for gcd_val in subseq_gcd_count:\n            count = subseq_gcd_count[gcd_val]\n            total_pairs += count * (count - 1) // 2\n        \n        # Subtract invalid pairs where the GCD is not 1\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if gcd(nums[i], nums[j]) != 1:\n                    total_pairs -= 1\n        \n        return total_pairs % MOD"
        ]
    },
    {
        "question_id": "3636",
        "code_list": [
            "class Solution:\n    def isBalanced(self, num: str) -> bool:\n        even_sum = sum(int(num[i]) for i in range(0, len(num), 2))\n        odd_sum = sum(int(num[i]) for i in range(1, len(num), 2))\n        return even_sum == odd_sum"
        ]
    },
    {
        "question_id": "3627",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def minTimeToReach(self, moveTime: List[List[int]]) -> int:\n        n, m = len(moveTime), len(moveTime[0])\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        visited = set()\n        pq = [(moveTime[0][0], 0, 0)]  # (time, row, col)\n        \n        while pq:\n            time, row, col = heapq.heappop(pq)\n            if (row, col) == (n - 1, m - 1):\n                return time\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n            \n            for dr, dc in directions:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited:\n                    new_time = max(time, moveTime[new_row][new_col]) + 1\n                    heapq.heappush(pq, (new_time, new_row, new_col))\n        \n        return -1  # This line should theoretically never be reached"
        ]
    },
    {
        "question_id": "3637",
        "code_list": [
            "from math import factorial\n\nclass Solution:\n    def countBalancedPermutations(self, num: str) -> int:\n        from collections import Counter\n        \n        # Count the frequency of each digit\n        freq = Counter(num)\n        \n        # Calculate the total number of permutations\n        total_permutations = factorial(len(num))\n        \n        # Calculate the number of balanced permutations\n        even_sum = 0\n        odd_sum = 0\n        for i, char in enumerate(num):\n            if i % 2 == 0:\n                even_sum += int(char)\n            else:\n                odd_sum += int(char)\n        \n        if even_sum != odd_sum:\n            return 0\n        \n        # If the sum of digits at even and odd indices is the same, calculate the number of balanced permutations\n        half_len = len(num) // 2\n        even_freq = freq.copy()\n        odd_freq = freq.copy()\n        \n        balanced_permutations = 0\n        for i in range(half_len + 1):\n            if even_freq[num[i]] == 0:\n                break\n            even_freq[num[i]] -= 1\n            if odd_freq[num[-i-1]] == 0:\n                break\n            odd_freq[num[-i-1]] -= 1\n            \n            # Calculate the number of balanced permutations for this configuration\n            even_permutations = factorial(half_len - i)\n            for value in even_freq.values():\n                even_permutations //= factorial(value)\n            \n            odd_permutations = factorial(half_len - i)\n            for value in odd_freq.values():\n                odd_permutations //= factorial(value)\n            \n            balanced_permutations += even_permutations * odd_permutations\n        \n        return balanced_permutations % (10**9 + 7)"
        ]
    },
    {
        "question_id": "3612",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:\n        for i in range(len(nums) - k * 2):\n            if all(nums[i + j] < nums[i + j + 1] for j in range(k)) and \\\n               all(nums[i + k + j] < nums[i + k + j + 1] for j in range(k)):\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3646",
        "code_list": [
            "from collections import defaultdict\nfrom typing import List\n\nclass Solution:\n    def sumOfGoodSubsequences(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        dp = defaultdict(lambda: [0, 0])\n        prefix_sum = defaultdict(int)\n        \n        for num in nums:\n            prev_dp = dp[num - 1][:]\n            next_dp = dp[num + 1][:]\n            \n            dp[num][0] = (prev_dp[0] + prev_dp[1]) * 2 + 1  # Include current number in both sequences\n            dp[num][1] = prev_dp[0] + 1  # Start new sequence with current number\n            \n            prefix_sum[num] = (prefix_sum[num - 1] + dp[num][0]) % MOD\n        \n        return prefix_sum[max(nums)]"
        ]
    },
    {
        "question_id": "3631",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def countKReducibleNumbers(self, s: str, k: int) -> int:\n        MOD = 10**9 + 7\n        \n        def count_set_bits(n):\n            return bin(n).count('1')\n        \n        def is_k_reducible(x, k):\n            while x > 1 and k > 0:\n                x = count_set_bits(x)\n                k -= 1\n            return x == 1\n        \n        n = int(s, 2)\n        count = 0\n        \n        for i in range(1, n):\n            if is_k_reducible(i, k):\n                count += 1\n        \n        return count % MOD"
        ]
    },
    {
        "question_id": "3616",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countValidSelections(self, nums: List[int]) -> int:\n        n = len(nums)\n        zero_positions = [i for i, num in enumerate(nums) if num == 0]\n        count = 0\n        \n        for start_pos in zero_positions:\n            direction = 1  # 1 for right, -1 for left\n            curr = start_pos\n            steps = 0\n            \n            while True:\n                if curr < 0 or curr >= n:\n                    break\n                if nums[curr] == 0:\n                    curr += direction * (steps % 2 == 0)\n                elif nums[curr] > 0:\n                    nums[curr] -= 1\n                    if direction == 1:\n                        direction = -1\n                    else:\n                        direction = 1\n                    curr += direction\n                    steps += 1\n                if all(num == 0 for num in nums):\n                    count += 1\n                    break\n        \n        return count"
        ]
    },
    {
        "question_id": "3639",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isZeroArray(self, nums: List[int], queries: List[List[int]]) -> bool:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        \n        for l, r in queries:\n            prefix_sum[l] += 1\n            prefix_sum[r + 1] -= 1\n        \n        for i in range(n):\n            prefix_sum[i + 1] += prefix_sum[i]\n        \n        return all(num == 0 for num in prefix_sum[:-1])"
        ]
    },
    {
        "question_id": "3658",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minDifference(self, nums: List[int]) -> int:\n        # Filter out the -1 positions and sort them\n        gaps = sorted((i for i, num in enumerate(nums) if num == -1))\n        # Filter out the actual numbers and sort them\n        values = sorted(num for num in nums if num != -1)\n        \n        # If there are no -1s, the max difference is already minimized\n        if not gaps:\n            return 0\n        \n        # Initialize the answer with a large value\n        ans = float('inf')\n        \n        # Check the difference when replacing -1s with the smallest and largest available values\n        for i in range(len(gaps)):\n            left = gaps[i] - (len(values) - 1 - i) if i < len(values) else float('inf')\n            right = gaps[-(i + 1)] - (len(values) - 1 - (len(gaps) - i - 1)) if len(gaps) - i - 1 < len(values) else float('inf')\n            ans = min(ans, max(left, right) - min(values))\n        \n        return ans"
        ]
    },
    {
        "question_id": "3644",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSumSubarray(self, nums: List[int], l: int, r: int) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        \n        for size in range(l, r + 1):\n            current_sum = 0\n            for i in range(n - size + 1):\n                current_sum += nums[i + size - 1]\n                if i >= size - 1:\n                    current_sum -= nums[i - (size - 1)]\n                if current_sum > 0 and current_sum < min_sum:\n                    min_sum = current_sum\n        \n        return min_sum if min_sum != float('inf') else -1"
        ]
    },
    {
        "question_id": "3654",
        "code_list": [
            "import heapq\n\nclass Solution:\n    def minArraySum(self, nums: List[int], k: int, op1: int, op2: int) -> int:\n        # Convert nums to a max heap for efficient extraction of the largest element\n        nums = [-num for num in nums]\n        heapq.heapify(nums)\n        ops1, ops2 = op1, op2\n        \n        while ops1 > 0 or ops2 > 0:\n            if nums and -nums[0] >= k:\n                if ops2 > 0:\n                    # Perform Operation 2\n                    heapq.heappush(nums, -(-nums[0] - k))\n                    ops2 -= 1\n                else:\n                    # Perform Operation 1\n                    val = -heapq.heappop(nums)\n                    heapq.heappush(nums, -(val // 2))\n                    ops1 -= 1\n            else:\n                break\n        \n        return -sum(nums)"
        ]
    },
    {
        "question_id": "3675",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def maximizeSumOfWeights(self, edges: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        graph = [[] for _ in range(n)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        \n        def dfs(node, parent):\n            weights = []\n            for neighbor, weight in graph[node]:\n                if neighbor != parent:\n                    dfs(neighbor, node)\n                    weights.append(graph[neighbor][-1])\n            weights.sort(reverse=True)\n            while len(weights) > k:\n                heapq.heappush(heap, weights.pop())\n            for i in range(len(weights)):\n                graph[node].append((graph[neighbor][-1][0], -weights[i]))\n        \n        heap = []\n        dfs(0, -1)\n        max_sum = 0\n        for _, weight in graph[0]:\n            max_sum += -weight\n        return max_sum"
        ]
    },
    {
        "question_id": "3605",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minBitwiseArray(self, nums: List[int]) -> List[int]:\n        ans = []\n        for num in nums:\n            # Check if num is odd or even\n            if num % 2 == 0:\n                # If num is even, we can directly find the answer\n                ans.append(num // 2)\n            else:\n                # If num is odd, we need to check the bits\n                # For odd numbers, the last bit is 1, so we subtract 1 to make it even\n                # Then we divide by 2 to get the closest smaller number\n                # Finally, we add 1 to get the correct answer\n                ans.append((num - 1) // 2)\n        return ans"
        ]
    },
    {
        "question_id": "3487",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:\n        # Create a mapping of each target index to its corresponding character in the source\n        char_map = {index: source[index] for index in targetIndices}\n        \n        # Initialize pointers for source, pattern, and the result\n        src_ptr, pat_ptr, result = 0, 0, 0\n        \n        # Iterate through the source and pattern\n        while src_ptr < len(source) and pat_ptr < len(pattern):\n            # If the current character in source matches the current character in pattern\n            if source[src_ptr] == pattern[pat_ptr]:\n                # Check if the current index is in the targetIndices\n                if src_ptr in char_map and char_map[src_ptr] == pattern[pat_ptr]:\n                    result += 1\n                    pat_ptr += 1\n            src_ptr += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3604",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def numberOfWays(self, n: int, x: int, y: int) -> int:\n        MOD = 10**9 + 7\n        \n        def power(a, b):\n            result = 1\n            while b > 0:\n                if b % 2 == 1:\n                    result = (result * a) % MOD\n                a = (a * a) % MOD\n                b //= 2\n            return result\n        \n        def count_ways(n, x):\n            if n == 0:\n                return 1\n            ways = 0\n            for i in range(1, min(x + 1, n + 1)):\n                ways += comb(n, i) * power(i, n)\n                ways %= MOD\n            return ways\n        \n        total_ways = 0\n        for i in range(1, n + 1):\n            for j in range(1, n - i + 1):\n                k = n - i - j\n                ways = count_ways(i, x) * count_ways(j, x) * count_ways(k, x) * power(y, comb(i + j + k, i))\n                total_ways += ways\n                total_ways %= MOD\n        \n        return total_ways"
        ]
    },
    {
        "question_id": "3617",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def possibleStringCount(self, word: str) -> int:\n        count = Counter(word)\n        n = len(word)\n        dp = [1] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            if count[word[i-1]] == 1:\n                dp[i] = dp[i-1]\n            else:\n                j = i - 2\n                while j >= 0 and word[j] == word[i-1]:\n                    j -= 1\n                dp[i] = dp[j+1]\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "3587",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:\n        # Initialize DP table\n        dp = [[0 for _ in range(n)] for _ in range(k + 1)]\n        \n        # Fill the DP table\n        for day in range(1, k + 1):\n            for curr_city in range(n):\n                # Option 1: Stay in the current city\n                stay_points = stayScore[day - 1][curr_city]\n                max_points_stay = stay_points + dp[day - 1][curr_city]\n                \n                # Option 2: Move to another city\n                move_points = 0\n                for dest_city in range(n):\n                    if dest_city != curr_city:\n                        move_points = travelScore[curr_city][dest_city] + dp[day - 1][dest_city]\n                        max_points_stay = max(max_points_stay, move_points)\n                \n                # Update the DP table\n                dp[day][curr_city] = max_points_stay\n        \n        # Return the maximum points for all cities on the last day\n        return max(dp[k])"
        ]
    },
    {
        "question_id": "3626",
        "code_list": [
            "class Solution:\n    def smallestNumber(self, n: int, t: int) -> int:\n        def digit_product(num):\n            product = 1\n            while num > 0:\n                product *= num % 10\n                num //= 10\n            return product\n        \n        num = n\n        while True:\n            if digit_product(num) % t == 0:\n                return num\n            num += 1"
        ]
    },
    {
        "question_id": "3622",
        "code_list": [
            "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:\n        nums.sort()\n        left, max_freq = 0, 0\n        \n        for right in range(len(nums)):\n            numOperations -= (nums[right] - nums[right - 1]) * (right - left)\n            while numOperations < 0:\n                numOperations += nums[right] - nums[left]\n                left += 1\n            max_freq = max(max_freq, right - left + 1)\n        \n        return max_freq"
        ]
    },
    {
        "question_id": "3625",
        "code_list": [
            "class Solution:\n    def canAliceWin(self, n: int) -> bool:\n        # If n is less than 10, Alice cannot win because she will be forced to leave more than 0 stones for Bob\n        if n < 10:\n            return False\n        # If n is 10 or greater, Alice can always win by removing 10 stones on her first turn\n        return True"
        ]
    },
    {
        "question_id": "3591",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:\n        shift_distance = 0\n        for i in range(len(s)):\n            current_cost_next = abs(ord(t[i]) - ord(s[i])) % 26 * nextCost[ord(s[i]) - ord('a')]\n            current_cost_previous = abs(ord(t[i]) - ord(s[i])) % 26 * previousCost[ord(s[i]) - ord('a')]\n            shift_distance += min(current_cost_next, current_cost_previous)\n        return shift_distance"
        ]
    },
    {
        "question_id": "3647",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        \n        def can_be_zero(l, r):\n            return (prefix_sum[r + 1] - prefix_sum[l]) <= (r - l) * (r - l + 1) // 2\n        \n        dp = [0] * len(queries)\n        query_indices = sorted(range(len(queries)), key=lambda i: queries[i][1])\n        \n        for i in reversed(query_indices):\n            l, r = queries[i]\n            if can_be_zero(l, r):\n                dp[i] = 1\n            elif i + 1 < len(dp) and dp[i + 1]:\n                dp[i] = dp[i + 1] + 1\n        \n        return max(dp) if any(dp) else -1"
        ]
    },
    {
        "question_id": "3648",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:\n        n = len(fruits)\n        paths = [\n            [(i, j) for i in range(n) for j in range(i, n) if (i + j) % 2 == 0],  # Path for child starting at (0, 0)\n            [(i, j) for i in range(n) for j in range(n - 1 - i, -1, -1) if (i + j) % 2 == 0],  # Path for child starting at (0, n-1)\n            [(i, j) for i in range(n - 1, -1, -1) for j in range(i, n) if (i + j) % 2 == 0]   # Path for child starting at (n-1, 0)\n        ]\n        \n        collected_fruits = [0] * n\n        \n        for path in paths:\n            for i, j in path:\n                collected_fruits[i] += fruits[i][j]\n        \n        return sum(collected_fruits)"
        ]
    },
    {
        "question_id": "3676",
        "code_list": [
            "class Solution:\n    def smallestNumber(self, n: int) -> int:\n        # Find the position of the highest set bit\n        highest_bit = n.bit_length()\n        # Create a mask with all bits set to 1 up to the highest bit\n        mask = (1 << highest_bit) - 1\n        # Return the mask which will have all bits set from the start up to the highest bit\n        return mask"
        ]
    },
    {
        "question_id": "3594",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getLargestOutlier(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        # The two smallest numbers are the special numbers or one of them is the sum and the other is the outlier\n        special_sum = nums[0] + nums[1]\n        # Check if the third number is the outlier\n        if nums[2] != special_sum:\n            return max(nums[2], special_sum)\n        else:\n            # If the third number is the sum, check the rest of the numbers\n            for i in range(3, n):\n                if nums[i] != special_sum and nums[i] != nums[0] and nums[i] != nums[1]:\n                    return max(nums[i], special_sum)\n            # If no outlier found, the last number is the outlier\n            return nums[-1]"
        ]
    },
    {
        "question_id": "3651",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def constructTransformedArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        result = [0] * n\n        \n        for i in range(n):\n            if nums[i] > 0:\n                # Move nums[i] steps to the right\n                new_index = (i + nums[i]) % n\n                result[i] = nums[new_index]\n            elif nums[i] < 0:\n                # Move abs(nums[i]) steps to the left\n                new_index = (i - abs(nums[i])) % n\n                result[i] = nums[new_index]\n            else:\n                # If nums[i] == 0, set result[i] to nums[i]\n                result[i] = nums[i]\n        \n        return result"
        ]
    },
    {
        "question_id": "3681",
        "code_list": [
            "from itertools import combinations\n\nclass Solution:\n    def maxRectangleArea(self, points: List[List[int]]) -> int:\n        point_set = set(map(tuple, points))\n        max_area = -1\n        \n        for (x1, y1), (x2, y2) in combinations(points, 2):\n            # Check if the opposite corners exist\n            if (x1, y2) in point_set and (x2, y1) in point_set:\n                width = abs(x2 - x1)\n                height = abs(y2 - y1)\n                area = width * height\n                max_area = max(max_area, area)\n        \n        return max_area"
        ]
    },
    {
        "question_id": "3653",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSubarraySum(self, nums: List[int], k: int) -> int:\n        prefix_sum = 0\n        max_sum = float('-inf')\n        remainder_map = {0: 0}\n        current_sum = 0\n        \n        for i, num in enumerate(nums):\n            current_sum += num\n            remainder = current_sum % k\n            \n            if remainder in remainder_map:\n                subarray_length = (i + 1 - remainder_map[remainder]) % k\n                if subarray_length > 0:\n                    max_sum = max(max_sum, current_sum - remainder_map[remainder])\n            else:\n                remainder_map[remainder] = current_sum\n            \n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3621",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        operations = 0\n        while True:\n            valid_h = None\n            for num in nums:\n                if num > k:\n                    if valid_h is None:\n                        valid_h = num\n                    elif valid_h != num:\n                        return -1\n            if valid_h is None:\n                break\n            k = valid_h\n            operations += 1\n            for i, num in enumerate(nums):\n                if num > k:\n                    nums[i] = k\n        return operations"
        ]
    },
    {
        "question_id": "3649",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findMinimumTime(self, strength: List[int], K: int) -> int:\n        n = len(strength)\n        dp = [float('inf')] * (1 << n)\n        dp[0] = 0\n        \n        for mask in range(1 << n):\n            time = 0\n            x = 1\n            energy = 0\n            for i in range(n):\n                if mask & (1 << i):\n                    while energy < strength[i]:\n                        time += 1\n                        energy += x\n                        x += K\n                    energy = 0\n                    x = 1\n            dp[mask] = min(dp[mask], time + (mask.bit_count() - 1) * K)\n        \n        return dp[(1 << n) - 1]"
        ]
    },
    {
        "question_id": "3655",
        "code_list": [
            "from math import inf\n\nclass Solution:\n    def minOperations(self, n: int, m: int) -> int:\n        if n == m:\n            return 0\n        \n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        if is_prime(m):\n            return -1\n        \n        def dfs(num, target, cost, memo):\n            if num == target:\n                return cost\n            if is_prime(num):\n                return inf\n            if (num, cost) in memo:\n                return memo[(num, cost)]\n            \n            min_cost = inf\n            for i in range(len(str(num))):\n                for inc in [-1, 1]:\n                    new_num = num[:i] + str((int(num[i]) + inc) % 10) + num[i+1:]\n                    if new_num[0] != '0' and new_num[-1] != '9':\n                        new_cost = cost + int(new_num)\n                        result = dfs(int(new_num), target, new_cost, memo)\n                        min_cost = min(min_cost, result)\n            memo[(num, cost)] = min_cost\n            return min_cost\n        \n        return dfs(n, m, n, {})"
        ]
    },
    {
        "question_id": "3680",
        "code_list": [
            "from math import gcd\nfrom typing import List\n\nclass Solution:\n    def countComponents(self, nums: List[int], threshold: int) -> int:\n        def lcm(x, y):\n            return x * y // gcd(x, y)\n        \n        parent = list(range(len(nums)))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if lcm(nums[i], nums[j]) <= threshold:\n                    union(i, j)\n        \n        return sum(parent[i] == i for i in range(len(nums)))"
        ]
    },
    {
        "question_id": "3632",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def buttonWithLongestTime(self, events: List[List[int]]) -> int:\n        max_time = 0\n        max_index = -1\n        \n        prev_time = events[0][1]\n        for index, time in events:\n            if index < max_index:\n                continue\n            duration = time - prev_time\n            if duration > max_time or (duration == max_time and index < max_index):\n                max_time = duration\n                max_index = index\n            prev_time = time\n        \n        # Handle the case for the last button press\n        if len(events) > 1 and events[-1][0] >= max_index:\n            duration = events[-1][1] - prev_time\n            if duration > max_time or (duration == max_time and events[-1][0] < max_index):\n                max_index = events[-1][0]\n        \n        return max_index"
        ]
    },
    {
        "question_id": "3613",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxAmount(self, initialCurrency: str, pairs1: List[List[str]], rates1: List[float], pairs2: List[List[str]], rates2: List[float]) -> float:\n        # Build the conversion graph for day 1\n        graph1 = defaultdict(dict)\n        for pair, rate in zip(pairs1, rates1):\n            start, end = pair\n            graph1[start][end] = rate\n        \n        # Build the conversion graph for day 2\n        graph2 = defaultdict(dict)\n        for pair, rate in zip(pairs2, rates2):\n            start, end = pair\n            graph2[start][end] = rate\n        \n        # Function to find the maximum amount of initialCurrency after conversions on a specific day\n        def dfs(graph, currency, target, rate, visited):\n            if currency == target:\n                return rate\n            visited.add(currency)\n            max_rate = 0\n            for next_currency in graph[currency]:\n                if next_currency not in visited:\n                    max_rate = max(max_rate, dfs(graph, next_currency, target, rate * graph[currency][next_currency], visited))\n            visited.remove(currency)\n            return max_rate\n        \n        # Calculate the maximum amount after conversions on day 1\n        max_amount_day1 = dfs(graph1, initialCurrency, initialCurrency, 1.0, set())\n        \n        # Calculate the maximum amount after conversions on day 2\n        max_amount_day2 = dfs(graph2, initialCurrency, initialCurrency, 1.0, set())\n        \n        # Return the maximum amount achievable by combining conversions from both days\n        return max_amount_day1 * max_amount_day2"
        ]
    },
    {
        "question_id": "3686",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def beautifulSplits(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        count = 0\n        for i in range(1, n - 1):\n            left_sum = prefix_sum[i]\n            right_sum = prefix_sum[n] - prefix_sum[i + 1]\n            mid_sum = prefix_sum[i + 1] - prefix_sum[0]\n            if (left_sum == mid_sum or mid_sum == right_sum):\n                count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3638",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def makeStringGood(self, s: str) -> int:\n        char_count = Counter(s)\n        freq = sorted(char_count.values())\n        min_operations = 0\n        \n        for i in range(len(freq)):\n            while i > 0 and freq[i] == freq[i - 1]:\n                freq[i] -= 1\n                min_operations += 1\n            \n            if i > 0 and freq[i] == freq[i - 1] + 1:\n                freq[i] -= 1\n                min_operations += 1\n        \n        return min_operations"
        ]
    },
    {
        "question_id": "3656",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        operations = 0\n        while len(nums) >= 3:\n            # Remove the first 3 elements or all remaining elements if less than 3\n            nums = nums[3:] if len(nums) >= 3 else []\n            operations += 1\n        return operations"
        ]
    },
    {
        "question_id": "3620",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxDistinctElements(self, nums: List[int], k: int) -> int:\n        count = Counter(nums)\n        min_count = min(count.values())\n        \n        # If all numbers are the same, we can only have as many distinct elements as the value of k allows\n        if min_count == len(nums):\n            return min(len(nums), len(nums) + 2 * k)\n        \n        # Remove elements that can be made unique within the range [-k, k]\n        for num in list(count.keys()):\n            while count[num] > 0 and count[num] <= 2 * k + 1:\n                count[num] -= 1\n                del count[num]\n        \n        # Count remaining distinct elements\n        return len(count)"
        ]
    },
    {
        "question_id": "3690",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def minLength(self, s: str, numOps: int) -> int:\n        n = len(s)\n        max_gap = 0\n        \n        # Find the maximum gap between two different characters\n        left, right = 0, 0\n        while right < n:\n            if s[left] != s[right]:\n                max_gap = max(max_gap, right - left)\n                left = right\n            right += 1\n        \n        # If there are no gaps or we can cover the largest gap with numOps\n        if max_gap == 0 or numOps >= max_gap:\n            return 1\n        \n        # Calculate the minimum length after operations\n        min_length = float('inf')\n        for i in range(n):\n            left_count = s[:i].count('1') if s[i] == '0' else s[:i].count('0')\n            right_count = s[i+1:].count('1') if s[i] == '0' else s[i+1:].count('0')\n            current_length = (i + 1 - left_count) + (n - i - 1 - right_count)\n            if current_length <= numOps:\n                min_length = min(min_length, current_length)\n        \n        return n - min_length"
        ]
    },
    {
        "question_id": "3683",
        "code_list": [
            "from itertools import combinations\n\nclass Solution:\n    def answerString(self, word: str, numFriends: int) -> str:\n        n = len(word)\n        if numFriends == 1:\n            return word\n        \n        # Generate all possible splits\n        splits = []\n        for i in range(1, n):\n            for combo in combinations(range(1, n), i):\n                parts = [word[:combo[0]]]\n                for j in range(len(combo) - 1):\n                    parts.append(word[combo[j]:combo[j + 1]])\n                parts.append(word[combo[-1]:])\n                if len(parts) == numFriends:\n                    splits.append(parts)\n        \n        # Find the lexicographically largest string from the box\n        max_string = \"\"\n        for parts in splits:\n            box = set()\n            for perm in permutations(parts):\n                box.add(\"\".join(perm))\n            max_string = max(max_string, max(box))\n        \n        return max_string"
        ]
    },
    {
        "question_id": "3699",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def numberOfSubsequences(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        result = 0\n        \n        for i in range(1, len(nums) - 2):\n            for j in range(i + 2, len(nums)):\n                product = nums[i] * nums[j]\n                if product in count_map:\n                    result += count_map[product]\n                    count_map[product] += 1\n                else:\n                    count_map[product] = 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3682",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countGoodArrays(self, n: int, m: int, k: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(length, prev, consecutive):\n            if length == n:\n                return 1 if consecutive == k else 0\n            count = 0\n            for num in range(1, m + 1):\n                if num == prev:\n                    count += dp(length + 1, num, consecutive + 1)\n                else:\n                    count += dp(length + 1, num, 1)\n            return count % MOD\n        \n        return dp(1, 0, 0)"
        ]
    },
    {
        "question_id": "3685",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums) - 2):\n            if nums[i] + nums[i + 2] == nums[i + 1] / 2:\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "3659",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPathsWithXorValue(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        MOD = 10**9 + 7\n        \n        # Initialize DP table\n        dp = [[[0 for _ in range(k)] for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0]] = 1\n        \n        # Fill DP table\n        for i in range(m):\n            for j in range(n):\n                for val in range(k):\n                    if i > 0:\n                        dp[i][j][(val ^ grid[i][j])] += dp[i-1][j][val]\n                        dp[i][j][(val ^ grid[i][j])] %= MOD\n                    if j > 0:\n                        dp[i][j][(val ^ grid[i][j])] += dp[i][j-1][val]\n                        dp[i][j][(val ^ grid[i][j])] %= MOD\n        \n        return dp[m-1][n-1][k]"
        ]
    },
    {
        "question_id": "3657",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def checkValidCuts(self, n: int, rectangles: List[List[int]]) -> bool:\n        # Extract all unique x and y boundaries from the rectangles\n        x_boundaries = set()\n        y_boundaries = set()\n        for rect in rectangles:\n            x_boundaries.update([rect[0], rect[2]])\n            y_boundaries.update([rect[1], rect[3]])\n        \n        # Sort the boundaries\n        x_boundaries = sorted(x_boundaries)\n        y_boundaries = sorted(y_boundaries)\n        \n        # Check for possible horizontal cuts\n        for i in range(1, len(y_boundaries) - 1):\n            if self.is_valid_section(n, rectangles, y_boundaries[i-1], y_boundaries[i], y_boundaries[i+1]):\n                return True\n        \n        # Check for possible vertical cuts\n        for i in range(1, len(x_boundaries) - 1):\n            if self.is_valid_section(n, rectangles, x_boundaries[i-1], x_boundaries[i], x_boundaries[i+1]):\n                return True\n        \n        return False\n    \n    def is_valid_section(self, n: int, rectangles: List[List[int]], y1: int, y2: int, y3: int) -> bool:\n        # Count rectangles in each section\n        count1, count2, count3 = 0, 0, 0\n        for rect in rectangles:\n            if rect[1] < y1 and rect[3] < y2:\n                count1 += 1\n            elif y1 <= rect[1] < y2 and rect[3] < y3:\n                count2 += 1\n            elif y2 <= rect[1] < y3 and rect[3] < y3:\n                count3 += 1\n        \n        # Check if each section has at least one rectangle\n        return count1 > 0 and count2 > 0 and count3 > 0"
        ]
    },
    {
        "question_id": "3700",
        "code_list": [
            "from collections import Counter\nfrom math import comb\n\nclass Solution:\n    def subsequencesWithMiddleMode(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Count the frequency of each number in nums\n        freq = Counter(nums)\n        \n        # Find the number(s) with the highest frequency\n        max_freq = max(freq.values())\n        candidates = [num for num, count in freq.items() if count == max_freq]\n        \n        # If there's more than one number with the highest frequency, no valid subsequences can be formed\n        if len(candidates) > 1:\n            return 0\n        \n        # If there's only one candidate, calculate the number of valid subsequences\n        if len(candidates) == 1:\n            candidate = candidates[0]\n            # Count how many times the candidate appears in nums\n            candidate_count = freq[candidate]\n            # Calculate the number of ways to choose the other 2 elements from the remaining elements\n            other_count = sum(count for num, count in freq.items() if num != candidate)\n            # The number of valid subsequences is the product of combinations\n            return (comb(candidate_count, 2) * comb(other_count, 3)) % MOD\n        \n        # If there's no candidate with the highest frequency, calculate the number of valid subsequences\n        else:\n            # Count the frequencies of all other numbers\n            other_freqs = [count for num, count in freq.items() if num != candidate]\n            # Calculate the number of valid subsequences\n            total = 0\n            for i in range(len(other_freqs)):\n                for j in range(i + 1, len(other_freqs)):\n                    for k in range(j + 1, len(other_freqs)):\n                        for l in range(k + 1, len(other_freqs)):\n                            total += (other_freqs[i] * other_freqs[j] * other_freqs[k] * other_freqs[l]) % MOD\n            return total % MOD"
        ]
    },
    {
        "question_id": "3702",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\nfrom typing import List\n\nclass Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_len = 0\n        \n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        \n        def lcm_of_list(lst):\n            return reduce(lcm, lst)\n        \n        for i in range(n):\n            for j in range(i, n):\n                subarray = nums[i:j+1]\n                prod = 1\n                for num in subarray:\n                    prod *= num\n                sub_lcm = lcm_of_list(subarray)\n                sub_gcd = reduce(gcd, subarray)\n                if prod == sub_lcm * sub_gcd:\n                    max_len = max(max_len, j - i + 1)\n        \n        return max_len"
        ]
    },
    {
        "question_id": "3634",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def calculateScore(self, s: str) -> int:\n        # Create a dictionary to map each letter to its mirror letter\n        mirror_map = {chr(i): chr(219 - i) for i in range(ord('a'), ord('z') + 1)}\n        \n        # Initialize the score and a stack to keep track of marked indices\n        score = 0\n        stack = []\n        \n        for i, char in enumerate(s):\n            # Find the mirror character of the current character\n            mirror_char = mirror_map[char]\n            \n            # While the stack is not empty and the top element is not the mirror character\n            while stack and stack[-1] != mirror_char:\n                stack.pop()\n            \n            # If the stack is not empty, it means we found a valid pair\n            if stack:\n                # Calculate the score\n                score += i - stack.pop()\n            \n            # Push the current index onto the stack\n            stack.append(i)\n        \n        return score"
        ]
    },
    {
        "question_id": "3715",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        n = len(coins)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + coins[i][2]\n        \n        max_coins = 0\n        left, right = 0, k - 1\n        \n        while right < n:\n            current_sum = prefix_sum[right + 1] - prefix_sum[left]\n            max_coins = max(max_coins, current_sum)\n            \n            if coins[left][1] < coins[right + 1][0]:\n                left += 1\n                right += 1\n            else:\n                left += 1\n        \n        return max_coins"
        ]
    },
    {
        "question_id": "3562",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        # Sort intervals based on start time, and if equal, by weight in descending order\n        intervals.sort(key=lambda x: (x[0], -x[2]))\n        \n        # Priority queue to keep track of the top 4 intervals with the highest weights\n        pq = []\n        \n        for start, end, weight in intervals:\n            # Remove intervals that have ended before the current interval starts\n            while pq and pq[0][0] < start:\n                _, index = heapq.heappop(pq)\n            \n            # If we have more than 4 intervals, remove the one with the lowest weight\n            if len(pq) > 3:\n                heapq.heappop(pq)\n            \n            # Add the current interval's weight and its index to the priority queue\n            heapq.heappush(pq, (weight, len(intervals) - 1 - intervals.index([start, end, weight])))\n        \n        # Extract the indices of the top 4 intervals\n        result_indices = [len(intervals) - 1 - index for _, index in pq]\n        return sorted(result_indices)"
        ]
    },
    {
        "question_id": "3684",
        "code_list": [
            "class Solution:\n    def hasMatch(self, s: str, p: str) -> bool:\n        star_index = p.find('*')\n        if star_index == -1:\n            return s == p\n        \n        prefix = p[:star_index]\n        suffix = p[star_index + 1:]\n        \n        for i in range(len(s) - len(suffix) + 1):\n            if s[i:i+len(prefix)] == prefix and (suffix == '' or s[i+len(prefix):i+len(prefix)+len(suffix)] == suffix):\n                return True\n        \n        return False"
        ]
    },
    {
        "question_id": "3716",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestSubsequence(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        # dp[i][j] represents the length of the longest subsequence ending at index i with last difference j\n        dp = [[0] * 301 for _ in range(n)]\n        \n        # Initialize the first element's subsequences\n        for diff in range(301):\n            dp[0][diff] = 1\n        \n        max_length = 1\n        for i in range(1, n):\n            for prev_diff in range(301):\n                if dp[i-1][prev_diff] > 0:\n                    current_diff = abs(nums[i] - nums[i-1])\n                    if current_diff <= prev_diff:\n                        dp[i][current_diff] = max(dp[i][current_diff], dp[i-1][prev_diff] + 1)\n                        max_length = max(max_length, dp[i][current_diff])\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3688",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def maxSubarraySum(self, nums: List[int]) -> int:\n        prefix_sum = 0\n        max_sum = float('-inf')\n        zero_prefix_sum = 0\n        num_to_index = defaultdict(list)\n        \n        for i, num in enumerate(nums):\n            prefix_sum += num\n            num_to_index[num].append(i)\n            max_sum = max(max_sum, prefix_sum)\n            \n            # Calculate the maximum subarray sum if we remove all occurrences of num\n            if num != 0:\n                max_sum = max(max_sum, prefix_sum - zero_prefix_sum)\n            else:\n                max_sum = max(max_sum, prefix_sum - zero_prefix_sum, max([self.maxSubarraySumBetweenIndices(nums, indices) for indices in num_to_index[num]]))\n                \n            if num == 0:\n                zero_prefix_sum = prefix_sum\n        \n        return max_sum\n    \n    def maxSubarraySumBetweenIndices(self, nums: List[int], indices: List[int]) -> int:\n        max_sum = float('-inf')\n        current_sum = 0\n        for index in sorted(indices):\n            current_sum += nums[index]\n            max_sum = max(max_sum, current_sum)\n            if current_sum < 0:\n                current_sum = 0\n        return max_sum"
        ]
    }
]