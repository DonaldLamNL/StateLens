[
    {
        "question_id": "1873_A",
        "code_list": [
            "def main():\n    for _ in range(int(input())):\n        s = input()\n        if sorted(s) == list('abc'):\n            print(\"YES\")\n        elif 'a' in s[:2] and 'b' in s[1:] and 'c' in s[1:]:\n            print(\"YES\")\n        elif 'a' in s[:2] and 'c' in s[1:] and 'b' in s[1:]:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1873_B",
        "code_list": [
            "def main():\n    def max_product_with_one_increment(digits):\n        product = 1\n        zero_count = 0\n        min_digit = 10\n        for digit in digits:\n            product *= digit\n            if digit == 0:\n                zero_count += 1\n            elif digit < min_digit:\n                min_digit = digit\n        \n        # If there are no zeros, incrementing the smallest digit will maximize the product\n        if zero_count == 0:\n            return product * (min_digit + 1)\n        \n        # If there are zeros, we can use them to increase the product significantly\n        product_with_zero = product // min_digit * (min_digit + 1)\n        return max(product, product_with_zero)\n\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        digits = list(map(int, input().split()))\n        print(max_product_with_one_increment(digits))"
        ]
    },
    {
        "question_id": "1873_D",
        "code_list": [
            "def min_operations_to_remove_black_cells(t):\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        s = input()\n        operations = 0\n        i = 0\n        while i < n:\n            if s[i] == 'B':\n                start = i\n                while i < n and s[i] == 'B':\n                    i += 1\n                end = i - 1\n                segments = (end - start + k - 1) // k\n                operations += segments\n            else:\n                i += 1\n        results.append(operations)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    min_operations_to_remove_black_cells(int(input()))"
        ]
    },
    {
        "question_id": "1883_B",
        "code_list": [
            "from collections import Counter\n\ndef can_form_palindrome(s, k):\n    char_count = Counter(s)\n    odd_counts = sum(1 for count in char_count.values() if count % 2 != 0)\n    \n    # If more than 1 odd count and k is not sufficient to make it 1 or 0, return False\n    if odd_counts > 1 and k < odd_counts - 1:\n        return \"NO\"\n    # If odd counts are 1 or 0 and k is sufficient to make it 0, return True\n    elif odd_counts <= 1 and k >= odd_counts - 1:\n        return \"YES\"\n    else:\n        return \"YES\"\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        s = input().strip()\n        print(can_form_palindrome(s, k))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1883_C",
        "code_list": [
            "def min_operations_to_divisible_by_k(t):\n    def operations_needed(n, k, arr):\n        from collections import Counter\n        \n        # Count the frequency of each element in the array\n        freq = Counter(arr)\n        \n        # Initialize the count of operations needed for each remainder when divided by k\n        ops = [0] * k\n        \n        # Calculate the initial product modulo k\n        product_mod_k = 1\n        for num in arr:\n            product_mod_k = (product_mod_k * (num % k)) % k\n        \n        # If the product is already divisible by k, no operations are needed\n        if product_mod_k == 0:\n            return 0\n        \n        # Calculate the required operations\n        for i in range(1, k):\n            if (product_mod_k * pow(i, -1, k)) % k == 0:\n                return freq[i]\n        \n        # If no single element can make the product divisible by k, calculate the minimum operations\n        min_ops = float('inf')\n        for i in range(k):\n            if freq[i]:\n                new_product_mod_k = (product_mod_k * pow(i, -1, k)) % k\n                if new_product_mod_k == 0:\n                    min_ops = min(min_ops, freq[i])\n                else:\n                    for j in range(k):\n                        if (new_product_mod_k * pow(j, -1, k)) % k == 0:\n                            min_ops = min(min_ops, freq[i] + freq[j])\n        \n        return min_ops\n    \n    # Process each test case\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        results.append(operations_needed(n, k, arr))\n    \n    # Print the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    t = int(input())\n    min_operations_to_divisible_by_k(t)"
        ]
    },
    {
        "question_id": "1899_A",
        "code_list": [
            "def determine_winner(n):\n    t = int(n)\n    if t % 3 == 0:\n        return \"First\"\n    elif t % 3 == 1:\n        # If n % 3 == 1, Vanya can only make it (n+1) % 3 == 2 or (n-2) % 3 == 0\n        # Vova can always make it (n-1) % 3 == 2, forcing Vanya to lose\n        return \"Second\"\n    else:  # t % 3 == 2\n        # If n % 3 == 2, Vanya can make it (n-1) % 3 == 1 or (n+2) % 3 == 0\n        # Vova can only make it (n+1) % 3 == 0, forcing Vanya to win\n        return \"First\"\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        print(determine_winner(n))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_B",
        "code_list": [
            "def max_weight_difference(n, weights):\n    # Calculate prefix sums\n    prefix_sums = [0]\n    for weight in weights:\n        prefix_sums.append(prefix_sums[-1] + weight)\n    \n    max_diff = 0\n    \n    # Iterate over all possible values of k\n    for k in range(1, n + 1):\n        if n % k == 0:\n            # Calculate the maximum and minimum possible weights for trucks\n            max_weight = 0\n            min_weight = float('inf')\n            for i in range(k):\n                start = i * (n // k)\n                end = start + (n // k)\n                current_weight = prefix_sums[end] - prefix_sums[start]\n                max_weight = max(max_weight, current_weight)\n                min_weight = min(min_weight, current_weight)\n            \n            # Update the maximum difference\n            max_diff = max(max_diff, max_weight - min_weight)\n    \n    return max_diff\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        weights = list(map(int, data[index:index + n]))\n        index += n\n        result = max_weight_difference(n, weights)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_C",
        "code_list": [
            "def max_alternating_subarray_sum(arr):\n    n = len(arr)\n    max_sum = float('-inf')\n    \n    # Initialize variables to keep track of the current subarray sum\n    current_sum_odd = 0\n    current_sum_even = 0\n    \n    for i in range(n):\n        if i % 2 == 0:\n            # If the index is even, we are looking for an odd number\n            if arr[i] % 2 == 1:\n                current_sum_odd += arr[i]\n            else:\n                # If the current number is even, start a new subarray from the next element\n                current_sum_odd = arr[i] if i + 1 < n and arr[i + 1] % 2 == 1 else 0\n        else:\n            # If the index is odd, we are looking for an even number\n            if arr[i] % 2 == 0:\n                current_sum_even += arr[i]\n            else:\n                # If the current number is odd, start a new subarray from the next element\n                current_sum_even = arr[i] if i + 1 < n and arr[i + 1] % 2 == 0 else 0\n        \n        # Update the maximum sum found so far\n        max_sum = max(max_sum, current_sum_odd, current_sum_even)\n    \n    return max_sum\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        arr = list(map(int, data[index:index + n]))\n        index += n\n        results.append(max_alternating_subarray_sum(arr))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "1899_D",
        "code_list": [
            "from collections import Counter\n\ndef count_equal_combinations(t):\n    results = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        counter = Counter(a)\n        total_pairs = 0\n        \n        for val in counter.values():\n            # Calculate the number of pairs for each unique value in the counter\n            total_pairs += val * (val - 1) // 2\n        \n        results.append(total_pairs)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    t = int(input().strip())\n    count_equal_combinations(t)"
        ]
    },
    {
        "question_id": "2727",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        return sum(int(detail[11:13]) > 60 for detail in details)"
        ]
    },
    {
        "question_id": "2728",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        score = 0\n        while nums:\n            max_removed = 0\n            temp_nums = []\n            for row in nums:\n                if row:\n                    max_removed = max(max_removed, row.pop())\n                else:\n                    continue\n                temp_nums.append(row)\n            score += max_removed\n            nums = [row for row in temp_nums if row]\n        return score"
        ]
    },
    {
        "question_id": "2730",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        prefix_or, suffix_or = 0, sum(nums)\n        max_or = 0\n        \n        for i, num in enumerate(nums):\n            suffix_or -= num\n            max_or = max(max_or, (num << k) | prefix_or | suffix_or)\n            prefix_or |= num\n        \n        return max_or"
        ]
    },
    {
        "question_id": "2754",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        # Remove zeros as they do not contribute to the product\n        nums = [num for num in nums if num != 0]\n        \n        # If there are no positive numbers and at most one negative number, the result is 0 or the single negative number\n        if len(nums) == 0:\n            return 0\n        elif len(nums) == 1:\n            return nums[0]\n        \n        # Separate positive and negative numbers\n        pos_nums = [num for num in nums if num > 0]\n        neg_nums = [num for num in nums if num < 0]\n        \n        # Sort negative numbers to potentially remove the smallest (most negative) number if there's an odd count of negatives\n        neg_nums.sort()\n        \n        # If there's an odd number of negative numbers, remove the smallest one to maximize the product\n        if len(neg_nums) % 2 == 1:\n            neg_nums.pop(0)\n        \n        # Calculate the product of remaining positive and negative numbers\n        strength = 1\n        for num in pos_nums + neg_nums:\n            strength *= num\n        \n        return strength"
        ]
    },
    {
        "question_id": "2755",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        dp = [float('inf')] * (len(s) + 1)\n        dp[-1] = 0\n        \n        for i in range(len(s) - 1, -1, -1):\n            dp[i] = dp[i + 1] + 1\n            for word in dictionary:\n                if s.startswith(word, i):\n                    dp[i] = min(dp[i], dp[i + len(word)])\n        \n        return dp[0]"
        ]
    },
    {
        "question_id": "2756",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        min1, min2 = float('inf'), float('inf')\n        for price in prices:\n            if price < min1:\n                min2 = min1\n                min1 = price\n            elif price < min2:\n                min2 = price\n        total_cost = min1 + min2\n        return money - total_cost if total_cost <= money else money"
        ]
    },
    {
        "question_id": "2757",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def digit_sum(n, tight, remaining_sum):\n            if len(n) == 0:\n                return 1 if remaining_sum == 0 else 0\n            if tight == 0 and remaining_sum < 0:\n                return 0\n            \n            ans = 0\n            upper_bound = int(n[0]) if tight else 9\n            for d in range(upper_bound + 1):\n                new_tight = tight if d == upper_bound else 0\n                ans += digit_sum(n[1:], new_tight, remaining_sum - d)\n            return ans % MOD\n        \n        def count_up_to(n, min_sum, max_sum):\n            total = 0\n            for s in range(min_sum, max_sum + 1):\n                total += digit_sum(n, 1, s)\n            return total % MOD\n        \n        num1_str = str(int(num1) - 1)\n        num2_str = str(int(num2) + 1)\n        \n        return (count_up_to(num2_str, min_sum, max_sum) - count_up_to(num1_str, min_sum, max_sum) + \n                (digit_sum(num2_str, 1, min_sum) if int(num1) <= int(num2) else 0)) % MOD"
        ]
    },
    {
        "question_id": "2777",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        def count_distinct(arr):\n            return len(set(arr))\n        \n        n = len(nums)\n        result = []\n        for i in range(n):\n            prefix_distinct = count_distinct(nums[:i+1])\n            suffix_distinct = count_distinct(nums[i+1:])\n            result.append(prefix_distinct - suffix_distinct)\n        return result"
        ]
    },
    {
        "question_id": "2779",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        nums = [0] * n\n        answer = []\n        count = 0\n        \n        for index, color in queries:\n            if index > 0 and nums[index - 1] == color and nums[index - 1] != 0:\n                count -= 1\n            if index < n - 1 and nums[index + 1] == color and nums[index + 1] != 0:\n                count -= 1\n            if nums[index] != 0:\n                if index > 0 and nums[index] == nums[index - 1]:\n                    count -= 1\n                if index < n - 1 and nums[index] == nums[index + 1]:\n                    count -= 1\n            nums[index] = color\n            if index > 0 and nums[index - 1] == nums[index] and nums[index] != 0:\n                count += 1\n            if index < n - 1 and nums[index + 1] == nums[index] and nums[index] != 0:\n                count += 1\n            answer.append(count)\n        \n        return answer"
        ]
    },
    {
        "question_id": "2784",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        nums.sort()\n        mod = 10**9 + 7\n        res = 0\n        prefix_sum = 0\n        \n        for num in nums:\n            # Calculate the power of the current number as a single group\n            res = (res + num**2 * (num % mod)) % mod\n            # Update the prefix sum to include the current number\n            prefix_sum = (prefix_sum * 2 + num) % mod\n        \n        return res"
        ]
    },
    {
        "question_id": "2785",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def semiOrderedPermutation(self, nums: List[int]) -> int:\n        n = len(nums)\n        index_1 = nums.index(1)\n        index_n = nums.index(n)\n        count = 0\n        \n        if index_1 < index_n:\n            # 1 is before n, so we only need to move n to the end\n            count += index_n + (n - 1 - index_1 - 1)\n        else:\n            # 1 is after n, so we need to move 1 to the beginning and n to the end\n            count += index_1 + (n - 1 - index_n) + (index_1 - index_n - 1)\n        \n        return count"
        ]
    },
    {
        "question_id": "2786",
        "code_list": [
            "from itertools import groupby\n\nclass Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        max_length = 0\n        for i, (key, group) in enumerate(groupby(s)):\n            length = sum(1 for _ in group)\n            if length > 1:\n                start = i - length + 2\n                max_length = max(max_length, length + next((len(list(g)) for k, g in groupby(s[start:]) if k == key), 0) - 1)\n            max_length = max(max_length, length)\n        return max_length"
        ]
    },
    {
        "question_id": "2791",
        "code_list": [
            "class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        visited = set()\n        step = 0\n        current_position = 0\n        \n        while True:\n            if current_position + 1 in visited:\n                break\n            visited.add(current_position + 1)\n            step += 1\n            current_position = (current_position + step * k) % n\n        \n        return sorted([i + 1 for i in range(n) if i + 1 not in visited])"
        ]
    },
    {
        "question_id": "2792",
        "code_list": [
            "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        # The key observation is that the XOR operation is its own inverse.\n        # Therefore, we can start with any value for original[0] (either 0 or 1)\n        # and check if the derived array can be formed.\n        # If the sum of all elements in derived is even, then a valid original array exists.\n        return sum(derived) % 2 == 0"
        ]
    },
    {
        "question_id": "2800",
        "code_list": [
            "class Solution:\n    def minLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            if char == 'B' and stack and stack[-1] == 'A':\n                stack.pop()\n            elif char == 'D' and stack and stack[-1] == 'C':\n                stack.pop()\n            else:\n                stack.append(char)\n        return len(stack)"
        ]
    },
    {
        "question_id": "2802",
        "code_list": [
            "class Solution:\n    def punishmentNumber(self, n: int) -> int:\n        def is_valid_partition(num_str, target):\n            if not num_str:\n                return target == 0\n            \n            for i in range(1, len(num_str) + 1):\n                current_num = int(num_str[:i])\n                if target >= current_num and (i == len(num_str) or num_str[i] != '0' or current_num == 0):\n                    if is_valid_partition(num_str[i:], target - current_num):\n                        return True\n            return False\n        \n        punishment_sum = 0\n        for i in range(1, n + 1):\n            square_str = str(i * i)\n            if is_valid_partition(square_str, i):\n                punishment_sum += i * i\n        return punishment_sum"
        ]
    },
    {
        "question_id": "2808",
        "code_list": [
            "from typing import List\nimport functools\n\nclass Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        @functools.lru_cache(None)\n        def dp(index, remaining):\n            if remaining <= 0:\n                return 0\n            if index == len(cost):\n                return float('inf')\n            # Option 1: Use the paid painter to paint the current wall\n            paid = cost[index] + dp(index + 1, remaining - time[index] - 1)\n            # Option 2: Use the free painter to skip the current wall\n            free = dp(index + 1, remaining)\n            return min(paid, free)\n        \n        return dp(0, len(cost))"
        ]
    },
    {
        "question_id": "2810",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minCost(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        # Initialize the result with the cost of buying all chocolates without any operations\n        res = sum(nums)\n        # Array to store the minimum cost to collect each type of chocolate after k operations\n        min_cost = [float('inf')] * n\n        \n        # Iterate over the number of operations\n        for k in range(1, n):\n            # Calculate the cost of collecting each type of chocolate after k operations\n            for i in range(n):\n                min_cost[i] = min(min_cost[i], nums[(i + k) % n])\n            # Update the result with the minimum cost considering k operations\n            res = min(res, sum(min_cost) + k * x)\n        \n        return res"
        ]
    },
    {
        "question_id": "2811",
        "code_list": [
            "class Solution:\n    def minimumSum(self, n: int, k: int) -> int:\n        if k <= 2:\n            return n * (n + 1) // 2\n        \n        # Initialize the result array with the first n natural numbers\n        result = list(range(1, n + 1))\n        i, j = n, 1\n        \n        # Remove elements from the array if they form a valid pair with any existing element\n        while i < len(result):\n            if any(result[i] + result[j] == k for j in range(i)):\n                result.pop(i)\n                i -= 1\n            i += 1\n            if i >= len(result):\n                break\n        \n        # If we still need more elements to reach n, add the next smallest numbers that don't form a valid pair\n        while len(result) < n:\n            candidate = len(result) + 1\n            if all(candidate + x != k for x in result):\n                result.append(candidate)\n        \n        return sum(result)"
        ]
    },
    {
        "question_id": "2812",
        "code_list": [
            "class Solution:\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        return num + t * 2"
        ]
    },
    {
        "question_id": "2816",
        "code_list": [
            "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        n = len(s)\n        result = list(s)\n        for i in range(n // 2):\n            if s[i] != s[n - i - 1]:\n                result[i] = result[n - i - 1] = min(s[i], s[n - i - 1])\n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2817",
        "code_list": [
            "class Solution:\n    def minimumCost(self, s: str) -> int:\n        n = len(s)\n        cost = 0\n        \n        # Iterate through the string to find the minimum cost\n        for i in range(1, n):\n            if s[i] != s[i-1]:\n                # Calculate the cost of inverting up to index i-1\n                cost += min(i, n - i)\n        \n        return cost"
        ]
    },
    {
        "question_id": "2819",
        "code_list": [
            "class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        return num.rstrip('0')"
        ]
    },
    {
        "question_id": "2824",
        "code_list": [
            "class Solution:\n    def isFascinating(self, n: int) -> bool:\n        concatenated_str = str(n) + str(2 * n) + str(3 * n)\n        return len(concatenated_str) == 9 and set(concatenated_str) == {'1', '2', '3', '4', '5', '6', '7', '8', '9'}"
        ]
    },
    {
        "question_id": "2825",
        "code_list": [
            "class Solution:\n    def minimizedStringLength(self, s: str) -> int:\n        unique_chars = set(s)\n        return len(unique_chars)"
        ]
    },
    {
        "question_id": "2827",
        "code_list": [
            "from math import gcd\nfrom typing import List\n\nclass Solution:\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\n        if len(nums) == 1:\n            return True\n        \n        max_num = max(nums)\n        sieve = [True] * (max_num + 1)\n        primes = []\n        \n        for i in range(2, int(max_num**0.5) + 1):\n            if sieve[i]:\n                for j in range(i*i, max_num + 1, i):\n                    sieve[j] = False\n        \n        for i in range(2, max_num + 1):\n            if sieve[i] and max_num % i == 0:\n                primes.append(i)\n        \n        parent = {i: i for i in nums}\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n        \n        for num in nums:\n            factors = set()\n            for prime in primes:\n                if prime * prime > num:\n                    break\n                if num % prime == 0:\n                    factors.add(prime)\n                    while num % prime == 0:\n                        num //= prime\n            if num > 1:\n                factors.add(num)\n            for factor in factors:\n                union(num, factor)\n        \n        return len(set(find(num) for num in nums)) == 1"
        ]
    },
    {
        "question_id": "2828",
        "code_list": [
            "class Solution:\n    def smallestString(self, s: str) -> str:\n        n = len(s)\n        i = 0\n        # Skip all 'a's from the start\n        while i < n and s[i] == 'a':\n            i += 1\n        \n        # If the whole string is 'a's, change the last 'a' to 'z'\n        if i == n:\n            return s[:-1] + 'z'\n        \n        # Replace characters until we encounter a non-'a' character\n        while i < n and s[i] == 'a':\n            s = s[:i] + chr(ord(s[i]) - 1) + s[i+1:]\n            i += 1\n        \n        # Append remaining part of the string\n        return s"
        ]
    },
    {
        "question_id": "2831",
        "code_list": [
            "from math import gcd\nfrom typing import List\n\nclass Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            first_digit = int(str(nums[i])[0])\n            for j in range(i + 1, len(nums)):\n                last_digit = nums[j] % 10\n                if gcd(first_digit, last_digit) == 1:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2832",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        max_length = 0\n        count_map = defaultdict(int)\n        left = 0\n        \n        for right in range(len(nums)):\n            count_map[nums[right]] += 1\n            current_max_count = count_map[nums[right]]\n            max_length = max(max_length, current_max_count)\n            \n            if (right - left + 1) - current_max_count > k:\n                count_map[nums[left]] -= 1\n                left += 1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2833",
        "code_list": [
            "from sortedcontainers import SortedList\n\nclass Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # Sort queries to process them in order\n        query_sorted = sorted((q, i) for i, q in enumerate(queries))\n        logs.sort(key=lambda log: log[1])\n        \n        result = [0] * len(queries)\n        server_status = SortedList()\n        current_time = 0\n        \n        for query_time, original_index in query_sorted:\n            # Add all logs up to the current query time\n            while current_time < query_time:\n                _, server_id = logs[bisect_right(logs, [current_time, 0]) - 1]\n                server_status.add(server_id)\n                current_time += 1\n            \n            # Remove all logs before the query time - x\n            while server_status and logs[bisect_left(logs, [query_time - x, 0]) - 1][1] < query_time - x:\n                server_status.remove(logs[bisect_left(logs, [query_time - x, 0]) - 1][0])\n            \n            # Calculate the number of servers that did not receive any requests\n            result[original_index] = n - len(server_status)\n        \n        return result"
        ]
    },
    {
        "question_id": "2834",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        positions = set(nums)\n        for start, end in zip(moveFrom, moveTo):\n            positions.remove(start)\n            positions.add(end)\n        return sorted(positions)"
        ]
    },
    {
        "question_id": "2837",
        "code_list": [
            "class Solution:\n    def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n        for ops in range(61):\n            target = num1 - ops * num2\n            if target <= 0:\n                break\n            count_set_bits = bin(target).count('1')\n            if count_set_bits <= ops and ops <= target:\n                return ops\n        return -1"
        ]
    },
    {
        "question_id": "2839",
        "code_list": [
            "from typing import List\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        # Pair up nums1 and nums2 values and sort them based on nums2 in descending order\n        paired_values = sorted(zip(nums2, nums1), reverse=True)\n        max_heap = []\n        result = [-1] * len(queries)\n        query_index = [(y, x, i) for i, (x, y) in enumerate(queries)]\n        query_index.sort()\n        \n        # Process each query\n        for y_q, x_q, i in query_index:\n            # Add valid pairs from paired_values to max_heap until the condition fails\n            while paired_values and paired_values[-1][0] >= y_q:\n                _, num1 = paired_values.pop()\n                heappush(max_heap, (-num1 - paired_values[-1][0], num1))\n            \n            # Remove invalid pairs from max_heap\n            while max_heap and -max_heap[0][0] < x_q:\n                heappop(max_heap)\n            \n            # If max_heap is not empty, update result for the current query\n            if max_heap:\n                result[i] = -max_heap[0][0]\n        \n        return result"
        ]
    },
    {
        "question_id": "2844",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n = len(nums)\n        return sum(num * num for i, num in enumerate(nums, start=1) if n % i == 0)"
        ]
    },
    {
        "question_id": "2845",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        nums.sort()\n        min_partition_value = float('inf')\n        for i in range(1, len(nums)):\n            min_partition_value = min(min_partition_value, nums[i] - nums[i - 1])\n        return min_partition_value"
        ]
    },
    {
        "question_id": "2847",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        seen = set()\n        pairs_count = 0\n        for word in words:\n            reversed_word = word[::-1]\n            if reversed_word in seen:\n                pairs_count += 1\n            else:\n                seen.add(word)\n        return pairs_count"
        ]
    },
    {
        "question_id": "2848",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(index, mask):\n            if index == len(nums):\n                return 1\n            count = 0\n            for i in range(len(nums)):\n                if mask & (1 << i) == 0 and (nums[i] % nums[index] == 0 or nums[index] % nums[i] == 0):\n                    count += dfs(index + 1, mask | (1 << i))\n                    count %= MOD\n            return count\n        \n        return dfs(0, 0)"
        ]
    },
    {
        "question_id": "2849",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumImbalanceNumbers(self, nums: List[int]) -> int:\n        from sortedcontainers import SortedList\n        \n        def imbalance_count(subarr):\n            sarr = SortedList(subarr)\n            return sum(1 for i in range(len(sarr) - 1) if sarr[i + 1] - sarr[i] > 1)\n        \n        total_imbalance = 0\n        for start in range(len(nums)):\n            for end in range(start, len(nums)):\n                total_imbalance += imbalance_count(nums[start:end + 1])\n        return total_imbalance"
        ]
    },
    {
        "question_id": "2850",
        "code_list": [
            "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        # If x != y, we can only use at most min(x, y) pairs of \"AA\" and \"BB\"\n        # And we can add all \"AB\" in between or at the end\n        max_length = 2 * (min(x, y) * 2 + z)\n        # If x == y, we can use all \"AA\" and \"BB\" pairs, but we need to ensure no \"AAA\" or \"BBB\"\n        if x == y:\n            max_length += 2\n        return max_length"
        ]
    },
    {
        "question_id": "2854",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def minimizeConcatenatedLength(self, words: List[str]) -> int:\n        @lru_cache(None)\n        def dp(i, start_char, end_char):\n            if i == len(words):\n                return 0\n            a = len(words[i])\n            if words[i][0] == end_char:\n                a -= 1\n            b = len(words[i])\n            if words[i][-1] == start_char:\n                b -= 1\n            return min(a + dp(i + 1, words[i][-1], end_char), b + dp(i + 1, start_char, words[i][0]))\n        \n        return len(words[0]) + dp(1, words[0][-1], words[0][0])"
        ]
    },
    {
        "question_id": "2855",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [-1] * n\n        dp[0] = 0\n        \n        for i in range(n):\n            if dp[i] == -1:\n                continue\n            for j in range(i + 1, n):\n                if -target <= nums[j] - nums[i] <= target:\n                    dp[j] = max(dp[j], dp[i] + 1)\n        \n        return dp[n - 1]"
        ]
    },
    {
        "question_id": "2856",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        from collections import Counter\n        \n        # Get the number of distinct elements in the whole array\n        total_distinct = len(set(nums))\n        \n        # Helper function to get the number of distinct elements in a subarray\n        def distinct_count(start: int) -> int:\n            return len(set(nums[start:end+1]))\n        \n        n = len(nums)\n        count = 0\n        \n        # Iterate over all possible starting points of the subarray\n        for start in range(n):\n            end = start\n            while end < n and distinct_count(start) == total_distinct:\n                end += 1\n            count += end - start\n        \n        return count"
        ]
    },
    {
        "question_id": "2857",
        "code_list": [
            "class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        distance = 0\n        while mainTank >= 5:\n            distance += 50  # Travel 50km using 5 liters\n            mainTank -= 5  # Main tank uses 5 liters\n            if additionalTank > 0:\n                mainTank += 1  # Transfer 1 liter from additional tank\n                additionalTank -= 1\n            else:\n                break\n        distance += mainTank * 10  # Travel with remaining fuel in main tank\n        return distance"
        ]
    },
    {
        "question_id": "2866",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        max_length = 0\n        start_index = -1\n        \n        for i in range(len(nums)):\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                if start_index == -1:\n                    start_index = i\n                current_length = 1\n                for j in range(i + 1, len(nums)):\n                    if nums[j] <= threshold and nums[j] % 2 != nums[j - 1] % 2:\n                        current_length += 1\n                    else:\n                        break\n                max_length = max(max_length, current_length)\n                if current_length < 2:\n                    start_index = -1\n            else:\n                start_index = -1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2867",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        prev_one = -1\n        count = 1\n        \n        for i, num in enumerate(nums):\n            if num == 1:\n                if prev_one != -1:\n                    count *= (i - prev_one)\n                    count %= MOD\n                prev_one = i\n        \n        return count if prev_one != -1 else 0"
        ]
    },
    {
        "question_id": "2868",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        left = 0\n        result = 0\n        max_deque = deque()\n        min_deque = deque()\n        \n        for right in range(len(nums)):\n            # Maintain max_deque\n            while max_deque and nums[max_deque[-1]] < nums[right]:\n                max_deque.pop()\n            max_deque.append(right)\n            \n            # Maintain min_deque\n            while min_deque and nums[min_deque[-1]] > nums[right]:\n                min_deque.pop()\n            min_deque.append(right)\n            \n            # Shrink the window from the left if the condition is violated\n            while nums[max_deque[0]] - nums[min_deque[0]] > 2:\n                if max_deque[0] == left:\n                    max_deque.popleft()\n                if min_deque[0] == left:\n                    min_deque.popleft()\n                left += 1\n            \n            # Add valid subarrays ending at 'right'\n            result += right - left + 1\n        \n        return result"
        ]
    },
    {
        "question_id": "2869",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        dp1, dp2 = [1] * n, [1] * n\n        \n        for i in range(1, n):\n            if nums1[i] >= nums1[i-1]:\n                dp1[i] = max(dp1[i], dp1[i-1] + 1)\n            if nums1[i] >= nums2[i-1]:\n                dp1[i] = max(dp1[i], dp2[i-1] + 1)\n            \n            if nums2[i] >= nums2[i-1]:\n                dp2[i] = max(dp2[i], dp2[i-1] + 1)\n            if nums2[i] >= nums1[i-1]:\n                dp2[i] = max(dp2[i], dp1[i-1] + 1)\n        \n        return max(max(dp1), max(dp2))"
        ]
    },
    {
        "question_id": "2870",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        max_length = -1\n        start = 0\n        \n        for end in range(1, len(nums)):\n            if nums[end] == nums[end - 1] + 1:\n                if end - start == 1 or (end - start > 1 and nums[end - 2] == nums[end]):\n                    max_length = max(max_length, end - start + 1)\n                else:\n                    start = end - 1\n            else:\n                start = end\n        \n        return max_length"
        ]
    },
    {
        "question_id": "2872",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        n = len(nums)\n        i = n - 2\n        max_val = nums[-1]\n        \n        while i >= 0:\n            if nums[i] <= nums[i + 1]:\n                nums[i + 1] += nums[i]\n                max_val = max(max_val, nums[i + 1])\n            else:\n                max_val = max(max_val, nums[i])\n            i -= 1\n        \n        return max_val"
        ]
    },
    {
        "question_id": "2873",
        "code_list": [
            "from math import sqrt\n\nclass Solution:\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(sqrt(num)) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        primes = [i for i in range(2, n) if is_prime(i)]\n        result = []\n        seen = set()\n        \n        for prime in primes:\n            complement = n - prime\n            if complement in primes and (complement, prime) not in seen:\n                result.append([prime, complement])\n                seen.add((prime, complement))\n        \n        return sorted(result)"
        ]
    },
    {
        "question_id": "2876",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        return sum(1 for hour in hours if hour >= target)"
        ]
    },
    {
        "question_id": "2877",
        "code_list": [
            "from itertools import permutations\n\nclass Solution:\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        def merge(x, y):\n            # Find the longest common suffix of x and the longest common prefix of y\n            for i in range(len(x), -1, -1):\n                if x.endswith(y[:i]):\n                    return x + y[i:]\n            return x + y\n        \n        # Generate all possible concatenations of a, b, and c\n        candidates = [merge(merge(a, b), c), merge(merge(a, c), b), merge(merge(b, a), c), \n                      merge(merge(b, c), a), merge(merge(c, a), b), merge(merge(c, b), a)]\n        \n        # Sort candidates by length, then lexicographically\n        candidates.sort(key=lambda x: (len(x), x))\n        \n        return candidates[0]"
        ]
    },
    {
        "question_id": "2878",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        n = len(nums)\n        operations = [0] * (n + 1)\n        \n        for i in range(n):\n            operations[i] -= nums[i]\n            if i + k <= n:\n                operations[i + k] += nums[i]\n            \n            if operations[i] < 0:\n                return False\n            \n            nums[i] += operations[i]\n        \n        return True"
        ]
    },
    {
        "question_id": "2879",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def minimumChanges(self, s: str, k: int) -> int:\n        @lru_cache(None)\n        def is_semi_palindrome(sub: str) -> bool:\n            n = len(sub)\n            for d in range(1, n // 2 + 1):\n                if n % d != 0:\n                    continue\n                palindrome = True\n                for i in range(d):\n                    for j in range(i, n, d):\n                        if sub[i] != sub[j]:\n                            palindrome = False\n                            break\n                    if not palindrome:\n                        break\n                if palindrome:\n                    return True\n            return False\n        \n        @lru_cache(None)\n        def dp(index: int, remaining_k: int) -> int:\n            if remaining_k == 1:\n                return 0 if is_semi_palindrome(s[index:]) else float('inf')\n            if index == len(s):\n                return float('inf')\n            min_changes = float('inf')\n            for split_index in range(index + 1, len(s)):\n                changes = sum(c1 != c2 for c1, c2 in zip(s[index:split_index], reversed(s[index:split_index])))\n                min_changes = min(min_changes, changes + dp(split_index, remaining_k - 1))\n            return min_changes\n        \n        return dp(0, k)"
        ]
    },
    {
        "question_id": "2881",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        result = []\n        for word in words:\n            # Split the word by the separator\n            split_words = word.split(separator)\n            # Extend the result list with non-empty split parts\n            result.extend([part for part in split_words if part])\n        return result"
        ]
    },
    {
        "question_id": "2882",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def numberOfWays(self, n: int, x: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(target, max_base):\n            if target == 0:\n                return 1\n            if target < 0 or max_base == 0:\n                return 0\n            \n            # Include max_base in the sum\n            include = dp(target - max_base**x, max_base - 1)\n            # Exclude max_base from the sum\n            exclude = dp(target, max_base - 1)\n            \n            return (include + exclude) % MOD\n        \n        return dp(n, int(n**(1/x)) + 1)"
        ]
    },
    {
        "question_id": "2883",
        "code_list": [
            "class Solution:\n    def minimumBeautifulSubstrings(self, s: str) -> int:\n        powers_of_5 = {bin(5**i)[2:] for i in range(16)}\n        n = len(s)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if s[j:i] in powers_of_5 and s[j] != '0':\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[n] if dp[n] != float('inf') else -1"
        ]
    },
    {
        "question_id": "2884",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        max_length = 0\n        last_forbidden_end = -1\n        \n        for i in range(len(word)):\n            for length in range(1, 11):  # forbidden[i] length <= 10\n                if i + length > len(word):\n                    break\n                substring = word[i:i+length]\n                if substring in forbidden:\n                    last_forbidden_end = max(last_forbidden_end, i + length - 1)\n                    break\n            \n            max_length = max(max_length, min(i, last_forbidden_end))\n        \n        return len(word) - max_length"
        ]
    },
    {
        "question_id": "2886",
        "code_list": [
            "class Solution:\n    def finalString(self, s: str) -> str:\n        result = []\n        for char in s:\n            if char == 'i':\n                result.reverse()\n            else:\n                result.append(char)\n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2887",
        "code_list": [
            "class Solution:\n    def sortVowels(self, s: str) -> str:\n        vowels = \"aeiouAEIOU\"\n        vowel_chars = [c for c in s if c in vowels]\n        vowel_chars.sort(key=lambda x: ord(x))\n        \n        result = []\n        vowel_index = 0\n        \n        for char in s:\n            if char in vowels:\n                result.append(vowel_chars[vowel_index])\n                vowel_index += 1\n            else:\n                result.append(char)\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "2888",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumIndex(self, nums: List[int]) -> int:\n        total_count = Counter(nums)\n        dominant_element = max(total_count, key=total_count.get)\n        left_count = 0\n        \n        for i, num in enumerate(nums):\n            left_count += 1 if num == dominant_element else 0\n            right_count = total_count[dominant_element] - left_count\n            if left_count * 2 > i + 1 and right_count * 2 > len(nums) - i - 1:\n                return i\n        \n        return -1"
        ]
    },
    {
        "question_id": "2891",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        max_beauty = 0\n        right = 0\n        \n        for left in range(len(nums)):\n            while right < len(nums) and nums[right] - nums[left] <= 2 * k:\n                right += 1\n            max_beauty = max(max_beauty, right - left)\n        \n        return max_beauty * 2"
        ]
    },
    {
        "question_id": "2892",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        max_num = max(nums)\n        if len(nums) != max_num + 1 or nums.count(max_num) != 2:\n            return False\n        expected = set(range(1, max_num))\n        return set(nums) == expected"
        ]
    },
    {
        "question_id": "2893",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp_even = [0] * n\n        dp_odd = [0] * n\n        \n        if nums[0] % 2 == 0:\n            dp_even[0] = nums[0]\n        else:\n            dp_odd[0] = nums[0]\n        \n        for i in range(1, n):\n            if nums[i] % 2 == 0:\n                dp_even[i] = max(dp_even[i-1] + nums[i], dp_odd[i-1] + nums[i] - x)\n                dp_odd[i] = dp_odd[i-1]\n            else:\n                dp_odd[i] = max(dp_odd[i-1] + nums[i], dp_even[i-1] + nums[i] - x)\n                dp_even[i] = dp_even[i-1]\n        \n        return max(dp_even[-1], dp_odd[-1])"
        ]
    },
    {
        "question_id": "2902",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int]) -> int:\n        max_sum = -1\n        num_map = {}\n        \n        for num in nums:\n            max_digit = max(int(digit) for digit in str(num))\n            if max_digit in num_map:\n                max_sum = max(max_sum, num + num_map[max_digit])\n                num_map[max_digit] = max(num_map[max_digit], num)\n            else:\n                num_map[max_digit] = num\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "2915",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        prefix_count = 0\n        count_map = defaultdict(int)\n        count_map[0] = 1\n        result = 0\n        \n        for num in nums:\n            prefix_count += (num % modulo == k)\n            target = (prefix_count - k + modulo) % modulo\n            result += count_map[target]\n            count_map[prefix_count % modulo] += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "2916",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        n = len(nums)\n        if n < 3:\n            return True\n        # Check if any adjacent pair's sum is greater than or equal to m\n        for i in range(n - 1):\n            if nums[i] + nums[i + 1] >= m:\n                return True\n        return False"
        ]
    },
    {
        "question_id": "2917",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] < target:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2919",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        usageLimits.sort()\n        groups = 0\n        total = 0\n        \n        for limit in usageLimits:\n            if limit >= total:\n                groups += 1\n                total = 0\n            else:\n                total += limit\n        \n        return groups"
        ]
    },
    {
        "question_id": "2920",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        index_map = defaultdict(list)\n        \n        # Map each value to its indices\n        for i, num in enumerate(nums):\n            index_map[num].append(i)\n        \n        max_distance = 0\n        \n        # Calculate the maximum distance between equal elements\n        for indices in index_map.values():\n            max_dist = 0\n            for j in range(len(indices)):\n                max_dist = max(max_dist, (indices[j] - indices[(j - 1) % len(indices)]) // 2)\n            max_dist = max(max_dist, (n + indices[0] - indices[-1]) // 2)\n            max_distance = max(max_distance, max_dist)\n        \n        return max_distance"
        ]
    },
    {
        "question_id": "2921",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(length, is_limit, is_num, prev_digit):\n            if length == 0:\n                return int(is_num)\n            res = 0\n            if not is_num:\n                res = dp(length - 1, False, False, None)\n            lower_bound = int(low[-length]) if is_limit and is_num else 0\n            upper_bound = int(high[-length]) if is_limit else 9\n            for digit in range(lower_bound, upper_bound + 1):\n                if prev_digit is None or abs(prev_digit - digit) == 1:\n                    res += dp(length - 1, is_limit and digit == upper_bound, True, digit)\n            return res % MOD\n        \n        def count_numbers(n):\n            return dp(len(n), True, False, None)\n        \n        return (count_numbers(high) - count_numbers(low) + int(low[0] != '0') + (int(low) <= 10 and int(high) >= 10)) % MOD"
        ]
    },
    {
        "question_id": "2952",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        n = len(nums1)\n        total_increase = sum(nums2)\n        dp = [0] * (n + 1)\n        \n        # Calculate the initial sum of nums1\n        initial_sum = sum(nums1)\n        \n        # Sort nums2 and nums1 based on nums2 values\n        pairs = sorted(zip(nums2, nums1), reverse=True)\n        nums2, nums1 = zip(*pairs)\n        \n        @lru_cache(None)\n        def dfs(index, remaining_time):\n            if initial_sum + total_increase * remaining_time - sum(dp) <= x:\n                return remaining_time\n            if index == n or remaining_time == 0:\n                return float('inf')\n            \n            # Option 1: Do not choose current index\n            not_choose = dfs(index + 1, remaining_time)\n            \n            # Option 2: Choose current index\n            choose = dfs(index + 1, remaining_time - 1) + nums1[index]\n            \n            dp[remaining_time - 1] = nums1[index]\n            return min(not_choose, choose)\n        \n        result = dfs(0, n)\n        return result if result != float('inf') else -1"
        ]
    },
    {
        "question_id": "2953",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        count = 0\n        n = len(coordinates)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (coordinates[i][0] ^ coordinates[j][0]) + (coordinates[i][1] ^ coordinates[j][1]) == k:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "2954",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        max_sum = 0\n        current_sum = 0\n        count_map = defaultdict(int)\n        \n        # Initialize the first window\n        for i in range(k):\n            current_sum += nums[i]\n            count_map[nums[i]] += 1\n        \n        # Check if the first window is valid\n        if len(count_map) >= m:\n            max_sum = current_sum\n        \n        # Slide the window across the array\n        for i in range(k, len(nums)):\n            # Add the new element to the current sum and update its count\n            current_sum += nums[i]\n            count_map[nums[i]] += 1\n            \n            # Remove the element that is sliding out of the window\n            current_sum -= nums[i - k]\n            count_map[nums[i - k]] -= 1\n            \n            # If the count of the removed element becomes zero, remove it from the map\n            if count_map[nums[i - k]] == 0:\n                del count_map[nums[i - k]]\n            \n            # Check if the current window is valid\n            if len(count_map) >= m:\n                max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "2955",
        "code_list": [
            "class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        roundedAmount = round(purchaseAmount / 10) * 10\n        return 100 - roundedAmount"
        ]
    },
    {
        "question_id": "2977",
        "code_list": [
            "class Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        return ''.join(word[0] for word in words) == s"
        ]
    },
    {
        "question_id": "2979",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        # Sort offers based on the starting house index\n        offers.sort(key=lambda x: x[0])\n        \n        # Initialize a DP array where dp[i] represents the maximum profit up to house i\n        dp = [0] * (n + 1)\n        \n        # Dictionary to map the ending house index to the offer index\n        offer_map = {end: idx for idx, (start, end, _) in enumerate(offers)}\n        \n        # Fill the DP array\n        for i in range(1, n + 1):\n            # Copy the previous day's profit\n            dp[i] = dp[i - 1]\n            \n            # Check if there is any offer ending at the current house\n            if i - 1 in offer_map:\n                idx = offer_map[i - 1]\n                start, end, gold = offers[idx]\n                # Update the DP value with the maximum profit\n                dp[i] = max(dp[i], dp[start] + gold)\n                \n            # Check if there is any offer starting at the current house\n            if i in offer_map:\n                idx = offer_map[i]\n                start, end, gold = offers[idx]\n                # Update the DP value with the maximum profit\n                dp[i] = max(dp[i], dp[end + 1] + gold)\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "2998",
        "code_list": [
            "class Solution:\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        count = 0\n        for num in range(low, high + 1):\n            num_str = str(num)\n            if len(num_str) % 2 != 0:\n                continue\n            mid = len(num_str) // 2\n            first_half_sum = sum(int(digit) for digit in num_str[:mid])\n            second_half_sum = sum(int(digit) for digit in num_str[mid:])\n            if first_half_sum == second_half_sum:\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "2999",
        "code_list": [
            "class Solution:\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        # Check if the characters at even indices are the same in both strings\n        # and the characters at odd indices are the same in both strings\n        return sorted(s1[::2]) == sorted(s2[::2]) and sorted(s1[1::2]) == sorted(s2[1::2])"
        ]
    },
    {
        "question_id": "3000",
        "code_list": [
            "from sortedcontainers import SortedList\n\nclass Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        sl = SortedList()\n        min_diff = float('inf')\n        for i in range(len(nums)):\n            if i >= x:\n                sl.add(nums[i - x])\n                pos = sl.bisect_left(nums[i])\n                if pos != len(sl):\n                    min_diff = min(min_diff, nums[i] - sl[pos])\n                if pos != 0:\n                    min_diff = min(min_diff, sl[pos - 1] - nums[i])\n            if i == x - 1:\n                sl.add(nums[i])\n        return min_diff"
        ]
    },
    {
        "question_id": "3017",
        "code_list": [
            "from math import floor, log10\n\nclass Solution:\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        def count_beautiful_numbers(n, k):\n            if n < 10:\n                return 0 if n % k != 0 or abs(n - (n % 2)) != abs(n // 2) else 1\n            count = 0\n            length = int(log10(n)) + 1\n            for i in range(1, length):\n                count += self.count_numbers_with_length(i, k)\n            count += self.count_numbers_with_length(length, k, n)\n            return count\n        \n        def self.count_numbers_with_length(length, k, upper_bound=None):\n            if length == 1:\n                return sum(1 for i in range(1, 10) if i % k == 0)\n            count = 0\n            for i in range(1 if length > 1 else 0, 10):\n                next_count = self.count_numbers_with_length(length - 1, k, upper_bound // 10 if upper_bound else None)\n                if upper_bound is None or i * pow(10, length - 1) + upper_bound % (pow(10, length - 1)) <= upper_bound:\n                    count += next_count\n                if i % 2 == 0:\n                    count -= next_count if i == 0 else next_count - (i % k == 0)\n                else:\n                    count += next_count if i == 0 else next_count - (i % k == 0)\n            return count\n        \n        return count_beautiful_numbers(high, k) - count_beautiful_numbers(low - 1, k)"
        ]
    },
    {
        "question_id": "3018",
        "code_list": [
            "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        j = 0\n        for i in range(len(str1)):\n            # Check if current character in str1 matches or can be incremented to match the current character in str2\n            if j < len(str2) and (str1[i] == str2[j] or chr((ord(str1[i]) - ord('a') + 1) % 26 + ord('a')) == str2[j]):\n                j += 1\n            # If all characters of str2 are matched, return True\n            if j == len(str2):\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3019",
        "code_list": [
            "class Solution:\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        count_L = moves.count('L')\n        count_R = moves.count('R')\n        count_blank = moves.count('_')\n        \n        # The furthest distance is achieved by maximizing the absolute difference\n        # between the number of '_' that can be used as 'L' or 'R'.\n        return abs(count_L - count_R) + count_blank"
        ]
    },
    {
        "question_id": "3024",
        "code_list": [
            "from collections import Counter\nfrom math import pow\n\nclass Solution:\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        if s == t:\n            # If s is already equal to t, we need to check if k operations can keep it the same\n            return (pow(26, k, MOD) - 1) % MOD\n        \n        # Find all rotations of s that match t\n        rotations = [s[i:] + s[:i] for i in range(n)]\n        if t not in rotations:\n            return 0\n        \n        # Calculate the frequency of each rotation\n        rotation_counts = Counter(rotations)\n        target_rotation = t\n        target_count = rotation_counts[target_rotation]\n        \n        # Calculate the number of ways to reach the target rotation in k steps\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for _ in range(k):\n            new_dp = [0] * (k + 1)\n            for j in range(k + 1):\n                if j > 0:\n                    new_dp[j] += dp[j - 1] * (n - 1)\n                    new_dp[j] %= MOD\n                new_dp[j] += dp[j] * (n - target_count)\n                new_dp[j] %= MOD\n            dp = new_dp\n        \n        return dp[k]"
        ]
    },
    {
        "question_id": "3025",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], target: int) -> int:\n        # Convert target to binary representation to check for required bits\n        target_bits = [1 if bit == '1' else 0 for bit in bin(target)[2:]]\n        # Initialize count to store the number of operations\n        count = 0\n        # Dictionary to store the count of each power of 2 in nums\n        num_counts = {}\n        \n        # Count the occurrences of each power of 2 in nums\n        for num in nums:\n            power = 0\n            while num > 0:\n                if num % 2 == 1:\n                    num_counts[power] = num_counts.get(power, 0) + 1\n                num //= 2\n                power += 1\n        \n        # Iterate over each bit position in target's binary representation\n        for i, bit in enumerate(target_bits):\n            if bit == 1:\n                # Check if the current bit is already covered\n                if num_counts.get(i, 0) >= 1:\n                    num_counts[i] -= 1\n                else:\n                    # Find the smallest power of 2 that can be split to cover the current bit\n                    j = i\n                    while num_counts.get(j, 0) == 0:\n                        j += 1\n                    # Use operations to split the larger power of 2 to get the needed smaller power(s)\n                    while j > i:\n                        num_counts[j] -= 1\n                        num_counts[j-1] += 2\n                        count += 1\n                        j -= 1\n        \n        # Check if all bits of target are covered\n        if all(num_counts.get(i, 0) >= 1 for i in range(len(target_bits))):\n            return count\n        else:\n            return -1"
        ]
    },
    {
        "question_id": "3031",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        n, m = len(grid), len(grid[0])\n        total_product = 1\n        zero_count = 0\n        \n        # Calculate the total product of all elements in grid\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 0:\n                    total_product *= grid[i][j]\n                else:\n                    zero_count += 1\n        \n        # If there are more than one zero in the grid, all elements in the result will be zero\n        if zero_count > 1:\n            return [[0] * m for _ in range(n)]\n        \n        result = [[0] * m for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] != 0:\n                    result[i][j] = (total_product // grid[i][j]) % 12345\n                else:\n                    result[i][j] = total_product % 12345\n        \n        return result"
        ]
    },
    {
        "question_id": "3032",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n        n = len(receiver)\n        dp = [[-1] * n for _ in range(40)]\n        for i in range(n):\n            dp[0][i] = receiver[i]\n        \n        # Precompute the receiver chain up to 39 levels (2^39 > 10^10)\n        for j in range(1, 40):\n            for i in range(n):\n                if dp[j-1][i] != -1:\n                    dp[j][i] = dp[j-1][dp[j-1][i]]\n        \n        def get_receiver_chain_sum(start, steps):\n            total = start\n            for j in range(39, -1, -1):\n                if steps >= (1 << j):\n                    total += dp[j][start]\n                    steps -= (1 << j)\n                    start = dp[j][start]\n            return total\n        \n        max_value = 0\n        for i in range(n):\n            max_value = max(max_value, get_receiver_chain_sum(i, k))\n        \n        return max_value"
        ]
    },
    {
        "question_id": "3033",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        n = len(s1)\n        diff_indices = [i for i in range(n) if s1[i] != s2[i]]\n        m = len(diff_indices)\n        \n        if m % 2 != 0:\n            return -1\n        \n        dp = [[float('inf')] * (m // 2 + 1) for _ in range(m + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, m + 1):\n            for j in range(min(i // 2 + 1, m // 2 + 1)):\n                if i >= 2 and j >= 1:\n                    dp[i][j] = min(dp[i][j], dp[i - 2][j - 1] + x)\n                if i >= 1:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n        \n        return dp[m][m // 2] if dp[m][m // 2] != float('inf') else -1"
        ]
    },
    {
        "question_id": "3034",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        covered_points = set()\n        for start, end in nums:\n            for point in range(start, end + 1):\n                covered_points.add(point)\n        return len(covered_points)"
        ]
    },
    {
        "question_id": "3044",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        collected = set()\n        operations = 0\n        \n        for i in range(len(nums) - 1, -1, -1):\n            if nums[i] <= k:\n                collected.add(nums[i])\n            if len(collected) == k:\n                return len(nums) - i\n            operations += 1\n        \n        return operations"
        ]
    },
    {
        "question_id": "3045",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        # Find the index where the array is not sorted\n        start = -1\n        for i in range(1, n):\n            if nums[i] < nums[i - 1]:\n                if start != -1:\n                    return -1  # More than one point where the array is not sorted\n                start = i\n        \n        # If no disordered part found, the array is already sorted\n        if start == -1:\n            return 0\n        \n        # Check if the array can be sorted by right shifts\n        for i in range(start, n - 1):\n            if nums[i] > nums[i + 1]:\n                return -1\n        \n        # Check the last and first elements to confirm sorting\n        if nums[0] < nums[n - 1]:\n            return -1\n        \n        # Calculate the number of right shifts needed\n        return n - start"
        ]
    },
    {
        "question_id": "3046",
        "code_list": [
            "class Solution:\n    def minimumOperations(self, num: str) -> int:\n        n = len(num)\n        dp = [float('inf')] * (n + 1)\n        dp[n] = 0\n        \n        for i in range(n - 1, -1, -1):\n            dp[i] = dp[i + 1] + 1\n            if num[i] == '0':\n                for j in range(i + 1, n):\n                    if num[j] in ['0', '5']:\n                        dp[i] = min(dp[i], dp[j + 1] + (j - i))\n            elif num[i] == '5':\n                for j in range(i + 1, n):\n                    if num[j] in ['0', '2', '5', '7']:\n                        dp[i] = min(dp[i], dp[j + 1] + (j - i))\n        \n        return dp[0]"
        ]
    },
    {
        "question_id": "3047",
        "code_list": [
            "from math import isqrt\nfrom typing import List\n\nclass Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        def is_perfect_square(n):\n            return isqrt(n) ** 2 == n\n        \n        n = len(nums)\n        factor_counts = [{} for _ in range(n)]\n        for i, num in enumerate(nums):\n            factors = []\n            for f in range(2, isqrt(num) + 1):\n                count = 0\n                while num % f == 0:\n                    num //= f\n                    count += 1\n                if count % 2 != 0:\n                    factors.append(f)\n            if num > 1:\n                factors.append(num)\n            factor_counts[i] = {f: count for f, count in sorted((factors + [1] * (len(factors) - len(set(factors))), [1] * (len(factors) - len(set(factors))))[:len(factors)])}\n        \n        max_sum = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                valid = True\n                for f, count in factor_counts[i].items():\n                    if f not in factor_counts[j] or (factor_counts[j][f] + count) % 2 != 0:\n                        valid = False\n                        break\n                if valid:\n                    max_sum = max(max_sum, nums[i] + nums[j])\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3055",
        "code_list": [
            "class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        ones = s.count('1')\n        zeros = s.count('0')\n        # Place all but one '1' at the beginning, followed by all '0's, and end with a single '1'\n        return '1' * (ones - 1) + '0' * zeros + '1'"
        ]
    },
    {
        "question_id": "3080",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSubarrays(self, nums: List[int]) -> int:\n        result = all_num = nums[0]\n        for num in nums[1:]:\n            all_num &= num\n            if all_num == 0:\n                result += 1\n                if len(nums) > 1:\n                    nums = nums[nums.index(all_num) + 1:]\n                all_num = nums[0] if nums else 0\n        return result + (all_num > 0)"
        ]
    },
    {
        "question_id": "3081",
        "code_list": [
            "from heapq import heapify, heappop\n\nclass Solution:\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_heap = [-num for num in nums]\n        heapify(max_heap)\n        \n        while len(max_heap) > 1 and -max_heap[0] > -max_heap[1]:\n            heappop(max_heap)\n            heappop(max_heap)\n        \n        return -len(max_heap)"
        ]
    },
    {
        "question_id": "3091",
        "code_list": [
            "from typing import List\nfrom collections import Counter\nfrom functools import lru_cache\n\nclass Solution:\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        mod = 10**9 + 7\n        cnt = Counter(nums)\n        keys = sorted(cnt.keys())\n        \n        @lru_cache(None)\n        def dp(index, target):\n            if target == 0:\n                return 1\n            if index == len(keys):\n                return 0\n            res = 0\n            for i in range(cnt[keys[index]] + 1):\n                if target - i * keys[index] >= l:\n                    res += dp(index + 1, target - i * keys[index])\n                    res %= mod\n            return res\n        \n        total = dp(0, r) - dp(0, l - 1)\n        return total % mod"
        ]
    },
    {
        "question_id": "3093",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        return sum(nums[i] for i in range(len(nums)) if bin(i).count('1') == k)"
        ]
    },
    {
        "question_id": "3094",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        operations = 0\n        \n        for freq in count.values():\n            if freq == 1:\n                return -1\n            operations += (freq + 2) // 3\n        \n        return operations"
        ]
    },
    {
        "question_id": "3104",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countWays(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        ways = 0\n        \n        # Case when no student is selected\n        if nums[0] > 0:\n            ways += 1\n        \n        # Case when all students are selected\n        if nums[-1] < n:\n            ways += 1\n        \n        # Case when some students are selected\n        for i in range(n - 1):\n            if nums[i] < i + 1 < nums[i + 1]:\n                ways += 1\n        \n        return ways"
        ]
    },
    {
        "question_id": "3106",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        dp = [0] + [-1] * target\n        for num in nums:\n            for t in range(target, num - 1, -1):\n                dp[t] = max(dp[t], dp[t - num] + 1)\n        return dp[target]"
        ]
    },
    {
        "question_id": "3114",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        left_smaller = [0] * n\n        right_smaller = [0] * n\n        \n        mono_stack = []\n        # Calculate left smaller\n        for i in range(n):\n            while mono_stack and maxHeights[mono_stack[-1]] >= maxHeights[i]:\n                mono_stack.pop()\n            left_smaller[i] = i if not mono_stack else i - mono_stack[-1] - 1\n            mono_stack.append(i)\n        \n        mono_stack.clear()\n        # Calculate right smaller\n        for i in range(n - 1, -1, -1):\n            while mono_stack and maxHeights[mono_stack[-1]] >= maxHeights[i]:\n                mono_stack.pop()\n            right_smaller[i] = n - i - 1 if not mono_stack else mono_stack[-1] - i - 1\n            mono_stack.append(i)\n        \n        # Calculate the maximum sum of heights\n        total_heights = [maxHeights[i] * (left_smaller[i] + right_smaller[i] + 1) for i in range(n)]\n        return max(total_heights)"
        ]
    },
    {
        "question_id": "3141",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        prefix_sum = 0\n        prefix_sums = {0: -1}\n        \n        # Calculate prefix sums and store their indices\n        for i, num in enumerate(nums):\n            prefix_sum += num\n            prefix_sums[prefix_sum] = i\n        \n        total_sum = sum(nums)\n        result = float('inf')\n        \n        # Check if target is a multiple of total sum\n        if target % total_sum == 0:\n            result = (target // total_sum) * n\n        \n        # Find the shortest subarray\n        prefix_sum = 0\n        for i, num in enumerate(nums + nums):\n            prefix_sum += num\n            needed_sum = prefix_sum - target\n            if needed_sum in prefix_sums:\n                result = min(result, i - prefix_sums[needed_sum])\n            if prefix_sum >= target:\n                break\n        \n        return result if result != float('inf') else -1"
        ]
    },
    {
        "question_id": "3150",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        n = len(s)\n        min_len = float('inf')\n        result = \"\"\n        \n        left = 0\n        count_ones = 0\n        for right in range(n):\n            if s[right] == '1':\n                count_ones += 1\n            \n            while count_ones == k:\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    result = s[left:right+1]\n                \n                if s[left] == '1':\n                    count_ones -= 1\n                left += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3151",
        "code_list": [
            "class Solution:\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        # Sort processor times in ascending order\n        processorTime.sort()\n        # Sort tasks in descending order\n        tasks.sort(reverse=True)\n        \n        # Initialize the result with the minimum possible value\n        result = 0\n        \n        # Assign tasks to processors\n        for i in range(len(processorTime)):\n            # Calculate the maximum time taken by the current processor\n            max_time = max(processorTime[i] + tasks[i * 4 + j] for j in range(4))\n            # Update the result with the maximum time among all processors\n            result = max(result, max_time)\n        \n        return result"
        ]
    },
    {
        "question_id": "3153",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSum(self, nums: List[int], k: int) -> int:\n        mod = 10**9 + 7\n        bit_counts = [0] * 30\n        \n        # Count the number of 1s at each bit position across all numbers\n        for num in nums:\n            for bit in range(30):\n                if num & (1 << bit):\n                    bit_counts[bit] += 1\n        \n        # Reconstruct the k largest possible numbers using the bit counts\n        k_largest = []\n        for _ in range(k):\n            current_num = 0\n            for bit in range(30):\n                if bit_counts[bit]:\n                    current_num |= (1 << bit)\n                    bit_counts[bit] -= 1\n            k_largest.append(current_num)\n        \n        # Calculate the sum of squares of the k largest numbers\n        result = sum(x ** 2 for x in k_largest) % mod\n        return result"
        ]
    },
    {
        "question_id": "3154",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        max_value = 0\n        n = len(nums)\n        max_diff = [0] * n\n        max_val = nums[-1]\n        \n        for j in range(n-2, 1, -1):\n            max_diff[j] = max(max_diff[j+1], (nums[j-1] - max_val) * nums[j])\n            max_val = max(max_val, nums[j])\n        \n        for i in range(n-3):\n            max_value = max(max_value, max_diff[i+2])\n        \n        return max_value"
        ]
    },
    {
        "question_id": "3163",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumCounts(self, nums: List[int]) -> int:\n        n = len(nums)\n        total_sum = 0\n        \n        for i in range(n):\n            seen = set()\n            for j in range(i, n):\n                seen.add(nums[j])\n                total_sum += len(seen) ** 2\n        \n        return total_sum"
        ]
    },
    {
        "question_id": "3164",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def lastVisitedIntegers(self, words: List[str]) -> List[int]:\n        result = []\n        nums = []\n        prev_count = 0\n        \n        for word in words:\n            if word != \"prev\":\n                nums.append(int(word))\n                prev_count = 0\n            else:\n                prev_count += 1\n                if len(nums) < prev_count:\n                    result.append(-1)\n                else:\n                    result.append(nums[-prev_count])\n        \n        return result"
        ]
    },
    {
        "question_id": "3166",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        values = list(count.values())\n        n = len(nums)\n        \n        def is_valid(group_size):\n            total_groups = 0\n            for val in values:\n                q, r = divmod(val, group_size)\n                if r > 0:\n                    if r + q > group_size:\n                        return False\n                    total_groups += r + 1\n                else:\n                    total_groups += q\n            return total_groups <= n\n        \n        for group_size in range(min(values), 0, -1):\n            if is_valid(group_size):\n                return sum((val + group_size - 1) // group_size for val in values)"
        ]
    },
    {
        "question_id": "3171",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        zeros1, total1 = nums1.count(0), sum(nums1)\n        zeros2, total2 = nums2.count(0), sum(nums2)\n        \n        # Calculate the required sums to make both arrays have the same sum\n        required_sum1 = total1 + zeros1\n        required_sum2 = total2 + zeros2\n        \n        # Check if it's possible to make the sums equal\n        if (total1 + zeros1 < total2 + zeros2 and zeros1 == 0) or (total2 + zeros2 < total1 + zeros1 and zeros2 == 0):\n            return -1\n        \n        return max(required_sum1, required_sum2)"
        ]
    },
    {
        "question_id": "3172",
        "code_list": [
            "class Solution:\n    def differenceOfSums(self, n: int, m: int) -> int:\n        num1 = sum(i for i in range(1, n + 1) if i % m != 0)\n        num2 = sum(i for i in range(1, n + 1) if i % m == 0)\n        return num1 - num2"
        ]
    },
    {
        "question_id": "3174",
        "code_list": [
            "class Solution:\n    def minChanges(self, s: str) -> int:\n        changes = 0\n        n = len(s)\n        i = 0\n        while i < n:\n            # Check if the current pair is beautiful\n            if s[i] != s[i + 1]:\n                changes += 1\n            i += 2\n        return changes"
        ]
    },
    {
        "question_id": "3176",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        left_min = [0] * n\n        right_min = [0] * n\n        \n        # Fill left_min array with the minimum value to the left of each index\n        left_min[0] = nums[0]\n        for i in range(1, n):\n            left_min[i] = min(left_min[i-1], nums[i])\n        \n        # Fill right_min array with the minimum value to the right of each index\n        right_min[n-1] = nums[n-1]\n        for i in range(n-2, -1, -1):\n            right_min[i] = min(right_min[i+1], nums[i])\n        \n        # Find the minimum sum of a mountain triplet\n        for j in range(1, n-1):\n            if nums[j] > left_min[j] and nums[j] > right_min[j]:\n                min_sum = min(min_sum, nums[j] + left_min[j] + right_min[j])\n        \n        return min_sum if min_sum != float('inf') else -1"
        ]
    },
    {
        "question_id": "3183",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        bit_count = [0] * 31\n        \n        for num in nums:\n            bit_position = 0\n            while num > 0:\n                if num % 2 == 1:\n                    bit_count[bit_position] += 1\n                num //= 2\n                bit_position += 1\n        \n        result = 0\n        for i, count in enumerate(bit_count):\n            if count >= k:\n                result |= (1 << i)\n        \n        return result"
        ]
    },
    {
        "question_id": "3184",
        "code_list": [
            "from typing import List\nfrom bisect import bisect_left\n\nclass Solution:\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n        dp = []\n        max_sum = float('-inf')\n        for i, num in enumerate(nums):\n            # Find the largest index j such that dp[j] + num - i <= dp[i]\n            j = bisect_left(dp, num - i)\n            if j == len(dp):\n                dp.append(num - i)\n            else:\n                dp[j] = num - i\n            # Update max_sum\n            max_sum = max(max_sum, num - dp[j] + i)\n        return max_sum"
        ]
    },
    {
        "question_id": "3188",
        "code_list": [
            "class Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        strongest_team = -1\n        for i in range(len(grid)):\n            if sum(grid[i]) == len(grid) - 1:\n                if strongest_team != -1:\n                    return -1  # In case there are multiple champions\n                strongest_team = i\n        return strongest_team"
        ]
    },
    {
        "question_id": "3190",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        max1, max2 = max(nums1), max(nums2)\n        if nums1[-1] == max1 and nums2[-1] == max2:\n            return 0\n        \n        def count_ops(i):\n            if nums1[i] <= max2 and nums2[i] <= max1:\n                return count_ops(i + 1) if i < n - 1 else 0\n            elif nums1[i] <= max1 and nums2[i] <= max2:\n                return 1 + count_ops(i + 1) if i < n - 1 else 1\n            else:\n                return float('inf')\n        \n        ops1 = count_ops(0)\n        ops2 = count_ops(0) + 1 if nums1[-1] <= max2 and nums2[-1] <= max1 else float('inf')\n        \n        return min(ops1, ops2) if min(ops1, ops2) != float('inf') else -1"
        ]
    },
    {
        "question_id": "3192",
        "code_list": [
            "class Solution:\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        MOD = 10**9 + 7\n        max_product = 0\n        \n        for x in range(2**n):\n            val = ((a ^ x) * (b ^ x)) % MOD\n            max_product = max(max_product, val)\n        \n        return max_product"
        ]
    },
    {
        "question_id": "3193",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        max_xor = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if abs(nums[i] - nums[j]) <= min(nums[i], nums[j]):\n                    max_xor = max(max_xor, nums[i] ^ nums[j])\n        return max_xor"
        ]
    },
    {
        "question_id": "3194",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findWordsContaining(self, words: List[str], x: str) -> List[int]:\n        result = []\n        for index, word in enumerate(words):\n            if x in word:\n                result.append(index)\n        return result"
        ]
    },
    {
        "question_id": "3195",
        "code_list": [
            "class Solution:\n    def minimumSteps(self, s: str) -> int:\n        steps = 0\n        zero_count = 0\n        \n        for i in range(len(s)):\n            if s[i] == '0':\n                zero_count += 1\n            else:\n                steps += i - zero_count\n        \n        return steps"
        ]
    },
    {
        "question_id": "3196",
        "code_list": [
            "from typing import List\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        sl = SortedList()\n        max_freq = 0\n        \n        for right in range(n):\n            sl.add(nums[right])\n            while sl[-1] - sl[0] > k:\n                sl.remove(nums[left])\n                left += 1\n            max_freq = max(max_freq, right - left + 1)\n        \n        return max_freq"
        ]
    },
    {
        "question_id": "3199",
        "code_list": [
            "class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        count = 0\n        for i in range(min(n, limit) + 1):\n            for j in range(min(n - i, limit) + 1):\n                if n - i - j <= limit:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3200",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def stringCount(self, n: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(length, has_e, has_l1, has_l2):\n            if length == n:\n                return 1\n            res = 0\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c == 'e' and not has_e:\n                    res += dp(length + 1, True, has_l1, has_l2)\n                elif c == 'l' and not has_l1:\n                    res += dp(length + 1, has_e, True, has_l2)\n                elif c == 't' and not has_l2:\n                    res += dp(length + 1, has_e, has_l1, True)\n                else:\n                    res += dp(length + 1, has_e, has_l1, has_l2)\n            return res % MOD\n        \n        return dp(0, False, False, False) * 26**(n-3) % MOD"
        ]
    },
    {
        "question_id": "3203",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        n = len(s)\n        left = list(s[:n // 2])\n        right = list(s[n // 2:])[::-1]\n        \n        def check_palindrome(left_sub, right_sub):\n            return all(l == r for l, r in zip(left_sub, right_sub))\n        \n        def can_form_palindrome():\n            left_sub = ''.join(left)\n            right_sub = ''.join(right)\n            return check_palindrome(left_sub, right_sub)\n        \n        def process_query(a, b, c, d):\n            left_sub = left[a:b+1]\n            right_sub = right[c:d+1]\n            \n            # Check if the substrings can form palindromes individually\n            if not (check_palindrome(left_sub[::-1], left_sub) or check_palindrome(right_sub[::-1], right_sub)):\n                return False\n            \n            # Rearrange the substrings to match the other half\n            left[a:b+1] = sorted(left_sub)\n            right[c:d+1] = sorted(right_sub)\n            \n            # Check if the entire string can now form a palindrome\n            return check_palindrome(''.join(left), ''.join(right))\n        \n        return [process_query(*query) for query in queries]"
        ]
    },
    {
        "question_id": "3206",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        set1, set2 = set(nums1), set(nums2)\n        count1 = sum(num in set2 for num in nums1)\n        count2 = sum(num in set1 for num in nums2)\n        return [count1, count2]"
        ]
    },
    {
        "question_id": "3207",
        "code_list": [
            "class Solution:\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        min_length = min(len(s1), len(s2), len(s3))\n        for i in range(min_length):\n            if s1[i] != s2[i] or s1[i] != s3[i]:\n                return len(s1) + len(s2) + len(s3) - 3 * (i + 1)\n        return len(s1) + len(s2) + len(s3) - 3 * min_length if min_length > 0 else -1"
        ]
    },
    {
        "question_id": "3209",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCoins(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for i in range(1, n + 1):\n            k = i - 1\n            while k >= 0 and k < n:\n                dp[i] = min(dp[i], dp[max(0, k - i + 1)] + prices[k - 1])\n                k += 1\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "3210",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        vowels = set('aeiou')\n        prefix_sum = 0\n        count = 0\n        index_map = defaultdict(lambda: -1)\n        index_map[0] = -1\n        \n        for i, char in enumerate(s):\n            prefix_sum += 1 if char in vowels else -1\n            if prefix_sum % 2 != 0:\n                continue\n            \n            half_vowels = prefix_sum // 2\n            if half_vowels * half_vowels % k == 0:\n                count += i - index_map[prefix_sum]\n            index_map[prefix_sum] = i\n        \n        return count"
        ]
    },
    {
        "question_id": "3211",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findMaximumLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [1] * n  # dp[i] represents the max length of non-decreasing array ending at index i\n        \n        for i in range(1, n):\n            for j in range(i):\n                # Calculate the sum of subarray nums[j+1:i+1]\n                subarray_sum = sum(nums[j+1:i+1])\n                # Check if replacing nums[j+1:i+1] with subarray_sum makes the array non-decreasing\n                if nums[j] <= subarray_sum <= nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"
        ]
    },
    {
        "question_id": "3212",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        last_occurrence = {}\n        for i, num in enumerate(nums):\n            last_occurrence[num] = i\n        \n        boundary = 0\n        partitions = 1\n        for i, num in enumerate(nums):\n            boundary = max(boundary, last_occurrence[num])\n            if i == boundary:\n                partitions *= 2\n                partitions %= 1000000007\n        \n        return partitions - 1"
        ]
    },
    {
        "question_id": "3213",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        max_elem = max(nums)\n        n = len(nums)\n        left = 0\n        count = 0\n        result = 0\n        \n        for right in range(n):\n            if nums[right] == max_elem:\n                count += 1\n            \n            while count >= k:\n                if nums[left] == max_elem:\n                    count -= 1\n                left += 1\n            \n            result += left\n        \n        return result"
        ]
    },
    {
        "question_id": "3219",
        "code_list": [
            "from typing import List\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        n = len(nums)\n        sorted_nums = sorted(zip(nums, range(n)))\n        groups = []\n        start = 0\n        \n        for i in range(1, n):\n            if sorted_nums[i][0] - sorted_nums[start][0] > limit:\n                groups.append(sorted_nums[start:i])\n                start = i\n        \n        groups.append(sorted_nums[start:])\n        \n        result = [0] * n\n        index_map = {}\n        \n        for group in groups:\n            indices = [index for _, index in group]\n            values = [num for num, _ in group]\n            sorted_indices = SortedList(indices)\n            \n            for i, index in enumerate(indices):\n                index_map[index] = values[i]\n                \n            for index in sorted_indices:\n                result[index] = index_map.popitem(last=False)[1]\n        \n        return result"
        ]
    },
    {
        "question_id": "3220",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        tested_count = 0\n        for i in range(len(batteryPercentages)):\n            if batteryPercentages[i] > 0:\n                tested_count += 1\n                for j in range(i + 1, len(batteryPercentages)):\n                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1)\n        return tested_count"
        ]
    },
    {
        "question_id": "3221",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        peaks = []\n        for i in range(1, len(mountain) - 1):\n            if mountain[i] > mountain[i - 1] and mountain[i] > mountain[i + 1]:\n                peaks.append(i)\n        return peaks"
        ]
    },
    {
        "question_id": "3223",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        n = len(word)\n        count = 0\n        \n        def isValid(sub):\n            freq = Counter(sub)\n            return all(v == k for v in freq.values()) and all(abs(ord(sub[i]) - ord(sub[i-1])) <= 2 for i in range(1, len(sub)))\n        \n        i = 0\n        while i < n:\n            j = i\n            chars = set()\n            while j < n and (word[j] not in chars or (j > i and abs(ord(word[j]) - ord(word[j-1])) > 2)):\n                chars.add(word[j])\n                j += 1\n            for size in range(k, len(chars) * k + 1, k):\n                for start in range(i, j - size + 1):\n                    sub = word[start:start + size]\n                    if isValid(sub):\n                        count += 1\n            i = j\n        return count"
        ]
    },
    {
        "question_id": "3224",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        # Calculate gaps between consecutive sick children\n        gaps = [sick[i+1] - sick[i] - 1 for i in range(len(sick) - 1)]\n        gaps.insert(0, sick[0])\n        gaps.append(n - 1 - sick[-1])\n        \n        # Calculate the product of combinations for each gap\n        total_sequences = 1\n        for gap in gaps:\n            if gap > 0:\n                total_sequences *= comb(gap + 1, 1)\n                total_sequences %= MOD\n        \n        return total_sequences"
        ]
    },
    {
        "question_id": "3225",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        freq_map = defaultdict(int)\n        left = 0\n        max_length = 0\n        \n        for right in range(len(nums)):\n            freq_map[nums[right]] += 1\n            \n            while freq_map[nums[right]] > k:\n                freq_map[nums[left]] -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3226",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        arr = []\n        while nums:\n            bob_move = nums.pop(0)  # Alice removes the minimum element\n            alice_move = nums.pop(0)  # Bob removes the next minimum element\n            arr.append(bob_move)  # Bob appends his removed element\n            arr.append(alice_move)  # Alice appends her removed element\n        return arr"
        ]
    },
    {
        "question_id": "3227",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid)\n        nums = [0] * (n * n + 1)\n        for row in grid:\n            for num in row:\n                nums[num] += 1\n        repeated = missing = -1\n        for i in range(1, n * n + 1):\n            if nums[i] == 2:\n                repeated = i\n            elif nums[i] == 0:\n                missing = i\n        return [repeated, missing]"
        ]
    },
    {
        "question_id": "3228",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        half = n // 2\n        \n        count1, count2 = Counter(nums1), Counter(nums2)\n        common = (count1 & count2).values()\n        \n        unique1, unique2 = len(count1) - sum(common), len(count2) - sum(common)\n        \n        max_remove1 = min(half, unique1)\n        max_remove2 = min(half, unique2)\n        \n        remaining1 = unique1 - max_remove1\n        remaining2 = unique2 - max_remove2\n        \n        common_count = sum(common)\n        \n        # If there are enough unique elements in both lists, we can take all of them\n        if remaining1 + remaining2 + common_count >= half:\n            return half\n        \n        # Otherwise, we take as many unique elements as possible\n        return remaining1 + remaining2 + common_count"
        ]
    },
    {
        "question_id": "3229",
        "code_list": [
            "from typing import List\nfrom bisect import bisect_left\n\ndef is_palindrome(num: int) -> bool:\n    return str(num) == str(num)[::-1]\n\ndef nearest_palindrome(num: int) -> int:\n    s = str(num)\n    n = len(s)\n    half = s[:n // 2]\n    if n % 2 == 0:\n        left_half = half\n        right_half = half[::-1]\n    else:\n        left_half = half[:-1]\n        right_half = half[-1::-1]\n    \n    candidate1 = int(left_half + right_half)\n    candidate2 = int(left_half + right_half[:-1] + str(int(right_half[-1]) + 1))\n    \n    if candidate1 < num:\n        return min(candidate1, candidate2, key=lambda x: abs(x - num))\n    else:\n        return max(candidate1, candidate2, key=lambda x: abs(x - num))\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        nums.sort()\n        median = nums[len(nums) // 2]\n        candidate1 = nearest_palindrome(median)\n        candidate2 = nearest_palindrome(median - 1) if median != 1 else 1\n        \n        cost1 = sum(abs(num - candidate1) for num in nums)\n        cost2 = sum(abs(num - candidate2) for num in nums)\n        \n        return min(cost1, cost2)"
        ]
    },
    {
        "question_id": "3230",
        "code_list": [
            "class Solution:\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        operations = 0\n        i = 0\n        while i < len(word) - 1:\n            if abs(ord(word[i]) - ord(word[i + 1])) <= 1:\n                operations += 1\n                i += 2\n            else:\n                i += 1\n        return operations"
        ]
    },
    {
        "question_id": "3231",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        added_coins = 0\n        max_reachable = 0\n        coins.sort()\n        \n        for coin in coins:\n            # While max_reachable < coin - 1, we need to add coins to cover the gap\n            while max_reachable + 1 < coin:\n                max_reachable += max_reachable + 1\n                added_coins += 1\n                if max_reachable >= target:\n                    return added_coins\n            \n            max_reachable += coin\n            if max_reachable >= target:\n                return added_coins\n        \n        # If there are still values between max_reachable and target, add coins to cover them\n        while max_reachable < target:\n            max_reachable += max_reachable + 1\n            added_coins += 1\n        \n        return added_coins"
        ]
    },
    {
        "question_id": "3233",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n        def count_partitions(s, k):\n            partitions = 0\n            i = 0\n            while i < len(s):\n                distinct_count = len(set(s[i:i+100]))  # Check up to 100 characters for efficiency\n                if distinct_count > k:\n                    partitions += 1\n                    i += distinct_count  # Skip the current segment\n                else:\n                    i += 1\n            return partitions + 1\n        \n        max_partitions = count_partitions(s, k)\n        for i in range(len(s)):\n            for new_char in 'abcdefghijklmnopqrstuvwxyz':\n                if new_char != s[i]:\n                    new_s = s[:i] + new_char + s[i+1:]\n                    max_partitions = max(max_partitions, count_partitions(new_s, k))\n        \n        return max_partitions"
        ]
    },
    {
        "question_id": "3234",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        good_indices = []\n        for i, (a, b, c, m) in enumerate(variables):\n            result = pow(pow(a, b, 10), c, m)\n            if result == target:\n                good_indices.append(i)\n        return good_indices"
        ]
    },
    {
        "question_id": "3235",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:\n        # Create a graph to store the relationships between characters\n        graph = defaultdict(dict)\n        for orig, chng, c in zip(original, changed, cost):\n            if chng not in graph[orig]:\n                graph[orig][chng] = c\n            else:\n                graph[orig][chng] = min(graph[orig][chng], c)\n        \n        # Dijkstra's algorithm to find the shortest path (minimum cost) between characters\n        def dijkstra(start_char):\n            distances = {char: float('inf') for char in graph}\n            distances[start_char] = 0\n            priority_queue = [(0, start_char)]\n            \n            while priority_queue:\n                current_cost, current_char = heapq.heappop(priority_queue)\n                \n                if current_char not in graph:\n                    continue\n                \n                for neighbor, edge_cost in graph[current_char].items():\n                    new_cost = current_cost + edge_cost\n                    if new_cost < distances[neighbor]:\n                        distances[neighbor] = new_cost\n                        heapq.heappush(priority_queue, (new_cost, neighbor))\n            \n            return distances\n        \n        total_cost = 0\n        for src_char, tgt_char in zip(source, target):\n            if src_char != tgt_char:\n                distances = dijkstra(src_char)\n                if tgt_char not in distances or distances[tgt_char] == float('inf'):\n                    return -1\n                total_cost += distances[tgt_char]\n        \n        return total_cost"
        ]
    },
    {
        "question_id": "3236",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def missingInteger(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 1\n        \n        # Find the longest sequential prefix\n        sequential_sum = nums[0]\n        for i in range(1, n):\n            if nums[i] == nums[i - 1] + 1:\n                sequential_sum += nums[i]\n            else:\n                break\n        \n        # Find the smallest missing integer greater than or equal to the sum of the longest sequential prefix\n        current = sequential_sum\n        while current in nums:\n            current += 1\n        \n        return current"
        ]
    },
    {
        "question_id": "3239",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:\n        queue = deque([(x, 0)])\n        visited = set([x])\n        \n        while queue:\n            current, steps = queue.popleft()\n            if current == y:\n                return steps\n            \n            # Decrement x by 1\n            new_val = current - 1\n            if new_val not in visited:\n                visited.add(new_val)\n                queue.append((new_val, steps + 1))\n            \n            # Increment x by 1\n            new_val = current + 1\n            if new_val not in visited:\n                visited.add(new_val)\n                queue.append((new_val, steps + 1))\n            \n            # Divide x by 11 if x is a multiple of 11\n            if current % 11 == 0 and current // 11 not in visited:\n                visited.add(current // 11)\n                queue.append((current // 11, steps + 1))\n            \n            # Divide x by 5 if x is a multiple of 5\n            if current % 5 == 0 and current // 5 not in visited:\n                visited.add(current // 5)\n                queue.append((current // 5, steps + 1))\n        \n        return -1  # This line should theoretically never be reached given the constraints"
        ]
    },
    {
        "question_id": "3240",
        "code_list": [
            "class Solution:\n    def findMaximumNumber(self, k: int, x: int) -> int:\n        def count_set_bits_in_range(n, x):\n            count = 0\n            for i in range(x - 1, n + 1, x):\n                count += (n // (1 << i)) + 1\n            return count\n        \n        low, high = 1, k\n        while low < high:\n            mid = (low + high + 1) // 2\n            if count_set_bits_in_range(mid, x) > k:\n                high = mid - 1\n            else:\n                low = mid\n        return low"
        ]
    },
    {
        "question_id": "3242",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        freq_counter = Counter(nums)\n        max_freq = max(freq_counter.values())\n        return sum(count for count in freq_counter.values() if count == max_freq)"
        ]
    },
    {
        "question_id": "3243",
        "code_list": [
            "from math import log10, ceil\n\nclass Solution:\n    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:\n        def count_numbers(n, k):\n            if n < len(s):\n                return 0\n            prefix = str(n)[:len(str(n)) - len(s)]\n            suffix = str(n)[-len(s):]\n            if suffix != s:\n                return 0\n            count = 0\n            for i in range(len(prefix)):\n                count += min(k, int(prefix[i])) * (k ** (len(prefix) - i - 1))\n            count += 1  # Include the number itself\n            if int(prefix) > k:\n                count -= k ** (len(prefix))\n            return count\n        \n        start_str = str(start)\n        finish_str = str(finish)\n        start_suffix = start_str[-len(s):]\n        finish_suffix = finish_str[-len(s):]\n        \n        if start_suffix != s:\n            start_count = count_numbers(int(start_str[:-len(s)] + s), limit)\n        else:\n            start_count = 0\n        \n        finish_count = count_numbers(finish, limit)\n        \n        return finish_count - start_count"
        ]
    },
    {
        "question_id": "3244",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        min_val = min(nums)\n        count_min = nums.count(min_val)\n        \n        for num in nums:\n            if min_val != 0 and num % min_val != 0:\n                return 1\n        return max(1, count_min - 1)"
        ]
    },
    {
        "question_id": "3245",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        a_indices = []\n        b_indices = []\n        \n        # Find all indices where substring 'a' starts in 's'\n        for i in range(len(s) - len(a) + 1):\n            if s[i:i+len(a)] == a:\n                a_indices.append(i)\n        \n        # Find all indices where substring 'b' starts in 's'\n        for i in range(len(s) - len(b) + 1):\n            if s[i:i+len(b)] == b:\n                b_indices.append(i)\n        \n        beautiful_indices = []\n        \n        # Check each 'a' index to see if there's a matching 'b' index within the distance k\n        for ai in a_indices:\n            for bi in b_indices:\n                if abs(ai - bi) <= k:\n                    beautiful_indices.append(ai)\n                    break\n        \n        return sorted(set(beautiful_indices))"
        ]
    },
    {
        "question_id": "3246",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if (nums[i] | nums[j]) & 1 == 0:\n                    return True\n        return False"
        ]
    },
    {
        "question_id": "3249",
        "code_list": [
            "from functools import reduce\nfrom operator import xor\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        target_xor = k\n        current_xor = reduce(xor, nums, 0)\n        return bin(target_xor ^ current_xor).count('1')"
        ]
    },
    {
        "question_id": "3251",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -> int:\n        max_area = 0\n        max_diagonal_squared = 0\n        \n        for length, width in dimensions:\n            diagonal_squared = length ** 2 + width ** 2\n            area = length * width\n            \n            if diagonal_squared > max_diagonal_squared or (diagonal_squared == max_diagonal_squared and area > max_area):\n                max_diagonal_squared = diagonal_squared\n                max_area = area\n        \n        return max_area"
        ]
    },
    {
        "question_id": "3252",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        n = len(nums)\n        left, right = 0, n - 1\n        \n        # Find the first index from the left where nums is not strictly increasing\n        while left < n - 1 and nums[left] < nums[left + 1]:\n            left += 1\n        \n        # If the whole array is already strictly increasing\n        if left == n - 1:\n            return (n * (n + 1)) // 2\n        \n        # Find the first index from the right where nums is not strictly increasing\n        while right > 0 and nums[right - 1] < nums[right]:\n            right -= 1\n        \n        count = 0\n        # Count all single element subarrays\n        count += n\n        \n        # Count subarrays starting from the beginning\n        for i in range(n):\n            if i > 0 and nums[i - 1] >= nums[i]:\n                break\n            count += n - i\n        \n        # Count subarrays ending at the end\n        for i in range(n - 1, -1, -1):\n            if i < n - 1 and nums[i] <= nums[i + 1]:\n                break\n            count += i + 1\n        \n        # Count subarrays that start before 'left' and end after 'right'\n        for i in range(left + 1):\n            j = bisect_right(nums, nums[i], lo=right)\n            count += max(0, j - right)\n        \n        return count"
        ]
    },
    {
        "question_id": "3261",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOrAfterOperations(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        # Precompute the prefix OR and suffix OR for each bit position\n        prefix_or = [0] * (n + 1)\n        suffix_or = [0] * (n + 1)\n        for i in range(n):\n            prefix_or[i + 1] = prefix_or[i] | nums[i]\n        for i in range(n - 1, -1, -1):\n            suffix_or[i] = suffix_or[i + 1] | nums[i]\n        \n        # Check if we can reduce the OR value to a specific bit pattern\n        def can_reduce_to(bit_mask):\n            operations = 0\n            for i in range(1, n + 1):\n                if prefix_or[i - 1] & bit_mask == 0 and suffix_or[i] & bit_mask != 0:\n                    operations += 1\n            return operations <= k\n        \n        # Try all possible bit patterns from 0 to (1 << 30) - 1\n        min_or_value = (1 << 30) - 1\n        for bit_mask in range(1 << 30):\n            if can_reduce_to(bit_mask):\n                min_or_value = min(min_or_value, bit_mask)\n        \n        return min_or_value"
        ]
    },
    {
        "question_id": "3262",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort(reverse=True)\n        for i in range(len(nums) - 2):\n            if nums[i] < nums[i + 1] + nums[i + 2]:\n                return nums[i] + nums[i + 1] + nums[i + 2]\n        return -1"
        ]
    },
    {
        "question_id": "3263",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, nums: List[int]) -> int:\n        # The cost of the first subarray is always the first element of the array\n        first_cost = nums[0]\n        # Find the two smallest elements from the rest of the array\n        min1, min2 = float('inf'), float('inf')\n        for num in nums[1:]:\n            if num < min1:\n                min1, min2 = num, min1\n            elif num < min2:\n                min2 = num\n        # Return the sum of the first element and the two smallest elements\n        return first_cost + min1 + min2"
        ]
    },
    {
        "question_id": "3265",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\n        prefix_sum = 0\n        max_sum = float('-inf')\n        index_map = defaultdict(lambda: float('inf'))\n        index_map[0] = -1\n        \n        for i, num in enumerate(nums):\n            prefix_sum += num\n            # Check for both conditions where abs(nums[i] - nums[j]) == k\n            if num + k in index_map:\n                max_sum = max(max_sum, prefix_sum - index_map[num + k])\n            if num - k in index_map:\n                max_sum = max(max_sum, prefix_sum - index_map[num - k])\n            \n            # Update the prefix sum with the minimum value encountered so far\n            index_map[prefix_sum] = min(index_map[prefix_sum], i)\n        \n        return max_sum if max_sum != float('-inf') else 0"
        ]
    },
    {
        "question_id": "3267",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maximumLength(self, s: str) -> int:\n        n = len(s)\n        count = defaultdict(list)\n        \n        # Find all special substrings and their lengths\n        i = 0\n        while i < n:\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            count[s[i]].append(j - i)\n            i = j\n        \n        max_length = -1\n        for lengths in count.values():\n            lengths.sort(reverse=True)\n            if len(lengths) >= 3:\n                max_length = max(max_length, lengths[2])\n            elif len(lengths) == 2:\n                max_length = max(max_length, min(lengths[0], lengths[1]) - 1)\n            elif lengths:\n                max_length = max(max_length, lengths[0] - 2)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3269",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countMatchingSubarrays(self, nums: List[int], pattern: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        m = len(pattern)\n        \n        for i in range(n - m):\n            matches = True\n            for k in range(m):\n                if pattern[k] == 1 and nums[i + k + 1] <= nums[i + k]:\n                    matches = False\n                    break\n                elif pattern[k] == 0 and nums[i + k + 1] != nums[i + k]:\n                    matches = False\n                    break\n                elif pattern[k] == -1 and nums[i + k + 1] >= nums[i + k]:\n                    matches = False\n                    break\n            if matches:\n                count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3279",
        "code_list": [
            "class Solution:\n    def flowerGame(self, n: int, m: int) -> int:\n        def count_odd_even(num):\n            odd = (num + 1) // 2\n            even = num // 2\n            return odd, even\n        \n        odd_n, even_n = count_odd_even(n)\n        odd_m, even_m = count_odd_even(m)\n        \n        # Alice wins if she can always pick a flower when it's her turn\n        # This happens when the total number of flowers is odd\n        total_odd_ways = odd_n * even_m + even_n * odd_m\n        \n        return total_odd_ways"
        ]
    },
    {
        "question_id": "3291",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        n = len(nums)\n        for i in range(n - 1):\n            while i < n - 1 and nums[i] > nums[i + 1]:\n                if bin(nums[i]).count('1') != bin(nums[i + 1]).count('1'):\n                    return False\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n                i -= 1\n                i = max(i, 0)\n        return True"
        ]
    },
    {
        "question_id": "3292",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n, m = len(nums), len(changeIndices)\n        last_occurrence = [-1] * (n + 1)\n        \n        for s, index in enumerate(changeIndices):\n            last_occurrence[index] = s\n        \n        def can_mark_all_in_seconds(t):\n            indegree = [0] * (n + 1)\n            time_needed = [0] * (n + 1)\n            queue = []\n            \n            for i in range(1, n + 1):\n                if last_occurrence[i] < t:\n                    time_needed[i] = nums[i - 1] + 1\n                    indegree[i] = 1\n                    if last_occurrence[i] != -1:\n                        queue.append(i)\n            \n            while queue:\n                curr = queue.pop(0)\n                for i in range(1, n + 1):\n                    if last_occurrence[i] > last_occurrence[curr]:\n                        indegree[i] -= 1\n                        if indegree[i] == 0:\n                            time_needed[i] = max(time_needed[i], time_needed[curr] + nums[i - 1] + 1)\n                            if last_occurrence[i] != -1:\n                                queue.append(i)\n            \n            return all(x <= t for x in time_needed[1:])\n        \n        left, right = 1, m\n        result = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if can_mark_all_in_seconds(mid):\n                result = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3297",
        "code_list": [
            "class Solution:\n    def minimumTimeToInitialState(self, word: str, k: int) -> int:\n        length = len(word)\n        time = 1\n        while True:\n            if word.startswith(word[k:]):\n                return time\n            time += 1\n            if k * time >= length:\n                return time"
        ]
    },
    {
        "question_id": "3298",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxSelectedElements(self, nums: List[int]) -> int:\n        nums.sort()\n        count = Counter(nums)\n        dp = {}\n\n        def dfs(index, prev):\n            if index == len(nums):\n                return 0\n            if (index, prev) in dp:\n                return dp[(index, prev)]\n            take = 0\n            if prev == 0 or nums[index] == prev + 1 or (nums[index] - 1 in count and count[nums[index] - 1] > 0):\n                take = 1 + dfs(index + 1, nums[index])\n            skip = dfs(index + 1, prev)\n            dp[(index, prev)] = max(take, skip)\n            return dp[(index, prev)]\n\n        return dfs(0, 0)"
        ]
    },
    {
        "question_id": "3299",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        num_counts = Counter(nums)\n        max_length = 1\n        \n        for num in num_counts:\n            if num == 1:\n                # Special case for 1, as 1^\u4efb\u4f55\u5e42\u6b21\u65b9\u90fd\u7b49\u4e8e1\n                length = 2 * num_counts[1] - (num_counts[1] % 2 == 0)\n                max_length = max(max_length, length)\n            else:\n                current_length = 0\n                while num_counts[num] > 1 and num_counts[num**2]:\n                    num_counts[num] -= 2\n                    num = num**2\n                    current_length += 2\n                if num_counts[num] >= 1:\n                    current_length += 1\n                max_length = max(max_length, current_length)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3308",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def lastNonEmptyString(self, s: str) -> str:\n        char_indices = {char: [] for char in set(s)}\n        for index, char in enumerate(s):\n            char_indices[char].append(index)\n        \n        max_count = max(Counter(s).values())\n        result = []\n        for char in reversed(sorted(char_indices.keys(), key=lambda x: -ord(x))):\n            if len(char_indices[char]) == max_count:\n                result.append(char)\n                char_indices[char].pop()\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "3309",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -> int:\n        def isPrefixAndSuffix(str1: str, str2: str) -> bool:\n            return str2.startswith(str1) and str2.endswith(str1)\n        \n        count = 0\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if isPrefixAndSuffix(words[i], words[j]):\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3311",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def returnToBoundaryCount(self, nums: List[int]) -> int:\n        position = 0\n        boundary_count = 0\n        \n        for num in nums:\n            position += num\n            if position == 0:\n                boundary_count += 1\n        \n        return boundary_count"
        ]
    },
    {
        "question_id": "3312",
        "code_list": [
            "class Solution:\n    def countKeyChanges(self, s: str) -> int:\n        count = 0\n        prev_char = s[0].lower()\n        for char in s[1:]:\n            current_char = char.lower()\n            if current_char != prev_char:\n                count += 1\n                prev_char = current_char\n        return count"
        ]
    },
    {
        "question_id": "3317",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxPalindromesAfterOperations(self, words: List[str]) -> int:\n        # Count the frequency of each character in all words\n        char_count = Counter()\n        for word in words:\n            char_count.update(word)\n        \n        # Calculate the number of pairs of characters\n        pairs = sum(count // 2 for count in char_count.values())\n        \n        # Sort the lengths of the words\n        word_lengths = sorted(len(word) for word in words)\n        \n        # Try to form as many palindromes as possible\n        result = 0\n        for length in word_lengths:\n            # A palindrome of length `n` needs `n // 2` pairs of characters\n            needed_pairs = length // 2\n            if pairs >= needed_pairs:\n                pairs -= needed_pairs\n                result += 1\n            else:\n                break\n        \n        return result"
        ]
    },
    {
        "question_id": "3320",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        if len(nums) < 2:\n            return 0\n        \n        target_score = nums[0] + nums[1]\n        count = 0\n        \n        i = 0\n        while i < len(nums) - 1:\n            if nums[i] + nums[i + 1] == target_score:\n                count += 1\n                i += 2\n            else:\n                break\n        \n        return count"
        ]
    },
    {
        "question_id": "3324",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def isPossibleToSplit(self, nums: List[int]) -> bool:\n        count = Counter(nums)\n        for value in count.values():\n            if value > 2:\n                return False\n        return True"
        ]
    },
    {
        "question_id": "3329",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:\n        def get_prefixes(num):\n            prefixes = set()\n            for i in range(len(str(num))):\n                prefixes.add(int(str(num)[:i+1]))\n            return prefixes\n        \n        max_length = 0\n        prefixes_arr1 = {num: get_prefixes(num) for num in arr1}\n        prefixes_arr2 = {num: get_prefixes(num) for num in arr2}\n        \n        for num1 in prefixes_arr1:\n            for num2 in prefixes_arr2:\n                common_prefixes = prefixes_arr1[num1].intersection(prefixes_arr2[num2])\n                if common_prefixes:\n                    max_length = max(max_length, max(common_prefixes).bit_length())\n        \n        return max_length - 1 if max_length else 0"
        ]
    },
    {
        "question_id": "3331",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        count = 0\n        while min(nums) < k:\n            nums.remove(min(nums))\n            count += 1\n        return count"
        ]
    },
    {
        "question_id": "3347",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def resultArray(self, nums: List[int]) -> List[int]:\n        arr1, arr2 = [nums[0]], [nums[1]]\n        for i in range(2, len(nums)):\n            if arr1[-1] > arr2[-1]:\n                arr1.append(nums[i])\n            else:\n                arr2.append(nums[i])\n        return arr1 + arr2"
        ]
    },
    {
        "question_id": "abc301_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    \n    taka_wins = S.count('T')\n    aoki_wins = S.count('A')\n    \n    if taka_wins > aoki_wins:\n        print('T')\n    elif aoki_wins > taka_wins:\n        print('A')\n    else:\n        # Check who reached the number of wins first\n        if S.index('T') < S.rindex('A'):\n            print('T')\n        else:\n            print('A')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def insert_sequence(A):\n        i = 0\n        while True:\n            for i in range(len(A) - 1):\n                if abs(A[i] - A[i + 1]) == 1:\n                    continue\n                if A[i] < A[i + 1]:\n                    A = A[:i + 1] + list(range(A[i] + 1, A[i + 1])) + A[i + 1:]\n                else:\n                    A = A[:i + 1] + list(range(A[i], A[i + 1], -1)) + A[i + 1:]\n                break\n            else:\n                break\n        return A\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    result = insert_sequence(A)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_c",
        "code_list": [
            "def main():\n    from collections import Counter\n\n    S = input().strip()\n    T = input().strip()\n\n    # Count the frequency of each character in both strings\n    count_S = Counter(S)\n    count_T = Counter(T)\n\n    # Count the frequency of '@' in both strings\n    at_S = count_S['@']\n    at_T = count_T['@']\n\n    # Remove '@' from the counts\n    del count_S['@']\n    del count_T['@']\n\n    # Check if we can make the two strings equal by replacing '@'\n    for char in set(S + T):\n        if (count_S.get(char, 0) - count_T.get(char, 0)) > at_T or \\\n           (count_T.get(char, 0) - count_S.get(char, 0)) > at_S:\n            print(\"No\")\n            return\n\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_d",
        "code_list": [
            "def main():\n    import re\n    \n    def max_binary_value(S, N):\n        max_val = -1\n        for i in range(2 ** S.count('?')):\n            binary_str = bin(i)[2:].zfill(S.count('?'))\n            temp_str = S\n            for j, char in enumerate(binary_str):\n                temp_str = temp_str[:j] + char + temp_str[j+1:]\n            val = int(temp_str, 2)\n            if val <= N:\n                max_val = max(max_val, val)\n        return max_val\n    \n    S = input().strip()\n    N = int(input())\n    \n    print(max_binary_value(S, N))"
        ]
    },
    {
        "question_id": "abc301_e",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start, goal):\n    H, W = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[False] * W for _ in range(H)]\n    queue = deque([(start[0], start[1], 0, set())])\n    max_candies = -1\n    \n    while queue:\n        x, y, moves, candies = queue.popleft()\n        \n        if (x, y) == goal:\n            max_candies = max(max_candies, len(candies))\n            continue\n        \n        if moves > 0 and moves > max_candies + (goal[0] - x)**2 + (goal[1] - y)**2:\n            break\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] != '#' and not visited[nx][ny]:\n                visited[nx][ny] = True\n                new_candies = candies.copy()\n                if grid[nx][ny] == 'o':\n                    new_candies.add((nx, ny))\n                queue.append((nx, ny, moves + 1, new_candies))\n    \n    return max_candies\n\ndef main():\n    H, W, T = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    start = None\n    goal = None\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n    \n    result = bfs(grid, start, goal)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc301_f",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    S = input().strip()\n    n = len(S)\n    count_q = S.count('?')\n    count_D = S.count('D')\n    count_A = S.count('A')\n    count_d = S.count('d')\n    \n    # Calculate the total number of ways to replace '?' without forming a DDoS-type string\n    total_ways = pow(52, count_q, 998244353)\n    \n    # Calculate the number of invalid ways (containing a DDoS-type string)\n    invalid_ways = 0\n    \n    # Iterate over all possible positions for '?'\n    for i in range(count_q):\n        for j in range(i + 1, count_q + 1):\n            # Generate a new string with '?' replaced by specific characters\n            new_S = S[:i] + 'A' * (j - i) + 'd' * (count_q - j) + S[j:]\n            # Check if the new string contains a DDoS-type substring\n            if 'DD' in new_S or 'AAaA' in new_S or 'DDaA' in new_S or 'AAad' in new_S:\n                invalid_ways += 1\n    \n    # Subtract the invalid ways from the total ways\n    valid_ways = (total_ways - invalid_ways) % 998244353\n    \n    print(valid_ways)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    print((-A + B - 1) // B)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_b",
        "code_list": [
            "def find_sequence(H, W, grid):\n    directions = [\n        (0, 1), (1, 1), (1, 0), (1, -1),\n        (0, -1), (-1, -1), (-1, 0), (-1, 1)\n    ]\n    \n    def check_path(start_row, start_col, direction):\n        r, c = start_row, start_col\n        for letter in 'snuke':\n            if not (0 <= r < H and 0 <= c < W and grid[r][c] == letter):\n                return False\n            r += direction[0]\n            c += direction[1]\n        return True\n    \n    for row in range(H):\n        for col in range(W):\n            if grid[row][col] == 's':\n                for direction in directions:\n                    r, c = row + direction[0], col + direction[1]\n                    if 0 <= r < H and 0 <= c < W and grid[r][c] == 'n':\n                        if check_path(r, c, direction):\n                            path = [(r, c)]\n                            for _ in range(3):\n                                r += direction[0]\n                                c += direction[1]\n                                path.append((r, c))\n                            if grid[r][c] == 'e':\n                                return path + [(row, col)]\n    \n    return []\n\ndef main():\n    H, W = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    result = find_sequence(H, W, grid)\n    for r, c in result:\n        print(r + 1, c + 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc302_c",
        "code_list": [
            "from collections import Counter\n\ndef can_rearrange_strings(N, M, strings):\n    # Count the frequency of each character in each position\n    char_counts = [Counter(s[i] for s in strings) for i in range(M)]\n    \n    # Check if we can form a valid sequence\n    for i in range(1, N):\n        diff_count = 0\n        for j in range(M):\n            if strings[i][j] != strings[i-1][j]:\n                diff_count += 1\n                if diff_count > 1:\n                    return False\n                if char_counts[j][strings[i-1][j]] < char_counts[j][strings[i][j]]:\n                    return False\n        if diff_count == 0:\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    strings = [input().strip() for _ in range(N)]\n    result = \"Yes\" if can_rearrange_strings(N, M, strings) else \"No\"\n    print(result)"
        ]
    },
    {
        "question_id": "abc302_d",
        "code_list": [
            "def find_max_sum(N, M, D, A, B):\n    # Sort the lists to facilitate binary search\n    A.sort()\n    B.sort()\n    \n    max_sum = -1\n    \n    # Iterate through each element in A\n    for a in A:\n        # Use binary search to find the largest element in B that satisfies the condition\n        left, right = 0, M - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if a + B[mid] <= D:\n                max_sum = max(max_sum, a + B[mid])\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return max_sum\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    D = int(data[2])\n    A = list(map(int, data[3:N+3]))\n    B = list(map(int, data[N+3:]))\n    \n    result = find_max_sum(N, M, D, A, B)\n    print(result)"
        ]
    },
    {
        "question_id": "abc302_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    # Read input\n    N, Q = map(int, input().split())\n    \n    # Initialize data structures\n    adjacency_list = defaultdict(set)\n    degree = [0] * (N + 1)\n    isolated_vertices = set(range(1, N + 1))\n    \n    def update_isolated_vertices():\n        nonlocal isolated_vertices\n        isolated_vertices = {v for v in range(1, N + 1) if degree[v] == 0}\n    \n    update_isolated_vertices()\n    \n    # Process queries\n    for _ in range(Q):\n        query_type, *args = map(int, input().split())\n        if query_type == 1:\n            u, v = args\n            adjacency_list[u].add(v)\n            adjacency_list[v].add(u)\n            degree[u] += 1\n            degree[v] += 1\n            update_isolated_vertices()\n        elif query_type == 2:\n            v = args[0]\n            for neighbor in adjacency_list[v]:\n                degree[neighbor] -= 1\n                adjacency_list[neighbor].remove(v)\n            adjacency_list[v].clear()\n            degree[v] = 0\n            update_isolated_vertices()\n        \n        # Print the number of isolated vertices\n        print(len(isolated_vertices))"
        ]
    },
    {
        "question_id": "abc302_f",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    sets = []\n    for _ in range(N):\n        A_i = int(input())\n        sets.append(set(map(int, input().split())))\n    \n    # Initialize the union-find structure\n    parent = list(range(M + 1))\n    size = [1] * (M + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if size[rootX] < size[rootY]:\n                rootX, rootY = rootY, rootX\n            parent[rootY] = rootX\n            size[rootX] += size[rootY]\n    \n    # Union all sets that have at least one common element\n    for s in sets:\n        for elem in s:\n            for other in sets:\n                if s & other:\n                    union(elem, min(other))\n    \n    # Check if 1 and M are connected\n    root1 = find(1)\n    rootM = find(M)\n    if root1 == rootM:\n        # Find the minimum number of operations\n        operations = 0\n        for s in sets:\n            if 1 in s and M in s:\n                break\n            elif 1 in s or M in s:\n                operations += 1\n        else:\n            operations = -1\n        print(operations)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc303_a",
        "code_list": [
            "def are_similar_strings(S: str, T: str) -> bool:\n    for x, y in zip(S, T):\n        if x != y and (x not in 'lo' or y not in 'lo1' or (x != 'o' and y != 'l') and (x != 'l' and y != '0')):\n            return False\n    return True\n\ndef main():\n    N = int(input())\n    S = input().strip()\n    T = input().strip()\n    if are_similar_strings(S, T):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc303_b",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    N, M = map(int, input().split())\n    photos = [list(map(int, input().split())) for _ in range(M)]\n    \n    # Find all pairs that are not adjacent in any photo\n    bad_mood_pairs = set()\n    for photo in photos:\n        for i in range(N - 1):\n            if abs(photo[i] - photo[i + 1]) > 1:\n                bad_mood_pairs.add(tuple(sorted((photo[i], photo[i + 1]))))\n    \n    # Count unique pairs\n    result = len(bad_mood_pairs)\n    print(result)"
        ]
    },
    {
        "question_id": "abc303_c",
        "code_list": [
            "def can_complete_moves(N, M, H, K, S, items):\n    health = H\n    position = [0, 0]\n    \n    for i in range(N):\n        # Move based on direction\n        if S[i] == 'R':\n            position[0] += 1\n        elif S[i] == 'L':\n            position[0] -= 1\n        elif S[i] == 'U':\n            position[1] += 1\n        elif S[i] == 'D':\n            position[1] -= 1\n        \n        # Decrease health\n        health -= 1\n        \n        # Check if health is negative\n        if health <= 0:\n            return \"No\"\n        \n        # Check if an item is at the new position and health is less than K\n        for item in items:\n            if position == item[:2] and health < K:\n                health = K\n                break\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N, M, H, K = map(int, input().split())\n    S = input()\n    items = [list(map(int, input().split())) for _ in range(M)]\n    \n    result = can_complete_moves(N, M, H, K, S, items)\n    print(result)"
        ]
    },
    {
        "question_id": "abc303_d",
        "code_list": [
            "def main():\n    import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    X = int(data[0])\n    Y = int(data[1])\n    Z = int(data[2])\n    S = data[3]\n    \n    length = len(S)\n    ans = 0\n    \n    for i in range(length):\n        if i == 0:\n            if S[i] == 'A':\n                ans += Z + X\n            else:\n                ans += X\n        else:\n            if S[i] != S[i - 1]:\n                if S[i] == 'A' and S[i - 1] == 'a':\n                    ans += Z + X\n                elif S[i] == 'a' and S[i - 1] == 'A':\n                    ans += Z + Y\n                else:\n                    ans += min(X, Y)\n            else:\n                if S[i] == 'A':\n                    ans += X\n                else:\n                    ans += Y\n    \n    print(ans)"
        ]
    },
    {
        "question_id": "abc303_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef find_root(parent, node):\n    while parent[node] != node:\n        node = parent[node]\n    return node\n\ndef union(parent, rank, x, y):\n    rootX = find_root(parent, x)\n    rootY = find_root(parent, y)\n    if rank[rootX] < rank[rootY]:\n        parent[rootX] = rootY\n    elif rank[rootX] > rank[rootY]:\n        parent[rootY] = rootX\n    else:\n        parent[rootY] = rootX\n        rank[rootX] += 1\n\ndef get_levels(n, edges):\n    # Initialize parent and rank for union-find\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    \n    # Process edges to form the tree\n    for u, v in edges:\n        union(parent, rank, u, v)\n    \n    # Find the root of each node\n    roots = [find_root(parent, i) for i in range(1, n + 1)]\n    \n    # Count the number of nodes under each root\n    root_count = defaultdict(int)\n    for root in roots:\n        root_count[root] += 1\n    \n    # Calculate the levels of the stars\n    levels = []\n    for count in root_count.values():\n        if count > 1:\n            levels.append(count - 1)\n    \n    # Sort and return the levels\n    levels.sort()\n    return levels\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    for i in range(1, len(data), 2):\n        u, v = int(data[i]), int(data[i + 1])\n        edges.append((u, v))\n    \n    levels = get_levels(n, edges)\n    print(\" \".join(map(str, levels)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_a",
        "code_list": [
            "def main():\n    N = int(input())\n    people = []\n    \n    for _ in range(N):\n        name, age = input().split()\n        age = int(age)\n        people.append((name, age))\n    \n    # Find the index of the youngest person\n    youngest_index = min(range(N), key=lambda i: people[i][1])\n    \n    # Print names in clockwise order starting from the youngest person\n    for i in range(N):\n        print(people[(youngest_index + i) % N][0])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_b",
        "code_list": [
            "def main():\n    N = int(input())\n    if N <= 10**3 - 1:\n        print(N)\n    elif N <= 10**4 - 1:\n        print(N // 10)\n    elif N <= 10**5 - 1:\n        print(N // 100)\n    elif N <= 10**6 - 1:\n        print(N // 1000)\n    elif N <= 10**7 - 1:\n        print(N // 10000)\n    elif N <= 10**8 - 1:\n        print(N // 100000)\n    else:\n        print(N // 1000000)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_c",
        "code_list": [
            "import math\n\ndef euclidean_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef is_infected(N, D, positions):\n    infected = [False] * N\n    infected[0] = True  # Person 1 is initially infected\n    \n    queue = [0]\n    while queue:\n        current = queue.pop(0)\n        for i in range(N):\n            if not infected[i] and euclidean_distance(positions[current], positions[i]) <= D:\n                infected[i] = True\n                queue.append(i)\n    \n    result = []\n    for i in range(N):\n        result.append(\"Yes\" if infected[i] else \"No\")\n    \n    return result\n\ndef main():\n    N, D = map(int, input().split())\n    positions = [tuple(map(int, input().split())) for _ in range(N)]\n    results = is_infected(N, D, positions)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_d",
        "code_list": [
            "def main():\n    W, H = map(int, input().split())\n    N = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n    A = int(input())\n    vertical_lines = sorted(set(map(int, input().split())))\n    B = int(input())\n    horizontal_lines = sorted(set(map(int, input().split())))\n\n    # Add boundary lines for easier calculation\n    vertical_lines = [0] + vertical_lines + [W]\n    horizontal_lines = [0] + horizontal_lines + [H]\n\n    # Calculate the minimum and maximum number of strawberries\n    min_strawberries = float('inf')\n    max_strawberries = 0\n\n    for i in range(1, len(vertical_lines)):\n        for j in range(1, len(horizontal_lines)):\n            # Count strawberries in this piece\n            count = sum((vertical_lines[i-1] < point[0] < vertical_lines[i]) and (horizontal_lines[j-1] < point[1] < horizontal_lines[j]) for point in points)\n            min_strawberries = min(min_strawberries, count)\n            max_strawberries = max(max_strawberries, count)\n\n    print(min_strawberries, max_strawberries)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc304_e",
        "code_list": [
            "from collections import defaultdict\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent, rank):\n    rootX = find(x, parent)\n    rootY = find(y, parent)\n    if rootX != rootY:\n        if rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        elif rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef is_good_graph(n, edges, k, blocked_edges, new_edges):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    # Union-Find to check connectivity before adding new edges\n    for u, v in edges:\n        union(u, v, parent, rank)\n\n    # Check if any of the blocked edges are connected\n    for x, y in blocked_edges:\n        if find(x, parent) == find(y, parent):\n            return \"No\"\n\n    # Add new edges and check connectivity again\n    for u, v in new_edges:\n        union(u, v, parent, rank)\n    \n    for u, v in new_edges:\n        if find(u, parent) == find(v, parent):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    n, m = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    k = int(input())\n    blocked_edges = [tuple(map(int, input().split())) for _ in range(k)]\n    q = int(input())\n    new_edges = [tuple(map(int, input().split())) for _ in range(q)]\n\n    for new_edge in new_edges:\n        print(is_good_graph(n, edges, k, blocked_edges, [new_edge]))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_a",
        "code_list": [
            "def main():\n    N = int(input())\n    nearest_water_station = min(N % 5, 10 - N % 5) * 5 + N // 5 * 5\n    if nearest_water_station < N:\n        nearest_water_station += 5\n    print(nearest_water_station)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_b",
        "code_list": [
            "def main():\n    # Define the distances between adjacent points\n    distances = {\n        ('A', 'B'): 3,\n        ('B', 'C'): 1,\n        ('C', 'D'): 4,\n        ('D', 'E'): 1,\n        ('E', 'F'): 5,\n        ('F', 'G'): 9\n    }\n    \n    # Function to calculate the distance between two points\n    def calculate_distance(p, q):\n        if p > q:\n            p, q = q, p\n        \n        total_distance = 0\n        for i in range(ord(p), ord(q)):\n            key = (chr(i), chr(i + 1))\n            total_distance += distances[key]\n        \n        return total_distance\n    \n    # Read input\n    p, q = input().strip().split()\n    \n    # Calculate and print the distance\n    print(calculate_distance(p, q))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_c",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    for i in range(1, H - 1):\n        for j in range(1, W - 1):\n            if grid[i][j] == '.':\n                continue\n            if grid[i-1][j] == '#' and grid[i+1][j] == '#' and grid[i][j-1] == '#' and grid[i][j+1] == '#':\n                print(i + 1, j + 1)\n                return\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc305_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    A = data[1:2 * n + 1]\n    q = data[2 * n + 1]\n    queries = [(data[i], data[i + 1]) for i in range(2 * n + 2, 2 * n + 2 + q)]\n\n    result = []\n    for l, r in queries:\n        count = 0\n        for i in range(1, len(A) - 1, 2):\n            if l <= A[i] and A[i + 1] <= r:\n                count += A[i + 1] - A[i]\n            elif A[i] < l < A[i + 1]:\n                count += min(r, A[i + 1]) - l\n            elif A[i] < r < A[i + 1]:\n                count += r - max(l, A[i])\n            elif l < A[i] and r > A[i + 1]:\n                count += A[i + 1] - A[i]\n        result.append(count)\n\n    for res in result:\n        print(res)"
        ]
    },
    {
        "question_id": "abc305_e",
        "code_list": [
            "from collections import deque\n\ndef bfs(graph, start, stamina):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    reachable = set()\n    \n    while queue:\n        current = queue.popleft()\n        if stamina[current] >= 0:\n            for neighbor in graph[current]:\n                if not visited[neighbor] and stamina[current] - 1 >= 0:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    reachable.add(neighbor)\n    \n    return reachable\n\ndef find_guarded_vertices(n, m, k, edges, positions, stamina):\n    # Build the graph\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Perform BFS for each guard to find reachable vertices\n    guarded = set()\n    for i in range(k):\n        reachable = bfs(graph, positions[i], stamina[i])\n        guarded.update(reachable)\n    \n    # Return sorted list of guarded vertices\n    return sorted(guarded)\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    positions = [0] + list(map(int, input().split()))\n    stamina = list(map(int, input().split()))\n    \n    guarded_vertices = find_guarded_vertices(n, m, k, edges, positions, stamina)\n    \n    print(len(guarded_vertices))\n    print(*guarded_vertices)"
        ]
    },
    {
        "question_id": "abc306_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    result = ''.join([char * 2 for char in S])\n    print(result)"
        ]
    },
    {
        "question_id": "abc306_b",
        "code_list": [
            "def main():\n    # Read the input sequence\n    sequence = list(map(int, input().split()))\n    \n    # Calculate the result using bitwise operations for efficiency\n    result = 0\n    for i, bit in enumerate(sequence):\n        result |= bit << i\n    \n    # Print the result\n    print(result)"
        ]
    },
    {
        "question_id": "abc306_c",
        "code_list": [
            "def find_middle_occurrence(n, arr):\n    occurrences = {}\n    for i, num in enumerate(arr):\n        if num in occurrences:\n            occurrences[num].append(i)\n        else:\n            occurrences[num] = [i]\n    \n    f_values = [(num, beta) for num, indices in occurrences.items() for beta in indices[1:-1]]\n    f_values.sort(key=lambda x: x[1])\n    \n    result = [num for num, _ in f_values]\n    return result\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = find_middle_occurrence(n, arr)\n    print(\" \".join(map(str, result)))"
        ]
    },
    {
        "question_id": "abc306_d",
        "code_list": [
            "def max_tastiness(N, courses):\n    healthy_sum = 0\n    upset_sum = float('-inf')\n    max_tastiness = 0\n    healthy = True\n    \n    for course in courses:\n        x, y = course\n        if x == 0:\n            if healthy:\n                healthy_sum += y\n            else:\n                upset_sum = max(upset_sum + y, healthy_sum)\n                healthy = True\n        else:\n            if healthy:\n                healthy_sum += y\n                max_tastiness = max(max_tastiness, healthy_sum)\n            else:\n                upset_sum = max(upset_sum + y, healthy_sum + y)\n                max_tastiness = max(max_tastiness, upset_sum)\n    \n    return max_tastiness\n\nif __name__ == \"__main__\":\n    N = int(input())\n    courses = []\n    for _ in range(N):\n        X, Y = map(int, input().split())\n        courses.append((X, Y))\n    print(max_tastiness(N, courses))"
        ]
    },
    {
        "question_id": "abc306_e",
        "code_list": [
            "import heapq\n\ndef main():\n    N, K, Q = map(int, input().split())\n    A = [0] * N\n    max_heap = []\n    \n    # Initialize the heap with negative values to simulate a max heap\n    for i in range(N):\n        heapq.heappush(max_heap, (-A[i], i))\n    \n    for _ in range(Q):\n        X, Y = map(int, input().split())\n        X -= 1\n        \n        # Remove the old value\n        old_value, index = heapq.heappop(max_heap)\n        old_value = -old_value\n        \n        if old_value != Y:\n            # Update the value in the array\n            A[index] = Y\n            # Push the new value back into the heap\n            heapq.heappush(max_heap, (-Y, index))\n        \n        # Calculate the sum of the top K elements\n        f_A = sum(-heapq.heappop(max_heap)[0] for _ in range(K))\n        print(f_A)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc307_a",
        "code_list": [
            "def main():\n    N = int(input())\n    steps = list(map(int, input().split()))\n    \n    weekly_steps = [sum(steps[i*7:(i+1)*7]) for i in range(N)]\n    \n    print(*weekly_steps)"
        ]
    },
    {
        "question_id": "abc307_b",
        "code_list": [
            "def is_palindrome(s):\n    return s == s[::-1]\n\ndef find_palindrome_pair(N, strings):\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                concatenated = strings[i] + strings[j]\n                if is_palindrome(concatenated):\n                    return \"Yes\"\n    return \"No\"\n\nif __name__ == \"__main__\":\n    N = int(input())\n    strings = [input().strip() for _ in range(N)]\n    print(find_palindrome_pair(N, strings))"
        ]
    },
    {
        "question_id": "abc307_c",
        "code_list": [
            "def find_paste_and_cut(A, B, X):\n    HA, WA = len(A), len(A[0])\n    HB, WB = len(B), len(B[0])\n   HX, WX = len(X), len(X[0])\n\n    # Check if X can be formed by any combination of A and B\n    def check_combination(A, B, X):\n        for dx in range(HX - HA + 1):\n            for dy in range(WX - WA + 1):\n                if all(A[i][j] == '#' or B[i+dx][j+dy] == '#' for i in range(HA) for j in range(WA)):\n                    if all(X[i][j] == '#' or (A[i+dx][j+dy] == '#' or B[i+dx][j+dy] == '#') for i in range(HX) for j in range(WX)):\n                        return True\n        return False\n\n    # Check if X can be formed by pasting A and B on C\n    if check_combination(A, B, X):\n        return \"Yes\"\n    else:\n        return \"No\"\n\nif __name__ == \"__main__\":\n    HA, WA = map(int, input().split())\n    A = [input() for _ in range(HA)]\n    HB, WB = map(int, input().split())\n    B = [input() for _ in range(HB)]\n    HX, WX = map(int, input().split())\n    X = [input() for _ in range(HX)]\n\n    print(find_paste_and_cut(A, B, X))"
        ]
    },
    {
        "question_id": "abc307_d",
        "code_list": [
            "def remove_substrings(s):\n    stack = []\n    result = list(s)\n    \n    for i, char in enumerate(result):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start_index = stack.pop()\n                # Remove the substring between the matching parentheses\n                del result[start_index+1:i]\n    \n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input().strip()\n    print(remove_substrings(S))"
        ]
    },
    {
        "question_id": "abc307_e",
        "code_list": [
            "from math import pow\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef count_ways(N, M):\n    mod = 998244353\n    if N == 1:\n        return M\n    if N == 2:\n        return M * (M - 1)\n    \n    # Calculate the result using matrix exponentiation\n    A = [[0] * 2 for _ in range(2)]\n    A[0][0] = M - 1\n    A[0][1] = M - 1\n    A[1][0] = 1\n    A[1][1] = 0\n    \n    B = [[0] * 2 for _ in range(2)]\n    B[0][0] = 1\n    B[0][1] = 0\n    B[1][0] = 0\n    B[1][1] = 1\n    \n    # Matrix exponentiation\n    while N > 0:\n        if N % 2 == 1:\n            B = [[(B[0][0] * A[0][0] + B[0][0] * A[1][0]) % mod, (B[0][0] * A[0][1] + B[0][1] * A[1][1]) % mod],\n                 [(B[1][0] * A[0][0] + B[1][1] * A[1][0]) % mod, (B[1][0] * A[0][1] + B[1][1] * A[1][1]) % mod]]\n        A = [[(A[0][0] * A[0][0] + A[0][1] * A[1][0]) % mod, (A[0][0] * A[0][1] + A[0][1] * A[1][1]) % mod],\n             [(A[1][0] * A[0][0] + A[1][1] * A[1][0]) % mod, (A[1][0] * A[0][1] + A[1][1] * A[1][1]) % mod]]\n        N //= 2\n    \n    return (B[0][0] * M + B[0][1]) % mod\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    print(count_ways(N, M))"
        ]
    },
    {
        "question_id": "abc308_a",
        "code_list": [
            "def main():\n    S = list(map(int, input().split()))\n    \n    # Check if all elements are between 100 and 675, inclusive, and are multiples of 25\n    if all(100 <= s <= 675 and s % 25 == 0 for s in S):\n        # Check if the sequence is monotonically non-decreasing\n        if all(S[i] <= S[i + 1] for i in range(len(S) - 1)):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_b",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    colors = [input() for _ in range(N)]\n    prices = dict()\n    P0, *Ps = map(int, input().split())\n    for i, price in enumerate(Ps):\n        prices[input()] = price if i > 0 else P0\n    \n    total_price = sum(prices.get(color, P0) for color in colors)\n    print(total_price)"
        ]
    },
    {
        "question_id": "abc308_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    people = []\n    \n    for i in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        success_rate = A / (A + B)\n        people.append((i + 1, success_rate, A + B))\n        index += 2\n    \n    people.sort(key=lambda x: (-x[1], x[2], x[0]))\n    \n    for person in people:\n        print(person[0], end=' ')"
        ]
    },
    {
        "question_id": "abc308_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up\n    \n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W\n    \n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y, 0)])  # (x, y, current_char_index)\n        visited = set([(start_x, start_y)])\n        \n        while queue:\n            x, y, char_index = queue.popleft()\n            \n            if char_index == 6:  # \"snukes\" length\n                return True\n            \n            target_char = \"snukes\"[char_index % 6]\n            if grid[x][y] != target_char:\n                continue\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny, char_index + 1))\n        \n        return False\n    \n    if bfs(0, 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc308_e",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    S = input()\n\n    def mex(arr):\n        cnt = Counter(arr)\n        for i in range(3):\n            if cnt[i] == 0:\n                return i\n        return 3\n\n    total_mex_sum = 0\n\n    for i in range(N - 2):\n        if S[i] == 'M':\n            total_mex_sum += mex([A[i], A[i + 1], A[i + 2]])\n\n    print(total_mex_sum)"
        ]
    },
    {
        "question_id": "abc308_f",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    prices = list(map(int, data[2:N+2]))\n    Ls = list(map(int, data[N+2:N+M+2]))\n    Ds = list(map(int, data[N+M+2:]))\n    \n    # Create a list of tuples (L, D) for each coupon\n    coupons = sorted(zip(Ls, Ds), key=lambda x: x[0])\n    \n    # Initialize the total cost\n    total_cost = 0\n    \n    # Track which coupons have been used\n    used_coupons = [False] * M\n    \n    # Sort prices in descending order\n    prices.sort(reverse=True)\n    \n    for price in prices:\n        # Try to find a suitable coupon for the current price\n        i = 0\n        while i < M and used_coupons[i]:\n            i += 1\n        \n        while i < M and coupons[i][0] <= price:\n            if not used_coupons[i]:\n                total_cost += price - coupons[i][1]\n                used_coupons[i] = True\n                break\n            i += 1\n        \n        if i == M or used_coupons[i]:\n            total_cost += price\n    \n    print(total_cost)"
        ]
    },
    {
        "question_id": "abc309_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    # Define the positions of numbers 1 through 9 on a 3x3 board\n    positions = {\n        1: (0, 0), 2: (0, 1), 3: (0, 2),\n        4: (1, 0), 5: (1, 1), 6: (1, 2),\n        7: (2, 0), 8: (2, 1), 9: (2, 2)\n    }\n    \n    # Get the positions of A and B\n    pos_A = positions[A]\n    pos_B = positions[B]\n    \n    # Check if A and B are adjacent horizontally\n    if pos_A[1] == pos_B[1] and abs(pos_A[0] - pos_B[0]) == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_b",
        "code_list": [
            "def shift_outer_squares(n, grid):\n    # Extract the outer squares into a list\n    outer_squares = []\n    for i in range(n):\n        outer_squares.append(grid[i][0])\n        outer_squares.append(grid[n-1][i])\n        if i < n-1:\n            outer_squares.append(grid[n-1-i][n-1])\n            outer_squares.append(grid[0][n-1-i])\n    \n    # Shift the outer squares clockwise by one\n    shifted_squares = [outer_squares[-1]] + outer_squares[:-1]\n    \n    # Place the shifted outer squares back into the grid\n    k = 0\n    for i in range(n):\n        grid[i][0] = shifted_squares[k]\n        k += 1\n        grid[n-1][i] = shifted_squares[k]\n        k += 1\n        if i < n-1:\n            grid[n-1-i][n-1] = shifted_squares[k]\n            k += 1\n            grid[0][n-1-i] = shifted_squares[k]\n            k += 1\n    \n    # Print the resulting grid\n    for row in grid:\n        print(''.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    n = int(input())\n    grid = []\n    for _ in range(n):\n        row = list(map(int, input()))\n        grid.append(row)\n    shift_outer_squares(n, grid)"
        ]
    },
    {
        "question_id": "abc309_c",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    medicines = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    current_day = 1\n    remaining_days = [a for a, b in medicines]\n    total_pills = [b for a, b in medicines]\n    \n    while True:\n        if sum(total_pills) <= K:\n            print(current_day)\n            return\n        \n        min_index = remaining_days.index(min(remaining_days))\n        remaining_days[min_index] -= 1\n        total_pills[min_index] -= 1\n        \n        if remaining_days[min_index] == 0:\n            del remaining_days[min_index]\n            del total_pills[min_index]\n        \n        current_day += 1\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc309_d",
        "code_list": [
            "import sys\nfrom collections import deque\n\ndef bfs(graph, start, end):\n    queue = deque([(start, 1)])\n    visited = {start}\n    \n    while queue:\n        current, dist = queue.popleft()\n        if current == end:\n            return dist\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n    return float('inf')\n\ndef find_max_path_length(N1, N2, M, edges):\n    # Create adjacency lists for the two subgraphs\n    subgraph1 = {i: [] for i in range(1, N1 + 1)}\n    subgraph2 = {i: [] for i in range(N1 + 1, N1 + N2 + 1)}\n    \n    # Build the graphs\n    for a, b in edges:\n        if 1 <= a <= N1 and 1 <= b <= N1:\n            subgraph1[a].append(b)\n            subgraph1[b].append(a)\n        elif N1 + 1 <= a <= N1 + N2 and N1 + 1 <= b <= N1 + N2:\n            subgraph2[a].append(b)\n            subgraph2[b].append(a)\n    \n    # Find the farthest node in subgraph1 from node 1\n    max_dist1 = bfs(subgraph1, 1, None)\n    farthest_node1 = None\n    for node in subgraph1:\n        if bfs(subgraph1, node, 1) > max_dist1:\n            max_dist1 = bfs(subgraph1, node, 1)\n            farthest_node1 = node\n    \n    # Find the farthest node in subgraph2 from node (N1 + N2)\n    max_dist2 = bfs(subgraph2, N1 + N2, None)\n    farthest_node2 = None\n    for node in subgraph2:\n        if bfs(subgraph2, node, N1 + N2) > max_dist2:\n            max_dist2 = bfs(subgraph2, node, N1 + N2)\n            farthest_node2 = node\n    \n    # Calculate the maximum possible path length after adding an edge\n    max_path_length = max_dist1 + max_dist2 + 1\n    return max_path_length\n\nif __name__ == \"__main__\":\n    N1, N2, M = map(int, input().split())\n    edges = [tuple(map(int, line.split())) for line in sys.stdin.readlines()[:M]]\n    print(find_max_path_length(N1, N2, M, edges))"
        ]
    },
    {
        "question_id": "abc309_e",
        "code_list": [
            "def find_parent(i, parent_map):\n    if parent_map[i] == -1:\n        return i\n    return find_parent(parent_map[i], parent_map)\n\ndef union(i, j, parent_map):\n    pi = find_parent(i, parent_map)\n    pj = find_parent(j, parent_map)\n    if pi != pj:\n        parent_map[pj] = pi\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    m = int(data[1])\n    parent_map = [-1] * (n + 1)\n    for i in range(2, n + 1):\n        parent_map[i] = int(data[i - 1])\n\n    start_indices = [2 + i * 2 for i in range(m)]\n    end_indices = [start_indices[i] + 1 for i in range(m)]\n\n    covered = [False] * (n + 1)\n    for i in range(m):\n        x = int(data[start_indices[i]])\n        y = int(data[end_indices[i]])\n        current = x\n        for j in range(y + 1):\n            if current > n:\n                break\n            covered[current] = True\n            current = parent_map[current]\n\n    print(sum(covered[1:]))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_a",
        "code_list": [
            "def main():\n    N, P, Q = map(int, input().split())\n    dishes = list(map(int, input().split()))\n    \n    # Calculate the minimum cost without using the coupon\n    min_dish_cost = min(dishes) if dishes else float('inf')\n    min_cost_without_coupon = P\n    \n    # Calculate the minimum cost using the coupon\n    min_cost_with_coupon = Q + min_dish_cost if min_dish_cost != float('inf') else float('inf')\n    \n    # Print the minimum total amount of money that he must pay\n    print(min(min_cost_without_coupon, min_cost_with_coupon))"
        ]
    },
    {
        "question_id": "abc310_b",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    products = []\n    \n    for _ in range(N):\n        P, C = map(int, input().split())\n        functions = set(map(int, input().split()))\n        products.append((P, functions))\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            if products[i][0] >= products[j][0]:\n                if products[j][1].issuperset(products[i][1]):\n                    if products[i][0] > products[j][0] or len(products[j][1] - products[i][1]) > 0:\n                        print(\"Yes\")\n                        return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc310_c",
        "code_list": [
            "from collections import defaultdict\n\ndef reverse_string(s):\n    return s[::-1]\n\ndef count_unique_sticks(N, sticks):\n    unique_sticks = defaultdict(int)\n    for stick in sticks:\n        # Check both the original and reversed string\n        unique_sticks[stick] += 1\n        unique_sticks[reverse_string(stick)] += 1\n    \n    # The number of unique sticks is the number of keys in the dictionary divided by 2\n    # since each unique stick appears twice (once in its original form and once in its reversed form)\n    return len(unique_sticks) // 2\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    sticks = []\n    for _ in range(N):\n        sticks.append(input().strip())\n    \n    print(count_unique_sticks(N, sticks))"
        ]
    },
    {
        "question_id": "abc310_d",
        "code_list": [
            "from itertools import combinations\n\ndef count_ways(N, T, M, incompatible_pairs):\n    # Create a graph to represent the incompatibilities\n    graph = {i: [] for i in range(1, N+1)}\n    for a, b in incompatible_pairs:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(player, team, visited, teams):\n        if player in visited[team]:\n            return False\n        visited[team].add(player)\n        for neighbor in graph[player]:\n            if neighbor in visited[team]:\n                continue\n            if not dfs(neighbor, team, visited, teams):\n                return False\n        return True\n\n    def is_valid_partition(partition):\n        visited = [set() for _ in range(T)]\n        for team in partition:\n            if not dfs(team[0], team[0], visited, partition):\n                return False\n        return True\n\n    def count_partitions():\n        count = 0\n        for partition in combinations(range(1, N+1), T):\n            if is_valid_partition(partition):\n                count += 1\n        return count\n\n    return count_partitions()\n\nif __name__ == \"__main__\":\n    N, T, M = map(int, input().split())\n    incompatible_pairs = [tuple(map(int, input().split())) for _ in range(M)]\n    print(count_ways(N, T, M, incompatible_pairs))"
        ]
    },
    {
        "question_id": "abc310_e",
        "code_list": [
            "def nand_sequence_sum(N, S):\n    # Initialize the result variable\n    result = 0\n    \n    # Convert the string to a list of integers for easier manipulation\n    A = [int(char) for char in S]\n    \n    # Iterate over all possible starting points i\n    for i in range(N):\n        current_value = A[i]\n        # Iterate over all possible ending points j starting from i\n        for j in range(i, N):\n            current_value = current_value and (not A[j])\n            result += current_value\n    \n    return result\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input().strip()\n    print(nand_sequence_sum(N, S))"
        ]
    },
    {
        "question_id": "abc310_f",
        "code_list": [
            "from functools import lru_cache\nfrom math import gcd\n\ndef modinv(a, m=998244353):\n    return pow(a, m-2, m)\n\ndef solve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    \n    @lru_cache(None)\n    def dp(i, target):\n        if i == n:\n            return int(target == 0)\n        res = dp(i+1, target) * A[i] % 998244353\n        for j in range(1, min(A[i], target)+1):\n            res += dp(i+1, target-j) * A[i]\n            res %= 998244353\n        return res\n    \n    total_prob = sum(dp(0, i) for i in range(1, 11)) % 998244353\n    total_prob = total_prob * modinv(sum(A)) % 998244353\n    \n    print(total_prob)\n\nif __name__ == \"__main__\":\n    solve()"
        ]
    },
    {
        "question_id": "abc311_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    \n    count = [0] * 3  # To keep track of the count of A, B, and C\n    required = 3      # We need all A, B, and C\n    \n    for i, char in enumerate(S):\n        if char == 'A':\n            count[0] += 1\n        elif char == 'B':\n            count[1] += 1\n        else:  # char == 'C'\n            count[2] += 1\n        \n        if min(count) >= 1:\n            print(i + 1)\n            break"
        ]
    },
    {
        "question_id": "abc311_b",
        "code_list": [
            "def find_max_consecutive_free_days(N, D, schedules):\n    max_days = 0\n    for start_day in range(D):\n        current_days = 0\n        for end_day in range(start_day, D):\n            all_free = True\n            for person in range(N):\n                if schedules[person][end_day] == 'x':\n                    all_free = False\n                    break\n            if all_free:\n                current_days += 1\n                max_days = max(max_days, current_days)\n            else:\n                current_days = 0\n    return max_days\n\nif __name__ == \"__main__\":\n    N, D = map(int, input().split())\n    schedules = [input() for _ in range(N)]\n    print(find_max_consecutive_free_days(N, D, schedules))"
        ]
    },
    {
        "question_id": "abc311_c",
        "code_list": [
            "def find_cycle(N, A):\n    # Initialize the starting point for the cycle\n    start = 0\n    \n    # Find the first cycle\n    cycle = [start]\n    current = A[start]\n    while current != start:\n        cycle.append(current)\n        start = current\n        current = A[current]\n    \n    # Find the second vertex of the cycle\n    second_vertex = cycle[1]\n    \n    # Trace back to find the cycle starting from the second vertex\n    cycle_start = A[second_vertex]\n    cycle_end = second_vertex\n    while cycle_start != cycle_end:\n        cycle_end = A[cycle_end]\n        cycle_start = A[cycle_start]\n    \n    # Determine the cycle length\n    cycle_length = 0\n    for i in range(len(cycle)):\n        if cycle[i] == cycle_start:\n            cycle_length = len(cycle) - i\n            break\n    \n    # Return the cycle\n    return cycle_length, cycle[cycle.index(cycle_start):] + [cycle_start]\n\ndef main():\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    \n    cycle_length, cycle = find_cycle(N, A)\n    print(cycle_length)\n    print(' '.join(map(str, cycle)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc311_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start):\n    n, m = len(grid), len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    count = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        count += 1\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 < nx < n - 1 and 0 < ny < m - 1 and grid[nx][ny] == '.' and not visited[nx][ny]:\n                visited[nx][ny] = True\n                queue.append((nx, ny))\n    \n    return count\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    start = (1, 1)\n    print(bfs(grid, start))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc311_e",
        "code_list": [
            "def count_holeless_squares(H, W, N, holes):\n    # Initialize a 2D array to keep track of the minimum size of holeless squares ending at each cell\n    dp = [[0] * (W + 1) for _ in range(H + 1)]\n    \n    # Mark the cells with holes as 0\n    for a, b in holes:\n        dp[a][b] = 0\n    \n    # Fill the dp table\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if dp[i][j] != 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n    \n    # Calculate the total number of holeless squares\n    total_holeless_squares = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if dp[i][j] != 0:\n                total_holeless_squares += dp[i][j]\n    \n    return total_holeless_squares\n\nif __name__ == \"__main__\":\n    H, W, N = map(int, input().split())\n    holes = [tuple(map(int, input().split())) for _ in range(N)]\n    print(count_holeless_squares(H, W, N, holes))"
        ]
    },
    {
        "question_id": "abc312_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S in [\"ACE\", \"BDF\", \"CEG\", \"DFA\", \"EGB\", \"FAC\", \"GBD\"]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_b",
        "code_list": [
            "def check_tak_code(grid, i, j):\n    # Check the top-left 3x3 region\n    for x in range(3):\n        for y in range(3):\n            if grid[i+x][j+y] != '#':\n                return False\n    \n    # Check the adjacent 14 cells\n    adjacent_cells = [\n        (i+1, j), (i+1, j+1), (i+1, j+2),\n        (i+2, j+1),\n        (i, j+1), (i, j+2),\n        (i-1, j+1), (i-1, j+2),\n        (i+1, j-1), (i+1, j-2),\n        (i+2, j-1),\n        (i, j-1), (i, j-2),\n        (i-1, j-1), (i-1, j-2)\n    ]\n    \n    for x, y in adjacent_cells:\n        if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != '.':\n            return False\n    \n    return True\n\ndef find_tak_codes(grid):\n    tak_codes = []\n    n, m = len(grid), len(grid[0])\n    \n    for i in range(n - 8):\n        for j in range(m - 8):\n            if check_tak_code(grid, i, j):\n                tak_codes.append((i + 1, j + 1))\n                \n    return tak_codes\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    \n    tak_codes = find_tak_codes(grid)\n    \n    for i, j in tak_codes:\n        print(i, j)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_c",
        "code_list": [
            "def main():\n    import bisect\n\n    N, M = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    B = sorted(map(int, input().split()))\n\n    # Find the minimum X that satisfies the condition\n    left, right = 1, max(A[-1], B[-1])\n    while left < right:\n        mid = (left + right) // 2\n        if sum(a >= mid for a in A) >= sum(b <= mid for b in B):\n            right = mid\n        else:\n            left = mid + 1\n\n    print(left)"
        ]
    },
    {
        "question_id": "abc312_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    S = input().strip()\n    n = len(S)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    mod = 998244353\n\n    left = deque()\n    right = deque()\n\n    for i, c in enumerate(S):\n        if c == '(':\n            left.append(i)\n        elif c == ')':\n            if left:\n                left.pop()\n        else:  # c == '?'\n            while left:\n                j = left.pop()\n                dp[i + 1] += dp[j]\n                dp[i + 1] %= mod\n            left.append(i)\n        if c == ')' or c == '?':\n            while right and (i - right[0] > 1 or (i - right[0] == 1 and S[right[0]] != '(')):\n                right.popleft()\n            if right:\n                dp[i + 1] += dp[right[0]]\n                dp[i + 1] %= mod\n            right.append(i)\n\n    print(dp[n])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    cuboids = []\n    for _ in range(N):\n        x1, y1, z1, x2, y2, z2 = map(int, input().split())\n        cuboids.append(((x1, y1, z1), (x2, y2, z2)))\n\n    adjacency = defaultdict(set)\n    for i, ((x1_i, y1_i, z1_i), (x2_i, y2_i, z2_i)) in enumerate(cuboids):\n        for j, ((x1_j, y1_j, z1_j), (x2_j, y2_j, z2_j)) in enumerate(cuboids):\n            if i != j:\n                if x1_i <= x1_j <= x2_i and x1_i <= x2_j <= x2_i:\n                    if y1_i <= y1_j <= y2_i and y1_i <= y2_j <= y2_i:\n                        if z1_i <= z1_j <= z2_i and z1_i <= z2_j <= z2_i:\n                            adjacency[i].add(j)\n                if x1_i <= x1_j <= x2_i and x1_i <= x2_j <= x2_i:\n                    if y1_i <= y1_j <= y2_i and y1_i <= y2_j <= y2_i:\n                        if z1_j <= z1_i <= z2_j and z1_j <= z2_i <= z2_j:\n                            adjacency[i].add(j)\n                if x1_i <= x1_j <= x2_i and x1_i <= x2_j <= x2_i:\n                    if y1_j <= y1_i <= y2_j and y1_j <= y2_i <= y2_j:\n                        if z1_i <= z1_j <= z2_i and z1_i <= z2_j <= z2_i:\n                            adjacency[i].add(j)\n                if x1_j <= x1_i <= x2_j and x1_j <= x2_i <= x2_j:\n                    if y1_j <= y1_i <= y2_j and y1_j <= y2_i <= y2_j:\n                        if z1_i <= z1_j <= z2_i and z1_i <= z2_j <= z2_i:\n                            adjacency[i].add(j)\n                if x1_j <= x1_i <= x2_j and x1_j <= x2_i <= x2_j:\n                    if y1_j <= y1_i <= y2_j and y1_j <= y2_i <= y2_j:\n                        if z1_j <= z1_i <= z2_j and z1_j <= z2_i <= z2_j:\n                            adjacency[i].add(j)\n                if x1_j <= x1_i <= x2_j and x1_j <= x2_i <= x2_j:\n                    if y1_i <= y1_j <= y2_i and y1_i <= y2_j <= y2_i:\n                        if z1_j <= z1_i <= z2_j and z1_j <= z2_i <= z2_j:\n                            adjacency[i].add(j)\n\n    result = [len(adjacency[i]) for i in range(N)]\n    print('\\n'.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc312_f",
        "code_list": [
            "import heapq\n\ndef main():\n    N, M = map(int, input().split())\n    items = []\n    for _ in range(N):\n        T, X = map(int, input().split())\n        items.append((X, T))\n    \n    # Separate into pull-tab cans, regular cans, and can openers\n    pull_tab_cans = [x for x, t in items if t == 0]\n    regular_cans = [x for x, t in items if t == 1]\n    can_openers = [x for x, t in items if t == 2]\n    \n    # Sort the lists\n    pull_tab_cans.sort()\n    regular_cans.sort()\n    can_openers.sort(reverse=True)\n    \n    # Use a max heap to keep track of the top M happiness values\n    max_happiness = 0\n    happiness_heap = []\n    \n    # Try to maximize happiness by using can openers on regular cans\n    for _ in range(min(M, len(can_openers))):\n        if regular_cans:\n            heapq.heappush(happiness_heap, regular_cans.pop())\n    \n    for _ in range(min(M, len(pull_tab_cans))):\n        heapq.heappush(happiness_heap, pull_tab_cans.pop())\n    \n    for _ in range(min(M - len(happiness_heap), len(can_openers))):\n        if happiness_heap:\n            max_happiness += heapq.heappop(happiness_heap)\n        heapq.heappush(happiness_heap, can_openers.pop())\n    \n    while happiness_heap and M > 0:\n        max_happiness += heapq.heappop(happiness_heap)\n        M -= 1\n    \n    print(max_happiness)"
        ]
    },
    {
        "question_id": "abc313_a",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:]))\n    \n    max_ability = max(P)\n    current_ability = P[0]\n    \n    x = max_ability - current_ability\n    \n    print(x)"
        ]
    },
    {
        "question_id": "abc313_b",
        "code_list": [
            "def find_strongest_programmer(N, M, relations):\n    # Initialize the graph to represent the superiority relations\n    graph = {i: set() for i in range(1, N+1)}\n    \n    # Build the graph based on the given relations\n    for A, B in relations:\n        graph[A].add(B)\n    \n    # Function to check if a person is the strongest\n    def is_strongest(person):\n        for other in range(1, N+1):\n            if other != person and (person not in graph[other] and len(graph[other]) == 0):\n                return False\n        return True\n    \n    # Check each person to see if they can be the strongest\n    for person in range(1, N+1):\n        if is_strongest(person):\n            # If more than one person satisfies the condition, return -1\n            if any(is_strongest(other) for other in range(1, N+1) if other != person):\n                return -1\n            else:\n                return person\n    \n    return -1\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    relations = [tuple(map(int, input().split())) for _ in range(M)]\n    print(find_strongest_programmer(N, M, relations))"
        ]
    },
    {
        "question_id": "abc313_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    total_sum = sum(A)\n    target_value = total_sum // N\n    \n    remainder = total_sum % N\n    \n    operations = 0\n    for value in A:\n        if value > target_value + 1:\n            operations += value - (target_value + 1)\n        elif value < target_value:\n            operations += target_value - value\n    \n    if remainder > 0:\n        operations -= remainder * (target_value + 1) - (total_sum - remainder * (target_value + 1))\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_a",
        "code_list": [
            "def main():\n    import math\n    N = int(input().strip())\n    pi_str = str(math.pi)\n    decimal_part = pi_str.split('.')[1][:N]\n    result = f\"3.{decimal_part}\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_b",
        "code_list": [
            "def main():\n    N = int(input())\n    bets = []\n    min_bets = float('inf')\n    \n    for i in range(N):\n        C_i = int(input())\n        outcomes = list(map(int, input().split()))\n        if X in outcomes:\n            min_bets = min(min_bets, C_i)\n            bets.append((i + 1, C_i))\n    \n    result = [person for person, num_bets in bets if num_bets == min_bets]\n    \n    K = len(result)\n    print(K)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_c",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    S = input()\n    colors = list(map(int, input().split()))\n    \n    # Create a list to store the positions of each color\n    color_positions = [[] for _ in range(M)]\n    for i in range(N):\n        color_positions[colors[i] - 1].append(i)\n    \n    # Perform right circular shifts for each color\n    for color in range(M):\n        positions = color_positions[color]\n        k = len(positions)\n        if k > 1:\n            new_positions = [positions[(i + 1) % k] for i in range(k)]\n            for i, pos in enumerate(new_positions):\n                S = S[:pos] + S[positions[i]:pos] + S[positions[i]] + S[pos+1:]\n    \n    print(S)"
        ]
    },
    {
        "question_id": "abc314_d",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_operations(s, operations):\n        for t, x, c in operations:\n            if t == 1:\n                s = s[:x-1] + c + s[x:]\n            elif t == 2:\n                s = s.lower()\n            elif t == 3:\n                s = s.upper()\n        return s\n    \n    # Read input\n    N = int(input().strip())\n    S = input().strip()\n    Q = int(input().strip())\n    operations = []\n    \n    for _ in range(Q):\n        t, x, c = map(int if t != 'a' else lambda x: x, input().strip().split())\n        if t == 1:\n            x -= 1  # Convert 1-based index to 0-based index\n        operations.append((t, x, c))\n    \n    # Process operations and print result\n    result = process_operations(S, operations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_e",
        "code_list": [
            "import sys\nfrom heapq import heappush, heappop\n\ndef main():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    \n    wheels = []\n    for _ in range(N):\n        C, P = map(int, input().split())\n        wheel = [(S, C) for S in map(int, input().split())]\n        wheels.append(wheel)\n    \n    # Priority queue to store (expected cost, current score, wheel index)\n    pq = [(0, 0, 0)]\n    visited = set()\n    \n    while pq:\n        cost, score, wheel_idx = heappop(pq)\n        \n        if (wheel_idx, score) in visited:\n            continue\n        visited.add((wheel_idx, score))\n        \n        if score >= M:\n            print(cost)\n            return\n        \n        for S, C in wheels[wheel_idx]:\n            new_score = score + S\n            if new_score < M:\n                heappush(pq, (cost + C, new_score, wheel_idx))\n            else:\n                heappush(pq, (cost + C, M, wheel_idx))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc314_f",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\ndef modinv(a, m=998244353):\n    return pow(a, m - 2, m)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef process_matches(N, matches):\n    # Initialize the parent array to represent each player's team\n    parent = list(range(N + 1))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Process each match\n    for p, q in matches:\n        union(p, q)\n    \n    # Calculate the size of each team\n    team_size = [0] * (N + 1)\n    for i in range(1, N + 1):\n        team_size[find(i)] += 1\n    \n    # Calculate the expected value for each player\n    expected_values = [0] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i != j:\n                if find(i) == find(j):\n                    continue\n                a, b = team_size[find(i)], team_size[find(j)]\n                prob_win_i = a / (a + b)\n                prob_win_j = b / (a + b)\n                expected_values[i] += prob_win_i\n                expected_values[j] += prob_win_j\n    \n    # Reduce the expected values modulo 998244353\n    mod_exp_values = []\n    for exp_val in expected_values[1:]:\n        numerator = int(exp_val)\n        denominator = 1\n        for i in range(1, N + 1):\n            denominator = lcm(denominator, i)\n        y = numerator * modinv(denominator, 998244353) % 998244353\n        mod_exp_values.append(y)\n    \n    return mod_exp_values\n\ndef main():\n    N = int(input().strip())\n    matches = [tuple(map(int, input().strip().split())) for _ in range(N - 1)]\n    results = process_matches(N, matches)\n    print(' '.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = ''.join([char for char in S if char not in 'aeiou'])\n    print(result)"
        ]
    },
    {
        "question_id": "abc315_b",
        "code_list": [
            "def main():\n    M = int(input())\n    days_in_month = list(map(int, input().split()))\n    \n    total_days = sum(days_in_month)\n    middle_day = (total_days + 1) // 2\n    \n    current_day = 0\n    for month in range(M):\n        current_day += days_in_month[month]\n        if current_day >= middle_day:\n            break\n    \n    # Calculate the exact day within the month\n    day_of_month = current_day - middle_day + 1 if current_day > middle_day else 1\n    \n    print(month + 1, day_of_month)"
        ]
    },
    {
        "question_id": "abc315_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    ice_creams = []\n    for _ in range(N):\n        F, S = map(int, input().split())\n        ice_creams.append((F, S))\n    \n    # Sort by deliciousness in descending order\n    ice_creams.sort(key=lambda x: x[1], reverse=True)\n    \n    max_satisfaction = 0\n    # Dictionary to store the maximum deliciousness of each flavor\n    max_deliciousness = defaultdict(int)\n    \n    for F, S in ice_creams:\n        # Check if there's another cup with the same flavor\n        if max_deliciousness[F] > 0:\n            # Calculate satisfaction when flavors are the same\n            satisfaction_same = max_deliciousness[F] + S / 2\n            max_satisfaction = max(max_satisfaction, satisfaction_same)\n        \n        # Update the maximum deliciousness for this flavor\n        max_deliciousness[F] = max(max_deliciousness[F], S)\n    \n    # Find the maximum satisfaction when flavors are different\n    for F, S in ice_creams:\n        for other_F, other_S in ice_creams:\n            if F != other_F:\n                satisfaction_diff = S + other_S\n                max_satisfaction = max(max_satisfaction, satisfaction_diff)\n    \n    print(int(max_satisfaction))"
        ]
    },
    {
        "question_id": "abc315_d",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    cookies = [input() for _ in range(H)]\n    \n    while True:\n        # Check rows\n        marked_rows = set()\n        for i in range(H):\n            if len(set(cookies[i])) == 1 and cookies[i].count(cookies[i][0]) > 1:\n                marked_rows.add(i)\n        \n        # Check columns\n        marked_cols = set()\n        for j in range(W):\n            col = ''.join([cookies[i][j] for i in range(H)])\n            if len(set(col)) == 1 and col.count(col[0]) > 1:\n                marked_cols.add(j)\n        \n        # Remove marked cookies\n        if marked_rows or marked_cols:\n            for r in marked_rows:\n                for j in range(W):\n                    if j not in marked_cols:\n                        print(cookies[r][j], end='')\n            print()\n            for c in marked_cols:\n                for i in range(H):\n                    if i not in marked_rows:\n                        print(cookies[i][c], end='')\n            print()\n            cookies = [input() for _ in range(H)]\n        else:\n            break\n    \n    # Count remaining cookies\n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if cookies[i][j] != '.':\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_e",
        "code_list": [
            "from collections import deque, defaultdict\n\ndef main():\n    N = int(input())\n    graph = defaultdict(list)\n    indegree = [0] * (N + 1)\n    for i in range(1, N + 1):\n        C, *P = map(int, input().split())\n        graph[0].append(i)  # Book 1 has no prerequisites\n        indegree[i] = C\n        for p in P:\n            graph[p].append(i)\n            indegree[i] += 1\n\n    queue = deque([i for i in range(1, N + 1) if indegree[i] == 0])\n    result = []\n    while queue:\n        current = queue.popleft()\n        result.append(current)\n        for neighbor in graph[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    print(*result[:-1])  # Exclude book 1 itself\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc315_f",
        "code_list": [
            "import math\nfrom itertools import combinations\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef min_race_time(N, checkpoints):\n    min_s = float('inf')\n    \n    # Generate all possible subsets of checkpoints to skip\n    for C in range(1, N-1):  # C > 0, and we don't consider skipping all but the first and last\n        for subset in combinations(range(1, N-1), C):\n            distances = [euclidean_distance(checkpoints[i], checkpoints[i+1]) for i in range(N-1)]\n            for index in sorted(subset, reverse=True):\n                del distances[index]\n            penalty = 2 ** (C - 1)\n            s = sum(distances) + penalty\n            min_s = min(min_s, s)\n    \n    return min_s\n\nif __name__ == \"__main__\":\n    N = int(input())\n    checkpoints = [tuple(map(int, input().split())) for _ in range(N)]\n    print(f\"{min_race_time(N, checkpoints):.15f}\")"
        ]
    },
    {
        "question_id": "abc318_a",
        "code_list": [
            "def main():\n    N, M, P = map(int, input().split())\n    count = 0\n    for day in range(M, N + 1, P):\n        if day <= N:\n            count += 1\n    print(count)"
        ]
    },
    {
        "question_id": "abc318_b",
        "code_list": [
            "from itertools import product\n\ndef main():\n    N = int(input())\n    intervals = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    # Generate all possible (x, y) points within the given range\n    x_range = range(101)\n    y_range = range(101)\n    \n    # Initialize a set to keep track of covered points\n    covered_points = set()\n    \n    # Check each rectangle\n    for A, B, C, D in intervals:\n        for x in range(A, B):\n            for y in range(C, D):\n                covered_points.add((x, y))\n    \n    # The number of unique covered points is the area S\n    S = len(covered_points)\n    print(S)"
        ]
    },
    {
        "question_id": "abc318_c",
        "code_list": [
            "def main():\n    N, D, P = map(int, input().split())\n    F = list(map(int, input().split()))\n    \n    # Calculate the total fare without any passes\n    total_fare = sum(F)\n    \n    # Calculate the cost if we buy enough passes to cover every D days\n    passes_cost = (N + D - 1) // D * P\n    \n    # Calculate the cost if we buy enough passes to cover every D days minus the most expensive days\n    optimized_cost = float('inf')\n    for i in range(D):\n        pass_days = (N + D - 1) // D * (D - i)\n        remaining_days = N - pass_days + i\n        cost = (pass_days * P) + sum(F[j] for j in range(remaining_days))\n        optimized_cost = min(optimized_cost, cost)\n    \n    # The result is the minimum of the two costs\n    result = min(total_fare, optimized_cost)\n    print(result)"
        ]
    },
    {
        "question_id": "abc318_d",
        "code_list": [
            "from itertools import combinations\n\ndef max_edge_weight(N, weights):\n    # Create a list of all possible edges\n    edges = [(i, j, weights[i-1][j-i]) for i in range(1, N+1) for j in range(i+1, N+1)]\n    \n    # Sort edges in descending order of weight\n    edges.sort(key=lambda x: x[2], reverse=True)\n    \n    # Initialize variables to keep track of the maximum weight and selected edges\n    max_weight = 0\n    selected_edges = []\n    \n    # Try all combinations of edges\n    for r in range(1, N//2 + 1):\n        for combo in combinations(edges, r):\n            # Check if the endpoints of the chosen edges are pairwise distinct\n            if len(set([edge[0] for edge in combo])) == r and len(set([edge[1] for edge in combo])) == r:\n                current_weight = sum(edge[2] for edge in combo)\n                if current_weight > max_weight:\n                    max_weight = current_weight\n                    selected_edges = combo\n    \n    return max_weight\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    weights = []\n    for _ in range(N):\n        row = list(map(int, input().strip().split()))\n        weights.append(row)\n    \n    print(max_edge_weight(N, weights))"
        ]
    },
    {
        "question_id": "abc318_e",
        "code_list": [
            "from collections import defaultdict\n\ndef count_triples():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Dictionary to store the indices of each element\n    index_map = defaultdict(list)\n    for i, num in enumerate(arr):\n        index_map[num].append(i)\n    \n    result = 0\n    for num, indices in index_map.items():\n        if len(indices) < 2:\n            continue\n        # Calculate the number of valid (i, j, k) triples\n        for j in range(1, len(indices) - 1):\n            left_count = indices[j] - indices[0] - 1\n            right_count = indices[-1] - indices[j]\n            result += left_count * right_count\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    count_triples()"
        ]
    },
    {
        "question_id": "abc319_b",
        "code_list": [
            "def main():\n    N = int(input().strip())\n    result = []\n    \n    for i in range(N + 1):\n        for j in range(1, 10):\n            if N % j == 0 and i % (N // j) == 0:\n                result.append(str(j))\n                break\n        else:\n            result.append('-')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc319_c",
        "code_list": [
            "from itertools import permutations\n\ndef calculate_probability(grid):\n    count_valid_permutations = 0\n    total_permutations = 0\n    \n    # Generate all possible permutations of the grid\n    for perm in permutations(range(9)):\n        valid = True\n        \n        # Check rows\n        for i in range(3):\n            if perm[i*3] == perm[i*3+1] and perm[i*3+1] != perm[i*3+2]:\n                valid = False\n                break\n        \n        # Check columns\n        for j in range(3):\n            if perm[j] == perm[3+j] and perm[3+j] != perm[6+j]:\n                valid = False\n                break\n        \n        # Check diagonals\n        if perm[0] == perm[4] and perm[4] != perm[8]:\n            valid = False\n        if perm[2] == perm[4] and perm[4] != perm[6]:\n            valid = False\n        \n        if valid:\n            count_valid_permutations += 1\n        total_permutations += 1\n    \n    # Calculate the probability\n    probability = count_valid_permutations / total_permutations\n    return probability\n\ndef main():\n    # Read the grid input\n    grid = []\n    for _ in range(3):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Calculate and print the probability\n    probability = calculate_probability(grid)\n    print(f\"{probability:.16f}\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc319_d",
        "code_list": [
            "def min_window_width(N, M, lengths):\n    def feasible(width):\n        lines, current_width = 1, 0\n        for length in lengths:\n            if current_width + length + (current_width > 0) > width:\n                lines += 1\n                current_width = length\n            else:\n                current_width += length + 1\n        return lines <= M\n    \n    left, right = max(lengths), sum(lengths) + N - 1\n    while left < right:\n        mid = (left + right) // 2\n        if feasible(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    lengths = list(map(int, input().split()))\n    print(min_window_width(N, M, lengths))"
        ]
    },
    {
        "question_id": "abc319_e",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef process_queries(N, X, Y, P, T, Q, queries):\n    # Calculate the LCM of all P_i values\n    lcm_value = reduce(lcm, P)\n    \n    # Precompute the next departure times for each bus stop\n    next_departures = [0] * N\n    for i in range(N - 1):\n        next_departures[i] = [(t + i * p) % lcm_value for t in range(p) for p in P[:i+1]]\n    \n    def earliest_arrival(q):\n        time = q\n        # Move from house to bus stop 1\n        time += X\n        current_stop = 0\n        \n        while current_stop < N - 1:\n            # Find the next departure time from the current bus stop\n            next_departure = min(next_departures[current_stop])\n            if time % lcm_value < next_departure:\n                time += lcm_value - (time % lcm_value)\n            time += next_departure - (time % lcm_value)\n            time += T[current_stop]\n            current_stop += 1\n        \n        # Move from bus stop N to Aoki's house\n        time += Y\n        return time\n    \n    # Process each query\n    for q in queries:\n        print(earliest_arrival(q))\n\nif __name__ == \"__main__\":\n    N, X, Y = map(int, input().split())\n    P = [int(input()) for _ in range(N - 1)]\n    T = [int(input()) for _ in range(N - 1)]\n    Q = int(input())\n    queries = [int(input()) for _ in range(Q)]\n    process_queries(N, X, Y, P, T, Q, queries)"
        ]
    },
    {
        "question_id": "abc320_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    A, B = map(int, input().split())\n    result = pow(A, B) + pow(B, A)\n    print(result)"
        ]
    },
    {
        "question_id": "abc320_b",
        "code_list": [
            "def expand_around_center(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1\n\ndef longest_palindromic_substring(s):\n    if len(s) < 2:\n        return len(s)\n    \n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(s, i, i)       # Odd length palindromes\n        len2 = expand_around_center(s, i, i + 1)   # Even length palindromes\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    \n    return end - start + 1\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(longest_palindromic_substring(s))"
        ]
    },
    {
        "question_id": "abc320_c",
        "code_list": [
            "def find_min_time(M, S):\n    # Check if all strings are the same\n    if S[0] == S[1] == S[2]:\n        return 0\n    \n    # Check for each possible time from 0 to M-1\n    for t in range(M):\n        if S[0][t % M] == S[1][t % M] == S[2][t % M]:\n            return t\n    \n    # If no valid time found, return -1\n    return -1\n\nif __name__ == \"__main__\":\n    M = int(input())\n    S = [input() for _ in range(3)]\n    print(find_min_time(M, S))"
        ]
    },
    {
        "question_id": "abc320_d",
        "code_list": [
            "from collections import defaultdict\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    info = defaultdict(list)\n    index = 2\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        X = int(data[index + 2])\n        Y = int(data[index + 3])\n        info[B].append((A, X, Y))\n        index += 4\n    \n    coordinates = [None] * (N + 1)\n    coordinates[1] = (0, 0)\n    \n    def dfs(person, x, y):\n        if coordinates[person] is None:\n            coordinates[person] = (x, y)\n        elif coordinates[person] != (x, y):\n            print(\"undecidable\")\n            exit(0)\n    \n    dfs(1, 0, 0)\n    \n    for person in range(2, N + 1):\n        if coordinates[person] is not None:\n            continue\n        if not info[person]:\n            print(\"undecidable\")\n            continue\n        valid = False\n        for A, X, Y in info[person]:\n            if coordinates[A] is None:\n                continue\n            dx, dy = X - coordinates[A][0], Y - coordinates[A][1]\n            if coordinates[person] is None:\n                coordinates[person] = (coordinates[A][0] + dx, coordinates[A][1] + dy)\n                valid = True\n            elif coordinates[person] != (coordinates[A][0] + dx, coordinates[A][1] + dy):\n                print(\"undecidable\")\n                exit(0)\n        if not valid:\n            print(\"undecidable\")\n    \n    for i in range(1, N + 1):\n        if coordinates[i] is None:\n            print(\"undecidable\")\n        else:\n            print(coordinates[i][0], coordinates[i][1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc320_e",
        "code_list": [
            "from collections import deque\n\ndef main():\n    N, M = map(int, input().split())\n    events = []\n    for _ in range(M):\n        T, W, S = map(int, input().split())\n        events.append((T, W, S))\n    \n    # Initialize the deque with all people\n    people = deque(range(1, N + 1))\n    noodles = [0] * (N + 1)\n    \n    current_time = 0\n    \n    for T, W, S in events:\n        while people and current_time >= people[0]:\n            person = people.popleft()\n            current_time += S\n        \n        if people:\n            person = people[0]\n            noodles[person] += W\n        \n        current_time = max(current_time, T) + S - 1\n    \n    # Handle the return of people\n    for _ in range(M):\n        T, W, S = events.pop()\n        while people and current_time >= people[0]:\n            person = people.popleft()\n            current_time += S\n            noodles[person] += W\n    \n    # Print the result\n    for i in range(1, N + 1):\n        print(noodles[i])"
        ]
    },
    {
        "question_id": "abc321_a",
        "code_list": [
            "def is_321_like_number(N):\n    digits = [int(d) for d in str(N)]\n    for i in range(len(digits) - 1):\n        if digits[i] <= digits[i + 1]:\n            return \"No\"\n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(is_321_like_number(N))"
        ]
    },
    {
        "question_id": "abc321_b",
        "code_list": [
            "def main():\n    N, X = map(int, input().split())\n    scores = list(map(int, input().split()))\n    \n    # Sort the scores\n    scores.sort()\n    \n    # Calculate the current sum without the highest and lowest scores\n    current_sum = sum(scores[1:-1])\n    \n    # Calculate the minimum score needed in the last round\n    min_score_needed = X - current_sum\n    \n    # Check if the minimum score needed is valid\n    if min_score_needed < 0:\n        min_score_needed = max(0, min_score_needed + scores[-2] - scores[1])\n    elif min_score_needed > 100:\n        min_score_needed = 100\n    \n    # Check if the minimum score needed is achievable\n    if current_sum + min_score_needed >= X:\n        print(min_score_needed)\n    else:\n        print(-1)"
        ]
    },
    {
        "question_id": "abc321_c",
        "code_list": [
            "from itertools import combinations\n\ndef generate_321_like_numbers(n):\n    digits = '9876543210'\n    result = []\n    for r in range(1, 11):  # Generate numbers with 1 to 10 digits\n        for combo in combinations(digits, r):\n            num = int(''.join(combo))\n            if num <= n:\n                result.append(num)\n            else:\n                break\n    return sorted(result)\n\ndef find_kth_321_like_number(k):\n    k -= 1  # Convert to 0-indexed\n    nums = generate_321_like_numbers(10**10)\n    return nums[k]\n\nif __name__ == \"__main__\":\n    k = int(input().strip())\n    print(find_kth_321_like_number(k))"
        ]
    },
    {
        "question_id": "abc321_d",
        "code_list": [
            "def calculate_total_price(N, M, P, A, B):\n    total_price = 0\n    A.sort()\n    B.sort()\n    \n    # Calculate the contribution of each main dish\n    for i in range(N):\n        if A[i] + B[0] > P:\n            total_price += (P - B[0]) * M\n        else:\n            total_price += sum(min(A[i] + b, P) for b in B)\n    \n    return total_price\n\nif __name__ == \"__main__\":\n    N, M, P = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(calculate_total_price(N, M, P, A, B))"
        ]
    },
    {
        "question_id": "abc321_e",
        "code_list": [
            "def count_vertices_distance(N, X, K):\n    if K == 0:\n        return 1 if X == 1 else 0\n    \n    count = 0\n    current_level = [X]\n    level = 0\n    \n    while current_level and level < K:\n        next_level = []\n        for node in current_level:\n            parent = node // 2\n            if parent != 0:\n                next_level.append(parent)\n        current_level = next_level\n        level += 1\n        \n        if level == K:\n            count = len(current_level)\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        X = int(data[index + 1])\n        K = int(data[index + 2])\n        index += 3\n        result = count_vertices_distance(N, X, K)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            print(i + 1)\n            return\n    print(-1)"
        ]
    },
    {
        "question_id": "abc322_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    S = input().strip()\n    T = input().strip()\n    \n    # Check if S is a prefix of T\n    is_prefix = T.startswith(S)\n    # Check if S is a suffix of T\n    is_suffix = T.endswith(S)\n    \n    # Determine the result based on the conditions\n    if is_prefix and is_suffix:\n        print(0)\n    elif is_prefix and not is_suffix:\n        print(1)\n    elif not is_prefix and is_suffix:\n        print(2)\n    else:\n        print(3)"
        ]
    },
    {
        "question_id": "abc322_c",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Initialize the result list\n    result = [0] * N\n\n    # Fill in the result list\n    for i in range(N):\n        if i + 1 in A:\n            result[i] = 0\n        else:\n            result[i] = min([A[j] - i - 1 for j in range(M) if A[j] > i + 1])\n\n    # Print the result\n    for r in result:\n        print(r)"
        ]
    },
    {
        "question_id": "abc322_d",
        "code_list": [
            "def rotate(polyomino):\n    \"\"\"Rotate the polyomino 90 degrees clockwise.\"\"\"\n    return [''.join(row) for row in zip(*polyomino[::-1])]\n\ndef flip(polyomino):\n    \"\"\"Flip the polyomino vertically.\"\"\"\n    return polyomino[::-1]\n\ndef place_polyomino(grid, polyomino, x, y, orientation):\n    \"\"\"Place the polyomino on the grid starting at (x, y) with given orientation.\"\"\"\n    for dx in range(4):\n        for dy in range(4):\n            if polyomino[dx][dy] == '#':\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 4 and 0 <= ny < 4 and grid[nx][ny] != '.':\n                    return False\n                grid[nx][ny] = '#'\n    return True\n\ndef remove_polyomino(grid, polyomino, x, y, orientation):\n    \"\"\"Remove the polyomino from the grid starting at (x, y) with given orientation.\"\"\"\n    for dx in range(4):\n        for dy in range(4):\n            if polyomino[dx][dy] == '#':\n                nx, ny = x + dx, y + dy\n                grid[nx][ny] = '.'\n\ndef check_fit(grid, polyomino, orientations):\n    \"\"\"Check if the polyomino fits in the grid without overlapping.\"\"\"\n    for orientation in orientations:\n        for x in range(4):\n            for y in range(4):\n                if place_polyomino(grid, polyomino, x, y, orientation):\n                    if all(cell == '#' for row in grid for cell in row):\n                        return True\n                    remove_polyomino(grid, polyomino, x, y, orientation)\n        if orientation != 'original':\n            polyomino = flip(polyomino)\n            for x in range(4):\n                for y in range(4):\n                    if place_polyomino(grid, polyomino, x, y, orientation):\n                        if all(cell == '#' for row in grid for cell in row):\n                            return True\n                        remove_polyomino(grid, polyomino, x, y, orientation)\n        polyomino = rotate(polyomino)\n    return False\n\ndef main():\n    polyominoes = []\n    for _ in range(3):\n        polyomino = [input().strip() for _ in range(4)]\n        polyominoes.append(polyomino)\n\n    orientations = ['original']\n    for i in range(3):\n        for _ in range(3):\n            polyominoes[i] = rotate(polyominoes[i])\n            orientations.append('rotated')\n\n    grid = [['.' for _ in range(4)] for _ in range(4)]\n\n    if check_fit(grid, polyominoes[0], orientations) and \\\n       check_fit(grid, polyominoes[1], orientations) and \\\n       check_fit(grid, polyominoes[2], orientations):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc322_e",
        "code_list": [
            "import sys\nfrom itertools import combinations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N, K, P = int(data[0]), int(data[1]), int(data[2])\n    costs = []\n    effects = [[] for _ in range(K)]\n    \n    start = 3\n    for i in range(N):\n        cost = int(data[start])\n        start += 1\n        for j in range(K):\n            effect = int(data[start + j])\n            effects[j].append(effect)\n        costs.append(cost)\n    \n    # Calculate the total increase needed for each parameter\n    target = [P - sum(effects[j]) for j in range(K)]\n    \n    # If any target is negative, it's impossible to achieve the goal\n    if any(t < 0 for t in target):\n        print(-1)\n        return\n    \n    # Find the minimum cost to achieve the goal\n    min_cost = float('inf')\n    for r in range(K + 1):\n        for combo in combinations(range(N), r):\n            current_cost = 0\n            current_effect = [0] * K\n            for idx in combo:\n                current_cost += costs[idx]\n                for j in range(K):\n                    current_effect[j] += effects[idx][j]\n            if all(te >= t for te, t in zip(current_effect, target)):\n                min_cost = min(min_cost, current_cost)\n    \n    print(min_cost if min_cost != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    for i in range(2, 17, 2):\n        if S[i-1] != '0':\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_b",
        "code_list": [
            "def main():\n    N = int(input())\n    wins = [0] * N\n    \n    for i in range(N):\n        S_i = input()\n        for j in range(N):\n            if S_i[j] == 'o':\n                wins[i] += 1\n    \n    ranked_players = sorted(range(N), key=lambda k: (-wins[k], k))\n    \n    for player in ranked_players:\n        print(player + 1, end=' ')"
        ]
    },
    {
        "question_id": "abc323_c",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    def calculate_score(solved, scores):\n        return sum(scores[i] for i in range(M) if s[i] == 'o') + (solved + 1)\n    \n    results = []\n    for _ in range(N):\n        S = input()\n        max_score = calculate_score(S.count('o'), A)\n        needed_problems = float('inf')\n        \n        for i in range(M):\n            if S[i] == 'x':\n                new_score = calculate_score(S.count('o') + 1, A[:i] + [A[i]] + A[i+1:])\n                if new_score > max_score:\n                    needed_problems = min(needed_problems, 1)\n                else:\n                    for j in range(i + 1, M):\n                        if S[j] == 'x':\n                            new_score = calculate_score(S.count('o') + 2, A[:i] + [A[i]] + A[i+1:j] + [A[j]] + A[j+1:])\n                            if new_score > max_score:\n                                needed_problems = min(needed_problems, 2)\n                                break\n                            else:\n                                for k in range(j + 1, M):\n                                    if S[k] == 'x':\n                                        new_score = calculate_score(S.count('o') + 3, A[:i] + [A[i]] + A[i+1:j] + [A[j]] + A[j+1:k] + [A[k]] + A[k+1:])\n                                        if new_score > max_score:\n                                            needed_problems = min(needed_problems, 3)\n                                            break\n                                        else:\n                                            break\n                                    else:\n                                        break\n                                else:\n                                    break\n                            break\n                        else:\n                            break\n                    else:\n                        break\n        \n        results.append(needed_problems)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc323_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    sizes = []\n    counts = []\n    \n    for _ in range(N):\n        sizes.append(int(data[index]))\n        counts.append(int(data[index+1]))\n        index += 2\n    \n    min_slimes = 0\n    for i in range(N):\n        if counts[i] % 2 == 1:\n            min_slimes += 1\n    \n    print(sum(counts) - min_slimes)"
        ]
    },
    {
        "question_id": "abc323_e",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\ndef modinv(a, m=998244353):\n    return pow(a, m - 2, m)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef main():\n    N, X = map(int, input().split())\n    T = list(map(int, input().split()))\n    \n    total_time = sum(T)\n    prob = [0] * N\n    for i in range(N):\n        prob[i] = T[i] / total_time\n    \n    dp = [0] * (X + 1)\n    dp[0] = 1\n    for t in T:\n        for x in range(t - 1, -1, -1):\n            if x >= 0:\n                dp[x + t] += dp[x]\n            else:\n                dp[t] += dp[0]\n        for x in range(X + 1):\n            dp[x] %= 998244353\n    \n    ans = 0\n    for i in range(N):\n        ans += prob[i] * dp[X]\n        ans %= 998244353\n    \n    # Calculate the modular inverse of the denominator\n    denom = reduce(lambda x, y: x * y % 998244353, prob)\n    inv_denom = modinv(denom)\n    \n    # Calculate the final result\n    result = ans * inv_denom % 998244353\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_a",
        "code_list": [
            "def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    if len(set(A)) == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_b",
        "code_list": [
            "import math\n\ndef main():\n    N = int(input())\n    # Check if N is divisible by 2 and then by 3 until it's no longer divisible\n    while N % 2 == 0:\n        N //= 2\n    while N % 3 == 0:\n        N //= 3\n    \n    # If after division N is 1, it means N was only composed of factors 2 and 3\n    if N == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_c",
        "code_list": [
            "def is_transformable(s, t):\n    if len(s) == len(t):\n        return s == t\n    if len(s) + 1 != len(t):\n        return False\n    \n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n    return i == len(s)\n\ndef find_possible_strings(n, t_prime, strings):\n    possible_indices = []\n    for i, s in enumerate(strings):\n        if is_transformable(s, t_prime):\n            possible_indices.append(i + 1)\n    \n    return possible_indices\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[1])\n    t_prime = data[2]\n    strings = data[3:]\n    \n    possible_indices = find_possible_strings(n, t_prime, strings)\n    print(len(possible_indices))\n    print(' '.join(map(str, possible_indices)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc324_d",
        "code_list": [
            "import math\nfrom itertools import permutations\n\ndef is_square(num):\n    return int(math.isqrt(num)) ** 2 == num\n\ndef count_square_numbers(N, S):\n    count = 0\n    for perm in permutations(range(N)):\n        num = 0\n        for i, p in enumerate(perm):\n            num += int(S[p]) * (10 ** (N - i - 1))\n        if is_square(num):\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    print(count_square_numbers(N, S))"
        ]
    },
    {
        "question_id": "abc324_e",
        "code_list": [
            "from collections import defaultdict\n\ndef is_subsequence(s, t):\n    t_index = 0\n    for char in s:\n        if t_index < len(t) and char == t[t_index]:\n            t_index += 1\n    return t_index == len(t)\n\ndef count_pairs(N, T, strings):\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            if is_subsequence(strings[i] + strings[j], T):\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    N, T = input().split()\n    N = int(N)\n    strings = [input().strip() for _ in range(N)]\n    print(count_pairs(N, T, strings))"
        ]
    },
    {
        "question_id": "abc324_f",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start, end):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if u == end:\n            break\n        if d > dist[u]:\n            continue\n        for v, b, c in graph[u]:\n            new_d = d + c\n            new_b = b + dist[u]\n            if new_d * new_b > dist[v] * b:\n                dist[v] = new_d\n                heapq.heappush(pq, (new_d, v))\n    return dist[end]\n\ndef max_beauty_cost_ratio(N, M, edges):\n    graph = defaultdict(list)\n    for u, v, b, c in edges:\n        graph[u-1].append((v-1, b, c))\n    \n    max_ratio = 0\n    for u, v, b, c in edges:\n        # Calculate the beauty/cost ratio for the path from 1 to N via this edge\n        ratio = (b + edges[-1][0]) / (c + edges[-1][1])\n        if ratio > max_ratio:\n            max_ratio = ratio\n    \n    return max_ratio\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        u, v, b, c = map(int, input().split())\n        edges.append((u-1, v-1, b, c))\n    \n    result = max_beauty_cost_ratio(N, M, edges)\n    print(f\"{result:.15f}\")"
        ]
    },
    {
        "question_id": "abc325_a",
        "code_list": [
            "def main():\n    S, T = input().split()\n    print(f\"{S} san\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_b",
        "code_list": [
            "def main():\n    N = int(input())\n    bases = []\n    for _ in range(N):\n        W, X = map(int, input().split())\n        # Calculate the start and end times of the working hours in UTC\n        start_time = (X + 9) % 24\n        end_time = (X + 18) % 24\n        bases.append((start_time, end_time, W))\n    \n    max_employees = 0\n    for start in range(24):\n        end = start + 1\n        employees = 0\n        for start_time, end_time, W in bases:\n            if start <= start_time and end_time <= end:\n                employees += W\n        max_employees = max(max_employees, employees)\n    \n    print(max_employees)"
        ]
    },
    {
        "question_id": "abc325_c",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    \n    def merge_sensors(i, j):\n        stack = [(i, j)]\n        while stack:\n            x, y = stack.pop()\n            if grid[x][y] == '.':\n                continue\n            grid[x][y] = '.'\n            for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '#':\n                    stack.append((nx, ny))\n    \n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                merge_sensors(i, j)\n                count += 1\n    \n    print(count)"
        ]
    },
    {
        "question_id": "abc325_d",
        "code_list": [
            "import heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    events = []\n    index = 1\n    \n    # Parse the input and create events\n    for i in range(N):\n        T = int(data[index])\n        D = int(data[index + 1])\n        events.append((T, 'enter', i))\n        events.append((T + D - 1, 'leave', i))\n        index += 2\n    \n    # Sort events by time, and by type (enter before leave), and by product index\n    events.sort()\n    \n    charge_time_ends = []  # Heap to manage charge times\n    printed_count = 0  # Count of printed products\n    \n    for event in events:\n        time, event_type, product_index = event\n        \n        # If it's a charge time end, make the printer available\n        if event_type == 'charge_end':\n            heapq.heappush(charge_time_ends, time)\n        \n        # If it's an enter event, try to print on the product\n        elif event_type == 'enter':\n            while charge_time_ends and charge_time_ends[0] <= time:\n                heapq.heappop(charge_time_ends)\n            \n            if len(charge_time_ends) < printed_count:\n                printed_count += 1\n                heapq.heappush(charge_time_ends, time + 1)\n        \n        # If it's a leave event, the printer becomes available\n        else:\n            if charge_time_ends and charge_time_ends[0] <= time:\n                heapq.heappop(charge_time_ends)\n    \n    print(printed_count)"
        ]
    },
    {
        "question_id": "abc325_e",
        "code_list": [
            "import heapq\n\ndef dijkstra(n, A, B, C, D):\n    # Initialize distances with infinity\n    dist = [[float('inf')] * n for _ in range(n)]\n    # Distance from city 1 to itself is 0\n    dist[0][0] = 0\n    \n    # Priority queue to store (time, current_city, last_transport)\n    pq = [(0, 0, 'car')]\n    \n    while pq:\n        time, city, transport = heapq.heappop(pq)\n        \n        if time > dist[city][transport == 'car']:\n            continue\n        \n        # Calculate time for next city using company car\n        for next_city in range(n):\n            if D[city][next_city] == float('inf'):\n                continue\n            new_time_car = time + D[city][next_city] * (A if transport == 'car' else B + C)\n            if new_time_car < dist[next_city]['car']:\n                dist[next_city]['car'] = new_time_car\n                heapq.heappush(pq, (new_time_car, next_city, 'car'))\n        \n        # Calculate time for next city using train\n        for next_city in range(n):\n            if D[city][next_city] == float('inf'):\n                continue\n            new_time_train = time + D[city][next_city] * (B + C)\n            if new_time_train < dist[next_city]['train']:\n                dist[next_city]['train'] = new_time_train\n                heapq.heappush(pq, (new_time_train, next_city, 'train'))\n        \n        # Switch to train in the current city\n        if transport == 'car':\n            for next_city in range(n):\n                if D[city][next_city] == float('inf'):\n                    continue\n                new_time_switch = time + D[city][next_city] * A\n                if new_time_switch < dist[next_city]['train']:\n                    dist[next_city]['train'] = new_time_switch\n                    heapq.heappush(pq, (new_time_switch, next_city, 'train'))\n    \n    # Return the minimum time to reach city N\n    return min(dist[n-1]['car'], dist[n-1]['train'])\n\ndef main():\n    # Read input\n    N, A, B, C = map(int, input().split())\n    D = []\n    for _ in range(N):\n        row = list(map(int, input().split()))\n        D.append(row)\n    \n    # Ensure D[i][i] = 0\n    for i in range(N):\n        D[i][i] = 0\n    \n    # Find the minimum time to travel from city 1 to city N\n    result = dijkstra(N, A, B, C, D)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc325_f",
        "code_list": [
            "import sys\nfrom heapq import heappush, heappop\n\ndef main():\n    input = sys.stdin.readline\n    N = int(input())\n    D = list(map(int, input().split()))\n    L1, C1, K1 = map(int, input().split())\n    L2, C2, K2 = map(int, input().split())\n\n    # Create a min heap to store the costs of monitoring each section\n    sections = []\n    for d in D:\n        # Calculate the number of type-1 and type-2 sensors needed to monitor the section\n        type1 = (d + L1 - 1) // L1\n        type2 = (d + L2 - 1) // L2\n        # Calculate the cost of using only type-1 sensors\n        cost_type1 = type1 * C1\n        # Calculate the cost of using only type-2 sensors\n        cost_type2 = type2 * C2\n        # Push the minimum cost to the heap\n        heappush(sections, (min(cost_type1, cost_type2), d))\n\n    total_cost = 0\n    type1_count = 0\n    type2_count = 0\n\n    while sections:\n        cost, d = heappop(sections)\n        if type1_count < K1:\n            type1_count += 1\n            total_cost += cost\n        elif type2_count < K2:\n            type2_count += 1\n            total_cost += cost\n        else:\n            # If we cannot use any more sensors, check if the remaining sections can be covered\n            remaining_sections = [section for section in sections if section[1] > d]\n            if not remaining_sections:\n                break\n            # Find the section with the minimum cost that can cover the current section\n            min_cost = float('inf')\n            for section in remaining_sections:\n                cost, _ = section\n                if cost < min_cost:\n                    min_cost = cost\n            total_cost += min_cost\n            sections = [(cost, d) for cost, _ in remaining_sections if cost != min_cost]\n            sections.append((min_cost, d))\n            sections.sort(key=lambda x: x[0])\n\n    # Check if all sections are covered\n    if len(sections) == 0:\n        print(total_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_a",
        "code_list": [
            "def main():\n    X, Y = map(int, input().split())\n    if abs(X - Y) <= 2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_b",
        "code_list": [
            "def find_next_326_like_number(N):\n    for num in range(N, 1000):\n        hundreds = num // 100\n        tens = (num // 10) % 10\n        ones = num % 10\n        if hundreds * tens == ones:\n            return num\n\nif __name__ == \"__main__\":\n    N = int(input())\n    print(find_next_326_like_number(N))"
        ]
    },
    {
        "question_id": "abc326_c",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    \n    max_gifts = 0\n    for i in range(N):\n        if i + M > A[i]:\n            max_gifts = max(max_gifts, sum(1 for j in range(i, N) if A[j] < A[i] + M))\n    \n    print(max_gifts)"
        ]
    },
    {
        "question_id": "abc326_d",
        "code_list": [
            "from itertools import permutations\n\ndef solve(N, R, C):\n    # Generate all possible permutations for rows and columns\n    row_perms = list(permutations('ABC' * (N // 3 + 1), N))\n    col_perms = list(permutations('ABC' * (N // 3 + 1), N))\n\n    # Filter permutations based on the required conditions\n    valid_rows = [perm for perm in row_perms if all(perm[i] == ch for i, ch in enumerate(R))]\n    valid_cols = [perm for perm in col_perms if all(perm[i] == ch for i, ch in enumerate(C))]\n\n    # Check for intersection of valid rows and columns\n    for row_perm in valid_rows:\n        for col_perm in valid_cols:\n            grid = [['.' for _ in range(N)] for _ in range(N)]\n            used = set()\n\n            # Place characters in the grid based on row and column permutations\n            for i in range(N):\n                for j in range(N):\n                    if (i, j) not in used:\n                        grid[i][j] = row_perm[i]\n                        grid[j][i] = col_perm[j]\n                        used.add((i, j))\n\n            # Check if the grid satisfies the condition of having exactly one A, B, and C per row and column\n            if all(grid[i].count(ch) == 1 for ch in 'ABC') and all(grid[j].count(ch) == 1 for ch in 'ABC'):\n                return grid\n\n    return None\n\ndef main():\n    N = int(input().strip())\n    R = input().strip()\n    C = input().strip()\n\n    result = solve(N, R, C)\n    if result:\n        print(\"Yes\")\n        for row in result:\n            print(''.join(row))\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc326_e",
        "code_list": [
            "from typing import List\n\ndef calculate_expected_salary(N: int, A: List[int]) -> int:\n    mod = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = sum(A) % mod\n    \n    for i in range(1, N + 1):\n        dp[i] = (dp[i - 1] + A[i - 1]) % mod\n        dp[i] = (dp[i] - dp[max(0, i - i)] + mod) % mod\n    \n    return dp[N]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(calculate_expected_salary(N, A))"
        ]
    },
    {
        "question_id": "abc327_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    for i in range(N - 1):\n        if S[i] == 'a' and S[i + 1] == 'b' or S[i] == 'b' and S[i + 1] == 'a':\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc327_b",
        "code_list": [
            "import math\n\ndef main():\n    B = int(input())\n    for A in range(1, int(B ** 0.5) + 1):\n        if A ** A == B:\n            print(A)\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc327_c",
        "code_list": [
            "def is_valid_sudoku(grid):\n    # Check rows\n    for row in grid:\n        if sorted(row) != list(range(1, 10)):\n            return \"No\"\n    \n    # Check columns\n    for col in range(9):\n        if sorted([grid[row][col] for row in range(9)]) != list(range(1, 10)):\n            return \"No\"\n    \n    # Check 3x3 subgrids\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            subgrid = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if sorted(subgrid) != list(range(1, 10)):\n                return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    grid = []\n    for _ in range(9):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    print(is_valid_sudoku(grid))"
        ]
    },
    {
        "question_id": "abc327_d",
        "code_list": [
            "def is_good_pair(N, M, A, B):\n    # Create a dictionary to store the relationship between A and B indices\n    relationships = {}\n    for i in range(M):\n        if A[i] not in relationships:\n            relationships[A[i]] = []\n        relationships[A[i]].append(B[i])\n    \n    # Check if there's any conflict in the relationships\n    for index, related_indices in relationships.items():\n        if len(set(related_indices)) < len(related_indices) - 1:\n            return \"No\"\n    \n    # If no conflicts, check if we can find a valid X sequence\n    for i in range(1, N + 1):\n        if i not in relationships:\n            return \"Yes\"\n    \n    return \"No\"\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(is_good_pair(N, M, A, B))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc327_e",
        "code_list": [
            "import heapq\nfrom math import sqrt\n\ndef calculate_rating(performance, k):\n    numerator = sum((0.9)**(k-i) * performance[i] for i in range(k))\n    denominator = sum((0.9)**(k-i) for i in range(k))\n    return numerator / denominator - 1200 / sqrt(k)\n\ndef max_rating(contests):\n    n = len(contests)\n    max_heap = []\n    \n    # Initialize the heap with the first element\n    for i in range(n):\n        heapq.heappush(max_heap, (-contests[i], i))\n    \n    max_rating = float('-inf')\n    \n    for k in range(1, n + 1):\n        current_sum = 0\n        for _ in range(k):\n            _, index = heapq.heappop(max_heap)\n            current_sum += contests[index]\n        \n        max_rating = max(max_rating, calculate_rating(contests, k))\n        \n        # Reinsert the elements back into the heap\n        for _ in range(k):\n            value, index = heapq.heappop(max_heap)\n            heapq.heappush(max_heap, (value, index))\n    \n    return max_rating\n\nif __name__ == \"__main__\":\n    n = int(input())\n    performances = list(map(int, input().split()))\n    print(max_rating(performances))"
        ]
    },
    {
        "question_id": "abc328_a",
        "code_list": [
            "def main():\n    # Read input values\n    N, X = map(int, input().split())\n    scores = list(map(int, input().split()))\n    \n    # Calculate total score for problems with score X or less\n    total_score = sum(score for score in scores if score <= X)\n    \n    # Print the result\n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc328_b",
        "code_list": [
            "def is_repdigit(n):\n    return n == int(str(n) * len(str(n)))\n\ndef count_repdigit_dates(N, days):\n    repdigit_count = 0\n    for i, D_i in enumerate(days, start=1):\n        for j in range(1, D_i + 1):\n            if is_repdigit(i) and is_repdigit(j):\n                repdigit_count += 1\n    return repdigit_count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    days = list(map(int, input().split()))\n    print(count_repdigit_dates(N, days))"
        ]
    },
    {
        "question_id": "abc328_c",
        "code_list": [
            "def count_consecutive_letters(s, queries):\n    n = len(s)\n    # Precompute the positions of consecutive letters\n    prev_positions = [-1] * n\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            prev_positions[i + 1] = i\n    \n    results = []\n    for l, r in queries:\n        count = 0\n        for i in range(l, r):\n            if prev_positions[i] >= l:\n                count += 1\n        results.append(count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, q = int(data[0]), int(data[1])\n    s = data[2]\n    queries = [(int(data[3 * i + 3]), int(data[3 * i + 4])) for i in range(q)]\n    \n    results = count_consecutive_letters(s, queries)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc328_d",
        "code_list": [
            "def main():\n    S = input().strip()\n    while 'ABC' in S:\n        S = S.replace('ABC', '', 1)\n    print(S)"
        ]
    },
    {
        "question_id": "abc328_e",
        "code_list": [
            "from typing import List\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef find(parent: List[int], x: int) -> int:\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent: List[int], rank: List[int], x: int, y: int) -> None:\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef kruskal(n: int, edges: List[List[int]], k: int) -> int:\n    parent = list(range(n))\n    rank = [0] * n\n    edges.sort(key=lambda x: x[2])\n    total_cost = 0\n    for u, v, w in edges:\n        if find(parent, u) != find(parent, v):\n            union(parent, rank, u, v)\n            total_cost = (total_cost + w) % k\n    return total_cost\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        edges.append([u - 1, v - 1, w])\n    print(kruskal(n, edges, k))"
        ]
    },
    {
        "question_id": "abc329_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    for i in range(len(S)):\n        print(S[i], end=' ')"
        ]
    },
    {
        "question_id": "abc329_b",
        "code_list": [
            "def main():\n    import heapq\n    \n    # Read the number of integers\n    N = int(input())\n    \n    # Read the list of integers\n    A = list(map(int, input().split()))\n    \n    # Find the largest integer\n    largest = max(A)\n    \n    # Remove the largest integer from the list\n    A.remove(largest)\n    \n    # Find and print the largest integer that is not the largest\n    print(heapq.nlargest(1, A)[0])"
        ]
    },
    {
        "question_id": "abc329_c",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    \n    count = 0\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N and S[j] == S[i]:\n            j += 1\n        length = j - i\n        count += length * (length + 1) // 2\n        i = j\n    \n    print(count)"
        ]
    },
    {
        "question_id": "abc329_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    votes = list(map(int, input().split()))\n    \n    # Initialize counters for each candidate\n    candidate_counts = defaultdict(int)\n    max_count = 0\n    winner = 0\n    \n    for i, vote in enumerate(votes):\n        candidate_counts[vote] += 1\n        \n        # Update the maximum count if necessary\n        if candidate_counts[vote] > max_count:\n            max_count = candidate_counts[vote]\n            winner = vote\n        elif candidate_counts[vote] == max_count:\n            winner = min(winner, vote)\n        \n        print(winner)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc329_e",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    S = input().strip()\n    T = input().strip()\n\n    # Check if it's possible to match S with X using the given operations\n    def is_possible_to_match(S, T):\n        for i in range(N - M + 1):\n            # Create a copy of S to simulate the operation\n            X = list(S)\n            for j in range(M):\n                X[i + j] = T[j]\n            # Check if the simulated X matches S\n            if ''.join(X) == S:\n                return True\n        return False\n\n    result = \"Yes\" if is_possible_to_match(S, T) else \"No\"\n    print(result)"
        ]
    },
    {
        "question_id": "abc329_f",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    # Read input\n    N, Q = map(int, input().split())\n    colors = list(map(int, input().split()))\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    # Initialize data structures\n    box_contents = defaultdict(set)\n    color_counts = defaultdict(int)\n    \n    # Process initial state\n    for i, color in enumerate(colors):\n        box_contents[i + 1].add(color)\n        color_counts[color] += 1\n    \n    # Process queries\n    for a, b in queries:\n        # Move all balls from box a to box b\n        for color in box_contents[a]:\n            box_contents[b].add(color)\n            color_counts[color] -= 1\n        box_contents[a] = set()\n        \n        # Print the number of different colors in box b\n        print(len(box_contents[b]))\n        \n        # Update the count of colors in box b\n        for color in box_contents[b]:\n            color_counts[color] += 1\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc330_a",
        "code_list": [
            "def main():\n    # Read input\n    N, L = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Count the number of people who passed\n    passed_count = sum(1 for score in A if score >= L)\n    \n    # Output the result\n    print(passed_count)"
        ]
    },
    {
        "question_id": "abc330_b",
        "code_list": [
            "def main():\n    # Read input\n    N, L, R = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Find X_i for each i\n    Xi = []\n    for a in A:\n        if a >= L and a <= R:\n            Xi.append(a)\n        elif a < L:\n            Xi.append(L)\n        else:\n            Xi.append(R)\n\n    # Print the result\n    print(*Xi)"
        ]
    },
    {
        "question_id": "abc330_c",
        "code_list": [
            "import math\n\ndef min_abs_difference(D):\n    min_diff = float('inf')\n    # Iterate over possible values of x\n    for x in range(int(math.sqrt(D)) + 1):\n        # Calculate the remaining value after subtracting x^2 from D\n        remaining = D - x * x\n        # Check if the remaining value is a perfect square\n        y_squared = int(math.isqrt(remaining)) ** 2\n        if y_squared == remaining:\n            min_diff = 0\n            break\n        else:\n            # Calculate the closest perfect square less than or equal to remaining\n            y = int(math.isqrt(remaining))\n            min_diff = min(min_diff, abs(x * x + y * y - D), abs(x * x + (y + 1) * (y + 1) - D))\n    return min_diff\n\nif __name__ == \"__main__\":\n    D = int(input().strip())\n    print(min_abs_difference(D))"
        ]
    },
    {
        "question_id": "abc330_d",
        "code_list": [
            "from collections import Counter\n\ndef count_triples(N, grid):\n    # Count the number of 'o's in each row and column\n    row_counts = [Counter(row) for row in grid]\n    col_counts = [Counter(col) for col in zip(*grid)]\n    \n    # Calculate the number of valid triples\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'o':\n                # Count pairs in the same row but different columns\n                same_row_pairs = (row_counts[i]['o'] - 1) * (N - 1 - col_counts[j]['o'])\n                # Count pairs in the same column but different rows\n                same_col_pairs = (col_counts[j]['o'] - 1) * (N - 1 - row_counts[i]['o'])\n                count += same_row_pairs + same_col_pairs\n    \n    return count // 2  # Each triple is counted twice\n\nif __name__ == \"__main__\":\n    N = int(input())\n    grid = [input().strip() for _ in range(N)]\n    print(count_triples(N, grid))"
        ]
    },
    {
        "question_id": "abc330_e",
        "code_list": [
            "from typing import List\n\ndef mex_of_sequence(sequence: List[int]) -> int:\n    seen = set(sequence)\n    for i in range(len(sequence)):\n        if i not in seen:\n            return i\n    return len(sequence)\n\ndef main():\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    for _ in range(Q):\n        i, x = map(int, input().split())\n        i -= 1  # Adjust index to be 0-based\n        A[i] = x\n        \n        print(mex_of_sequence(A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_a",
        "code_list": [
            "def main():\n    M, D = map(int, input().split())\n    y, m, d = map(int, input().split())\n    \n    # Calculate the next day\n    if d < D:\n        d += 1\n    else:\n        d = 1\n        if m < M:\n            m += 1\n        else:\n            m = 1\n            y += 1\n    \n    print(y, m, d)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_b",
        "code_list": [
            "import sys\n\ndef main():\n    N, S, M, L = map(int, sys.stdin.readline().split())\n    min_cost = float('inf')\n    \n    for i in range(N // 6 + 1):\n        for j in range(N // 8 + 1):\n            for k in range(N // 12 + 1):\n                if 6 * i + 8 * j + 12 * k >= N:\n                    min_cost = min(min_cost, i * S + j * M + k * L)\n    \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    suffix_sum = [0] * (n + 1)\n    count = [0] * (max(a) + 1)\n    \n    # Calculate suffix sums and counts\n    for i in range(n - 1, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + a[i]\n        count[a[i]] += 1\n    \n    # Calculate the result for each index\n    result = []\n    for i in range(n):\n        result.append(suffix_sum[i + 1] - (a[i] * count[a[i]]))\n    \n    # Print the result\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc331_d",
        "code_list": [
            "def count_black_squares(N, queries):\n    # Precompute the prefix sum of black squares for each starting point (i, j)\n    prefix_sum = [[0] * (N + 1) for _ in range(N + 1)]\n    \n    # Compute the prefix sum\n    for i in range(N):\n        for j in range(N):\n            prefix_sum[i + 1][j + 1] = prefix_sum[i + 1][j] + prefix_sum[i][j + 1] - prefix_sum[i][j] + (1 if P[i % N][j % N] == 'B' else 0)\n    \n    def query(A, B, C, D):\n        # Convert the coordinates to the grid size\n        A, B, C, D = A % N, B % N, C % N, D % N\n        return prefix_sum[C + 1][D + 1] - prefix_sum[A][D + 1] - prefix_sum[C + 1][B] + prefix_sum[A][B]\n    \n    # Process each query\n    for A, B, C, D in queries:\n        print(query(A, B, C, D))\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    P = [input() for _ in range(N)]\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    count_black_squares(N, queries)"
        ]
    },
    {
        "question_id": "abc331_e",
        "code_list": [
            "def find_most_expensive_set_meal():\n    import sys\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    N, M, L = int(data[0]), int(data[1]), int(data[2])\n    a = list(map(int, data[3:N+3]))\n    b = list(map(int, data[N+3:2*N+3]))\n    forbidden_pairs = []\n    \n    for i in range(L):\n        c, d = int(data[2*N+3+i*2]), int(data[2*N+4+i*2])\n        forbidden_pairs.append((c-1, d-1))\n    \n    max_price = 0\n    for i in range(N):\n        for j in range(M):\n            if (i, j) not in forbidden_pairs:\n                max_price = max(max_price, a[i] + b[j])\n    \n    print(max_price)\n\nif __name__ == \"__main__\":\n    find_most_expensive_set_meal()"
        ]
    },
    {
        "question_id": "abc332_a",
        "code_list": [
            "def calculate_total_cost():\n    # Read input\n    N, S, K = map(int, input().split())\n    total_price = 0\n    \n    # Calculate total price of products\n    for _ in range(N):\n        P, Q = map(int, input().split())\n        total_price += P * Q\n    \n    # Calculate shipping fee\n    if total_price < S:\n        total_price += K\n    \n    # Print the total cost\n    print(total_price)\n\nif __name__ == \"__main__\":\n    calculate_total_cost()"
        ]
    },
    {
        "question_id": "abc332_b",
        "code_list": [
            "def main():\n    K, G, M = map(int, input().split())\n    glass = 0\n    mug = 0\n    \n    for _ in range(K):\n        if glass == G:\n            glass = 0\n        elif mug < M:\n            mug = min(M, glass + mug)\n            if mug >= G:\n                glass = G\n                mug -= G\n            else:\n                glass += mug\n                mug = 0\n        else:\n            mug = M\n    \n    print(glass, mug)"
        ]
    },
    {
        "question_id": "abc332_c",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    S = input()\n\n    # Count the number of days he plans to go out for a meal (1) and attend a competitive programming event (2)\n    meal_days = S.count('1')\n    event_days = S.count('2')\n\n    # The total number of T-shirts needed is the maximum of meal_days and event_days\n    # Since he already has M plain T-shirts, we subtract M from the total if M is greater than or equal to the required number\n    tshirts_to_buy = max(meal_days, event_days) - M if M >= event_days else max(meal_days, event_days)\n\n    # Ensure the number of T-shirts to buy is non-negative\n    print(max(0, tshirts_to_buy))"
        ]
    },
    {
        "question_id": "abc332_d",
        "code_list": [
            "def min_operations_to_match_grids(H, W, A, B):\n    def count_swaps(arr1, arr2):\n        count = 0\n        for i in range(len(arr1)):\n            if arr1[i] != arr2[i]:\n                count += 1\n        return count\n\n    # Convert 2D grids to 1D lists for easier manipulation\n    A_1d = [A[i][j] for i in range(H) for j in range(W)]\n    B_1d = [B[i][j] for i in range(H) for j in range(W)]\n\n    # Check if the grids can be made identical\n    if sorted(A_1d) != sorted(B_1d):\n        return -1\n\n    # Count the number of swaps needed\n    swaps = 0\n    for i in range(H):\n        if A[i] != B[i]:\n            swaps += count_swaps(A[i], B[i])\n            A[i] = B[i]\n\n    for j in range(W):\n        col_A = [A[i][j] for i in range(H)]\n        col_B = [B[i][j] for i in range(H)]\n        if col_A != col_B:\n            swaps += count_swaps(col_A, col_B)\n            for i in range(H):\n                A[i][j] = B[i][j]\n\n    return swaps\n\nif __name__ == \"__main__\":\n    H, W = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(H)]\n    B = [list(map(int, input().split())) for _ in range(H)]\n    print(min_operations_to_match_grids(H, W, A, B))"
        ]
    },
    {
        "question_id": "abc333_a",
        "code_list": [
            "def main():\n    N = int(input())\n    result = str(N) * N\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc333_b",
        "code_list": [
            "def main():\n    # Read input\n    S1, S2 = input().split()\n    T1, T2 = input().split()\n    \n    # Define the positions of the vertices of the pentagon\n    positions = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}\n    \n    # Calculate the indices of the points\n    idx_S1, idx_S2 = positions[S1], positions[S2]\n    idx_T1, idx_T2 = positions[T1], positions[T2]\n    \n    # Calculate the distances using the properties of a regular pentagon\n    def distance(i1, i2):\n        if i1 == i2:\n            return 0\n        elif abs(i1 - i2) <= 2:\n            return 1\n        else:\n            return 2\n    \n    # Check if the distances are equal\n    if distance(idx_S1, idx_S2) == distance(idx_T1, idx_T2):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc333_c",
        "code_list": [
            "def generate_repunit(n):\n    return int('1' * n)\n\ndef find_nth_sum_of_three_repunits(N):\n    count = 0\n    i = 1\n    while True:\n        repunit_i = generate_repunit(i)\n        j = 1\n        while True:\n            repunit_j = generate_repunit(j)\n            k = 1\n            while True:\n                repunit_k = generate_repunit(k)\n                total = repunit_i + repunit_j + repunit_k\n                if total > 10**10:  # To avoid very large numbers\n                    break\n                count += 1\n                if count == N:\n                    return total\n                k += 1\n            j += 1\n        i += 1\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(find_nth_sum_of_three_repunits(N))"
        ]
    },
    {
        "question_id": "abc333_d",
        "code_list": [
            "import sys\n\ndef dfs(node, parent, graph):\n    depth = 0\n    for child in graph[node]:\n        if child != parent:\n            d = dfs(child, node, graph) + 1\n            if d > depth:\n                depth = d\n    return depth\n\ndef min_operations_to_delete_vertex_1(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Find the maximum depth of the subtree rooted at each node\n    max_depth = [0] * (N + 1)\n    for i in range(2, N + 1):\n        max_depth[i] = dfs(i, 0, graph)\n    \n    # Calculate the minimum operations required to delete vertex 1\n    operations = 0\n    for child in graph[1]:\n        operations += max_depth[child]\n    \n    return operations\n\nif __name__ == \"__main__\":\n    N = int(input())\n    edges = []\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    result = min_operations_to_delete_vertex_1(N, edges)\n    print(result)"
        ]
    },
    {
        "question_id": "abc333_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    events = []\n    for _ in range(N):\n        t, x = map(int, input().split())\n        events.append((t, x))\n    \n    # Initialize variables\n    max_potions_needed = 0\n    current_potions = defaultdict(int)\n    max_potions = 0\n    min_k = float('inf')\n    actions = []\n    \n    for i, (t, x) in enumerate(events):\n        if t == 1:\n            # Find a potion\n            current_potions[x] += 1\n            max_potions = max(max_potions, current_potions[x])\n            actions.append(1)\n        else:\n            # Encounter a monster\n            if x in current_potions:\n                current_potions[x] -= 1\n                if current_potions[x] == 0:\n                    del current_potions[x]\n            else:\n                # Cannot defeat the monster\n                if min_k == float('inf'):\n                    min_k = -1\n                break\n            actions.append(0)\n            max_potions_needed = max(max_potions_needed, len(current_potions))\n    \n    if min_k == float('inf'):\n        min_k = max(max_potions_needed, max_potions)\n    \n    print(min_k)\n    print(*actions)"
        ]
    },
    {
        "question_id": "abc334_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    B, G = map(int, input().split())\n    if B > G:\n        print(\"Bat\")\n    else:\n        print(\"Glove\")"
        ]
    },
    {
        "question_id": "abc334_b",
        "code_list": [
            "def main():\n    A, M, L, R = map(int, input().split())\n    # Adjust A, L, R to be relative to the starting point A\n    A -= A\n    L -= A\n    R -= A\n    \n    # If L is greater than R, no trees are between them\n    if L > R:\n        print(0)\n        return\n    \n    # Calculate the first tree position after or at L\n    first_tree = (L + M - 1) // M * M\n    # Calculate the last tree position before or at R\n    last_tree = R // M * M\n    \n    # If the first tree is after R, there are no trees between L and R\n    if first_tree > R:\n        print(0)\n        return\n    \n    # Calculate the number of trees\n    num_trees = (last_tree - first_tree) // M + 1\n    print(num_trees)"
        ]
    },
    {
        "question_id": "abc334_c",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    lost_colors = sorted(map(int, input().split()))\n    \n    remaining_socks = [i for i in range(1, N + 1) if i not in lost_colors]\n    remaining_count = len(remaining_socks)\n    target_pairs = (2 * N - K) // 2\n    \n    # If there's an odd number of remaining socks, remove one to make the count even\n    if remaining_count % 2 != 0:\n        remaining_count -= 1\n        target_pairs -= 1\n    \n    total_weirdness = 0\n    i, j = 0, remaining_count - 1\n    while target_pairs > 0:\n        total_weirdness += abs(remaining_socks[i] - remaining_socks[j])\n        i += 1\n        j -= 1\n        target_pairs -= 1\n    \n    print(total_weirdness)"
        ]
    },
    {
        "question_id": "abc334_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    q = int(data[index])\n    index += 1\n    \n    reindeer_per_sleigh = []\n    for _ in range(n):\n        reindeer_per_sleigh.append(int(data[index]))\n        index += 1\n    \n    queries = []\n    for _ in range(q):\n        queries.append(int(data[index]))\n        index += 1\n    \n    # Sort the reindeer requirements in descending order\n    reindeer_per_sleigh.sort(reverse=True)\n    \n    # Calculate prefix sums\n    prefix_sums = [0]\n    for r in reindeer_per_sleigh:\n        prefix_sums.append(prefix_sums[-1] + r)\n    \n    # Process each query\n    for x in queries:\n        count = 0\n        for i, r in enumerate(reindeer_per_sleigh):\n            if x >= r:\n                x -= r\n                count += 1\n            else:\n                break\n        print(count)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc334_e",
        "code_list": [
            "from collections import defaultdict\nfrom math import comb\nfrom typing import List, Tuple\n\ndef count_green_components(grid: List[str]) -> int:\n    def dfs(x: int, y: int) -> None:\n        if 0 <= x < h and 0 <= y < w and grid[x][y] == '#':\n            grid[x] = grid[x][:y] + '.' + grid[x][y+1:]\n            for dx, dy in directions:\n                dfs(x + dx, y + dy)\n\n    h, w = len(grid), len(grid[0])\n    components = 0\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '#':\n                components += 1\n                dfs(i, j)\n    return components\n\ndef solve(grid: List[str], h: int, w: int) -> int:\n    green_cells = [(i, j) for i in range(h) for j in range(w) if grid[i][j] == '#']\n    red_cells = [(i, j) for i in range(h) for j in range(w) if grid[i][j] == '.']\n\n    total_red = len(red_cells)\n    green_components = count_green_components(grid[:])\n\n    mod = 998244353\n    result = 0\n\n    for i, j in red_cells:\n        new_grid = [row[:] for row in grid]\n        new_grid[i] = new_grid[i][:j] + '#' + new_grid[i][j+1:]\n        new_components = count_green_components(new_grid)\n        result += new_components - green_components\n        result %= mod\n\n    expected_value = (result * pow(total_red, mod - 2, mod)) % mod\n    return expected_value\n\nif __name__ == \"__main__\":\n    h, w = map(int, input().split())\n    grid = [input().strip() for _ in range(h)]\n    print(solve(grid, h, w))"
        ]
    },
    {
        "question_id": "abc335_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    S = S[:-4] + '2024'\n    print(S)"
        ]
    },
    {
        "question_id": "abc335_b",
        "code_list": [
            "def generate_triples(N):\n    for x in range(N + 1):\n        for y in range(x + 1):\n            for z in range(y + 1):\n                if x + y + z <= N:\n                    print(f\"{x} {y} {z}\")\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    generate_triples(N)"
        ]
    },
    {
        "question_id": "abc335_c",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    \n    # Initialize positions\n    positions = [(i, 0) for i in range(1, N+1)]\n    \n    # Process queries\n    for _ in range(Q):\n        query = list(map(str.strip, input().split()))\n        if query[0] == '1':\n            direction = query[1]\n            head_x, head_y = positions[0]\n            if direction == 'R':\n                head_x += 1\n            elif direction == 'L':\n                head_x -= 1\n            elif direction == 'U':\n                head_y += 1\n            elif direction == 'D':\n                head_y -= 1\n            positions = [(head_x - (i-1), head_y) for i in range(N)]\n        else:\n            p = int(query[1])\n            print(positions[p-1][0], positions[p-1][1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc335_d",
        "code_list": [
            "def main():\n    N = int(input())\n    # Initialize the grid with zeros\n    grid = [[0] * N for _ in range(N)]\n    \n    # Place Takahashi at the center\n    center_i, center_j = (N + 1) // 2 - 1, (N + 1) // 2 - 1\n    grid[center_i][center_j] = 'T'\n    \n    # Function to get the next position based on the current position and direction\n    def get_next_position(i, j, direction):\n        if direction == 'right':\n            return i, j + 1\n        elif direction == 'down':\n            return i + 1, j\n        elif direction == 'left':\n            return i, j - 1\n        elif direction == 'up':\n            return i - 1, j\n    \n    # Directions for moving right, down, left, up\n    directions = ['right', 'down', 'left', 'up']\n    current_direction_index = 0\n    current_i, current_j = center_i - 1, center_j - 1\n    current_value = 1\n    \n    while current_value <= N**2 - 1:\n        # Move in the current direction\n        for _ in range(2):\n            for _ in range(2):\n                if 0 <= current_i < N and 0 <= current_j < N and grid[current_i][current_j] == 0:\n                    grid[current_i][current_j] = current_value\n                    current_value += 1\n                current_i, current_j = get_next_position(current_i, current_j, directions[current_direction_index])\n            current_direction_index = (current_direction_index + 1) % 4\n        current_i, current_j = get_next_position(current_i, current_j, directions[current_direction_index])\n        current_direction_index = (current_direction_index + 1) % 4\n    \n    # Print the grid\n    for row in grid:\n        print(' '.join(str(x) for x in row))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_a",
        "code_list": [
            "def main():\n    N = int(input())\n    dragon_string = 'L' + 'o' * N + 'n' + 'g'\n    print(dragon_string)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_b",
        "code_list": [
            "def main():\n    N = int(input())\n    ctz = 0\n    while N % 2 == 0 and N != 0:\n        ctz += 1\n        N //= 2\n    print(ctz)"
        ]
    },
    {
        "question_id": "abc336_c",
        "code_list": [
            "def main():\n    N = int(input())\n    result = \"\"\n    \n    while N > 0:\n        # Determine the current digit based on the position\n        if N <= 5 * (10 ** 11):\n            digit = str((N - 1) % 5)\n            N = (N - 1) // 5\n        else:\n            digit = \"2\"\n            N -= 5 * (10 ** 11)\n        \n        # Prepend the digit to the result\n        result = digit + result\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc336_d",
        "code_list": [
            "def max_pyramid_sequence_size(N, A):\n    # Count the frequency of each number in the sequence\n    freq = [0] * (max(A) + 1)\n    for num in A:\n        freq[num] += 1\n    \n    # Calculate the maximum possible pyramid size\n    left = 0\n    right = len(A) - 1\n    k = 0\n    while left <= right:\n        if freq[k] > 0:\n            if left < right:\n                freq[k] -= min(freq[k], min(freq[:k+1], freq[-k-1:]))\n            else:\n                freq[k] -= 1\n            k += 1\n        left += 1\n        right -= 1\n    \n    return k - 1\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    print(max_pyramid_sequence_size(N, A))"
        ]
    },
    {
        "question_id": "abc337_a",
        "code_list": [
            "def main():\n    N = int(input())\n    takahashi_score = 0\n    aoki_score = 0\n    \n    for _ in range(N):\n        X_i, Y_i = map(int, input().split())\n        takahashi_score += X_i\n        aoki_score += Y_i\n    \n    if takahashi_score > aoki_score:\n        print(\"Takahashi\")\n    elif aoki_score > takahashi_score:\n        print(\"Aoki\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc337_b",
        "code_list": [
            "def is_extended_abc(s):\n    count_a = s.count('A')\n    count_b = s.count('B')\n    count_c = s.count('C')\n    \n    # Check if the string can be divided into parts of equal lengths\n    total_length = len(s)\n    if total_length % 3 != 0:\n        return \"No\"\n    \n    part_length = total_length // 3\n    \n    # Check if each part is an Extended A, B, or C string\n    if (count_a >= part_length and s[:part_length] == 'A' * part_length and\n        count_b >= part_length and s[part_length:2*part_length] == 'B' * part_length and\n        count_c >= part_length and s[2*part_length:] == 'C' * part_length):\n        return \"Yes\"\n    else:\n        return \"No\"\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(is_extended_abc(s))"
        ]
    },
    {
        "question_id": "abc337_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_front_person(arr):\n        for i, val in enumerate(arr):\n            if val == -1:\n                return i + 1\n    \n    def rearrange_line(front_person, arr):\n        result = [front_person]\n        next_person = arr[front_person - 1]\n        while next_person != -1:\n            result.append(next_person)\n            next_person = arr[next_person - 1]\n        return result\n    \n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    front_person = find_front_person(arr)\n    result = rearrange_line(front_person, arr)\n    \n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc337_d",
        "code_list": [
            "def min_operations_to_fill(grid, h, w, k):\n    def count_empty_cols(i, j, k):\n        return sum(1 for col in range(j, j + k) if grid[i][col] == '.')\n\n    def count_empty_rows(i, j, k):\n        return sum(1 for row in range(i, i + k) if grid[row][j] == '.')\n\n    def fill_columns():\n        dp = [float('inf')] * (w - k + 2)\n        dp[k] = 0\n        for j in range(k, w):\n            dp[j + 1] = min(dp[j], dp[j - k + 1]) + count_empty_cols(0, j - k + 1, k)\n        return dp[w]\n\n    def fill_rows():\n        dp = [float('inf')] * (h - k + 2)\n        dp[k] = 0\n        for i in range(k, h):\n            dp[i + 1] = min(dp[i], dp[i - k + 1]) + count_empty_rows(i - k + 1, 0, k)\n        return dp[h]\n\n    # Check if the condition is already satisfied\n    for i in range(h):\n        if 'o' * k in grid[i]:\n            return 0\n    for j in range(w):\n        if 'o' * k in ''.join(grid[i][j] for i in range(h)):\n            return 0\n\n    # Calculate minimum operations to fill columns and rows\n    min_ops = min(fill_columns(), fill_rows())\n    return min_ops if min_ops != float('inf') else -1\n\nif __name__ == \"__main__\":\n    h, w, k = map(int, input().split())\n    grid = [input().strip() for _ in range(h)]\n    print(min_operations_to_fill(grid, h, w, k))"
        ]
    },
    {
        "question_id": "abc337_e",
        "code_list": [
            "import sys\n\ndef main():\n    # Read the number of bottles\n    N = int(input())\n    \n    # The strategy is to use binary search to minimize the number of friends needed\n    # We will divide the bottles into two groups and check which group contains the bad bottle\n    \n    def query(bottles):\n        # Convert list of bottles to space-separated string\n        bottles_str = ' '.join(map(str, bottles))\n        \n        # Print the number of friends and the bottles to be served\n        M = len(bottles) // 2 + 1\n        print(M)\n        print(M, *bottles_str)\n        sys.stdout.flush()\n        \n        # Get the response from the judge\n        S = input().strip()\n        \n        # If all friends are fine, the bad bottle is in the second half\n        if S == '0' * M:\n            return bottles[M:]\n        else:\n            # Otherwise, the bad bottle is in the first half or exactly at the boundary\n            return bottles[:M]\n    \n    low, high = 1, N\n    while low < high:\n        mid = (low + high) // 2\n        bottles = list(range(1, N + 1))\n        bad_bottles = bottles[mid - 1:mid + 1]\n        remaining_bottles = query(bad_bottles)\n        if remaining_bottles[0] == mid:\n            high = mid\n        else:\n            low = mid + 1\n    \n    # The last remaining bottle is the bad one\n    print(low)\n    sys.stdout.flush()"
        ]
    },
    {
        "question_id": "abc338_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S[0].isupper() and S[1:].islower():\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_b",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    S = input().strip()\n    char_count = Counter(S)\n    max_count = max(char_count.values())\n    most_common_chars = [char for char, count in char_count.items() if count == max_count]\n    most_common_chars.sort()\n    print(most_common_chars[0])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_c",
        "code_list": [
            "def max_servings(N, Q, A, B):\n    min_A = float('inf')\n    min_B = float('inf')\n    \n    # Find the minimum requirements for making one serving of each dish\n    for i in range(N):\n        if A[i] > 0:\n            min_A = min(min_A, Q[i] // A[i])\n        if B[i] > 0:\n            min_B = min(min_B, Q[i] // B[i])\n    \n    # The maximum number of servings is the minimum of the two calculated values\n    return min(min_A, min_B)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    Q = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    print(max_servings(N, Q, A, B))"
        ]
    },
    {
        "question_id": "abc338_d",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    X = list(map(int, input().split()))\n    \n    # Calculate the distances between consecutive islands in the tour\n    dists = []\n    for i in range(M - 1):\n        dists.append(min(abs(X[i] - X[i + 1]), N - abs(X[i] - X[i + 1])))\n    \n    # Add the distance between the last and the first island in the tour\n    dists.append(min(abs(X[0] - X[-1]), N - abs(X[0] - X[-1])))\n    \n    # Find the minimum distance among all possible bridge closures\n    min_length = float('inf')\n    for i in range(N):\n        length = sum(dists) - max(dists[i % N], dists[(i + 1) % N])\n        min_length = min(min_length, length)\n    \n    print(min_length)"
        ]
    },
    {
        "question_id": "abc338_e",
        "code_list": [
            "def intersects(a1, b1, a2, b2):\n    # Check if the endpoints of the second chord are between the endpoints of the first chord\n    return (min(a1, b1) < min(a2, b2) < max(a1, b1) or \n            min(a1, b1) < max(a2, b2) < max(a1, b1) or \n            min(a2, b2) < min(a1, b1) < max(a2, b2) or \n            min(a2, b2) < max(a1, b1) < max(a2, b2))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = []\n    for i in range(1, 2 * n + 1, 2):\n        points.append((int(data[i]), int(data[i+1])))\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if intersects(points[i][0], points[i][1], points[j][0], points[j][1]):\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc338_f",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    def read_int():\n        return int(input())\n    \n    def read_ints():\n        return map(int, input().split())\n    \n    N, M = read_ints()\n    edges = defaultdict(list)\n    for _ in range(M):\n        U, V, W = read_ints()\n        edges[U].append((V, W))\n    \n    # Function to calculate the minimum cost to visit all vertices\n    def min_cost_to_visit_all_vertices(start_vertex):\n        dist = [float('inf')] * (1 << N)\n        dist[0] = 0\n        for mask in range(1 << N):\n            for u in range(1, N + 1):\n                if mask & (1 << (u - 1)):\n                    for v, w in edges[u]:\n                        next_mask = mask | (1 << (v - 1))\n                        if dist[next_mask] > dist[mask] + w:\n                            dist[next_mask] = dist[mask] + w\n        return dist[-1]\n    \n    # Check if there's any vertex that can start the walk\n    for start_vertex in range(1, N + 1):\n        cost = min_cost_to_visit_all_vertices(start_vertex)\n        if cost != float('inf'):\n            print(cost)\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    # Find the index of the last '.'\n    last_dot_index = S.rfind('.')\n    # Print the substring from the last dot to the end of the string\n    print(S[last_dot_index+1:])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_b",
        "code_list": [
            "def main():\n    H, W, N = map(int, input().split())\n    grid = [['.' for _ in range(W)] for _ in range(H)]\n    direction = (-1, 0)  # Initial direction: up\n    position = (0, 0)\n    \n    for _ in range(N):\n        i, j = position\n        if grid[i][j] == '.':\n            grid[i][j] = '#'\n            direction = rotate(direction, True)\n        else:\n            grid[i][j] = '.'\n            direction = rotate(direction, False)\n        position = move(position, direction)\n    \n    for row in grid:\n        print(''.join(row))\n\ndef rotate(direction, clockwise):\n    if clockwise:\n        return (direction[1], -direction[0])\n    else:\n        return (-direction[1], direction[0])\n\ndef move(position, direction):\n    i, j = position\n    di, dj = direction\n    return ((i + di) % len(grid), (j + dj) % len(grid[0]))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc339_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    current_passengers = 0\n    min_passengers = 0\n    \n    for i in range(N):\n        current_passengers += A[i]\n        min_passengers = min(min_passengers, current_passengers)\n    \n    print(max(0, current_passengers - min_passengers))"
        ]
    },
    {
        "question_id": "abc339_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(start1, start2, grid):\n    n = len(grid)\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = set([start1])\n    queue = deque([(start1, start2, 0)])\n    \n    while queue:\n        (x1, y1), (x2, y2), steps = queue.popleft()\n        \n        if (x1, y1) == (x2, y2):\n            return steps\n        \n        for dx, dy in directions:\n            nx1, ny1 = x1 + dx, y1 + dy\n            nx2, ny2 = x2 + dx, y2 + dy\n            \n            if 0 <= nx1 < n and 0 <= ny1 < n and grid[nx1][ny1] != '#' and (nx1, ny1) not in visited:\n                visited.add((nx1, ny1))\n                queue.append(((nx1, ny1), (x2, y2), steps + 1))\n            \n            if 0 <= nx2 < n and 0 <= ny2 < n and grid[nx2][ny2] != '#' and (nx2, ny2) not in visited:\n                visited.add((nx2, ny2))\n                queue.append(((x1, y1), (nx2, ny2), steps + 1))\n                \n    return -1\n\ndef main():\n    n = int(input().strip())\n    grid = [input().strip() for _ in range(n)]\n    \n    positions = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'P':\n                positions.append((i, j))\n    \n    start1, start2 = positions\n    result = bfs(start1, start2, grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_a",
        "code_list": [
            "def main():\n    # Read input from stdin\n    A, B, D = map(int, input().split())\n    \n    # Initialize the current term as the first term\n    current_term = A\n    \n    # Print the terms of the arithmetic sequence\n    while current_term <= B:\n        print(current_term, end=' ')\n        current_term += D\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_b",
        "code_list": [
            "def main():\n    Q = int(input())\n    A = []\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            A.append(query[1])\n        elif query[0] == 2:\n            print(A[-query[1]])"
        ]
    },
    {
        "question_id": "abc340_c",
        "code_list": [
            "def main():\n    import math\n    N = int(input())\n    total_cost = 0\n    \n    while N >= 2:\n        # Find the largest power of 2 less than or equal to N\n        k = int(math.log2(N))\n        # Calculate the cost for the current operation\n        cost = N - (1 << k)\n        # Add the cost to the total\n        total_cost += cost\n        # Update N to the sum of the two new numbers added\n        N = (1 << k) + ((1 << k) + 1 - N % (1 << k)) // 2\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc340_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    A = []\n    B = []\n    X = []\n    \n    for i in range(N-1):\n        A.append(int(data[index]))\n        B.append(int(data[index+1]))\n        X.append(int(data[index+2]) - 1)\n        index += 3\n    \n    dp = [0] * N\n    for i in range(N-1):\n        dp[X[i]] = min(dp[X[i]], dp[i] + B[i])\n        dp[i+1] = min(dp[i+1], dp[i] + A[i])\n    \n    print(dp[N-1])"
        ]
    },
    {
        "question_id": "abc340_e",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Initialize the result array with the initial number of balls in each box\n    result = A.copy()\n\n    # Process each operation\n    for i in range(M):\n        current_box = B[i]\n        taken_balls = 0\n        while True:\n            taken_balls += 1\n            next_box = (current_box + i + taken_balls) % N\n            result[next_box] += 1\n            if taken_balls >= A[current_box]:\n                break\n\n    # Print the final number of balls in each box\n    print(\" \".join(map(str, result)))"
        ]
    },
    {
        "question_id": "abc341_a",
        "code_list": [
            "def main():\n    n = int(input())\n    result = '1' * (n + 1) + '0' * n\n    print(result[1::2])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc341_b",
        "code_list": [
            "def max_currency(N, A, S, T):\n    total_units = sum(A)\n    for i in range(N - 2, -1, -1):\n        if A[i] >= S[i]:\n            A[i + 1] += A[i] - S[i]\n            A[i] = S[i]\n        else:\n            needed = S[i] - A[i]\n            A[i + 1] += A[i]\n            A[i] = 0\n            total_units -= needed\n            if A[i + 1] >= S[i + 1]:\n                A[i + 2] += A[i + 1] - S[i + 1]\n                A[i + 1] = S[i + 1]\n            else:\n                break\n    return total_units\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    S = []\n    T = []\n    for _ in range(N - 1):\n        s, t = map(int, input().split())\n        S.append(s)\n        T.append(t)\n    print(max_currency(N, A, S, T))"
        ]
    },
    {
        "question_id": "abc341_c",
        "code_list": [
            "def main():\n    H, W, N = map(int, input().split())\n    T = input()\n    grid = [input() for _ in range(H)]\n    \n    directions = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}\n    start_position = None\n    \n    # Find the initial position\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                start_position = (i, j)\n                break\n        if start_position:\n            break\n    \n    possible_positions = set([start_position])\n    \n    # Simulate the moves\n    x, y = start_position\n    for move in T:\n        dx, dy = directions[move]\n        nx, ny = x + dx, y + dy\n        if 0 < nx < H - 1 and 0 < ny < W - 1 and grid[nx][ny] == '.':\n            possible_positions.add((nx, ny))\n            x, y = nx, ny\n    \n    print(len(possible_positions))"
        ]
    },
    {
        "question_id": "abc341_d",
        "code_list": [
            "def lcm(a, b):\n    from math import gcd\n    return a * b // gcd(a, b)\n\ndef count_divisible(n, m, x):\n    count = 0\n    # Count numbers divisible by n but not by m\n    count += (x // n) - (x // lcm(n, m))\n    # Count numbers divisible by m but not by n\n    count += (x // m) - (x // lcm(n, m))\n    return count\n\ndef find_kth_number(n, m, k):\n    low, high = 1, 10**20\n    while low < high:\n        mid = (low + high) // 2\n        if count_divisible(n, m, mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    print(find_kth_number(n, m, k))"
        ]
    },
    {
        "question_id": "abc341_e",
        "code_list": [
            "def main():\n    # Read input\n    N, Q = map(int, input().split())\n    S = input()\n    \n    # Initialize variables\n    flips = [False] * (N + 1)\n    result = []\n    \n    # Process queries\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            # Flip the specified range\n            L, R = query[1], query[2]\n            for i in range(L, R + 1):\n                flips[i] = not flips[i]\n        else:\n            # Check if the substring is good\n            L, R = query[1], query[2]\n            is_good = True\n            prev_char = None\n            for i in range(L, R + 1):\n                char = S[i - 1] if not flips[i] else '1' if S[i - 1] == '0' else '0'\n                if prev_char is not None and char == prev_char:\n                    is_good = False\n                    break\n                prev_char = char\n            result.append('Yes' if is_good else 'No')\n    \n    # Output results\n    for res in result:\n        print(res)"
        ]
    },
    {
        "question_id": "abc341_f",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    weights = list(map(int, input().split()))\n    pieces = list(map(int, input().split()))\n\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    # Priority queue to store (weight, vertex, pieces)\n    pq = []\n    for i in range(N):\n        if pieces[i] > 0:\n            heapq.heappush(pq, (-weights[i], i, pieces[i]))\n\n    total_operations = 0\n\n    while pq:\n        weight, vertex, pieces_on_vertex = heapq.heappop(pq)\n        weight = -weight  # Convert back to positive\n\n        # Find all adjacent vertices with smaller weights\n        adjacent_vertices = [v for v in graph[vertex] if weights[v] < weight]\n        for adj_vertex in adjacent_vertices:\n            if pieces[adj_vertex] < weight:\n                pieces[adj_vertex] += 1\n                total_operations += 1\n                heapq.heappush(pq, (-weights[adj_vertex], adj_vertex, pieces[adj_vertex]))\n\n    print(total_operations)"
        ]
    },
    {
        "question_id": "abc342_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in S:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the character that appears only once\n    unique_char = None\n    for char in char_count:\n        if char_count[char] == 1:\n            unique_char = char\n            break\n    \n    # Find the index of the unique character\n    for i in range(len(S)):\n        if S[i] == unique_char:\n            print(i + 1)\n            return\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc342_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_query(N, positions, A, B):\n        return positions[A-1] if positions[A-1] < positions[B-1] else positions[B-1]\n    \n    N = int(input())\n    positions = list(map(int, input().split()))\n    Q = int(input())\n    \n    for _ in range(Q):\n        A, B = map(int, input().split())\n        print(process_query(N, positions, A, B))"
        ]
    },
    {
        "question_id": "abc342_c",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    Q = int(input())\n    \n    replacements = {}\n    for _ in range(Q):\n        c, d = input().split()\n        replacements[c] = d\n    \n    for c, d in replacements.items():\n        S = S.replace(c, d)\n    \n    print(S)"
        ]
    },
    {
        "question_id": "abc342_d",
        "code_list": [
            "import math\nfrom collections import Counter\n\ndef is_square(n):\n    return int(math.isqrt(n)) ** 2 == n\n\ndef count_square_pairs(N, A):\n    factor_counts = Counter()\n    square_pairs_count = 0\n    \n    for num in A:\n        if num == 0:\n            square_pairs_count += N - 1\n        else:\n            factors = []\n            # Factorize the number\n            for i in range(2, int(math.isqrt(num)) + 1):\n                count = 0\n                while num % i == 0:\n                    num //= i\n                    count += 1\n                if count % 2 != 0:\n                    factors.append(i)\n            if num > 1:\n                factors.append(num)\n            \n            # Count pairs\n            for factor in factors:\n                if factor in factor_counts:\n                    square_pairs_count += factor_counts[factor]\n                factor_counts[factor] += 1\n    \n    return square_pairs_count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(count_square_pairs(N, A))"
        ]
    },
    {
        "question_id": "abc342_e",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n                \n    return dist\n\ndef process_trains(N, M, trains):\n    # Create a graph where each node represents a station and edges represent train connections\n    graph = defaultdict(list)\n    \n    for l, d, k, c, A, B in trains:\n        for t in range(l, l + k * d, d):\n            graph[A].append((B, c))\n            graph[B].append((A, c))\n            \n    # Calculate the latest time to reach each station from each station\n    results = []\n    for start in range(1, N):\n        dist = dijkstra(N, graph, start)\n        results.append(dist[N-1])\n        \n    return results\n\ndef main():\n    N, M = map(int, input().split())\n    trains = []\n    for _ in range(M):\n        l, d, k, c, A, B = map(int, input().split())\n        trains.append((l, d, k, c, A, B))\n        \n    results = process_trains(N, M, trains)\n    \n    for result in results:\n        if result == float('inf'):\n            print(\"Unreachable\")\n        else:\n            print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    A, B = map(int, input().split())\n    result = (A + B) % 10 if A + B <= 9 else (A + B - 10) % 10\n    while result == A + B:\n        result = (result + 1) % 10\n    print(result)"
        ]
    },
    {
        "question_id": "abc343_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def read_input():\n        return [line.strip() for line in sys.stdin]\n    \n    def parse_adj_matrix(input_lines):\n        return [[int(j) for j in line.split()] for line in input_lines[1:]]\n    \n    def find_neighbors(adj_matrix, vertex):\n        return [i + 1 for i, neighbor in enumerate(adj_matrix[vertex - 1]) if neighbor == 1]\n    \n    def sort_and_print_neighbors(adj_matrix):\n        for i in range(1, len(adj_matrix) + 1):\n            neighbors = find_neighbors(adj_matrix, i)\n            print(' '.join(map(str, sorted(neighbors))))\n    \n    input_lines = read_input()\n    n = int(input_lines[0])\n    adj_matrix = parse_adj_matrix(input_lines)\n    sort_and_print_neighbors(adj_matrix)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc343_c",
        "code_list": [
            "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef find_max_palindromic_cube(N):\n    for x in range(int(N**(1/3)), 0, -1):\n        cube = x ** 3\n        if cube > N:\n            continue\n        if is_palindrome(cube):\n            return cube\n    return 1\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(find_max_palindromic_cube(N))"
        ]
    },
    {
        "question_id": "abc343_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, T = map(int, input().split())\n    score_changes = defaultdict(list)\n    \n    for _ in range(T):\n        A, B = map(int, input().split())\n        score_changes[A].append(B)\n    \n    times = sorted(score_changes.keys())\n    current_scores = set()\n    result = []\n    \n    for time in times:\n        for change in score_changes[time]:\n            current_scores.add(change)\n        \n        result.append(len(current_scores))\n    \n    # Handle remaining changes after the last time point\n    for i in range(times[-1] + 1, T + 1):\n        for j in range(1, N + 1):\n            if j not in score_changes:\n                current_scores.add(0)\n            else:\n                for change in score_changes[j]:\n                    current_scores.add(change)\n        \n        result.append(len(current_scores))\n    \n    for r in result:\n        print(r)"
        ]
    },
    {
        "question_id": "abc343_e",
        "code_list": [
            "def main():\n    V1, V2, V3 = map(int, input().split())\n    \n    # Check if the given V1, V2, V3 can form the required configuration\n    if V1 + 3 * V2 + 6 * V3 != 3 * 7**3:\n        print(\"No\")\n        return\n    \n    # Calculate the volumes for the given configuration\n    total_volume = 3 * 7**3\n    overlap_volume = V3\n    double_overlap_volume = V2\n    single_volume = V1\n    \n    # Check if the configuration is possible\n    if (total_volume - 3 * overlap_volume - 3 * double_overlap_volume) != single_volume:\n        print(\"No\")\n        return\n    \n    # Assign coordinates for the cubes\n    a1, b1, c1 = 0, 0, 0\n    a2, b2, c2 = 0, 7, 0\n    a3, b3, c3 = 7, 0, 0\n    \n    # Verify the solution\n    if (7 - 0) * (7 - 0) * (7 - 0) == overlap_volume and \\\n       (7 - 0) * (7 - 7) * (7 - 0) + (7 - 7) * (7 - 0) * (7 - 0) + (7 - 0) * (7 - 0) * (7 - 7) == double_overlap_volume and \\\n       (7 - 0) * (7 - 0) * (7 - 7) + (7 - 0) * (7 - 7) * (7 - 0) + (7 - 7) * (7 - 0) * (7 - 0) + \\\n       (7 - 7) * (7 - 7) * (7 - 0) + (7 - 7) * (7 - 0) * (7 - 7) + (7 - 0) * (7 - 7) * (7 - 7) == single_volume:\n        print(\"Yes\")\n        print(a1, b1, c1, a2, b2, c2, a3, b3, c3)\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    T = input().strip()\n    N = int(input().strip())\n    bags = [defaultdict(int) for _ in range(N)]\n    \n    for i in range(N):\n        A = int(input().strip())\n        for _ in range(A):\n            s = input().strip()\n            bags[i][s] += 1\n    \n    dp = [float('inf')] * (len(T) + 1)\n    dp[0] = 0\n    \n    for i in range(1, len(T) + 1):\n        for j in range(N):\n            for k, v in bags[j].items():\n                if T[i-1:i-1+len(k)] == k:\n                    dp[i] = min(dp[i], dp[i-len(k)] + (1 if i-len(k) > 0 else 0))\n    \n    if dp[len(T)] == float('inf'):\n        print(-1)\n    else:\n        print(dp[len(T)])"
        ]
    },
    {
        "question_id": "abc344_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    start = S.find('|')\n    end = S.find('|', start + 1)\n    print(S[:start] + S[end+1:])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_c",
        "code_list": [
            "def main():\n    import sys\n    from itertools import product\n    \n    def read_int():\n        return int(next(sys.stdin))\n    \n    def read_line():\n        return next(sys.stdin).strip().split()\n    \n    def read_int_list():\n        return list(map(int, read_line()))\n    \n    N = read_int()\n    A = read_int_list()\n    M = read_int()\n    B = read_int_list()\n    L = read_int()\n    C = read_int_list()\n    Q = read_int()\n    X = read_int_list()\n    \n    # Generate all possible sums of elements from A, B, and C\n    possible_sums = set(a + b + c for a, b, c in product(A, B, C))\n    \n    # Check each X_i\n    for x in X:\n        if x in possible_sums:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc344_b",
        "code_list": [
            "def main():\n    # Read input until 0 is encountered\n    numbers = []\n    while True:\n        try:\n            num = int(input())\n            numbers.append(num)\n        except EOFError:\n            break\n    \n    # Print the numbers in reverse order\n    for num in reversed(numbers):\n        print(num)"
        ]
    },
    {
        "question_id": "abc344_e",
        "code_list": [
            "from collections import deque\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    Q = int(input())\n    \n    # Initialize the sequence and a dictionary to keep track of insertion points\n    seq = deque(A)\n    insert_points = {a: i for i, a in enumerate(seq)}\n    \n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            x, y = query[1], query[2]\n            idx = insert_points[x]\n            seq.insert(idx + 1, y)\n            del insert_points[x]\n            insert_points[y] = idx + 1\n        else:\n            x = query[1]\n            idx = insert_points[x]\n            seq.remove(x)\n            del insert_points[x]\n    \n    # Output the final sequence\n    print(*seq)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc345_d",
        "code_list": [
            "def can_cover_grid(N, H, W, tiles):\n    # Helper function to check if a tile can fit in the grid\n    def can_fit(tile, h, w):\n        return h % max(tile) == 0 and w % min(tile) == 0 or w % max(tile) == 0 and h % min(tile) == 0\n    \n    # Helper function to recursively try placing tiles\n    def place_tiles(remaining_tiles, grid):\n        if not remaining_tiles:\n            return True\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == 0:\n                    for tile in remaining_tiles:\n                        tile1 = tile\n                        tile2 = (tile[1], tile[0])\n                        if can_fit(tile1, H-i, W-j) and can_fit(tile2, H-i, W-j):\n                            for orientation in [tile1, tile2]:\n                                new_tile = [(i + k, j + l) for k in range(orientation[0]) for l in range(orientation[1])]\n                                if all(grid[k][l] == 0 for k, l in new_tile):\n                                    new_grid = [row[:] for row in grid]\n                                    for k, l in new_tile:\n                                        new_grid[k][l] = 1\n                                    if place_tiles(remaining_tiles - {tile}, new_grid):\n                                        return True\n        return False\n    \n    # Create an empty grid\n    grid = [[0 for _ in range(W)] for _ in range(H)]\n    \n    # Try placing each tile\n    for tile in tiles:\n        if can_fit(tile, H, W):\n            new_grid = [row[:] for row in grid]\n            for i in range(H):\n                for j in range(W):\n                    if new_grid[i][j] == 0:\n                        new_tile = [(i + k, j + l) for k in range(tile[0]) for l in range(tile[1])]\n                        if all(new_grid[k][l] == 0 for k, l in new_tile):\n                            new_grid2 = [row[:] for row in new_grid]\n                            for k, l in new_tile:\n                                new_grid2[k][l] = 1\n                            if place_tiles(tiles - {tile}, new_grid2):\n                                return \"Yes\"\n    return \"No\"\n\nif __name__ == \"__main__\":\n    N, H, W = map(int, input().split())\n    tiles = {tuple(map(int, input().split())) for _ in range(N)}\n    print(can_cover_grid(N, H, W, tiles))"
        ]
    },
    {
        "question_id": "abc345_b",
        "code_list": [
            "import math\n\ndef main():\n    X = int(input())\n    result = math.ceil(X / 10)\n    print(result)"
        ]
    },
    {
        "question_id": "abc346_d",
        "code_list": [
            "def min_cost_to_make_good_string(N, S, costs):\n    # Initialize prefix sum array for costs\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + costs[i]\n    \n    # Initialize variables to track the minimum cost\n    min_cost = float('inf')\n    \n    # Iterate through the string to find the minimum cost\n    for i in range(1, N):\n        if S[i] == S[i - 1]:\n            continue\n        \n        # Calculate the cost of making the string good by flipping the i-th character\n        cost_if_flip_i = prefix_sum[i] + (prefix_sum[-1] - prefix_sum[i + 1]) - (costs[i] if S[i] == '0' else 0)\n        \n        # Calculate the cost of making the string good by flipping the (i+1)-th character\n        cost_if_flip_next = prefix_sum[i + 1] + (prefix_sum[-1] - prefix_sum[i]) - (costs[i + 1] if S[i + 1] == '0' else 0)\n        \n        # Update the minimum cost\n        min_cost = min(min_cost, cost_if_flip_i, cost_if_flip_next)\n    \n    return min_cost\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    costs = list(map(int, input().strip().split()))\n    print(min_cost_to_make_good_string(N, S, costs))"
        ]
    },
    {
        "question_id": "abc346_b",
        "code_list": [
            "def main():\n    W, B = map(int, input().split())\n    # The repeating pattern in S\n    pattern = \"wbwbwwbwbwbw\"\n    # Calculate the number of w and b in the pattern\n    count_w = pattern.count('w')\n    count_b = pattern.count('b')\n    \n    # Calculate the number of times the pattern needs to repeat\n    full_repeats = (W + B - 1) // (count_w + count_b)\n    remaining_w = W % count_w\n    remaining_b = B % count_b\n    \n    # Check if we can find the required substring in the repeated pattern\n    for i in range(count_w):\n        if pattern[i] == 'w' and remaining_w > 0:\n            remaining_w -= 1\n        elif pattern[i] == 'b' and remaining_b > 0:\n            remaining_b -= 1\n        if remaining_w == 0 and remaining_b == 0:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_e",
        "code_list": [
            "def main():\n    H, W, M = map(int, input().split())\n    row_colors = [0] * H\n    col_colors = [0] * W\n    row_max = [0] * H\n    col_max = [0] * W\n    \n    for _ in range(M):\n        T, A, X = map(int, input().split())\n        A -= 1\n        \n        if T == 1:\n            if row_max[A] < X:\n                row_max[A] = X\n                row_colors[A] = X\n            elif row_max[A] == X:\n                row_colors[A] = -1\n        else:\n            if col_max[A] < X:\n                col_max[A] = X\n                col_colors[A] = X\n            elif col_max[A] == X:\n                col_colors[A] = -1\n    \n    # Find the maximum color in rows and columns\n    max_row_color = max(row_colors)\n    max_col_color = max(col_colors)\n    \n    # Count the number of cells for each color\n    color_count = {}\n    for i in range(H):\n        if row_colors[i] != 0 and row_colors[i] != -1:\n            color_count[row_colors[i]] = color_count.get(row_colors[i], 0) + 1\n    for j in range(W):\n        if col_colors[j] != 0 and col_colors[j] != -1:\n            color_count[col_colors[j]] = color_count.get(col_colors[j], 0) + 1\n    \n    # Output the result\n    K = len(color_count)\n    print(K)\n    for color in sorted(color_count.keys()):\n        print(color, color_count[color])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_a",
        "code_list": [
            "def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    for i in range(N-1):\n        B = A[i] * A[i+1]\n        print(B, end=' ' if i < N-2 else '\\n')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc346_c",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    A = set(map(int, input().split()))\n    total_sum = K * (K + 1) // 2\n    missing_sum = 0\n    for i in range(1, K + 1):\n        if i not in A:\n            missing_sum += i\n    print(total_sum - missing_sum)"
        ]
    },
    {
        "question_id": "abc347_c",
        "code_list": [
            "def main():\n    N, A, B = map(int, input().split())\n    D = list(map(int, input().split()))\n    \n    # Calculate the difference between consecutive days\n    diff = [D[i] - D[i-1] for i in range(1, N)]\n    \n    # Check if all differences are multiples of (A + B)\n    if all(d % (A + B) == 0 for d in diff):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc347_a",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Extract multiples of K, divide them by K, and store the quotients\n    quotients = [a // K for a in A if a % K == 0]\n\n    # Print the quotients in ascending order\n    print(\" \".join(map(str, sorted(quotients))))"
        ]
    },
    {
        "question_id": "abc347_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    queries = [int(x) for x in data[2:]]\n    \n    # Initialize the sequence A and the set S\n    A = [0] * N\n    S = set()\n    \n    start = 0\n    for i in range(Q):\n        x = queries[i]\n        if x < start:\n            # Update the values in A for elements that were added to S since the last occurrence of x\n            for j in range(start, i):\n                if queries[j] == x:\n                    A[x-1] += i - start\n            start = i\n        \n        if x not in S:\n            S.add(x)\n        else:\n            S.remove(x)\n        \n        # Update the values in A for the current state of S\n        for j in S:\n            A[j-1] += len(S)\n    \n    # Handle the remaining elements in S\n    for j in S:\n        A[j-1] += len(S)\n    \n    print(' '.join(map(str, A)))"
        ]
    },
    {
        "question_id": "abc347_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    n = len(S)\n    unique_substrings = set()\n    \n    # Generate all possible substrings\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            unique_substrings.add(S[i:j])\n    \n    # Print the number of unique non-empty substrings\n    print(len(unique_substrings))"
        ]
    },
    {
        "question_id": "abc348_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    bean_map = defaultdict(list)\n    \n    for _ in range(N):\n        A, C = map(int, input().split())\n        bean_map[C].append(A)\n    \n    max_min_deliciousness = 0\n    \n    for colors in bean_map.values():\n        colors.sort()\n        max_min_deliciousness = max(max_min_deliciousness, colors[0])\n    \n    print(max_min_deliciousness)"
        ]
    },
    {
        "question_id": "abc348_b",
        "code_list": [
            "import math\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef find_farthest_points(points):\n    n = len(points)\n    result = []\n    \n    for i in range(n):\n        max_distance = 0\n        farthest_point_id = -1\n        \n        for j in range(n):\n            if i != j:\n                distance = euclidean_distance(points[i], points[j])\n                if distance > max_distance:\n                    max_distance = distance\n                    farthest_point_id = j + 1\n        \n        result.append(farthest_point_id)\n    \n    return result\n\nif __name__ == \"__main__\":\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    result = find_farthest_points(points)\n    for id in result:\n        print(id)"
        ]
    },
    {
        "question_id": "abc348_a",
        "code_list": [
            "def main():\n    N = int(input())\n    result = ''.join(['o' if (i + 1) % 3 != 0 else 'x' for i in range(N)])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start, end, medicines):\n    h, w = len(grid), len(grid[0])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = [[[False for _ in range(w+1)] for _ in range(h)] for _ in range(h*w+1)]\n    \n    queue = deque([(start[0], start[1], 0)])\n    visited[start[0]][start[1]][0] = True\n    \n    while queue:\n        x, y, energy = queue.popleft()\n        \n        if (x, y) == end:\n            return True\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < h and 0 <= ny < w and grid[nx][ny] != '#':\n                next_energy = energy\n                for med_x, med_y, med_energy in medicines:\n                    if (nx, ny) == (med_x, med_y) and next_energy < med_energy:\n                        next_energy = med_energy\n                \n                if not visited[nx][ny][next_energy]:\n                    visited[nx][ny][next_energy] = True\n                    queue.append((nx, ny, next_energy))\n    \n    return False\n\ndef main():\n    h, w = map(int, input().split())\n    grid = [input() for _ in range(h)]\n    n = int(input())\n    medicines = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    start = None\n    end = None\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'T':\n                end = (i, j)\n    \n    if bfs(grid, start, end, medicines):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc348_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, graph, c, subtree_size, distance_sum):\n    subtree_size[node] = 1\n    distance_sum[node] = c[node]\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, graph, c, subtree_size, distance_sum)\n            subtree_size[node] += subtree_size[neighbor]\n            distance_sum[node] += distance_sum[neighbor]\n\ndef calculate_f_value(node, parent, graph, c, subtree_size, distance_sum, n):\n    result = distance_sum[node]\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            distance_sum[neighbor] += distance_sum[node] - distance_sum[neighbor] - c[neighbor] * subtree_size[neighbor]\n            subtree_size[neighbor] += subtree_size[node] - subtree_size[neighbor]\n            result = min(result, calculate_f_value(neighbor, node, graph, c, subtree_size, distance_sum, n))\n            distance_sum[neighbor] -= distance_sum[node] - distance_sum[neighbor] - c[neighbor] * subtree_size[neighbor]\n            subtree_size[neighbor] -= subtree_size[node] - subtree_size[neighbor]\n    return result\n\ndef main():\n    n = int(input())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    c = list(map(int, input().split()))\n    \n    subtree_size = [0] * n\n    distance_sum = [0] * n\n    \n    dfs(0, -1, graph, c, subtree_size, distance_sum)\n    \n    print(calculate_f_value(0, -1, graph, c, subtree_size, distance_sum, n))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc349_c",
        "code_list": [
            "def is_airport_code(S: str, T: str) -> bool:\n    # Check if T can be formed by taking a subsequence of length 3 from S and converting it to uppercase\n    for i in range(len(S) - 2):\n        for j in range(i + 1, len(S) - 1):\n            for k in range(j + 1, len(S)):\n                if S[i] == T[0] and S[j] == T[1] and S[k] == T[2]:\n                    return True\n    \n    # Check if T can be formed by taking a subsequence of length 2 from S, converting it to uppercase, and appending 'X'\n    for i in range(len(S) - 1):\n        for j in range(i + 1, len(S)):\n            if S[i] == T[0] and S[j] == T[1] and T[2] == 'X':\n                return True\n    \n    return False\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    T = input().strip()\n    print(\"Yes\" if is_airport_code(S, T) else \"No\")"
        ]
    },
    {
        "question_id": "abc349_a",
        "code_list": [
            "def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Calculate the total change in scores for all pairs except the last person\n    total_change = sum(A)\n    \n    # The final score of person N is the negative of the total change\n    final_score_N = -total_change\n    \n    print(final_score_N)"
        ]
    },
    {
        "question_id": "abc349_b",
        "code_list": [
            "from collections import Counter\n\ndef is_good_string(S):\n    # Count the frequency of each character in the string\n    freq = Counter(S)\n    # Count how many characters have the same frequency\n    freq_of_freq = Counter(freq.values())\n    \n    # Check the condition for all frequencies\n    for count in freq_of_freq.values():\n        if count not in [0, 2]:\n            return \"No\"\n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(is_good_string(S))"
        ]
    },
    {
        "question_id": "abc349_d",
        "code_list": [
            "def find_good_sequences(L, R):\n    def find_min_good_sequence(l, r):\n        i = 0\n        while (1 << i) <= r - l:\n            i += 1\n        i -= 1\n        j = (r - l) // (1 << i)\n        return (l, (1 << i) * j)\n    \n    result = []\n    while L < R:\n        l, r = find_min_good_sequence(L, R)\n        result.append((l, r))\n        L = r\n    \n    return len(result), result\n\ndef main():\n    L, R = map(int, input().split())\n    M, divisions = find_good_sequences(L, R)\n    print(M)\n    for l, r in divisions:\n        print(l, r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc349_e",
        "code_list": [
            "def main():\n    # Read the grid\n    grid = []\n    for _ in range(3):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    # Function to check if a player can win in the next move\n    def can_win_next_move(grid, player):\n        for i in range(3):\n            for j in range(3):\n                if grid[i][j] == 0:\n                    # Simulate the move\n                    grid[i][j] = player\n                    # Check rows\n                    for k in range(3):\n                        if grid[i][k] == player:\n                            count = 1\n                            for l in range(k+1, 3):\n                                if grid[i][l] == player:\n                                    count += 1\n                                else:\n                                    break\n                            if count == 3:\n                                return True\n                        else:\n                            break\n                    # Check columns\n                    for k in range(3):\n                        if grid[k][j] == player:\n                            count = 1\n                            for l in range(k+1, 3):\n                                if grid[l][j] == player:\n                                    count += 1\n                                else:\n                                    break\n                            if count == 3:\n                                return True\n                        else:\n                            break\n                    # Check diagonals\n                    if i == j:\n                        count = 1\n                        for k in range(1, 3):\n                            if grid[i+k][j+k] == player:\n                                count += 1\n                            else:\n                                break\n                        if count == 3:\n                            return True\n                        count = 1\n                        for k in range(1, 3):\n                            if grid[i-k][j-k] == player:\n                                count += 1\n                            else:\n                                break\n                        if count == 3:\n                            return True\n                    if i + j == 2:\n                        count = 1\n                        for k in range(1, 3):\n                            if grid[i-k][j+k] == player:\n                                count += 1\n                            else:\n                                break\n                        if count == 3:\n                            return True\n                        count = 1\n                        for k in range(1, 3):\n                            if grid[i+k][j-k] == player:\n                                count += 1\n                            else:\n                                break\n                        if count == 3:\n                            return True\n                    # Revert the move\n                    grid[i][j] = 0\n        return False\n    \n    # Function to determine the winner\n    def determine_winner(grid):\n        # Check if Takahashi can win in the next move\n        if can_win_next_move(grid, 1):\n            return \"Takahashi\"\n        # Check if Aoki can win in the next move\n        if can_win_next_move(grid, -1):\n            return \"Aoki\"\n        # If neither can win in the next move, check the sum of scores\n        takahashi_score = sum(max(0, cell) for row in grid for cell in row)\n        aoki_score = sum(min(0, cell) for row in grid for cell in row)\n        if takahashi_score > aoki_score:\n            return \"Takahashi\"\n        elif aoki_score > takahashi_score:\n            return \"Aoki\"\n        else:\n            return \"Draw\"\n    \n    # Determine the winner\n    winner = determine_winner(grid)\n    print(winner)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S[:3] == \"ABC\" and 100 <= int(S[3:]) <= 349 and int(S[3:]) != 316:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc350_e",
        "code_list": [
            "import math\n\ndef expected_cost(N, A, X, Y):\n    # Base case: if N is 0, no cost is incurred\n    if N == 0:\n        return 0\n    \n    # Calculate the cost of the floor division operation\n    cost_divide = X + expected_cost(math.floor(N / A), A, X, Y)\n    \n    # Calculate the expected cost of rolling the die\n    expected_die = sum(expected_cost(math.floor(N / b), A, X, Y) for b in range(1, 7)) / 6 + Y\n    \n    # Return the minimum cost between the two operations\n    return min(cost_divide, expected_die)\n\nif __name__ == \"__main__\":\n    N, A, X, Y = map(int, input().split())\n    print(expected_cost(N, A, X, Y))"
        ]
    },
    {
        "question_id": "abc350_b",
        "code_list": [
            "def main():\n    N, Q = map(int, input().split())\n    treated_holes = set()\n    \n    for _ in range(Q):\n        T = int(input()) - 1\n        if T in treated_holes:\n            treated_holes.remove(T)\n        else:\n            treated_holes.add(T)\n    \n    print(len(treated_holes))"
        ]
    },
    {
        "question_id": "abc350_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def swap_elements(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n    \n    def find_index(arr, value):\n        return arr.index(value)\n    \n    def transform_permutation(n, perm):\n        operations = []\n        for i in range(n):\n            if perm[i] != i + 1:\n                target_index = find_index(perm, i + 1)\n                swap_elements(perm, i, target_index)\n                operations.append((i + 1, target_index + 1))\n        print(len(operations))\n        for op in operations:\n            print(*op)\n    \n    n = int(input())\n    perm = list(map(int, input().split()))\n    transform_permutation(n, perm)"
        ]
    },
    {
        "question_id": "abc350_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    graph = defaultdict(set)\n    \n    for _ in range(M):\n        A, B = map(int, input().split())\n        graph[A].add(B)\n        graph[B].add(A)\n    \n    degree = [0] * (N + 1)\n    for i in range(1, N + 1):\n        degree[i] = len(graph[i])\n    \n    ans = 0\n    for i in range(1, N + 1):\n        for j in graph[i]:\n            for k in graph[j]:\n                if k != i and k not in graph[i]:\n                    ans += 1\n    \n    print(ans // 3)"
        ]
    },
    {
        "question_id": "abc351_a",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    takahashi_scores = [0] * 9\n    aoki_scores = [0] * 8\n    \n    # Parse scores for Team Takahashi\n    for i in range(9):\n        takahashi_scores[i] = int(data[i])\n    \n    # Parse scores for Team Aoki\n    for i in range(9, 17):\n        aoki_scores[i-9] = int(data[i])\n    \n    # Calculate total scores at the end of the top of the ninth inning\n    takahashi_total = sum(takahashi_scores)\n    aoki_total = sum(aoki_scores)\n    \n    # Determine the minimum runs needed for Team Aoki to win\n    if takahashi_total - aoki_total >= 0:\n        min_runs_needed = takahashi_total - aoki_total + 1\n    else:\n        min_runs_needed = 0\n    \n    print(min_runs_needed)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc351_b",
        "code_list": [
            "def find_mismatched_cell(N, grid_A, grid_B):\n    for i in range(N):\n        for j in range(N):\n            if grid_A[i][j] != grid_B[i][j]:\n                return i + 1, j + 1\n\nif __name__ == \"__main__\":\n    N = int(input())\n    grid_A = [input() for _ in range(N)]\n    input()  # Skip the empty line between grid A and grid B\n    grid_B = [input() for _ in range(N)]\n    \n    result_i, result_j = find_mismatched_cell(N, grid_A, grid_B)\n    print(result_i, result_j)"
        ]
    },
    {
        "question_id": "abc351_e",
        "code_list": [
            "from collections import defaultdict\n\ndef calculate_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Calculate the differences in coordinates\n    diff_x = [x - y for x, y in points]\n    diff_y = [x + y for x, y in points]\n    \n    # Count occurrences of each difference\n    count_diff_x = defaultdict(int)\n    count_diff_y = defaultdict(int)\n    for dx, dy in zip(diff_x, diff_y):\n        count_diff_x[dx] += 1\n        count_diff_y[dy] += 1\n    \n    # Calculate the sum of distances\n    total_distance = 0\n    for dx in count_diff_x:\n        for other_dx in count_diff_x:\n            if dx != other_dx:\n                total_distance += (count_diff_x[dx] * count_diff_x[other_dx] * abs(dx - other_dx))\n                \n    for dy in count_diff_y:\n        for other_dy in count_diff_y:\n            if dy != other_dy:\n                total_distance += (count_diff_y[dy] * count_diff_y[other_dy] * abs(dy - other_dy))\n                \n    print(total_distance // 2)"
        ]
    },
    {
        "question_id": "abc351_f",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n = data[0]\n    a = data[1:]\n    \n    max_diff_sum = [0] * (n + 1)\n    for i in range(n):\n        max_diff_sum[i + 1] = max_diff_sum[i] + a[i]\n    \n    prefix_sum = [0] * (n + 1)\n    result = 0\n    for i in range(n):\n        result += (max_diff_sum[n] - max_diff_sum[i + 1]) - (prefix_sum[i] * (n - i - 1))\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    \n    print(result)"
        ]
    },
    {
        "question_id": "abc351_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_operations(N, A):\n        sequence = []\n        for i in range(N):\n            sequence.append(2 ** A[i])\n            while len(sequence) > 1 and sequence[-1] == sequence[-2]:\n                sequence.pop()\n                sequence.pop()\n                if sequence:\n                    sequence.append(2 * sequence[-1])\n        \n        return len(sequence)\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    print(process_operations(N, A))"
        ]
    },
    {
        "question_id": "abc351_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start):\n    H, W = len(grid), len(grid[0])\n    visited = [[False] * W for _ in range(H)]\n    queue = deque([start])\n    visited[start[0]][start[1]] = True\n    count = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        count += 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and grid[nx][ny] != '#':\n                visited[nx][ny] = True\n                queue.append((nx, ny))\n    \n    return count\n\ndef main():\n    H, W = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    \n    max_degree_of_freedom = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] != '#':\n                max_degree_of_freedom = max(max_degree_of_freedom, bfs(grid, (i, j)))\n    \n    print(max_degree_of_freedom)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_e",
        "code_list": [
            "from collections import defaultdict\nimport sys\ninput = sys.stdin.read\nsys.setrecursionlimit(10**7)\n\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x, y):\n    x, y = find(x), find(y)\n    if x == y:\n        return False\n    if par[x] > par[y]:\n        x, y = y, x\n    par[x] += par[y]\n    par[y] = x\n    return True\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef size(x):\n    return -par[find(x)]\n\ndef main():\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        K, C = map(int, input().split())\n        S = list(map(lambda x: int(x)-1, input().split()))\n        for i in range(K):\n            for j in range(i+1, K):\n                edges.append((C, S[i], S[j]))\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    # Initialize disjoint set\n    par = [-1] * N\n    \n    total_weight = 0\n    num_edges = 0\n    for w, u, v in edges:\n        if not same(u, v):\n            unite(u, v)\n            total_weight += w\n            num_edges += 1\n        if num_edges == N-1:\n            break\n    \n    # Check if the graph is connected\n    if num_edges < N-1 or any(par[i] != -1 for i in range(N)):\n        print(-1)\n    else:\n        print(total_weight)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_a",
        "code_list": [
            "def main():\n    N, X, Y, Z = map(int, input().split())\n    if X < Y:  # Traveling from X to Y using an inbound train\n        stops = [i for i in range(X + 1, Y + 1)]\n    else:  # Traveling from X to Y using an outbound train\n        stops = [i for i in range(X - 1, Y - 1, -1)]\n    \n    if Z in stops:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = []\n    B = []\n    start_index = 1\n    for i in range(N):\n        A.append(int(data[start_index]))\n        B.append(int(data[start_index + 1]))\n        start_index += 2\n    \n    # Calculate the difference between head and shoulder heights\n    diff = [B[i] - A[i] for i in range(N)]\n    \n    # Find the maximum difference\n    max_diff = max(diff)\n    \n    # Find the index of the maximum difference\n    max_diff_index = diff.index(max_diff)\n    \n    # Calculate the total height starting from the giant with the maximum difference\n    total_height = B[max_diff_index]\n    for i in range(max_diff_index + 1, N):\n        total_height += A[i] - B[i - 1]\n    \n    print(total_height)"
        ]
    },
    {
        "question_id": "abc352_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    T = input().strip()\n    \n    correct_positions = []\n    j = 0\n    \n    for i in range(len(T)):\n        if j < len(S) and T[i] == S[j]:\n            correct_positions.append(i + 1)\n            j += 1\n    \n    print(*correct_positions)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc352_d",
        "code_list": [
            "from collections import defaultdict\n\ndef find_min_gap(N, K, P):\n    # Create a dictionary to store the positions of each number in the permutation\n    pos = defaultdict(list)\n    for i, num in enumerate(P):\n        pos[num].append(i)\n    \n    min_gap = float('inf')\n    \n    # Iterate through each number in the range [min_num, max_num - K + 1]\n    for num in range(1, N - K + 2):\n        start_pos = pos[num][0]\n        end_pos = pos[num + K - 1][0]\n        \n        # Find the minimum gap for the current number\n        for i in range(1, len(pos[num])):\n            next_start_pos = pos[num][i]\n            if next_start_pos - end_pos <= end_pos - start_pos:\n                start_pos = next_start_pos\n            end_pos = pos[num + K - 1][i]\n        \n        # Update the minimum gap found so far\n        min_gap = min(min_gap, end_pos - start_pos)\n    \n    return min_gap\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    P = list(map(int, input().split()))\n    print(find_min_gap(N, K, P))"
        ]
    },
    {
        "question_id": "abc353_c",
        "code_list": [
            "def f(x, y):\n    return (x + y) % 100000000\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            total_sum += f(A[i], A[j])\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc353_b",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    started_count = 0\n    empty_seats = K\n    \n    while A:\n        if empty_seats < A[0]:\n            started_count += 1\n            empty_seats = K\n        else:\n            empty_seats -= A[0]\n            A.pop(0)\n            started_count += 1\n    \n    print(started_count)"
        ]
    },
    {
        "question_id": "abc353_a",
        "code_list": [
            "def main():\n    # Read input\n    N = int(input())\n    heights = list(map(int, input().split()))\n    \n    # Check if any building is taller than the first one\n    for i in range(1, N):\n        if heights[i] > heights[0]:\n            print(i + 1)\n            return\n    print(-1)"
        ]
    },
    {
        "question_id": "abc353_e",
        "code_list": [
            "def longest_common_prefix_length(s1, s2):\n    min_length = min(len(s1), len(s2))\n    for i in range(min_length):\n        if s1[i] != s2[i]:\n            return i\n    return min_length\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    strings = data[1:]\n    \n    total_sum = 0\n    \n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            total_sum += longest_common_prefix_length(strings[i], strings[j])\n    \n    print(total_sum)"
        ]
    },
    {
        "question_id": "abc353_d",
        "code_list": [
            "def f(x, y):\n    return int(str(x) + str(y))\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    mod = 998244353\n    total_sum = 0\n    \n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            total_sum += f(A[i], A[j])\n            total_sum %= mod\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    users = []\n    ratings = []\n\n    for i in range(1, n * 2 + 1, 2):\n        users.append(data[i])\n        ratings.append(int(data[i + 1]))\n\n    # Calculate the total rating\n    total_rating = sum(ratings)\n\n    # Find the winner based on the modulo operation\n    winner_index = total_rating % n\n\n    # Sort users based on lexicographical order\n    sorted_users = sorted(zip(users, ratings))\n\n    # Print the winner's username\n    print(sorted_users[winner_index][0])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_a",
        "code_list": [
            "def main():\n    H = int(input())\n    i = 0\n    while (1 << i) - 1 < H:\n        i += 1\n    print(i)"
        ]
    },
    {
        "question_id": "abc354_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    cards = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Count the occurrences of each number on the front and back sides\n    front_counts = defaultdict(int)\n    back_counts = defaultdict(int)\n    for a, b in cards:\n        front_counts[a] += 1\n        back_counts[b] += 1\n    \n    # Calculate the total number of pairs with the same front or back number\n    same_front_back_pairs = sum(min(front_counts[a], back_counts[b]) for a, b in cards)\n    \n    # Calculate the total number of cards\n    total_cards = len(cards)\n    \n    # Calculate the number of unique front and back numbers\n    unique_fronts = len(front_counts)\n    unique_backs = len(back_counts)\n    \n    # Calculate the number of cards that have both a matching front and back number\n    both_pairs = sum(1 for a, b in cards if a in back_counts and b in front_counts and a != b)\n    \n    # Determine the winner based on the parity of the number of removable pairs\n    if (same_front_back_pairs + both_pairs) % 2 == 0:\n        print(\"Aoki\")\n    else:\n        print(\"Takahashi\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = []\n    C = []\n    for i in range(1, 2 * N + 1, 2):\n        A.append(int(data[i]))\n        C.append(int(data[i + 1]))\n    \n    # Create a list of indices sorted by cost\n    indices = sorted(range(N), key=lambda x: C[x])\n    \n    stack = []\n    for index in indices:\n        a, c = A[index], C[index]\n        while stack and A[stack[-1]] < a and C[stack[-1]] > c:\n            stack.pop()\n        stack.append(index)\n    \n    remaining_cards = sorted(stack)\n    m = len(remaining_cards)\n    print(m)\n    print(*[x + 1 for x in remaining_cards])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc354_d",
        "code_list": [
            "def main():\n    import sys\n\n    def get_color(x, y):\n        if (x - y) % 2 == 0:\n            return (x + y) % 2\n        else:\n            return (x + y + 1) % 2\n\n    def count_black_area(A, B, C, D):\n        # Determine the color of the bottom-left and top-right corners\n        bottom_left_color = get_color(A, B)\n        top_right_color = get_color(C, D)\n\n        # If the bottom-left corner is black, we need to adjust the counts\n        if bottom_left_color == 1:\n            A += 0.5\n            B += 0.5\n\n        # Calculate the area based on the color of the corners\n        width = C - A\n        height = D - B\n        area = width * height\n\n        # Adjust the area based on the colors of the corners\n        if bottom_left_color != top_right_color:\n            area -= min(width, height)\n\n        return area\n\n    A, B, C, D = map(float, sys.stdin.readline().split())\n    result = 2 * count_black_area(A, B, C, D)\n    print(int(result))"
        ]
    },
    {
        "question_id": "abc355_e",
        "code_list": [
            "import math\n\ndef query(i, j):\n    print(f\"? {i} {j}\")\n    T = int(input())\n    if T == -1:\n        exit()\n    return T\n\ndef solve(N, L, R):\n    def get_sum(start, end):\n        if start > end:\n            return 0\n        if start == end:\n            return query(0, start)[start]\n        \n        i = int(math.log2((end - start + 1)))\n        j = (start + end) // (2**i)\n        mid = 2**i * j\n        \n        left_sum = get_sum(start, mid - 1)\n        right_sum = get_sum(mid + 1, end)\n        middle_sum = query(i, j)\n        \n        return (left_sum + middle_sum + right_sum) % 100\n    \n    result = get_sum(L, R)\n    print(f\"! {result}\")\n\nif __name__ == \"__main__\":\n    N, L, R = map(int, input().split())\n    solve(N, L, R)"
        ]
    },
    {
        "question_id": "abc355_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Combine and sort A and B\n    C = sorted(A + B)\n\n    # Check for consecutive elements from A in C\n    for i in range(len(C) - 1):\n        if C[i] in A and C[i + 1] in A:\n            print(\"Yes\")\n            return\n\n    # If no consecutive elements found\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_c",
        "code_list": [
            "def main():\n    N, T = map(int, input().split())\n    grid = [[0] * N for _ in range(N)]\n    marked_rows = [0] * N\n    marked_cols = [0] * N\n    marked_diags = [0] * 2\n    \n    for turn in range(1, T + 1):\n        A = int(input())\n        i, j = divmod(A - 1, N)\n        \n        # Mark the cell\n        grid[i][j] = 1\n        \n        # Update marked rows and columns\n        marked_rows[i] += 1\n        marked_cols[j] += 1\n        \n        # Update marked diagonals\n        if i == j:\n            marked_diags[0] += 1\n        if i + j == N - 1:\n            marked_diags[1] += 1\n        \n        # Check if Bingo is achieved\n        if marked_rows[i] == N or marked_cols[j] == N or marked_diags[0] == N or marked_diags[1] == N:\n            print(turn)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    suspects = [1, 2, 3]\n    if A != 1:\n        suspects.remove(1)\n    if B != 2:\n        suspects.remove(2)\n    if len(suspects) == 1:\n        print(suspects[0])\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc355_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    intervals = []\n    start = 1\n    for i in range(N):\n        l = int(data[start])\n        r = int(data[start + 1])\n        intervals.append((l, r))\n        start += 2\n    \n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if max(intervals[i][0], intervals[j][0]) <= min(intervals[i][1], intervals[j][1]):\n                count += 1\n    \n    print(count)"
        ]
    },
    {
        "question_id": "3334",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:\n        total_apples = sum(apple)\n        capacity.sort(reverse=True)\n        boxes_used = 0\n        \n        for box_capacity in capacity:\n            if total_apples <= 0:\n                break\n            total_apples -= box_capacity\n            boxes_used += 1\n        \n        return boxes_used"
        ]
    },
    {
        "question_id": "3351",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumHappinessSum(self, happiness: List[int], k: int) -> int:\n        # Sort the happiness array in descending order\n        happiness.sort(reverse=True)\n        total_happiness = 0\n        \n        for i in range(k):\n            # Decrease the happiness value by the number of remaining selections\n            adjusted_happiness = max(0, happiness[i] - i)\n            total_happiness += adjusted_happiness\n        \n        return total_happiness"
        ]
    },
    {
        "question_id": "3356",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def shortestSubstrings(self, arr: List[str]) -> List[str]:\n        from collections import defaultdict\n        \n        # Function to generate all substrings of a string\n        def generate_substrings(s):\n            substrings = set()\n            for i in range(len(s)):\n                for j in range(i + 1, len(s) + 1):\n                    substrings.add(s[i:j])\n            return substrings\n        \n        # Generate all substrings for each string in arr\n        substrings_dict = defaultdict(set)\n        for i, s in enumerate(arr):\n            substrings = generate_substrings(s)\n            for sub in substrings:\n                substrings_dict[sub].add(i)\n        \n        # Find the answer for each string\n        answer = []\n        for i, s in enumerate(arr):\n            valid_substrings = {sub for sub in generate_substrings(s) if len(substrings_dict[sub]) == 1}\n            if not valid_substrings:\n                answer.append(\"\")\n            else:\n                # Find the shortest and lexicographically smallest substring\n                min_len = float('inf')\n                min_str = \"\"\n                for sub in valid_substrings:\n                    if len(sub) < min_len or (len(sub) == min_len and sub < min_str):\n                        min_len = len(sub)\n                        min_str = sub\n                answer.append(min_str)\n        \n        return answer"
        ]
    },
    {
        "question_id": "3313",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumStrength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]\n        \n        for i in range(1, n + 1):\n            for j in range(1, min(i, k) + 1):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                if i >= j:\n                    for x in range(1, j + 1):\n                        dp[i][j] = max(dp[i][j], dp[i - x][j - x] + (prefix_sum[i] - prefix_sum[i - x]) * ((k + 1) // 2 - x + 1) * (-1) ** (x))\n        \n        return dp[n][k]"
        ]
    },
    {
        "question_id": "3353",
        "code_list": [
            "class Solution:\n    def isSubstringPresent(self, s: str) -> bool:\n        reverse_s = s[::-1]\n        for i in range(len(s) - 1):\n            if s[i:i+2] in reverse_s:\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3337",
        "code_list": [
            "class Solution:\n    def countSubstrings(self, s: str, c: str) -> int:\n        count = s.count(c)\n        return (count * (count + 1)) // 2"
        ]
    },
    {
        "question_id": "3360",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumDeletions(self, word: str, k: int) -> int:\n        freqs = list(Counter(word).values())\n        freqs.sort()\n        n = len(freqs)\n        min_deletions = float('inf')\n        \n        for target_freq in freqs:\n            deletions = 0\n            for freq in freqs:\n                if freq > target_freq + k:\n                    deletions += freq - (target_freq + k)\n                elif freq < target_freq:\n                    continue\n                else:\n                    break\n            min_deletions = min(min_deletions, deletions)\n        \n        return min_deletions"
        ]
    },
    {
        "question_id": "3327",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -> int:\n        n = len(nums)\n        ones = [i for i, num in enumerate(nums) if num == 1]\n        m = len(ones)\n        if m < k:\n            return -1\n        \n        prefix_sum = [0] * (m + 1)\n        for i in range(m):\n            prefix_sum[i + 1] = prefix_sum[i] + ones[i]\n        \n        min_moves = float('inf')\n        for left in range(m - k + 1):\n            right = left + k - 1\n            total_ones = prefix_sum[right + 1] - prefix_sum[left]\n            if total_ones > k:\n                continue\n            moves = ones[right] - ones[left] + 1 - k + total_ones\n            if total_ones < k:\n                moves += min(maxChanges, k - total_ones)\n            min_moves = min(min_moves, moves)\n        \n        return min_moves"
        ]
    },
    {
        "question_id": "3349",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maximumLengthSubstring(self, s: str) -> int:\n        char_count = defaultdict(int)\n        left = 0\n        max_length = 0\n        \n        for right in range(len(s)):\n            char_count[s[right]] += 1\n            \n            while char_count[s[right]] > 2:\n                char_count[s[left]] -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3328",
        "code_list": [
            "class Solution:\n    def minOperations(self, k: int) -> int:\n        if k == 1:\n            return 0\n        \n        min_ops = float('inf')\n        for i in range(1, k + 1):\n            # Calculate the number of increases needed to reach i\n            increases = i - 1\n            # Calculate the number of duplications needed to make the sum >= k\n            duplications = (k + i - 1) // i - 1\n            min_ops = min(min_ops, increases + duplications)\n        \n        return min_ops"
        ]
    },
    {
        "question_id": "3363",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -> List[int]:\n        id_count = Counter()\n        ans = []\n        for i in range(len(nums)):\n            id_count[nums[i]] += freq[i]\n            max_count = max(id_count.values()) if id_count else 0\n            ans.append(max_count)\n        return ans"
        ]
    },
    {
        "question_id": "3376",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def stringIndices(self, wordsContainer: List[str], wordsQuery: List[str]) -> List[int]:\n        n, m = len(wordsContainer), len(wordsQuery)\n        ans = [-1] * m\n        \n        for i in range(m):\n            query = wordsQuery[i]\n            max_len = -1\n            min_len_index = -1\n            \n            for j in range(n):\n                word = wordsContainer[j]\n                k = len(query) - 1\n                l = len(word) - 1\n                while k >= 0 and l >= 0 and word[l] == query[k]:\n                    k -= 1\n                    l -= 1\n                if k == -1:\n                    if l == -1 or (l != -1 and (min_len_index == -1 or len(word) < len(wordsContainer[min_len_index]) or (len(word) == len(wordsContainer[min_len_index]) and j < min_len_index))):\n                        min_len_index = j\n                        max_len = len(query)\n        \n            ans[i] = min_len_index\n        \n        return ans"
        ]
    },
    {
        "question_id": "3371",
        "code_list": [
            "class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n        sum_of_digits = sum(int(digit) for digit in str(x))\n        if x % sum_of_digits == 0:\n            return sum_of_digits\n        else:\n            return -1"
        ]
    },
    {
        "question_id": "3374",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        result = 0\n        i = 0\n        \n        while i < n:\n            # Find the end of the current alternating subarray\n            j = i + 1\n            while j < n and nums[j] != nums[j - 1]:\n                j += 1\n            \n            # Calculate the number of alternating subarrays ending at position j-1\n            length = j - i\n            result += length * (length + 1) // 2\n            \n            # Move to the next potential starting point\n            i = j\n        return result"
        ]
    },
    {
        "question_id": "3344",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumDistance(self, points: List[List[int]]) -> int:\n        n = len(points)\n        max_distances = []\n        \n        # Calculate all pairwise Manhattan distances\n        for i in range(n):\n            min_x = float('inf')\n            min_y = float('inf')\n            max_x = float('-inf')\n            max_y = float('-inf')\n            for j in range(n):\n                if i != j:\n                    x_dist = abs(points[i][0] - points[j][0])\n                    y_dist = abs(points[i][1] - points[j][1])\n                    min_x = min(min_x, x_dist)\n                    min_y = min(min_y, y_dist)\n                    max_x = max(max_x, x_dist)\n                    max_y = max(max_y, y_dist)\n            max_distances.append(max_x + max_y - min_x - min_y)\n        \n        return min(max_distances)"
        ]
    },
    {
        "question_id": "3372",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        max_length = 1\n        current_length = 1\n        \n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                current_length += 1\n                max_length = max(max_length, current_length)\n            elif nums[i] < nums[i - 1]:\n                current_length = 2\n            else:\n                current_length = 1\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3346",
        "code_list": [
            "from string import ascii_lowercase\n\nclass Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n        n = len(s)\n        result = list(s)\n        \n        for i in range(n):\n            char = s[i]\n            index = ascii_lowercase.index(char)\n            \n            # Calculate the minimum distance to change to 'a'\n            min_distance_to_a = (index + 26 - i) % 26\n            if k >= min_distance_to_a:\n                result[i] = 'a'\n                k -= min_distance_to_a\n            else:\n                # Calculate the new character\n                new_index = (index - k) % 26\n                result[i] = ascii_lowercase[new_index]\n                break  # No need to continue if we already used up k\n            \n            # Early exit if k is 0 or negative\n            if k <= 0:\n                break\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "3387",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        mid_index = n // 2\n        \n        if nums[mid_index] == k:\n            return 0\n        \n        operations = 0\n        if nums[mid_index] < k:\n            for i in range(mid_index, n):\n                if nums[i] > k:\n                    break\n                operations += k - nums[i]\n        else:\n            for i in range(mid_index, -1, -1):\n                if nums[i] >= k:\n                    break\n                operations += nums[i] - k\n        \n        return operations"
        ]
    },
    {
        "question_id": "3361",
        "code_list": [
            "class Solution:\n    def findLatestTime(self, s: str) -> str:\n        # Helper function to determine the maximum digit for a given position\n        def max_digit(pos):\n            if pos == 0:\n                return 1 if s[pos + 1] != '0' or s[pos + 2] != '?' else 0\n            elif pos == 1:\n                return 9 if s[pos - 1] != '1' else 3\n            elif pos == 3:\n                return 5\n        \n        # Iterate from the end of the string to the beginning\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == '?':\n                if i == 0 or i == 1:\n                    # For hours, set the maximum possible digit\n                    s = s[:i] + str(max_digit(i)) + s[i+1:]\n                else:\n                    # For minutes, set the minimum possible digit to maximize the time\n                    s = s[:i] + '9' + s[i+1:]\n        \n        return s"
        ]
    },
    {
        "question_id": "3373",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        primes = []\n        for i, num in enumerate(nums):\n            if all(num % d != 0 for d in range(2, int(num**0.5) + 1)):\n                primes.append(i)\n        if len(primes) < 2:\n            return 0\n        return max(primes) - min(primes)"
        ]
    },
    {
        "question_id": "3375",
        "code_list": [
            "from heapq import heappush, heappop\n\nclass Solution:\n    def findKthSmallest(self, coins: List[int], k: int) -> int:\n        heap = []\n        for coin in coins:\n            heappush(heap, coin)\n        \n        value = 0\n        for _ in range(k):\n            value = heappop(heap)\n            heappush(heap, value + min(coins))\n        \n        return value"
        ]
    },
    {
        "question_id": "3364",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumValueSum(self, nums: List[int], andValues: List[int]) -> int:\n        n, m = len(nums), len(andValues)\n        if n < m:\n            return -1\n        \n        # Check if the target AND value can be formed by any suffix of nums\n        def valid_suffix(target):\n            for i in range(n - 1, -1, -1):\n                if (all(num & target == target for num in nums[i:]) and\n                    (i == n - 1 or nums[i] & nums[i + 1] == target)):\n                    return True\n            return False\n        \n        # Find the minimum sum of subarrays\n        min_sum = float('inf')\n        for target in andValues:\n            if valid_suffix(target):\n                current_sum = sum(nums[i] for i in range(n) if (nums[i] & target == target))\n                min_sum = min(min_sum, current_sum)\n        \n        return min_sum if min_sum != float('inf') else -1"
        ]
    },
    {
        "question_id": "3367",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumOfEncryptedInt(self, nums: List[int]) -> int:\n        def encrypt(x: int) -> int:\n            max_digit = max(str(x))\n            return int(max_digit * len(str(x)))\n        \n        return sum(encrypt(num) for num in nums)"
        ]
    },
    {
        "question_id": "3306",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def unmarkedSumArray(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        marked = set()\n        min_heap = [(nums[i], i) for i in range(len(nums))]\n        heapq.heapify(min_heap)\n        total_sum = sum(nums)\n        result = []\n        \n        for index, k in queries:\n            if index not in marked:\n                marked.add(index)\n                total_sum -= nums[index]\n            while k > 0 and min_heap:\n                value, i = heapq.heappop(min_heap)\n                if i not in marked:\n                    marked.add(i)\n                    total_sum -= nums[i]\n                    k -= 1\n            result.append(total_sum)\n        \n        return result"
        ]
    },
    {
        "question_id": "3354",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimizeStringValue(self, s: str) -> str:\n        # Count the frequency of each character in the string\n        char_count = Counter(s)\n        # List to store the characters to be used for replacement\n        replacements = []\n        result = list(s)\n        \n        for i, char in enumerate(result):\n            if char == '?':\n                # Find the character with the minimum frequency\n                min_char = 'a'\n                min_count = float('inf')\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if char_count[c] < min_count:\n                        min_count = char_count[c]\n                        min_char = c\n                # Add the chosen character to the replacements list\n                replacements.append(min_char)\n                # Increment the count of the chosen character\n                char_count[min_char] += 1\n        \n        # Sort the replacements to ensure lexicographical order\n        replacements.sort()\n        # Replace '?' with the sorted characters\n        for i, rep in zip(range(len(replacements)), replacements):\n            if result[i] == '?':\n                result[i] = rep\n        \n        return ''.join(result)"
        ]
    },
    {
        "question_id": "3345",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def sumOfPower(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        n = len(nums)\n        dp = defaultdict(int)\n        dp[0] = 1\n        \n        for num in nums:\n            new_dp = defaultdict(int)\n            for sub_sum in dp:\n                if sub_sum + num <= k:\n                    new_dp[sub_sum + num] += dp[sub_sum]\n                new_dp[sub_sum] += dp[sub_sum]\n            dp = new_dp\n        \n        return sum(dp.values()) * pow(2, n - len(dp), MOD) % MOD"
        ]
    },
    {
        "question_id": "3381",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        min_length = float('inf')\n        \n        for start in range(n):\n            current_or = 0\n            for end in range(start, n):\n                current_or |= nums[end]\n                if current_or >= k:\n                    min_length = min(min_length, end - start + 1)\n                    break\n        \n        return min_length if min_length != float('inf') else -1"
        ]
    },
    {
        "question_id": "3355",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumLevels(self, possible: List[int]) -> int:\n        n = len(possible)\n        prefix_sum = [0] * n\n        suffix_sum = [0] * n\n        \n        # Calculate prefix sum where 1 contributes +1 and 0 contributes -1\n        prefix_sum[0] = 1 if possible[0] else -1\n        for i in range(1, n):\n            prefix_sum[i] = prefix_sum[i-1] + (1 if possible[i] else -1)\n        \n        # Calculate suffix sum where 1 contributes +1 and 0 contributes -1\n        suffix_sum[-1] = 1 if possible[-1] else -1\n        for i in range(n-2, -1, -1):\n            suffix_sum[i] = suffix_sum[i+1] + (1 if possible[i] else -1)\n        \n        # Find the minimum index where prefix sum > suffix sum\n        for i in range(n-1):\n            if prefix_sum[i] > suffix_sum[i+1]:\n                return i + 1\n        \n        return -1"
        ]
    },
    {
        "question_id": "3316",
        "code_list": [
            "from typing import List\nfrom itertools import combinations\n\nclass Solution:\n    def sumOfPowers(self, nums: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n        nums.sort()\n        total_sum = 0\n        \n        for subseq in combinations(nums, k):\n            min_diff = float('inf')\n            for i in range(1, k):\n                min_diff = min(min_diff, abs(subseq[i] - subseq[i - 1]))\n            total_sum = (total_sum + min_diff) % MOD\n        \n        return total_sum"
        ]
    },
    {
        "question_id": "3379",
        "code_list": [
            "class Solution:\n    def scoreOfString(self, s: str) -> int:\n        return sum(abs(ord(s[i]) - ord(s[i+1])) for i in range(len(s) - 1))"
        ]
    },
    {
        "question_id": "3382",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfSubarrays(self, nums: List[int]) -> int:\n        max_val = max(nums)\n        count_max = sum(1 for num in nums if num == max_val)\n        return (count_max * (count_max + 1)) // 2"
        ]
    },
    {
        "question_id": "3408",
        "code_list": [
            "class Solution:\n    def numberOfSpecialChars(self, word: str) -> int:\n        seen_lower = set()\n        seen_upper = set()\n        \n        for char in word:\n            if char.islower():\n                seen_lower.add(char)\n            elif char.isupper():\n                seen_upper.add(char.lower())\n        \n        return len(seen_lower & seen_upper)"
        ]
    },
    {
        "question_id": "3397",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        for i in range(len(nums1)):\n            x = nums2[i] - nums1[i]\n            if all(num2 == num1 + x for num1, num2 in zip(nums1, nums2)):\n                return x"
        ]
    },
    {
        "question_id": "3394",
        "code_list": [
            "class Solution:\n    def minEnd(self, n: int, x: int) -> int:\n        # Convert x to binary and find the length of its binary representation\n        bin_x = bin(x)[2:]\n        len_bin_x = len(bin_x)\n        \n        # If n is less than or equal to the length of the binary representation of x,\n        # we can directly set the first n bits of the result to match the binary representation of x\n        if n <= len_bin_x:\n            return int(bin_x.ljust(n, '0'), 2)\n        \n        # Otherwise, we need to ensure that the bitwise AND of all elements is x\n        # We can achieve this by setting the first len_bin_x bits to match the binary representation of x\n        # and the remaining bits to the maximum value that maintains the increasing order\n        result = int(bin_x.ljust(len_bin_x, '1'), 2)\n        for i in range(len_bin_x, n):\n            result |= (1 << i)\n        \n        return result"
        ]
    },
    {
        "question_id": "3362",
        "code_list": [
            "from typing import List\nfrom bisect import bisect_left, bisect_right\n\nclass Solution:\n    def medianOfUniquenessArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + 1)\n        \n        def count_distinct(k):\n            left = 0\n            right = n\n            while left < right:\n                mid = (left + right) // 2\n                if prefix[mid + 1] - prefix[left] >= k:\n                    right = mid\n                else:\n                    left = mid + 1\n            return left\n        \n        distinct_values = set()\n        for i in range(n):\n            start = i\n            end = n\n            while start < end:\n                mid = (start + end) // 2\n                if count_distinct(mid - i + 1) == mid - i + 1:\n                    start = mid + 1\n                else:\n                    end = mid\n            distinct_values.add(start - i)\n        \n        distinct_values = sorted(list(distinct_values))\n        median_index = (len(distinct_values) - 1) // 2\n        return distinct_values[median_index]"
        ]
    },
    {
        "question_id": "3396",
        "code_list": [
            "class Solution:\n    def isValid(self, word: str) -> bool:\n        vowels = set('aeiouAEIOU')\n        consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n        \n        if len(word) < 3:\n            return False\n        \n        has_vowel = False\n        has_consonant = False\n        \n        for char in word:\n            if char.isdigit():\n                continue\n            elif char in vowels:\n                has_vowel = True\n            elif char in consonants:\n                has_consonant = True\n            else:\n                return False\n        \n        return has_vowel and has_consonant"
        ]
    },
    {
        "question_id": "3384",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n        n = len(word)\n        prefix_count = [Counter() for _ in range(k)]\n        \n        # Count character frequencies in each segment of length k\n        for i in range(n):\n            prefix_count[i % k][word[i]] += 1\n        \n        # Determine the target segment\n        target = prefix_count[0]\n        for i in range(1, k):\n            for char in prefix_count[i]:\n                if char not in target or prefix_count[i][char] > target[char]:\n                    target[char] += 1\n        \n        # Calculate the number of operations needed\n        operations = 0\n        for i in range(k):\n            for char in prefix_count[i]:\n                if char in target:\n                    target[char] -= prefix_count[i][char]\n                else:\n                    operations += prefix_count[i][char]\n        \n        return operations"
        ]
    },
    {
        "question_id": "3395",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minAnagramLength(self, s: str) -> int:\n        count_s = Counter(s)\n        unique_chars = set(s)\n        min_length = float('inf')\n        \n        for char in unique_chars:\n            current_count = count_s[char]\n            while current_count > 0:\n                valid = True\n                for i in range(26):\n                    if chr(ord('a') + i) in count_s and count_s[chr(ord('a') + i)] % len(unique_chars) != 0:\n                        valid = False\n                        break\n                if valid:\n                    min_length = min(min_length, len(unique_chars))\n                    break\n                current_count -= 1\n                for i in range(26):\n                    if chr(ord('a') + i) in count_s:\n                        count_s[chr(ord('a') + i)] += 1\n        \n        return min_length if min_length != float('inf') else len(s)"
        ]
    },
    {
        "question_id": "3402",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minCostToEqualizeArray(self, nums: List[int], cost1: int, cost2: int) -> int:\n        mod = 10**9 + 7\n        n = len(nums)\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        \n        def get_cost(target):\n            cost = 0\n            for i in range(n):\n                diff = target - nums[i]\n                if diff > 0:\n                    cost += diff * (prefix_sum[i+1] - prefix_sum[max(0, i-diff+1)])\n            return cost\n        \n        min_cost = float('inf')\n        for num in set(nums):\n            cost = get_cost(num)\n            min_cost = min(min_cost, cost)\n        \n        return min_cost % mod"
        ]
    },
    {
        "question_id": "3398",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canMakeSquare(self, grid: List[List[str]]) -> bool:\n        # Check each 2x2 sub-square in the 3x3 grid\n        for i in range(2):\n            for j in range(2):\n                # Count the number of 'B's and 'W's in the current 2x2 sub-square\n                count_B = sum(grid[x][y] == 'B' for x in range(i, i+2) for y in range(j, j+2))\n                count_W = sum(grid[x][y] == 'W' for x in range(i, i+2) for y in range(j, j+2))\n                \n                # If there is at most one cell that needs to be changed to make the sub-square uniform\n                if abs(count_B - count_W) <= 1:\n                    return True\n        \n        return False"
        ]
    },
    {
        "question_id": "3388",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        row_count = [defaultdict(int) for _ in range(rows)]\n        col_count = [defaultdict(int) for _ in range(cols)]\n        \n        # Count ones in each row and column\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    row_count[i][j] += 1\n                    col_count[j][i] += 1\n        \n        count = 0\n        # Iterate through each cell\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    # Check all previous columns in the same row\n                    for k in range(j):\n                        if grid[i][k] == 1:\n                            count += row_count[i][k] - 1\n                    # Check all previous rows in the same column\n                    for k in range(i):\n                        if grid[k][j] == 1:\n                            count += col_count[j][k] - 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3406",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n        mod = 10**9 + 7\n        \n        def count_stable(z, o, l):\n            if z > o:\n                return count_stable(o, z, l)\n            if z == 0:\n                return 1 if o <= l else 0\n            if z == 1:\n                return 1 if o == 1 and o <= l else 0\n            \n            total = 0\n            for i in range(l + 1):\n                if i < o:\n                    total += comb(o - 1, i) * count_stable(z - 1, o - i - 1, l)\n                else:\n                    total += comb(o, i) * count_stable(z - 1, o - i, l)\n                total %= mod\n            return total\n        \n        return count_stable(zero, one, limit)"
        ]
    },
    {
        "question_id": "3412",
        "code_list": [
            "class Solution:\n    def findPermutationDifference(self, s: str, t: str) -> int:\n        s_indices = {char: idx for idx, char in enumerate(s)}\n        t_indices = {char: idx for idx, char in enumerate(t)}\n        \n        permutation_difference = sum(abs(s_indices[char] - t_indices[char]) for char in s)\n        return permutation_difference"
        ]
    },
    {
        "question_id": "3383",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumEnergy(self, energy: List[int], k: int) -> int:\n        n = len(energy)\n        dp = [0] * n\n        dp[0] = energy[0]\n        for i in range(1, n):\n            dp[i] = energy[i]\n            if (i + k) < n:\n                dp[i] += dp[i - k]\n            dp[i] = max(dp[i], (dp[i - 1] if i > 0 else 0))\n        return max(dp)"
        ]
    },
    {
        "question_id": "3429",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isArraySpecial(self, nums: List[int]) -> bool:\n        for i in range(len(nums) - 1):\n            if (nums[i] % 2) == (nums[i + 1] % 2):\n                return False\n        return True"
        ]
    },
    {
        "question_id": "3416",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def sumDigitDifferences(self, nums: List[int]) -> int:\n        total_diff = 0\n        num_length = len(str(nums[0]))  # All numbers have the same length\n        \n        for i in range(num_length):\n            digit_sum = 0\n            for num in nums:\n                digit_sum += (num // (10 ** i)) % 10\n            total_diff += digit_sum * (len(nums) - digit_sum)\n        \n        return total_diff"
        ]
    },
    {
        "question_id": "3414",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def waysToReachStair(self, k: int) -> int:\n        @lru_cache(None)\n        def dp(stair, jump):\n            if stair == k:\n                return 1\n            if stair > k or jump < 0:\n                return 0\n            \n            # Go down to stair i - 1\n            down = dp(stair - 1, jump - 1) if stair > 0 else 0\n            # Go up to stair i + 2^jump\n            up = dp(stair + (1 << jump), jump + 1)\n            \n            return down + up\n        \n        return dp(1, 0)"
        ]
    },
    {
        "question_id": "3446",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums1)):\n            for j in range(len(nums2)):\n                if nums1[i] % (nums2[j] * k) == 0:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3451",
        "code_list": [
            "class Solution:\n    def compressedString(self, word: str) -> str:\n        comp = \"\"\n        i = 0\n        while i < len(word):\n            char = word[i]\n            count = 0\n            while i < len(word) and word[i] == char:\n                i += 1\n                count += 1\n            comp += str(count) + char\n        return comp"
        ]
    },
    {
        "question_id": "3423",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        \n        def max_sum_subsequence(arr):\n            incl = 0  # Max sum including the previous element\n            excl = 0  # Max sum excluding the previous element\n            for num in arr:\n                new_excl = max(incl, excl)\n                incl = excl + num\n                excl = new_excl\n            return max(incl, excl)\n        \n        total_sum = 0\n        for pos, val in queries:\n            original_value = nums[pos]\n            nums[pos] = val\n            total_sum += max_sum_subsequence(nums) % MOD\n            nums[pos] = original_value  # Restore the original value for the next query\n        \n        return total_sum % MOD"
        ]
    },
    {
        "question_id": "3403",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumSubstringsInPartition(self, s: str) -> int:\n        count_map = Counter()\n        partitions = 0\n        \n        for char in s:\n            count_map[char] += 1\n            \n            # Check if current partition is balanced\n            if all(count_map[letter] > 0 for letter in count_map):\n                partitions += 1\n                count_map.clear()\n                \n        return partitions"
        ]
    },
    {
        "question_id": "3411",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findProductsOfElements(self, queries: List[List[int]]) -> List[int]:\n        MOD = 10**5\n        \n        # Precompute the powerful array up to a certain limit\n        powerful_array = []\n        power_of_two = 1\n        while power_of_two <= 10**15:\n            powerful_array.extend([power_of_two] * (1 + (10**15 // power_of_two - 10**15 // (2 * power_of_two))))\n            power_of_two *= 2\n        \n        # Function to get the value at index i in the powerful array\n        def get_value(i):\n            if i >= len(powerful_array):\n                return 0\n            return powerful_array[i]\n        \n        # Function to compute the product modulo mod_i\n        def product_mod(from_i, to_i, mod_i):\n            product = 1\n            for i in range(from_i, to_i + 1):\n                product = (product * get_value(i)) % mod_i\n            return product\n        \n        # Process each query\n        result = []\n        for from_i, to_i, mod_i in queries:\n            result.append(product_mod(from_i, to_i, mod_i))\n        \n        return result"
        ]
    },
    {
        "question_id": "3428",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def duplicateNumbersXOR(self, nums: List[int]) -> int:\n        xor_result = 0\n        seen_once = set()\n        seen_twice = set()\n        \n        for num in nums:\n            if num in seen_once:\n                seen_once.remove(num)\n                seen_twice.add(num)\n            else:\n                seen_once.add(num)\n        \n        for num in seen_twice:\n            xor_result ^= num\n        \n        return xor_result"
        ]
    },
    {
        "question_id": "3420",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def occurrencesOfElement(self, nums: List[int], queries: List[int], x: int) -> List[int]:\n        occurrence_indices = []\n        count = 0\n        \n        # First pass to record the indices of x in nums\n        for i, num in enumerate(nums):\n            if num == x:\n                occurrence_indices.append(i)\n                count += 1\n        \n        result = []\n        # Second pass to handle queries\n        for query in queries:\n            if query > count:\n                result.append(-1)\n            else:\n                result.append(occurrence_indices[query - 1])\n        \n        return result"
        ]
    },
    {
        "question_id": "abc356_a",
        "code_list": [
            "def reverse_subsequence():\n    N, L, R = map(int, input().split())\n    A = list(range(1, N + 1))\n    A[L - 1:R] = reversed(A[L - 1:R])\n    print(' '.join(map(str, A)))\n\nif __name__ == \"__main__\":\n    reverse_subsequence()"
        ]
    },
    {
        "question_id": "abc356_d",
        "code_list": [
            "def popcount(x):\n    return bin(x).count('1')\n\ndef main():\n    N, M = map(int, input().split())\n    MOD = 998244353\n    \n    # Precompute the prefix sums of popcount for all bits in M\n    prefix_sums = [0] * 61\n    for k in range(1, 61):\n        mask = (1 << k) - 1\n        count = sum(popcount((M & mask) & i) for i in range(1 << k))\n        prefix_sums[k] = (prefix_sums[k-1] + count) % MOD\n    \n    # Calculate the final result using prefix sums\n    result = 0\n    for k in range(61):\n        if (N >> k) & 1:\n            result = (result + prefix_sums[k]) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc356_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Count frequency of each element\n    freq = defaultdict(int)\n    for a in A:\n        freq[a] += 1\n    \n    # Calculate the contribution of each unique element\n    total_sum = 0\n    for a in freq:\n        for b in freq:\n            if a <= b:\n                ratio = b // a\n                if b % a != 0:\n                    ratio += 1\n                count_a = freq[a]\n                count_b = freq[b]\n                total_sum += (count_a * count_b * ratio)\n    \n    # Subtract double-counted pairs\n    for i in range(N):\n        for j in range(i+1, N):\n            max_val = max(A[i], A[j])\n            min_val = min(A[i], A[j])\n            ratio = max_val // min_val\n            if max_val % min_val != 0:\n                ratio += 1\n            total_sum -= ratio\n    \n    print(total_sum)"
        ]
    },
    {
        "question_id": "abc356_c",
        "code_list": [
            "from itertools import product\n\ndef main():\n    N, M, K = map(int, input().split())\n    tests = []\n    for _ in range(M):\n        C, *keys, result = input().split()\n        C = int(C)\n        tests.append((C, set(map(int, keys)), result))\n    \n    valid_combinations = 0\n    \n    # Iterate over all possible combinations of keys being real or dummies\n    for combination in product([0, 1], repeat=N):\n        real_keys = {i + 1 for i, is_real in enumerate(combination) if is_real}\n        passes_tests = True\n        \n        for C, keys_set, result in tests:\n            if len(real_keys & keys_set) >= K:\n                if result == 'x':\n                    passes_tests = False\n                    break\n            else:\n                if result == 'o':\n                    passes_tests = False\n                    break\n        \n        if passes_tests:\n            valid_combinations += 1\n    \n    print(valid_combinations)"
        ]
    },
    {
        "question_id": "abc356_b",
        "code_list": [
            "def main():\n    # Read input\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    X = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Check if goals are met\n    for i in range(M):\n        total_nutrient = sum(X[j][i] for j in range(N))\n        if total_nutrient < A[i]:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc357_c",
        "code_list": [
            "def print_carpet(N):\n    def generate_carpet(size):\n        if size == 1:\n            return [\"#\"]\n        sub_carpet = generate_carpet(size // 3)\n        result = []\n        for row in sub_carpet:\n            result.append(\"#\" * size)\n            result.append(\"#\" + \".\" * (size - 2) + \"#\")\n        result.append(\"#\" * size)\n        return result\n    \n    carpet = generate_carpet(3 ** N)\n    for row in carpet:\n        print(row)\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print_carpet(N)"
        ]
    },
    {
        "question_id": "abc357_a",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    H = list(map(int, input().split()))\n    \n    count = 0\n    for hand_count in H:\n        if M >= hand_count:\n            M -= hand_count\n            count += 1\n        else:\n            break\n    \n    print(count)"
        ]
    },
    {
        "question_id": "abc357_d",
        "code_list": [
            "def modular_concatenation(N):\n    MOD = 998244353\n    \n    # Function to compute (base^exp) % mod using iterative method\n    def power_mod(base, exp, mod):\n        result = 1\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp //= 2\n        return result\n    \n    # Calculate the length of N\n    len_N = len(str(N))\n    \n    # Calculate the sum of digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Calculate the result using properties of modular arithmetic\n    result = (power_mod(10, N * len_N - len_N * (N - 1), MOD) * digit_sum) % MOD\n    \n    return result\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(modular_concatenation(N))"
        ]
    },
    {
        "question_id": "abc357_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    lower_count = sum(1 for char in S if char.islower())\n    upper_count = len(S) - lower_count\n    \n    if upper_count > lower_count:\n        result = S.lower()\n    else:\n        result = S.upper()\n    \n    print(result)"
        ]
    },
    {
        "question_id": "abc357_e",
        "code_list": [
            "from collections import defaultdict\n\ndef count_reachable_pairs(N, edges):\n    # Create a dictionary to store the adjacency list representation of the graph\n    graph = defaultdict(list)\n    for i, edge in enumerate(edges):\n        graph[i + 1].append(edge)\n    \n    # Initialize the count of reachable pairs\n    reachable_pairs_count = 0\n    \n    # Function to perform DFS and count reachable nodes\n    def dfs(node, visited):\n        nonlocal reachable_pairs_count\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                reachable_pairs_count += 1\n                dfs(neighbor, visited)\n    \n    # Iterate over each node to start DFS from it\n    for start_node in range(1, N + 1):\n        visited = set()\n        dfs(start_node, visited)\n    \n    # Each node contributes its own count plus the counts of all nodes reachable from it\n    return reachable_pairs_count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    edges = list(map(int, input().split()))\n    print(count_reachable_pairs(N, edges))"
        ]
    },
    {
        "question_id": "abc358_e",
        "code_list": [
            "from math import comb\n\ndef modinv(x, mod=998244353):\n    return pow(x, mod - 2, mod)\n\ndef main():\n    K = int(input())\n    C = list(map(int, input().split()))\n\n    mod = 998244353\n    dp = [0] * (K + 1)\n    dp[0] = 1\n\n    for k in range(1, K + 1):\n        new_dp = [0] * (k + 1)\n        for i in range(k + 1):\n            if i > 0:\n                new_dp[i] += dp[i - 1] * C[0]\n            if i < k:\n                new_dp[i] += dp[i] * sum(C[1:])\n            new_dp[i] %= mod\n        dp = new_dp\n\n    print(sum(dp) % mod)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc358_c",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    S = [input() for _ in range(N)]\n    \n    # Create a set of indices for each flavor\n    flavor_indices = [set() for _ in range(M)]\n    for i, stand in enumerate(S):\n        for j, flavor in enumerate(stand):\n            if flavor == 'o':\n                flavor_indices[j].add(i)\n    \n    # Find the minimum number of stands needed\n    min_stands = float('inf')\n    for i in range(1, N + 1):\n        stands = set()\n        for j in range(M):\n            if len(flavor_indices[j]) <= i:\n                stands.update(flavor_indices[j])\n        if len(stands) == M:\n            min_stands = min(min_stands, i)\n    \n    print(min_stands)"
        ]
    },
    {
        "question_id": "abc358_b",
        "code_list": [
            "def main():\n    # Read input\n    N, A = map(int, input().split())\n    T = list(map(int, input().split()))\n\n    # Initialize the time when the first person starts\n    current_time = T[0]\n    \n    # Process each person's arrival and ticket purchase\n    for i in range(N):\n        # Determine when the current person finishes purchasing their ticket\n        finish_time = current_time + A\n        \n        # Print the finish time\n        print(finish_time)\n        \n        # Update the current time to the finish time\n        current_time = finish_time\n        \n        # If there are more people, update the current time based on the next arrival time\n        if i < N - 1:\n            current_time = max(current_time, T[i + 1])"
        ]
    },
    {
        "question_id": "abc358_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, m = data[0], data[1]\n    prices = data[2:2*n+2:2]\n    candies = data[3:2*n+2:2]\n\n    # Create a list of tuples (candies, price) and sort it in descending order\n    items = sorted(zip(candies, prices), reverse=True)\n\n    # Initialize variables\n    selected_boxes = [False] * n\n    total_cost = 0\n    assigned_candies = [0] * m\n\n    for i in range(n):\n        candy, price = items[i]\n        for j in range(m):\n            if assigned_candies[j] < candy and not selected_boxes[i]:\n                assigned_candies[j] = candy\n                total_cost += price\n                selected_boxes[i] = True\n                break\n\n    # Check if all people have enough candies\n    for i in range(m):\n        if assigned_candies[i] < data[2*m+2+i]:\n            print(-1)\n            return\n\n    print(total_cost)"
        ]
    },
    {
        "question_id": "abc358_a",
        "code_list": [
            "if __name__ == \"__main__\":\n    S, T = input().split()\n    if S == \"AtCoder\" and T == \"Land\":\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        ]
    },
    {
        "question_id": "abc359_c",
        "code_list": [
            "def main():\n    S_x, S_y = map(int, input().split())\n    T_x, T_y = map(int, input().split())\n\n    # Calculate the difference in coordinates\n    dx = abs(S_x - T_x)\n    dy = abs(S_y - T_y)\n\n    # Determine the toll based on the parity of the sum of coordinates\n    if (S_x + S_y) % 2 == (T_x + T_y) % 2:\n        toll = max(dx, dy)\n    else:\n        toll = dx + dy - min(dx, dy)\n\n    print(toll)"
        ]
    },
    {
        "question_id": "abc359_b",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Count occurrences of each color\n    color_counts = Counter(A)\n    \n    # Check for each color if there is exactly one person between the two people wearing that color\n    count = 0\n    for color in range(1, N + 1):\n        if color_counts[color] != 2:\n            continue\n        positions = [i for i, a in enumerate(A) if a == color]\n        if positions[1] - positions[0] == 2 or positions[0] - positions[1] == 2:\n            count += 1\n    \n    print(count)"
        ]
    },
    {
        "question_id": "abc359_e",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:N+1]))\n    A = [0] * (N + 1)\n    \n    ans = []\n    for i in range(1, N + 1):\n        steps = 0\n        while True:\n            A[0] += 1\n            for j in range(1, i + 1):\n                if A[j - 1] > A[j] and A[j - 1] > H[j - 1]:\n                    A[j - 1] -= 1\n                    A[j] += 1\n            steps += 1\n            if A[i] > 0:\n                ans.append(steps)\n                break\n    \n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc359_a",
        "code_list": [
            "def main():\n    N = int(input())\n    takahashi_count = 0\n    for _ in range(N):\n        S_i = input()\n        if S_i == \"Takahashi\":\n            takahashi_count += 1\n    print(takahashi_count)"
        ]
    },
    {
        "question_id": "abc359_d",
        "code_list": [
            "from itertools import product\n\ndef is_good_string(s, k):\n    n = len(s)\n    for i in range(n - k + 1):\n        substr = s[i:i+k]\n        if substr == substr[::-1] and '?' not in substr:\n            return False\n    return True\n\ndef count_good_strings(n, k, s):\n    mod = 998244353\n    q = s.count('?')\n    if q == 0:\n        return int(is_good_string(s, k))\n    \n    # Generate all possible replacements for '?'\n    possibilities = ['A', 'B']\n    valid_count = 0\n    \n    for replacement in product(possibilities, repeat=q):\n        new_s = s[:]\n        for i, char in enumerate(replacement):\n            new_s = new_s[:i] + char + new_s[i+1:]\n        if is_good_string(new_s, k):\n            valid_count = (valid_count + 1) % mod\n            \n    return valid_count\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    s = input().strip()\n    print(count_good_strings(n, k, s))"
        ]
    },
    {
        "question_id": "abc360_c",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    W = list(map(int, input().split()))\n\n    # Count the frequency of each box number\n    box_count = Counter(A)\n\n    # Create a list of weights for each box\n    box_weights = [[] for _ in range(N + 1)]\n    for i, a in enumerate(A):\n        box_weights[a].append(W[i])\n\n    # Sort weights for each box\n    for weights in box_weights:\n        weights.sort()\n\n    total_cost = 0\n    for i in range(1, N + 1):\n        if len(box_weights[i]) > 1:\n            # Calculate the cost to move all but one item to other boxes\n            total_cost += sum(box_weights[i][1:]) * (box_count[i] - 1)\n\n    print(total_cost)"
        ]
    },
    {
        "question_id": "abc360_b",
        "code_list": [
            "def main():\n    S, T = input().split()\n    n, m = len(S), len(T)\n    \n    for w in range(1, n):\n        for c in range(1, w + 1):\n            result = ''\n            for i in range(c, n, w):\n                if len(S[i:i+w]) >= c:\n                    result += S[i+c-1]\n            if result == T:\n                print('Yes')\n                return\n    print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc360_e",
        "code_list": [
            "from math import gcd\n\ndef modinv(a, m=998244353):\n    return pow(a, m-2, m)\n\ndef expected_value(N, K):\n    # Initialize the numerator and denominator for the expected value\n    numerator = N\n    denominator = 1\n    \n    # Update the numerator and denominator after each operation\n    for _ in range(K):\n        numerator = (numerator * (2 * N - 2)) % 998244353\n        denominator = (denominator * (2 * N - 1)) % 998244353\n        N -= 1\n    \n    # Simplify the fraction\n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n    \n    # Calculate the modular inverse of the denominator\n    denominator_inv = modinv(denominator)\n    \n    # Calculate the result\n    result = (numerator * denominator_inv) % 998244353\n    \n    return result\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    print(expected_value(N, K))"
        ]
    },
    {
        "question_id": "abc360_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    rice_index = S.index('R')\n    miso_soup_index = S.index('M')\n    \n    if rice_index < miso_soup_index:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc360_d",
        "code_list": [
            "def count_passing_pairs(N, T, S, X):\n    # Initialize lists to store positions of ants moving left and right\n    left_ants = []\n    right_ants = []\n    \n    # Separate ants based on their direction\n    for i in range(N):\n        if S[i] == '0':  # Moving left\n            left_ants.append(X[i])\n        else:  # Moving right\n            right_ants.append(X[i])\n    \n    # Sort the positions of ants\n    left_ants.sort()\n    right_ants.sort()\n    \n    # Initialize counters\n    left_index = 0\n    right_index = 0\n    passing_pairs = 0\n    \n    # Count passing pairs\n    while left_index < len(left_ants) and right_index < len(right_ants):\n        if left_ants[left_index] + T > right_ants[right_index] - T:\n            passing_pairs += len(right_ants) - right_index\n            left_index += 1\n        else:\n            right_index += 1\n    \n    return passing_pairs\n\nif __name__ == \"__main__\":\n    N, T = map(int, input().split())\n    S = input()\n    X = list(map(int, input().split()))\n    print(count_passing_pairs(N, T, S, X))"
        ]
    },
    {
        "question_id": "abc361_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    N = int(input())\n    S = input()\n    T = input()\n\n    # Initialize the state with all stones in their initial positions\n    initial_state = [i for i in range(N)]\n    target_state = [i for i in range(N)]\n\n    # Create a mapping of stone positions to their colors\n    color_map = {i: 'W' if S[i] == 'W' else 'B' for i in range(N)}\n\n    # Function to check if a state is valid\n    def is_valid_state(state):\n        for i in range(N):\n            if state[i] != target_state[i]:\n                return False\n        return True\n\n    # Function to perform the operation\n    def move_stones(state, x):\n        new_state = state[:]\n        k = new_state.index(x)\n        new_state[k], new_state[k + 1] = new_state[k + 1], new_state[k]\n        return new_state\n\n    # BFS to find the minimum number of operations\n    queue = deque([(initial_state, 0)])\n    visited = set([tuple(initial_state)])\n\n    while queue:\n        current_state, steps = queue.popleft()\n        if is_valid_state(current_state):\n            print(steps)\n            return\n\n        for x in range(N - 1):\n            if current_state[x] != target_state[x] and current_state[x + 1] != target_state[x + 1]:\n                next_state = move_stones(current_state[:], current_state[x])\n                if tuple(next_state) not in visited:\n                    visited.add(tuple(next_state))\n                    queue.append((next_state, steps + 1))\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc361_b",
        "code_list": [
            "def check_intersection():\n    a, b, c, d, e, f = map(int, input().split())\n    g, h, i, j, k, l = map(int, input().split())\n\n    # Check if there is any overlap along each axis\n    x_overlap = max(0, min(d, j) - max(a, g))\n    y_overlap = max(0, min(e, k) - max(b, h))\n    z_overlap = max(0, min(f, l) - max(c, i))\n\n    # If there is overlap along all three axes, the intersection has a positive volume\n    if x_overlap > 0 and y_overlap > 0 and z_overlap > 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    check_intersection()"
        ]
    },
    {
        "question_id": "abc361_a",
        "code_list": [
            "def main():\n    # Read input\n    N, K, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Insert X after the K-th element\n    B = A[:K] + [X] + A[K:]\n    \n    # Print the result\n    print(' '.join(map(str, B)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc361_f",
        "code_list": [
            "import math\n\ndef main():\n    N = int(input())\n    count = 0\n    \n    # Iterate over possible values of b starting from 2\n    for b in range(2, int(math.log(N, 2)) + 2):\n        a = 2\n        while True:\n            x = a ** b\n            if x > N:\n                break\n            count += 1\n            a += 1\n            \n    print(count)"
        ]
    },
    {
        "question_id": "abc361_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    \n    min_vals = [a[0]]\n    max_vals = [a[-1]]\n    \n    for i in range(1, n):\n        min_vals.append(min(min_vals[-1], a[i]))\n        max_vals.append(max(max_vals[-1], a[-i-1]))\n    \n    min_diff = float('inf')\n    for i in range(n - k + 1):\n        if i == 0:\n            min_diff = min(min_diff, max_vals[n-k] - a[i+k-1])\n        elif i == n - k:\n            min_diff = min(min_diff, max_vals[-1] - a[i-1])\n        else:\n            min_diff = min(min_diff, max_vals[n-k] - min_vals[i-1])\n    \n    print(min_diff)"
        ]
    },
    {
        "question_id": "abc361_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    edges = defaultdict(list)\n    idx = 1\n    \n    for _ in range(n - 1):\n        u = int(data[idx]) - 1\n        v = int(data[idx + 1]) - 1\n        w = int(data[idx + 2])\n        edges[u].append((v, w))\n        edges[v].append((u, w))\n        idx += 3\n    \n    def dfs(node, parent, dist):\n        max_dist = 0\n        second_max_dist = 0\n        for neighbor, weight in edges[node]:\n            if neighbor != parent:\n                current_max, current_second_max = dfs(neighbor, node, dist + weight)\n                if current_max > max_dist:\n                    second_max_dist = max_dist\n                    max_dist = current_max\n                elif current_max > second_max_dist:\n                    second_max_dist = current_max\n        return max_dist + dist, second_max_dist + dist\n    \n    root = 0\n    _, second_max_dist = dfs(root, -1, 0)\n    \n    print(second_max_dist * 2)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_d",
        "code_list": [
            "import heapq\n\ndef dijkstra(N, edges, A):\n    # Initialize distances with infinity\n    dist = [float('inf')] * (N + 1)\n    dist[1] = A[1]\n    \n    # Priority queue to store (distance, vertex)\n    pq = [(A[1], 1)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        \n        if d > dist[u]:\n            continue\n        \n        for v, w in edges[u]:\n            new_dist = d + A[v] + w\n            \n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n    \n    return dist[2:]\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    edges = [[] for _ in range(N + 1)]\n    \n    for _ in range(M):\n        U, V, B = map(int, input().split())\n        edges[U].append((V, B))\n        edges[V].append((U, B))\n    \n    result = dijkstra(N, edges, A)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    n = int(input())\n    A = list(map(int, input().split()))\n    \n    mod = 998244353\n    \n    # Initialize prefix sums and suffix sums\n    prefix_sum = [defaultdict(int) for _ in range(n)]\n    suffix_sum = [defaultdict(int) for _ in range(n)]\n    \n    # Fill prefix sums\n    for i in range(n):\n        for j in range(i):\n            diff = A[i] - A[j]\n            prefix_sum[i][diff] += 1 + prefix_sum[j][diff]\n    \n    # Fill suffix sums\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, i, -1):\n            diff = A[i] - A[j]\n            suffix_sum[i][diff] += 1 + suffix_sum[j][diff]\n    \n    # Calculate the answer for each k\n    ans = []\n    for k in range(1, n+1):\n        count = 0\n        for i in range(n):\n            if k <= n - i:\n                diff = A[i]\n                count += prefix_sum[i][diff] * suffix_sum[i][diff]\n                count %= mod\n        ans.append(count)\n    \n    print(*ans)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_sequence(N, intervals):\n        total_sum = sum(R - L + 1 for L, R in intervals)\n        target = -sum(L for L, R in intervals)\n        \n        if target < 0 or abs(target) > total_sum:\n            print(\"No\")\n            return\n        \n        sequence = []\n        for L, R in intervals:\n            if target >= R - L + 1:\n                sequence.append(R)\n                target -= R - L + 1\n            else:\n                sequence.append(target + L)\n                target = 0\n        \n        if target != 0:\n            print(\"No\")\n            return\n        \n        print(\"Yes\")\n        print(*sequence)\n    \n    # Read input\n    N = int(input().strip())\n    intervals = [tuple(map(int, input().strip().split())) for _ in range(N)]\n    \n    # Solve the problem\n    find_sequence(N, intervals)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_a",
        "code_list": [
            "def main():\n    R, G, B = map(int, input().split())\n    C = input()\n    \n    if C == \"Red\":\n        print(min(G, B))\n    elif C == \"Green\":\n        print(min(R, B))\n    else:\n        print(min(R, G))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc362_b",
        "code_list": [
            "import math\n\ndef main():\n    # Read input coordinates\n    x_A, y_A = map(int, input().split())\n    x_B, y_B = map(int, input().split())\n    x_C, y_C = map(int, input().split())\n    \n    # Calculate squared lengths of sides\n    AB2 = (x_B - x_A)**2 + (y_B - y_A)**2\n    BC2 = (x_C - x_B)**2 + (y_C - y_B)**2\n    CA2 = (x_C - x_A)**2 + (y_C - y_A)**2\n    \n    # Check if any angle is 90 degrees\n    if AB2 + BC2 == CA2 or AB2 + CA2 == BC2 or BC2 + CA2 == AB2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_a",
        "code_list": [
            "def main():\n    R = int(input())\n    current_display = (R + 99) // 100\n    next_display = current_display + 1\n    \n    target_rating = next_display * 100 - 100\n    increase_required = target_rating - R\n    \n    print(increase_required)"
        ]
    },
    {
        "question_id": "abc363_f",
        "code_list": [
            "def main():\n    import math\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def find_palindrome(n):\n        for i in range(int(math.sqrt(n)), 0, -1):\n            if n % i == 0:\n                quotient = n // i\n                str_i = str(i)\n                str_quotient = str(quotient)\n                \n                # Check if both parts are valid palindromes\n                if str_i[0] in '123456789' and str_quotient[0] in '123456789':\n                    part1 = str_i + '*' + str_quotient\n                    part2 = str_quotient[::-1] + '*' + str_i[::-1]\n                    \n                    # Construct the full palindrome\n                    if is_palindrome(part1) and is_palindrome(part2):\n                        return part1 + part2[1:]\n        \n        return -1\n    \n    N = int(input())\n    result = find_palindrome(N)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc363_b",
        "code_list": [
            "def main():\n    N, T, P = map(int, input().split())\n    hair_lengths = list(map(int, input().split()))\n    \n    # Count how many people already have hair length >= T\n    initial_count = sum(1 for length in hair_lengths if length >= T)\n    \n    if initial_count >= P:\n        print(0)\n    else:\n        # Calculate the number of days needed\n        days = 0\n        for i in range(N):\n            if hair_lengths[i] + days < T:\n                needed_days = T - hair_lengths[i] - 1\n                days += needed_days\n                initial_count += 1\n                if initial_count >= P:\n                    break\n        \n        print(days)"
        ]
    },
    {
        "question_id": "abc363_c",
        "code_list": [
            "from itertools import permutations\n\ndef is_palindrome(s, k):\n    n = len(s)\n    for i in range(n - k + 1):\n        if s[i:i + k] == s[i:i + k][::-1]:\n            return True\n    return False\n\ndef count_valid_permutations(n, k, s):\n    valid_count = 0\n    for perm in permutations(s):\n        if not is_palindrome(perm, k):\n            valid_count += 1\n    return valid_count\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    s = input().strip()\n    result = count_valid_permutations(n, k, s)\n    print(result)"
        ]
    },
    {
        "question_id": "abc363_d",
        "code_list": [
            "def generate_palindrome(n):\n    def reverse(s):\n        return s[::-1]\n    \n    def is_palindrome(s):\n        return s == reverse(s)\n    \n    def generate_even_length_palindrome(length):\n        half = int('5' * (length // 2))\n        for i in range(10**(length // 2 - 1), 10**(length // 2)):\n            num = int(str(i) + reverse(str(i)))\n            if num >= n:\n                return num\n        return None\n    \n    def generate_odd_length_palindrome(length):\n        half = int('5' * ((length - 1) // 2))\n        for i in range(10**((length - 1) // 2), 10**((length - 1) // 2 + 1)):\n            for j in range(10):\n                num = int(str(i) + str(j) + reverse(str(i)))\n                if num >= n:\n                    return num\n        return None\n    \n    length = 1\n    while True:\n        # Generate even length palindromes\n        result = generate_even_length_palindrome(length)\n        if result:\n            return result\n        \n        # Generate odd length palindromes\n        result = generate_odd_length_palindrome(length)\n        if result:\n            return result\n        \n        length += 1\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(generate_palindrome(n))"
        ]
    },
    {
        "question_id": "abc363_e",
        "code_list": [
            "def main():\n    # Read input\n    H, W, Y = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(H)]\n    \n    # Initialize the result list\n    result = []\n    \n    # Process each year\n    for y in range(1, Y + 1):\n        # Create a copy of the current elevation map\n        current_elevation = [row[:] for row in A]\n        \n        # Mark sections that will sink\n        for i in range(H):\n            for j in range(W):\n                if current_elevation[i][j] <= y:\n                    current_elevation[i][j] = -1\n        \n        # Flood fill to mark all connected sections that will sink\n        def flood_fill(i, j):\n            if i < 0 or i >= H or j < 0 or j >= W or current_elevation[i][j] != -1:\n                return\n            current_elevation[i][j] = -2\n            flood_fill(i + 1, j)\n            flood_fill(i - 1, j)\n            flood_fill(i, j + 1)\n            flood_fill(i, j - 1)\n        \n        for i in range(H):\n            for j in range(W):\n                if current_elevation[i][j] == -1:\n                    flood_fill(i, j)\n        \n        # Count the remaining area\n        remaining_area = sum(row.count(-2) for row in current_elevation)\n        result.append(remaining_area)\n    \n    # Print the results\n    for area in result:\n        print(area)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_b",
        "code_list": [
            "def main():\n    H, W = map(int, input().split())\n    Si, Sj = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    X = input()\n\n    i, j = Si - 1, Sj - 1\n\n    for move in X:\n        if move == 'L' and j > 0 and grid[i][j - 1] == '.':\n            j -= 1\n        elif move == 'R' and j < W - 1 and grid[i][j + 1] == '.':\n            j += 1\n        elif move == 'U' and i > 0 and grid[i - 1][j] == '.':\n            i -= 1\n        elif move == 'D' and i < H - 1 and grid[i + 1][j] == '.':\n            i += 1\n\n    print(i + 1, j + 1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_e",
        "code_list": [
            "def main():\n    from itertools import permutations\n\n    N, X, Y = map(int, input().split())\n    AB = [tuple(map(int, input().split())) for _ in range(N)]\n\n    max_dishes = 0\n    for perm in permutations(AB):\n        total_sweetness = 0\n        total_saltiness = 0\n        for dish in perm:\n            total_sweetness += dish[0]\n            total_saltiness += dish[1]\n            if total_sweetness > X or total_saltiness > Y:\n                break\n        else:\n            max_dishes = max(max_dishes, len(perm))\n\n    print(max_dishes)"
        ]
    },
    {
        "question_id": "abc364_f",
        "code_list": [
            "from collections import defaultdict\nimport sys\ninput = sys.stdin.read\nsys.setrecursionlimit(10**7)\n\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x, y):\n    x, y = find(x), find(y)\n    if x == y:\n        return False\n    if par[x] > par[y]:\n        x, y = y, x\n    par[x] += par[y]\n    par[y] = x\n    return True\n\ndef same(x, y):\n    return find(x) == find(y)\n\ndef size(x):\n    return -par[find(x)]\n\ndef main():\n    N, Q = map(int, input().split())\n    edges = []\n    for _ in range(Q):\n        L, R, C = map(int, input().split())\n        edges.append((C, L, R))\n    \n    # Sort edges by cost\n    edges.sort()\n    \n    # Initialize parent array for union-find\n    par = [-1] * (N + Q + 1)\n    \n    # Process edges\n    total_cost = 0\n    for c, l, r in edges:\n        for j in range(l, r + 1):\n            if not same(N + Q, j):\n                unite(N + Q, j)\n                total_cost += c\n    \n    # Check if the graph is connected\n    if size(N + Q) == N + Q:\n        print(total_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_d",
        "code_list": [
            "import heapq\nfrom typing import List\n\ndef find_kth_distance(N: int, Q: int, A: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for b, k in queries:\n        distances = [abs(a - b) for a in A]\n        heapq.heapify(distances)\n        for _ in range(k - 1):\n            heapq.heappop(distances)\n        results.append(heapq.heappop(distances))\n    return results\n\ndef main():\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    queries = [list(map(int, input().split())) for _ in range(Q)]\n    results = find_kth_distance(N, Q, A, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    x = data[1]\n    y = data[2]\n    a = data[3:3 * n + 3:3]\n    b = data[4:3 * n + 3:3]\n\n    # Calculate prefix sums for sweetness and saltiness\n    sweet_prefix_sum = [0] * (n + 1)\n    salt_prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        sweet_prefix_sum[i + 1] = sweet_prefix_sum[i] + a[i]\n        salt_prefix_sum[i + 1] = salt_prefix_sum[i] + b[i]\n\n    # Binary search for the minimum number of dishes\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if check(mid, sweet_prefix_sum, salt_prefix_sum, x, y):\n            right = mid\n        else:\n            left = mid + 1\n\n    print(left)\n\ndef check(k, sweet_prefix_sum, salt_prefix_sum, x, y):\n    max_saltiness = 0\n    for i in range(len(sweet_prefix_sum) - k):\n        if sweet_prefix_sum[i + k] - sweet_prefix_sum[i] > x:\n            continue\n        max_saltiness = max(max_saltiness, salt_prefix_sum[i + k] - salt_prefix_sum[i])\n        if max_saltiness <= y:\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc364_a",
        "code_list": [
            "def can_eat_all_dishes():\n    N = int(input())\n    previous_dish = \"\"\n    \n    for _ in range(N):\n        current_dish = input()\n        if current_dish == \"sweet\" and previous_dish == \"sweet\":\n            print(\"No\")\n            return\n        previous_dish = current_dish\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    can_eat_all_dishes()"
        ]
    },
    {
        "question_id": "abc365_b",
        "code_list": [
            "def main():\n    # Read input\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    \n    # Find the maximum element\n    max_element = max(A)\n    # Remove the maximum element to find the second maximum\n    A.remove(max_element)\n    second_max_index = A.index(max(A)) + 1\n    \n    # Print the index of the second largest element\n    print(second_max_index)"
        ]
    },
    {
        "question_id": "abc365_a",
        "code_list": [
            "def main():\n    Y = int(input())\n    if Y % 400 == 0:\n        print(366)\n    elif Y % 100 == 0:\n        print(365)\n    elif Y % 4 == 0:\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc365_e",
        "code_list": [
            "def main():\n    import sys\n    \n    def count_set_bits(num):\n        count = 0\n        while num:\n            num &= num - 1\n            count += 1\n        return count\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Calculate prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(N):\n        prefix_xor[i + 1] = prefix_xor[i] ^ A[i]\n    \n    # Initialize result\n    result = 0\n    \n    # Iterate over all possible ending points of the subarray\n    for j in range(1, N + 1):\n        # For each ending point, calculate the number of times each prefix XOR appears\n        for i in range(j):\n            xor_val = prefix_xor[j] ^ prefix_xor[i]\n            result += count_set_bits(xor_val)\n    \n    print(result)"
        ]
    },
    {
        "question_id": "abc365_d",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n\n    # Count the occurrences of each move\n    count_R = S.count('R')\n    count_P = S.count('P')\n    count_S = S.count('S')\n\n    # Determine the maximum number of wins Takahashi can have\n    max_wins = 0\n    if count_R > 0:\n        max_wins += count_R - 1\n    if count_P > 0:\n        max_wins += count_P - 1\n    if count_S > 0:\n        max_wins += count_S - 1\n\n    print(max_wins)"
        ]
    },
    {
        "question_id": "abc365_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    N, M = data[0], data[1]\n    A = data[2:]\n\n    # If the sum of all transportation costs is less than or equal to M, the subsidy limit can be made infinitely large\n    if sum(A) <= M:\n        print(\"infinite\")\n        return\n\n    low, high = 0, max(A)\n    while low < high:\n        mid = (low + high + 1) // 2\n        total_cost = sum(min(mid, cost) for cost in A)\n        if total_cost > M:\n            high = mid - 1\n        else:\n            low = mid\n\n    print(low)"
        ]
    },
    {
        "question_id": "3426",
        "code_list": [
            "class Solution:\n    def minimumChairs(self, s: str) -> int:\n        max_chairs_needed = 0\n        current_chairs = 0\n        \n        for event in s:\n            if event == 'E':\n                current_chairs += 1\n                max_chairs_needed = max(max_chairs_needed, current_chairs)\n            else:\n                current_chairs -= 1\n        \n        return max_chairs_needed"
        ]
    },
    {
        "question_id": "3430",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countDays(self, days: int, meetings: List[List[int]]) -> int:\n        meetings.sort(key=lambda x: x[0])  # Sort meetings by start time\n        busy_days = set()\n        \n        for start, end in meetings:\n            for day in range(start, end + 1):\n                busy_days.add(day)\n        \n        return days - len(busy_days)"
        ]
    },
    {
        "question_id": "3436",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        min_diff = float('inf')\n        current_or = 0\n        \n        for num in nums:\n            current_or |= num\n            diff = abs(current_or - k)\n            min_diff = min(min_diff, diff)\n            \n            # Early termination if the current OR value is equal to k\n            if current_or == k:\n                return 0\n        \n        return min_diff"
        ]
    },
    {
        "question_id": "3450",
        "code_list": [
            "class Solution:\n    def numberOfChild(self, n: int, k: int) -> int:\n        direction = 1  # 1 for right, -1 for left\n        position = 0\n        \n        for _ in range(k):\n            position += direction\n            if position == 0 or position == n - 1:\n                direction *= -1\n        \n        return position"
        ]
    },
    {
        "question_id": "3422",
        "code_list": [
            "class Solution:\n    def valueAfterKSeconds(self, n: int, k: int) -> int:\n        MOD = 10**9 + 7\n        # Initialize the array\n        a = [1] * n\n        \n        # Update the array for k seconds\n        for _ in range(k):\n            for i in range(1, n):\n                a[i] = (a[i] + a[i-1]) % MOD\n        \n        # Return the value of a[n-1] after k seconds\n        return a[-1]"
        ]
    },
    {
        "question_id": "3442",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        rewardValues.sort()\n        total_reward = 0\n        for value in rewardValues:\n            if value > total_reward:\n                total_reward += value\n        return total_reward"
        ]
    },
    {
        "question_id": "3421",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countCompleteDayPairs(self, hours: List[int]) -> int:\n        count = 0\n        mod_values = {}\n        for hour in hours:\n            complement = (24 - hour % 24) % 24\n            count += mod_values.get(complement, 0)\n            mod_values[hour % 24] = mod_values.get(hour % 24, 0) + 1\n        return count"
        ]
    },
    {
        "question_id": "3437",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalDamage(self, power: List[int]) -> int:\n        power.sort()\n        n = len(power)\n        dp = [0] * (n + 4)  # Extra padding to handle edge cases easily\n        \n        for p in power:\n            dp[p + 2] = max(dp[p + 1], dp[p - 1], dp[p - 2]) + p\n        \n        return max(dp[power[-1] + 1], dp[power[-1]], dp[power[-1] - 1], dp[power[-1] - 2])"
        ]
    },
    {
        "question_id": "3438",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countOfPeaks(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            if i > 0 and i < n - 1 and nums[i-1] < nums[i] > nums[i+1]:\n                prefix_sum[i+1] = prefix_sum[i] + 1\n            else:\n                prefix_sum[i+1] = prefix_sum[i]\n        \n        def query_range(start: int, end: int) -> int:\n            return prefix_sum[end + 1] - prefix_sum[start]\n        \n        result = []\n        for q in queries:\n            if q[0] == 1:\n                l, r = q[1], q[2]\n                original_value = nums[l]\n                nums[l] = q[2]\n                if l > 0 and l < n - 1:\n                    if original_value > nums[l-1] and original_value > nums[l+1]:\n                        prefix_sum[l+1] -= 1\n                    if q[2] > nums[l-1] and q[2] > nums[l+1]:\n                        prefix_sum[l+1] += 1\n                result.append(query_range(l, r))\n            elif q[0] == 2:\n                index, val = q[1], q[2]\n                nums[index] = val\n                if index > 0 and index < n - 1:\n                    if nums[index-1] < nums[index] > nums[index+1]:\n                        prefix_sum[index+1] += 1\n                    else:\n                        prefix_sum[index+1] -= 1\n        return result"
        ]
    },
    {
        "question_id": "3471",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumAverage(self, nums: List[int]) -> float:\n        nums.sort()\n        averages = []\n        for _ in range(len(nums) // 2):\n            min_element = nums.pop(0)\n            max_element = nums.pop(-1)\n            averages.append((min_element + max_element) / 2)\n        return min(averages)"
        ]
    },
    {
        "question_id": "3461",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumArea(self, grid: List[List[int]]) -> int:\n        rows, cols = len(grid), len(grid[0])\n        first_occurrence = [-1] * cols\n        last_occurrence = [-1] * cols\n        ones_count = 0\n        \n        # Find the first and last occurrence of 1 in each row\n        for row in grid:\n            left, right = -1, -1\n            for j in range(cols):\n                if row[j] == 1:\n                    if left == -1:\n                        left = j\n                    right = j\n                    ones_count += 1\n            for j in range(left, right + 1):\n                if first_occurrence[j] == -1:\n                    first_occurrence[j] = ones_count\n                last_occurrence[j] = ones_count\n        \n        min_area = float('inf')\n        \n        # Calculate the minimum area\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    min_area = min(min_area, (last_occurrence[j] - first_occurrence[j] + 1) * (i + 1))\n        \n        return min_area"
        ]
    },
    {
        "question_id": "3464",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        max_cost = dp[0]\n        \n        for i in range(1, n):\n            # Calculate the cost of the current subarray ending at index i\n            cost = nums[i] * (-1) ** (i - 0)\n            if i - 1 >= 0:\n                cost += dp[i - 1] * (-1) ** (i - (i - 1))\n            \n            # Update dp[i] to be the maximum cost we can get by either continuing the previous subarray or starting a new one\n            dp[i] = max(cost, nums[i])\n            max_cost = max(max_cost, dp[i])\n        \n        return max_cost"
        ]
    },
    {
        "question_id": "3469",
        "code_list": [
            "class Solution:\n    def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n        total_balls = red + blue\n        for height in range(min(red, blue, total_balls // 2), 0, -1):\n            if (height * (height + 1)) // 2 <= red and (height * (height + 1)) // 2 <= blue:\n                return height\n        return 0"
        ]
    },
    {
        "question_id": "3490",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumLength(self, nums: List[int]) -> int:\n        dp_even = [1] * len(nums)\n        dp_odd = [1] * len(nums)\n        for i in range(1, len(nums)):\n            if (nums[i] + nums[i-1]) % 2 == 0:\n                dp_even[i] = dp_even[i-1] + 1\n                dp_odd[i] = max(dp_odd[i-1], dp_even[i-1])\n            else:\n                dp_odd[i] = dp_odd[i-1] + 1\n                dp_even[i] = max(dp_even[i-1], dp_odd[i-1])\n        return max(dp_even[-1], dp_odd[-1])"
        ]
    },
    {
        "question_id": "3439",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:\n        def dfs(node, parent, graph, visited):\n            visited.add(node)\n            farthest_node = node\n            max_distance = 0\n            for neighbor in graph[node]:\n                if neighbor != parent and neighbor not in visited:\n                    distance, farthest_from_neighbor = dfs(neighbor, node, graph, visited)\n                    if distance + 1 > max_distance:\n                        max_distance = distance + 1\n                        farthest_node = farthest_from_neighbor\n            return max_distance, farthest_node\n        \n        def build_graph(edges):\n            graph = defaultdict(list)\n            for u, v in edges:\n                graph[u].append(v)\n                graph[v].append(u)\n            return graph\n        \n        # Build graphs for both trees\n        graph1 = build_graph(edges1)\n        graph2 = build_graph(edges2)\n        \n        # Find the diameter of each tree\n        def find_diameter(graph):\n            start_node = next(iter(graph))\n            _, farthest_node = dfs(start_node, None, graph, set())\n            _, diameter = dfs(farthest_node, None, graph, set())\n            return diameter\n        \n        diameter1 = find_diameter(graph1)\n        diameter2 = find_diameter(graph2)\n        \n        # Try to merge nodes from both trees\n        merged_diameter = float('inf')\n        for u, v in graph1.values():\n            for x, y in graph2.values():\n                if (u, v) == (x, y) or (u, v) == (y, x):\n                    new_graph1 = graph1.copy()\n                    new_graph2 = graph2.copy()\n                    new_graph1.pop(u)\n                    new_graph1.pop(v)\n                    new_graph2.pop(x)\n                    new_graph2.pop(y)\n                    new_graph1.update(new_graph2)\n                    \n                    merged_diameter = min(merged_diameter, find_diameter(new_graph1))\n        \n        return min(diameter1, diameter2, merged_diameter)"
        ]
    },
    {
        "question_id": "3468",
        "code_list": [
            "class Solution:\n    def getEncryptedString(self, s: str, k: int) -> str:\n        encrypted_string = \"\"\n        for char in s:\n            # Calculate the new character position considering the cyclic nature\n            new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a'))\n            encrypted_string += new_char\n        return encrypted_string"
        ]
    },
    {
        "question_id": "3453",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def validStrings(self, n: int) -> List[str]:\n        if n == 1:\n            return [\"0\", \"1\"]\n        result = set()\n        for s in self.validStrings(n - 1):\n            for i in range(len(s) + 1):\n                new_str = s[:i] + \"1\" + s[i:]\n                if all(\"00\" not in s[j:j+2] for j in range(len(new_str) - 1)):\n                    result.add(new_str)\n        return list(result)"
        ]
    },
    {
        "question_id": "3492",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfSubmatrices(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n        count = 0\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if grid[i - 1][j - 1] == 'X':\n                    prefix_sum[i][j] = prefix_sum[i][j - 1] + 1\n                else:\n                    prefix_sum[i][j] = prefix_sum[i][j - 1]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if grid[i - 1][j - 1] != 'X':\n                    continue\n                x_count, y_count = 0, 0\n                for k in range(i):\n                    x_count += prefix_sum[k + 1][j] - prefix_sum[k + 1][0]\n                    y_count += prefix_sum[k + 1][j + 1] - prefix_sum[k + 1][j]\n                    if x_count == y_count:\n                        count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3482",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, target: str, words: List[str], costs: List[int]) -> int:\n        from collections import defaultdict\n        \n        # Create a dictionary to store the indices of words that contain each prefix\n        prefix_indices = defaultdict(list)\n        for i, word in enumerate(words):\n            for j in range(1, len(word) + 1):\n                prefix_indices[word[:j]].append(i)\n        \n        # Initialize variables\n        current_index = 0\n        total_cost = 0\n        \n        # Iterate through the target string\n        while current_index < len(target):\n            found = False\n            for j in range(current_index + 1, len(target) + 1):\n                prefix = target[current_index:j]\n                if prefix in prefix_indices:\n                    # Find the word with the minimum cost among the candidates\n                    min_cost = float('inf')\n                    best_index = -1\n                    for index in prefix_indices[prefix]:\n                        if words[index] == prefix and costs[index] < min_cost:\n                            min_cost = costs[index]\n                            best_index = index\n                    if best_index != -1:\n                        total_cost += min_cost\n                        current_index = j - 1\n                        found = True\n                        break\n            if not found:\n                return -1\n        \n        return total_cost"
        ]
    },
    {
        "question_id": "3484",
        "code_list": [
            "class Solution:\n    def getSmallestString(self, s: str) -> str:\n        n = len(s)\n        s_list = list(s)\n        \n        for i in range(n):\n            max_j = i\n            for j in range(i + 1, n):\n                if (int(s[i]) % 2 == int(s[j]) % 2) and (s[max_j] > s[j]):\n                    max_j = j\n            if max_j != i:\n                s_list[i], s_list[max_j] = s_list[max_j], s_list[i]\n        \n        return ''.join(s_list)"
        ]
    },
    {
        "question_id": "3494",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumCost(self, m: int, n: int, horizontalCut: List[int], verticalCut: List[int]) -> int:\n        # Add the initial dimensions to the respective cut lists\n        horizontalCut = [0] + sorted(horizontalCut) + [m]\n        verticalCut = [0] + sorted(verticalCut) + [n]\n        \n        # Calculate the maximum difference between consecutive cuts for both directions\n        max_horizontal_cost = max(b - a for a, b in zip(horizontalCut[:-1], horizontalCut[1:]))\n        max_vertical_cost = max(b - a for a, b in zip(verticalCut[:-1], verticalCut[1:]))\n        \n        # The total cost is the sum of the maximum costs in both directions\n        return max_horizontal_cost + max_vertical_cost"
        ]
    },
    {
        "question_id": "3508",
        "code_list": [
            "class Solution:\n    def minChanges(self, n: int, k: int) -> int:\n        # Convert n and k to their binary representations without the '0b' prefix\n        bin_n = bin(n)[2:]\n        bin_k = bin(k)[2:]\n        \n        # Ensure both binary strings have the same length by padding with leading zeros\n        max_len = max(len(bin_n), len(bin_k))\n        bin_n = bin_n.zfill(max_len)\n        bin_k = bin_k.zfill(max_len)\n        \n        # Count the number of positions where the bits differ\n        diff_count = sum(1 for bit_n, bit_k in zip(bin_n, bin_k) if bit_n != bit_k)\n        \n        # If all bits of n are 1 and k has at least one 0, it's impossible to make them equal\n        if all(bit == '1' for bit in bin_n) and '1' in bin_k:\n            return -1\n        \n        return diff_count"
        ]
    },
    {
        "question_id": "3462",
        "code_list": [
            "class Solution:\n    def doesAliceWin(self, s: str) -> bool:\n        # Count the number of vowels in the string\n        vowel_count = sum(1 for char in s if char in 'aeiou')\n        \n        # If the total number of vowels is odd, Alice can always win\n        # because she goes first and can always find a substring with an odd number of vowels\n        return vowel_count % 2 != 0"
        ]
    },
    {
        "question_id": "3493",
        "code_list": [
            "class Solution:\n    def maxOperations(self, s: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s) - 1:\n            if s[i] == '1' and s[i + 1] == '0':\n                count += 1\n                # Find the position to insert '1'\n                j = i + 2\n                while j < len(s) and s[j] == '1':\n                    j += 1\n                # Move '1' to the right until it reaches the end or another '1'\n                s = s[:i] + s[i+1:j] + '1' + s[j:i] + s[j+1:]\n                i = j\n            else:\n                i += 1\n        return count"
        ]
    },
    {
        "question_id": "3454",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumOperations(self, nums: List[int], target: List[int]) -> int:\n        operations = 0\n        for num, tar in zip(nums, target):\n            if num != tar:\n                operations += abs(num - tar)\n                nums[nums.index(num)] = tar  # Directly modify nums to match target at this position\n        return operations"
        ]
    },
    {
        "question_id": "3515",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def canAliceWin(self, nums: List[int]) -> bool:\n        single_digit_sum = sum(num for num in nums if 0 < num < 10)\n        double_digit_sum = sum(num for num in nums if 10 <= num <= 99)\n        \n        return double_digit_sum > single_digit_sum or single_digit_sum > double_digit_sum"
        ]
    },
    {
        "question_id": "3507",
        "code_list": [
            "from math import sqrt\n\nclass Solution:\n    def nonSpecialCount(self, l: int, r: int) -> int:\n        def is_special(n):\n            if n < 2:\n                return False\n            for i in range(2, int(sqrt(n)) + 1):\n                if n % i == 0:\n                    return len([d for d in [i, n // i] if 1 < d < n]) == 2\n            return False\n        \n        count = 0\n        for x in range(l, r + 1):\n            if not is_special(x):\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "3479",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def numberOfSubstrings(self, s: str) -> int:\n        n = len(s)\n        zero_count = s.count('0')\n        one_count = n - zero_count\n        if one_count ** 2 > zero_count:\n            return (n * (n + 1)) // 2\n        else:\n            prefix_zeros = [0] * (n + 1)\n            for i in range(1, n + 1):\n                prefix_zeros[i] = prefix_zeros[i - 1] + (s[i - 1] == '0')\n            \n            result = 0\n            for i in range(n):\n                if s[i] == '1':\n                    left = i + 1\n                    right = n\n                    while left < right:\n                        mid = (left + right) // 2\n                        current_zeros = prefix_zeros[mid] - prefix_zeros[i]\n                        current_ones = mid - i - current_zeros\n                        if current_ones ** 2 >= current_zeros:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    result += left\n            return result"
        ]
    },
    {
        "question_id": "3478",
        "code_list": [
            "from typing import List\nimport math\n\nclass Solution:\n    def canReachCorner(self, xCorner: int, yCorner: int, circles: List[List[int]]) -> bool:\n        # Define a function to check if a point is inside or on the boundary of any circle\n        def isInsideCircle(x, y):\n            for cx, cy, r in circles:\n                if math.sqrt((x - cx) ** 2 + (y - cy) ** 2) <= r:\n                    return True\n            return False\n        \n        # Check if there's a path from (0, 0) to (xCorner, 0) without touching any circle\n        for y in range(1, yCorner):\n            if not isInsideCircle(0, y) and not isInsideCircle(xCorner, y):\n                continue\n            elif isInsideCircle(0, y) and isInsideCircle(xCorner, y):\n                return False\n            else:\n                return True\n        \n        # Check if there's a path from (0, 0) to (0, yCorner) without touching any circle\n        for x in range(1, xCorner):\n            if not isInsideCircle(x, 0) and not isInsideCircle(x, yCorner):\n                continue\n            elif isInsideCircle(x, 0) and isInsideCircle(x, yCorner):\n                return False\n            else:\n                return True\n        \n        # If no obstacles are found, a direct path exists\n        return True"
        ]
    },
    {
        "question_id": "3517",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def shortestDistanceAfterQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        # Initialize the graph with direct connections\n        graph = {i: [i-1, i+1] for i in range(n)}\n        graph[0].remove(-1)\n        graph[n-1].remove(n)\n        \n        # Initialize the answer list\n        answer = []\n        \n        # Function to perform BFS and find the shortest path\n        def bfs(start):\n            visited = set()\n            queue = deque([(start, 0)])\n            while queue:\n                current, dist = queue.popleft()\n                if current == n - 1:\n                    return dist\n                visited.add(current)\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, dist + 1))\n            return float('inf')\n        \n        # Process each query\n        for u, v in queries:\n            graph[u].append(v)\n            graph[v].add(u)\n            \n            # Find the shortest path after adding the new road\n            shortest_path = bfs(0)\n            answer.append(shortest_path)\n        \n        return answer"
        ]
    },
    {
        "question_id": "3527",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfAlternatingGroups(self, colors: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(colors)\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                size = query[1]\n                count = 0\n                i = 0\n                while i < n:\n                    if i + size > n:\n                        break\n                    group = colors[i:i+size]\n                    if len(group) == size and self.isAlternating(group):\n                        count += 1\n                    i += 1\n                result.append(count)\n            elif query[0] == 2:\n                index = query[1]\n                new_color = query[2]\n                colors[index] = new_color\n        return result\n    \n    def isAlternating(self, group: List[int]) -> bool:\n        for i in range(1, len(group)):\n            if group[i] == group[i-1]:\n                return False\n        return True"
        ]
    },
    {
        "question_id": "3533",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def finalPositionOfSnake(self, n: int, commands: List[str]) -> int:\n        # Initialize starting position\n        i, j = 0, 0\n        \n        # Define the direction changes for each command\n        direction_changes = {\n            \"UP\": (-1, 0),\n            \"DOWN\": (1, 0),\n            \"LEFT\": (0, -1),\n            \"RIGHT\": (0, 1)\n        }\n        \n        # Process each command\n        for command in commands:\n            di, dj = direction_changes[command]\n            # Ensure the snake stays within the grid boundaries\n            if 0 <= i + di < n and 0 <= j + dj < n:\n                i, j = i + di, j + dj\n        \n        # Return the final position as a single integer\n        return i * n + j"
        ]
    },
    {
        "question_id": "3535",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countOfPairs(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        def count_non_decreasing(nums):\n            count = 1\n            max_val = nums[0]\n            for i in range(1, len(nums)):\n                if nums[i] >= max_val:\n                    max_val = nums[i]\n                    count += 1\n            return count\n        \n        def count_non_increasing(nums):\n            count = 1\n            min_val = nums[0]\n            for i in range(1, len(nums)):\n                if nums[i] <= min_val:\n                    min_val = nums[i]\n                    count += 1\n            return count\n        \n        total_count = 0\n        for i in range(len(nums)):\n            arr1 = [nums[j] - nums[i] for j in range(len(nums)) if j != i]\n            arr2 = [nums[i] - nums[j] for j in range(len(nums)) if j != i]\n            \n            non_decreasing_count = count_non_decreasing(arr1)\n            non_increasing_count = count_non_increasing(arr2)\n            \n            total_count += non_decreasing_count * non_increasing_count\n        \n        return total_count % MOD"
        ]
    },
    {
        "question_id": "3447",
        "code_list": [
            "class Solution:\n    def clearDigits(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char.isdigit():\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(char)\n        return ''.join(stack)"
        ]
    },
    {
        "question_id": "3413",
        "code_list": [
            "from heapq import heappush, heappop\n\nclass Solution:\n    def findWinningPlayer(self, skills: List[int], k: int) -> int:\n        max_heap = []\n        for i, skill in enumerate(skills):\n            heappush(max_heap, (-skill, i))\n        \n        consecutive_wins = 0\n        current_player = heappop(max_heap)[1]\n        \n        while max_heap:\n            next_player_skill = -heappop(max_heap)[0]\n            if skills[current_player] > next_player_skill:\n                consecutive_wins += 1\n                if consecutive_wins == k:\n                    return current_player\n            else:\n                consecutive_wins = 1\n            # Move the loser to the end of the queue\n            heappush(max_heap, (-next_player_skill, next_player_skill))\n            current_player = -heappop(max_heap)[1]\n        \n        return current_player"
        ]
    },
    {
        "question_id": "3456",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][0] = 1\n            for j in range(i - 1, -1, -1):\n                if nums[j] == nums[i]:\n                    dp[i][0] = max(dp[i][0], dp[j][0] + 1)\n                else:\n                    for m in range(1, k + 1):\n                        dp[i][m] = max(dp[i][m], dp[j][m - 1] + 1)\n        \n        return max(max(row) for row in dp)"
        ]
    },
    {
        "question_id": "3476",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        mod_counts = Counter(num % 3 for num in nums)\n        if mod_counts[0] == len(nums):\n            return 0\n        if mod_counts[1] + mod_counts[2] == len(nums):\n            return min(mod_counts[1], mod_counts[2])\n        if mod_counts[1] > 0 and mod_counts[2] > 0:\n            return len(nums) - mod_counts[0] - min(mod_counts[1], mod_counts[2])\n        if mod_counts[1] > 0:\n            return len(nums) - mod_counts[0] - mod_counts[1]\n        if mod_counts[2] > 0:\n            return len(nums) - mod_counts[0] - mod_counts[2]"
        ]
    },
    {
        "question_id": "3475",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        count_zeros = sum(nums)  # Count initial number of zeros\n        \n        if count_zeros == n or count_zeros == 0:\n            return 0 if count_zeros == n else -1  # All ones or all zeros\n        \n        operations = 0\n        for i in range(n - 2):\n            if nums[i] == 0 and nums[i + 1] == 0 and nums[i + 2] == 0:\n                operations += 1\n                nums[i], nums[i + 1], nums[i + 2] = 1, 1, 1  # Simulate flipping\n        \n        # Check if all elements are now 1s\n        if sum(nums) == n:\n            return operations\n        else:\n            return -1"
        ]
    },
    {
        "question_id": "3460",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfPermutations(self, n: int, requirements: List[List[int]]) -> int:\n        MOD = 10**9 + 7\n        \n        # Initialize DP table\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        \n        # Process each requirement\n        for end, cnt in requirements:\n            new_dp = [[0] * (n + 1) for _ in range(n + 1)]\n            for i in range(end + 1):\n                for j in range(n + 1):\n                    if dp[i][j]:\n                        if j + (n - i - 1) <= cnt:\n                            new_dp[i + 1][j + (n - i - 1)] += dp[i][j]\n                            new_dp[i + 1][j + (n - i - 1)] %= MOD\n                        if j <= cnt:\n                            new_dp[i][j] += dp[i][j]\n                            new_dp[i][j] %= MOD\n            dp = new_dp\n        \n        # Sum up the valid permutations\n        result = 0\n        for i in range(n + 1):\n            result += dp[n][i]\n            result %= MOD\n        \n        return result"
        ]
    },
    {
        "question_id": "3463",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def numberOfAlternatingGroups(self, colors: List[int]) -> int:\n        n = len(colors)\n        count = 0\n        i = 0\n        \n        while i < n:\n            # Check if the current group of 3 tiles is alternating\n            if (i + 2 < n and colors[i] != colors[i + 1] and colors[i + 1] != colors[(i + 2) % n] and colors[i] != colors[(i + 2) % n]):\n                count += 1\n                i += 3  # Skip the next 2 tiles as they are part of the same alternating group\n            else:\n                i += 1  # Move to the next tile\n        \n        return count"
        ]
    },
    {
        "question_id": "3264",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumPoints(self, enemyEnergies: List[int], currentEnergy: int) -> int:\n        enemyEnergies.sort()\n        n = len(enemyEnergies)\n        dp = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            take = 0\n            if currentEnergy >= enemyEnergies[i]:\n                take = 1 + dp[i + 1]\n            skip = dp[i + 1]\n            for j in range(i + 1, n):\n                if enemyEnergies[j] <= currentEnergy:\n                    currentEnergy += enemyEnergies[j]\n                else:\n                    break\n            skip += currentEnergy\n            dp[i] = max(take, skip)\n        return dp[0]"
        ]
    },
    {
        "question_id": "3466",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        prefix_and = 0\n        freq = {0: 1}\n        \n        for num in nums:\n            prefix_and &= num\n            prefix_and &= k\n            if prefix_and < k:\n                prefix_and = 0\n            count += freq.get(prefix_and, 0)\n            freq[prefix_and] = freq.get(prefix_and, 0) + 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3511",
        "code_list": [
            "class Solution:\n    def losingPlayer(self, x: int, y: int) -> str:\n        # Calculate the total number of 10-value coins needed to make up 115\n        needed_y = (115 - 75) // 10\n        # If Alice can pick a combination that leaves Bob with no valid move, she wins\n        if x >= 1 and y >= needed_y:\n            return \"Alice\"\n        else:\n            return \"Bob\""
        ]
    },
    {
        "question_id": "3455",
        "code_list": [
            "class Solution:\n    def minimumLength(self, s: str) -> int:\n        stack = []\n        for char in s:\n            if stack and stack[-1] == char:\n                stack.pop()\n            else:\n                stack.append(char)\n        return len(stack)"
        ]
    },
    {
        "question_id": "3498",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\nimport heapq\n\nclass Solution:\n    def minChanges(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        half_n = n // 2\n        dp = [float('inf')] * half_n\n        dp[-1] = 0\n        \n        # Group indices by their position relative to the center\n        groups = [defaultdict(int) for _ in range(k)]\n        for i in range(half_n):\n            groups[i % k][nums[i]] += 1\n            groups[i % k][nums[n - i - 1]] -= 1\n        \n        # Calculate the cost to make pairs equal\n        for i in range(1, half_n):\n            for j in range(k):\n                groups[j][nums[i]] += 1\n                groups[j][nums[n - i - 1]] -= 1\n                dp[i] = min(dp[i], dp[i - 1] + sum(abs(v) for v in groups[j].values()))\n        \n        return dp[half_n - 1]"
        ]
    },
    {
        "question_id": "3519",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def winningPlayerCount(self, n: int, pick: List[List[int]]) -> int:\n        color_count = defaultdict(int)\n        winning_players = 0\n        \n        for player, color in pick:\n            color_count[color] += 1\n            if color_count[color] > player:\n                winning_players += 1\n        \n        return winning_players"
        ]
    },
    {
        "question_id": "3526",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minFlips(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        all_ones = (1 << n) - 1\n        \n        # Helper function to check if a row is palindromic\n        def is_palindromic(row):\n            return row == row[::-1]\n        \n        # Helper function to count flips to make a row palindromic\n        def count_flips_to_palindromic(row):\n            original = row[:]\n            for i in range(n // 2):\n                if row[i] != row[n - 1 - i]:\n                    if row[i] == 1:\n                        row[i] = 0\n                        row[n - 1 - i] = 1\n                    else:\n                        row[i] = 1\n                        row[n - 1 - i] = 0\n            return sum(original[i] != row[i] for i in range(n))\n        \n        # Convert each row to its binary representation\n        rows = [sum([grid[i][j] << j for j in range(n)]) for i in range(m)]\n        \n        # Calculate the minimum flips needed to make all rows palindromic\n        min_flips_rows = min(sum(rows[i] != (rows[i] ^ all_ones) for i in range(m)), \n                             sum(rows[i] != (rows[i] ^ (all_ones >> 1)) for i in range(m)))\n        \n        # Transpose the grid to work with columns\n        transposed_grid = list(zip(*grid))\n        \n        # Convert each column to its binary representation\n        cols = [sum([transposed_grid[j][i] << j for j in range(m)]) for i in range(n)]\n        \n        # Calculate the minimum flips needed to make all columns palindromic\n        min_flips_cols = min(sum(cols[i] != (cols[i] ^ all_ones) for i in range(n)), \n                             sum(cols[i] != (cols[i] ^ (all_ones >> 1)) for i in range(n)))\n        \n        return min(min_flips_rows, min_flips_cols)"
        ]
    },
    {
        "question_id": "3532",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def timeTaken(self, edges: List[List[int]]) -> List[int]:\n        # Build the graph\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        # Function to perform DFS and calculate the time taken\n        def dfs(node, parent, time):\n            max_time_odd = 0\n            max_time_even = 0\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    odd_time, even_time = dfs(neighbor, node, time + 1)\n                    if odd_time > max_time_odd:\n                        max_time_even, max_time_odd = max_time_odd, odd_time\n                    else:\n                        max_time_even = max(max_time_even, odd_time)\n            return max_time_odd + (1 if node % 2 == 0 else 0), max_time_even + (1 if node % 2 == 1 else 0)\n        \n        # Calculate the maximum time for each node\n        result = []\n        for i in range(len(edges) + 1):\n            _, max_time = dfs(i, -1, 0)\n            result.append(max_time)\n        \n        return result"
        ]
    },
    {
        "question_id": "abc366_f",
        "code_list": [
            "def max_function_value(N, K, functions):\n    def apply_function(x, index):\n        return functions[index][0] * x + functions[index][1]\n    \n    def dfs(index, current_value, path):\n        nonlocal max_value\n        if len(path) == K:\n            max_value = max(max_value, current_value)\n            return\n        for i in range(N):\n            if i not in path:\n                next_value = apply_function(current_value, i)\n                dfs(i, next_value, path | {i})\n    \n    max_value = float('-inf')\n    dfs(-1, 1, set())\n    return max_value\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    functions = [tuple(map(int, input().split())) for _ in range(N)]\n    print(max_function_value(N, K, functions))"
        ]
    },
    {
        "question_id": "abc366_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def transpose_strings(strings):\n        max_length = max(len(s) for s in strings)\n        transposed = ['' for _ in range(max_length)]\n        \n        for i, s in enumerate(strings):\n            for j in range(len(s)):\n                transposed[j] += s[-(j + 1)]\n            transposed[j] += '*' * (max_length - len(s))\n        \n        # Remove trailing '*' from each string\n        transposed = [s.rstrip('*') for s in transposed]\n        \n        return transposed\n    \n    N = int(input())\n    strings = [input().strip() for _ in range(N)]\n    \n    result = transpose_strings(strings)\n    \n    for line in result:\n        print(line)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_e",
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    d = int(data[1])\n    points = []\n    for i in range(2, len(data), 2):\n        points.append((int(data[i]), int(data[i+1])))\n    \n    # Calculate median of x and y coordinates\n    xs = sorted([p[0] for p in points])\n    ys = sorted([p[1] for p in points])\n    median_x = xs[n // 2]\n    median_y = ys[n // 2]\n    \n    # Count points on each side of the median\n    count_x_left = sum(1 for x, _ in points if x < median_x)\n    count_x_right = sum(1 for x, _ in points if x > median_x)\n    count_y_left = sum(1 for _, y in points if y < median_y)\n    count_y_right = sum(1 for _, y in points if y > median_y)\n    \n    # Initialize result\n    result = 0\n    \n    # Iterate over all possible (x, y) pairs\n    for x in range(median_x - d, median_x + d + 1):\n        for y in range(median_y - d, median_y + d + 1):\n            cost = 0\n            for px, py in points:\n                cost += abs(px - x) + abs(py - y)\n            if cost <= d:\n                result += 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_d",
        "code_list": [
            "def main():\n    import numpy as np\n    \n    # Read input\n    N = int(input())\n    A = []\n    for _ in range(N * N):\n        row = list(map(int, input().split()))\n        A.extend(row)\n    Q = int(input())\n    \n    # Reshape A into 3D array\n    A = np.array(A).reshape(N, N, N)\n    \n    # Precompute prefix sums along each dimension\n    prefix_sum_x = np.zeros((N+1, N+1, N+1), dtype=int)\n    prefix_sum_y = np.zeros((N+1, N+1, N+1), dtype=int)\n    prefix_sum_z = np.zeros((N+1, N+1, N+1), dtype=int)\n    \n    for x in range(1, N+1):\n        for y in range(1, N+1):\n            for z in range(1, N+1):\n                prefix_sum_x[x][y][z] = prefix_sum_x[x-1][y][z] + A[x-1][y-1][z-1]\n                prefix_sum_y[x][y][z] = prefix_sum_y[x][y-1][z] + A[x-1][y-1][z-1]\n                prefix_sum_z[x][y][z] = prefix_sum_z[x][y][z-1] + A[x-1][y-1][z-1]\n    \n    # Process queries\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, input().split())\n        result = 0\n        \n        for x in range(Lx, Rx+1):\n            for y in range(Ly, Ry+1):\n                for z in range(Lz, Rz+1):\n                    result += A[x-1][y-1][z-1]\n        \n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_a",
        "code_list": [
            "def main():\n    N, T, A = map(int, input().split())\n    remaining_votes = N - (T + A)\n    if T > A + remaining_votes:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc366_c",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    Q = int(input())\n    bag = Counter()\n    \n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            bag[query[1]] += 1\n        elif query[0] == 2:\n            bag[query[1]] -= 1\n            if bag[query[1]] == 0:\n                del bag[query[1]]\n        else:\n            print(len(bag))"
        ]
    },
    {
        "question_id": "abc366_g",
        "code_list": [
            "from collections import defaultdict\n\ndef solve(N, M, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check if the graph is bipartite\n    def is_bipartite(graph, start):\n        color = [-1] * (N + 1)\n        queue = [start]\n        color[start] = 0\n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[node]\n                    queue.append(neighbor)\n                elif color[neighbor] == color[node]:\n                    return False\n        return True\n\n    if not is_bipartite(graph, 1):\n        return \"No\"\n\n    # Assign values based on the bipartition\n    values = [0] * (N + 1)\n    for node in range(1, N + 1):\n        if color[node] == 0:\n            values[node] = 1\n        else:\n            values[node] = 0\n\n    # Verify the solution\n    for node in range(1, N + 1):\n        xor_sum = 0\n        for neighbor in graph[node]:\n            xor_sum ^= values[neighbor]\n        if xor_sum != 0:\n            return \"No\"\n\n    return \"Yes\\n\" + \" \".join(str(val) for val in values[1:])\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    print(solve(N, M, edges))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_e",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    X = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    # Find the cycle or fixed points in the permutation\n    cycle_length = [0] * N\n    for i in range(N):\n        if cycle_length[i] == 0:\n            j = i\n            while cycle_length[j] == 0:\n                cycle_length[j] = len(cycle_length) + 1\n                j = X[j] - 1\n            cycle_length[i] = cycle_length[j]\n\n    # Determine the effective number of operations based on cycle length\n    effective_operations = K % sum(cycle_length)\n\n    # Perform the operations up to the effective number\n    for _ in range(effective_operations):\n        new_A = [0] * N\n        for i in range(N):\n            new_A[i] = A[X[i] - 1]\n        A = new_A\n\n    # Output the final sequence\n    print(*A)"
        ]
    },
    {
        "question_id": "abc367_f",
        "code_list": [
            "from collections import Counter\n\ndef can_rearrange_subsequence(N, Q, A, B, queries):\n    def check_subsequence(A_sub, B_sub):\n        return Counter(A_sub) == Counter(B_sub)\n    \n    for l, r, L, R in queries:\n        A_sub = A[l-1:r]\n        B_sub = B[L-1:R]\n        if check_subsequence(A_sub, B_sub):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    can_rearrange_subsequence(N, Q, A, B, queries)"
        ]
    },
    {
        "question_id": "abc367_a",
        "code_list": [
            "def main():\n    A, B, C = map(int, input().split())\n    # Check if A falls within the awake period [B, C) or crosses midnight\n    if B <= A < C or (A >= C and A < 24 and B <= 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_g",
        "code_list": [
            "from collections import defaultdict\nfrom math import comb\n\ndef main():\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    # Precompute powers of 2 up to 2^20\n    pow2 = [1] * 21\n    for i in range(1, 21):\n        pow2[i] = pow2[i-1] * 2 % 998244353\n\n    # Precompute K-th power of 2 up to 2^20\n    pow2K = [1] * 21\n    for i in range(1, 21):\n        pow2K[i] = pow2K[i-1] * pow2[K] % 998244353\n\n    # Count the frequency of each prefix XOR value\n    prefix_xor_count = defaultdict(int)\n    prefix_xor_count[0] = 1\n    prefix_xor = 0\n    for a in A:\n        prefix_xor ^= a\n        prefix_xor_count[prefix_xor] += 1\n\n    # Calculate the contribution of each prefix XOR value\n    contributions = defaultdict(int)\n    for xor_val, count in prefix_xor_count.items():\n        for i in range(M):\n            if (i + 1) % M == 0:\n                contributions[xor_val] += pow2[count] * pow2K[M] % 998244353\n            else:\n                contributions[xor_val] -= pow2[count] * pow2K[(M - (i + 1)) % M] % 998244353\n\n    # Sum up the contributions and take modulo 998244353\n    result = 0\n    for val, contrib in contributions.items():\n        result += contrib\n        result %= 998244353\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_b",
        "code_list": [
            "def main():\n    X = float(input())\n    X_str = f\"{X:.3f}\"\n    integer_part, decimal_part = X_str.split('.')\n    \n    if decimal_part.rstrip('0') == '0':\n        print(integer_part)\n    else:\n        print(X_str)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_d",
        "code_list": [
            "from math import gcd\nfrom itertools import accumulate\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Calculate prefix sums\n    prefix_sum = list(accumulate(A))\n    \n    # Adjust prefix sums for circular nature\n    prefix_sum = [x % M for x in prefix_sum]\n    prefix_sum.append(prefix_sum[0])\n    \n    # Count occurrences of each remainder\n    count = [0] * M\n    for val in prefix_sum:\n        count[val] += 1\n    \n    # Calculate the number of valid (s, t) pairs\n    ans = 0\n    for i in range(M):\n        if count[i] > 0:\n            # Number of ways to choose 2 different indices with the same remainder\n            ans += count[i] * (count[i] - 1)\n            # Add the number of self-pairs if the remainder is 0\n            if i == 0:\n                ans += count[i]\n    \n    print(ans // 2)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc367_c",
        "code_list": [
            "from itertools import product\n\ndef find_sequences(N, K, R):\n    # Generate all possible sequences\n    all_sequences = list(product(*[range(1, R_i + 1) for R_i in R]))\n    \n    # Filter sequences based on the condition that their sum is a multiple of K\n    valid_sequences = [seq for seq in all_sequences if sum(seq) % K == 0]\n    \n    # Sort the valid sequences in lexicographical order\n    valid_sequences.sort()\n    \n    return valid_sequences\n\ndef main():\n    N, K = map(int, input().split())\n    R = tuple(map(int, input().split()))\n    \n    sequences = find_sequences(N, K, R)\n    \n    # Print the result\n    print(len(sequences))\n    for seq in sequences:\n        print(' '.join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_g",
        "code_list": [
            "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    queries = [(data[2*N+2+i*4], int(data[2*N+3+i*4]), int(data[2*N+4+i*4]), int(data[2*N+5+i*4])) for i in range(Q)]\n    \n    def process_queries(A, B, queries):\n        for query_type, i, x, _ in queries:\n            if query_type == '1':\n                A[i-1] = x\n            elif query_type == '2':\n                B[i-1] = x\n    \n    def solve_query(l, r, A, B):\n        max_v = 0\n        current_value = 0\n        for i in range(l-1, r):\n            add = A[i]\n            multiply = B[i]\n            if current_value * multiply > current_value + add:\n                current_value *= multiply\n            else:\n                current_value += add\n            max_v = max(max_v, current_value)\n        return max_v\n    \n    process_queries(A, B, queries[:Q])\n    \n    for query_type, _, l, r in queries[Q:]:\n        if query_type == '3':\n            print(solve_query(l, r+1, A, B))"
        ]
    },
    {
        "question_id": "abc368_a",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    cards = list(map(int, input().split()))\n    \n    # Take K cards from the bottom and move them to the top\n    moved_cards = cards[-K:]\n    remaining_cards = cards[:-K]\n    new_stack = moved_cards + remaining_cards\n    \n    # Print the result\n    print(\" \".join(map(str, new_stack)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    operations = 0\n    \n    while len([x for x in A if x > 0]) > 1:\n        A.sort(reverse=True)\n        A[0] -= 1\n        A[1] -= 1\n        operations += 1\n    \n    print(operations)"
        ]
    },
    {
        "question_id": "abc368_f",
        "code_list": [
            "def main():\n    import math\n    \n    def count_divisors(n):\n        count = 0\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                if i * i == n:\n                    count += 1\n                else:\n                    count += 2\n        return count\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    xor_result = 0\n    for num in A:\n        xor_result ^= count_divisors(num)\n    \n    if xor_result != 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc368_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def calculate_attacks(healths):\n        total_attacks = 0\n        for health in healths:\n            if health % 3 == 0:\n                total_attacks += health // 3\n            else:\n                total_attacks += (health // 3) + 1\n        return total_attacks\n    \n    N = int(input())\n    healths = list(map(int, input().split()))\n    \n    result = calculate_attacks(healths)\n    print(result)"
        ]
    },
    {
        "question_id": "abc368_d",
        "code_list": [
            "from collections import defaultdict\n\ndef find_root(node, parent, graph):\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            return find_root(neighbor, node, graph)\n    return node\n\ndef dfs(node, parent, target_nodes, graph, depth):\n    if node in target_nodes:\n        target_nodes.remove(node)\n        return 1, depth\n    max_depth = 0\n    min_nodes = float('inf')\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            nodes, depth = dfs(neighbor, node, target_nodes, graph, depth + 1)\n            if nodes > 0:\n                max_depth = max(max_depth, depth - nodes + 1)\n                min_nodes = min(min_nodes, nodes)\n    if node in target_nodes:\n        return min_nodes, max_depth\n    return 0, max_depth\n\ndef min_vertices_in_tree(N, K, edges, target_nodes):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    root = find_root(1, -1, graph)\n    target_nodes = set(target_nodes)\n    \n    _, min_nodes = dfs(root, -1, target_nodes, graph, 0)\n    return min_nodes\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    target_nodes = list(map(int, input().split()))\n    print(min_vertices_in_tree(N, K, edges, target_nodes))"
        ]
    },
    {
        "question_id": "abc368_e",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef solve(N, M, X1, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for i, (A, B, S, T) in enumerate(edges):\n        graph[A-1].append((B-1, T-S))\n    \n    # Run Dijkstra's algorithm to get the minimum delays\n    min_delays = dijkstra(N, graph, 0)\n    \n    # Calculate the final delays\n    result = []\n    for _, (A, B, S, T) in enumerate(edges):\n        result.append(max(0, min_delays[B-1] - X1 + T - S))\n    \n    return result\n\nif __name__ == \"__main__\":\n    N, M, X1 = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    print(*solve(N, M, X1, edges))"
        ]
    },
    {
        "question_id": "abc369_d",
        "code_list": [
            "def max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    strengths = list(map(int, data[1:n+1]))\n    even_sum = sum(strengths[i] for i in range(0, n, 2))\n    odd_sum = sum(strengths[i] for i in range(1, n, 2))\n    \n    dp = [0] * (n + 1)\n    dp[1] = strengths[0]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            dp[i] = max(dp[i-1], dp[i-2] + strengths[i-1] + strengths[i-1])\n        else:\n            dp[i] = max(dp[i-1], dp[i-2] + strengths[i-1])\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    print(max_experience_points())"
        ]
    },
    {
        "question_id": "abc369_g",
        "code_list": [
            "import sys\nfrom typing import List\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    for i in range(1, n):\n        u = int(data[i*3]) - 1\n        v = int(data[i*3 + 1]) - 1\n        l = int(data[i*3 + 2])\n        edges.append((u, v, l))\n    \n    # Calculate the diameter and the longest path from each node to the farthest node\n    def dfs(node: int, parent: int, dist: List[int], diam: List[int]) -> None:\n        for neighbor, _, weight in edges:\n            if neighbor != parent:\n                dfs(neighbor, node, dist, diam)\n                dist[node] += max(dist[neighbor], 0)\n                diam[node] = max(diam[node], dist[neighbor] + weight)\n    \n    dist = [0] * n\n    diam = [0] * n\n    dfs(0, -1, dist, diam)\n    \n    # Calculate the second longest path from each node to the farthest node\n    dist2 = [0] * n\n    dfs(0, -1, dist2, diam)\n    \n    # Calculate the answer for each K\n    ans = [0] * n\n    for i in range(n):\n        ans[i] = diam[0] + max(diam[j] - dist[j] - dist2[j] for j in range(n))\n    \n    for k in range(1, n + 1):\n        print(ans[k - 1])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc369_c",
        "code_list": [
            "def count_arithmetic_progressions(N, A):\n    def count_from_start(i):\n        d = None\n        count = 1\n        for j in range(i + 1, N):\n            if d is None:\n                d = A[j] - A[i]\n            elif A[j] - A[j - 1] == d:\n                count += 1\n            else:\n                break\n        return count\n    \n    total_count = 0\n    for i in range(N):\n        total_count += count_from_start(i)\n    \n    return total_count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(count_arithmetic_progressions(N, A))"
        ]
    },
    {
        "question_id": "abc369_a",
        "code_list": [
            "def main():\n    A, B = map(int, input().split())\n    count = 0\n    \n    # Calculate the possible values of x\n    if A != B:\n        # If A and B are different, there are three possible values for x\n        count = 3\n    else:\n        # If A and B are the same, there is only one possible value for x (which is A or B)\n        count = 1\n    \n    print(count)"
        ]
    },
    {
        "question_id": "abc369_b",
        "code_list": [
            "def min_fatigue_level():\n    N = int(input())\n    actions = [list(map(str.strip, input().split())) for _ in range(N)]\n    \n    left_hand_pos = 0\n    right_hand_pos = 0\n    fatigue = 0\n    \n    for key, hand in actions:\n        key = int(key)\n        if hand == 'L':\n            # Move left hand to key\n            fatigue += abs(key - left_hand_pos)\n            left_hand_pos = key\n        else:\n            # Move right hand to key\n            fatigue += abs(key - right_hand_pos)\n            right_hand_pos = key\n    \n    print(fatigue)\n\nif __name__ == \"__main__\":\n    min_fatigue_level()"
        ]
    },
    {
        "question_id": "abc369_e",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(n, graph, start, end):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if u == end:\n            return d\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return float('inf')\n\ndef solve(N, M, edges, Q, queries):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, t in edges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n    \n    def min_time_for_query(query_edges):\n        # Create a subgraph with only the edges in the query\n        subgraph = defaultdict(list)\n        for u, v, t in edges:\n            if (u, v) in query_edges or (v, u) in query_edges:\n                subgraph[u].append((v, t))\n                subgraph[v].append((u, t))\n        \n        # Run Dijkstra's algorithm on the subgraph\n        return dijkstra(N, subgraph, 1, N)\n    \n    results = []\n    for K, query_edges in queries:\n        results.append(min_time_for_query(query_edges))\n    \n    return results\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        U, V, T = map(int, input().split())\n        edges.append((U, V, T))\n    \n    Q = int(input())\n    queries = []\n    for _ in range(Q):\n        K = int(input())\n        query_edges = set()\n        for _ in range(K):\n            B = int(input())\n            query_edges.add(B)\n        queries.append((K, query_edges))\n    \n    results = solve(N, M, edges, Q, queries)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc370_a",
        "code_list": [
            "def main():\n    L, R = map(int, input().split())\n    if (L + R) == 1:\n        print(\"Yes\")\n    elif (L + R) == 2:\n        print(\"Invalid\")\n    else:\n        print(\"Invalid\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_g",
        "code_list": [
            "from math import sqrt\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef is_good(n):\n    div_sum = 1  # Start with 1 because it's a divisor of every number\n    for i in range(2, int(sqrt(n)) + 1):\n        count = 0\n        while n % i == 0:\n            n //= i\n            count += 1\n        if count > 0:\n            div_sum *= (i**(count+1) - 1) // (i - 1)\n        if n == 1:\n            break\n    if n > 1:  # If n is a prime greater than 1\n        div_sum *= (n + 1)\n    return div_sum % 3 == 0\n\n@lru_cache(None)\ndef count_good_numbers(max_val):\n    count = 0\n    for i in range(1, max_val + 1):\n        if is_good(i):\n            count += 1\n    return count\n\ndef main():\n    N, M = map(int, input().split())\n    max_val = int(N ** (1/M))\n    good_count = count_good_numbers(max_val)\n    \n    dp = [0] * (M + 1)\n    dp[0] = 1\n    for _ in range(M):\n        new_dp = [0] * (M + 1)\n        for j in range(M + 1):\n            if dp[j] > 0:\n                for k in range(good_count + 1):\n                    new_dp[j + k] = (new_dp[j + k] + dp[j]) % MOD\n        dp = new_dp\n    \n    print(dp[M])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_c",
        "code_list": [
            "def min_transformations(S, T):\n    X = []\n    i = 0\n    while S != T:\n        # Find the first differing character\n        while i < len(S) and S[i] == T[i]:\n            i += 1\n        # Change the differing character to match T\n        S = S[:i] + T[i] + S[i+1:]\n        X.append(S)\n    return X\n\ndef main():\n    S = input().strip()\n    T = input().strip()\n    X = min_transformations(S, T)\n    print(len(X))\n    for s in X:\n        print(s)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_d",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    H, W, Q = map(int, input().split())\n    wall_destroyed = defaultdict(list)\n    \n    for _ in range(Q):\n        R, C = map(int, input().split())\n        R -= 1\n        C -= 1\n        \n        # Check if there's already a wall destroyed at this position\n        if (R, C) not in wall_destroyed:\n            # Destroy walls in all four directions\n            for r, c in [(R-1, C), (R+1, C), (R, C-1), (R, C+1)]:\n                if 0 <= r < H and 0 <= c < W:\n                    wall_destroyed[(r, c)].append((R, C))\n        \n        # Remove the wall at (R, C)\n        wall_destroyed[(R, C)].clear()\n    \n    # Calculate the number of remaining walls\n    remaining_walls = H * W - sum(len(v) for v in wall_destroyed.values())\n    print(remaining_walls)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc370_e",
        "code_list": [
            "from itertools import accumulate\nfrom collections import defaultdict\n\ndef count_divisions(N, K, A):\n    MOD = 998244353\n    \n    # Calculate prefix sums\n    prefix_sums = [0] + list(accumulate(A))\n    \n    # Dictionary to store the first occurrence of each prefix sum\n    prefix_sum_indices = defaultdict(lambda: -1)\n    for i, ps in enumerate(prefix_sums):\n        prefix_sum_indices[ps] = i\n    \n    # Initialize DP table\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    # Iterate over all possible prefix sums\n    for i in range(1, N + 1):\n        if prefix_sums[i] == K:\n            dp[i] = 0\n        else:\n            dp[i] = dp[i - 1]\n        \n        # Check if there's a subsequence ending at i with sum K\n        if prefix_sum_indices[prefix_sums[i] - K] != -1:\n            dp[i] -= dp[prefix_sum_indices[prefix_sums[i] - K]]\n        \n        # Ensure non-negative result\n        dp[i] = (dp[i] + MOD) % MOD\n    \n    # Total number of valid divisions\n    total_valid_divisions = dp[N]\n    \n    # Subtract the cases where at least one subsequence has sum K\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            if prefix_sums[j] - prefix_sums[i] == K:\n                total_valid_divisions -= dp[i - 1] * dp[j - i] % MOD\n                total_valid_divisions %= MOD\n    \n    return total_valid_divisions\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(count_divisions(N, K, A))"
        ]
    },
    {
        "question_id": "abc370_b",
        "code_list": [
            "def main():\n    import sys\n    \n    def parse_input():\n        return [line.strip() for line in sys.stdin.readlines()]\n    \n    def combine_elements(element, new_element):\n        return min(element, new_element)\n    \n    N = int(parse_input()[0])\n    A = []\n    for i in range(1, N + 1):\n        row = list(map(int, parse_input()[i].split()))\n        A.append(row)\n    \n    current_element = 1\n    for i in range(N):\n        current_element = combine_elements(current_element, A[i][i] if i >= 1 else A[i][0])\n    \n    print(current_element)"
        ]
    },
    {
        "question_id": "abc370_f",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n, k = data[0], data[1]\n    a = data[2:n+2]\n    \n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    \n    min_weight = (prefix_sum[-1] + k - 1) // k\n    start = 0\n    end = n + 1\n    \n    while end - start > 1:\n        mid = (start + end) // 2\n        if check(a, prefix_sum, mid, k):\n            start = mid\n        else:\n            end = mid\n    \n    min_weight = start\n    \n    # Count the number of cut lines that are never cut\n    cuts = [False] * n\n    for i in range(n):\n        if a[i] >= min_weight and a[n-1] - a[i] >= min_weight:\n            cuts[i] = True\n    \n    count_never_cut = 0\n    for i in range(n):\n        if not cuts[i] and not cuts[(i + 1) % n]:\n            count_never_cut += 1\n    \n    print(min_weight, count_never_cut)\n\ndef check(a, prefix_sum, target, k):\n    count = 0\n    current_sum = 0\n    for i in range(len(a)):\n        current_sum += a[i]\n        if current_sum >= target:\n            count += 1\n            current_sum = 0\n            if count == k:\n                return True\n    return False\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_b",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    family_boys = [False] * N\n    result = []\n\n    for _ in range(M):\n        A, B = map(str, input().split())\n        A = int(A) - 1\n        if B == 'M':\n            if not family_boys[A]:\n                family_boys[A] = True\n                result.append('Yes')\n            else:\n                result.append('No')\n        else:\n            result.append('No')\n\n    for r in result:\n        print(r)"
        ]
    },
    {
        "question_id": "abc371_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    X = list(map(int, data[1:N+1]))\n    P = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    queries = list(zip(map(int, data[2*N+2:2*N+2+Q*2:2]), map(int, data[2*N+2+Q*2::2])))\n\n    # Create a prefix sum array for the number of villagers\n    prefix_sum = [0]\n    for p in P:\n        prefix_sum.append(prefix_sum[-1] + p)\n\n    # Process each query\n    for L, R in queries:\n        left_index = bisect_left(X, L)\n        right_index = bisect_right(X, R)\n        result = prefix_sum[right_index] - prefix_sum[left_index]\n        print(result)\n\nimport bisect"
        ]
    },
    {
        "question_id": "abc371_g",
        "code_list": [
            "def main():\n    import sys\n    \n    def find_cycle(start, permutation):\n        cycle = []\n        current = start\n        while True:\n            cycle.append(current)\n            next_pos = permutation[current - 1]\n            if next_pos == start:\n                break\n            current = next_pos\n        return cycle\n    \n    def apply_permutation(arr, permutation):\n        return [arr[permutation[i] - 1] for i in range(len(arr))]\n    \n    n = int(input())\n    permutation = list(map(int, input().split()))\n    arr = list(map(int, input().split()))\n    \n    # Find cycles in the permutation\n    cycles = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            cycle = find_cycle(i, permutation)\n            cycles.append(cycle)\n            for node in cycle:\n                visited[node] = True\n    \n    # Sort elements within each cycle\n    for cycle in cycles:\n        indices = sorted(range(len(cycle)), key=lambda x: arr[cycle[x] - 1])\n        for i, index in enumerate(indices):\n            arr[cycle[index] - 1] = i + 1\n    \n    # Print the result\n    print(*arr)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc371_f",
        "code_list": [
            "import sys\nfrom typing import List\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    X = list(map(int, data[1:N+1]))\n    Q = int(data[N+1])\n    tasks = [(int(data[i*2+N+2]), int(data[i*2+N+3])) for i in range(Q)]\n    \n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + abs(X[i] - X[-1])\n    \n    result = 0\n    for t, g in tasks:\n        index = bisect_left(X, g)\n        if index == 0:\n            result += g * t - prefix_sum[index]\n        elif index == N:\n            result += prefix_sum[index] - g * t\n        else:\n            result += min(g * t - prefix_sum[index] + X[index] * (index + 1 - t),\n                          prefix_sum[index] - g * t + X[index - 1] * (t - index))\n    \n    print(result)"
        ]
    },
    {
        "question_id": "abc371_c",
        "code_list": [
            "import itertools\nfrom collections import defaultdict\n\ndef min_cost_to_isomorphism(n, mg, edges_g, mh, edges_h, costs):\n    # Create adjacency lists for both graphs\n    adj_g = defaultdict(set)\n    adj_h = defaultdict(set)\n    \n    for u, v in edges_g:\n        adj_g[u].add(v)\n        adj_g[v].add(u)\n    \n    for a, b in edges_h:\n        adj_h[a].add(b)\n        adj_h[b].add(a)\n    \n    def count_edges(adj_list):\n        return sum(1 for neighbors in adj_list.values() for neighbor in neighbors)\n    \n    def isomorphic(adj_g, adj_h):\n        return count_edges(adj_g) == count_edges(adj_h)\n    \n    def cost_to_make_isomorphic():\n        min_cost = float('inf')\n        \n        for perm in itertools.permutations(range(1, n+1)):\n            temp_adj_h = defaultdict(set)\n            for i in range(n):\n                temp_adj_h[perm[i]] = set(adj_h[perm[i]])\n            \n            if isomorphic(adj_g, temp_adj_h):\n                current_cost = 0\n                for i in range(1, n):\n                    for j in range(i+1, n+1):\n                        if (i, j) in costs and ((i in adj_g[j] and j not in temp_adj_h[i]) or (j in adj_g[i] and i not in temp_adj_h[j])):\n                            current_cost += costs[i, j]\n                        elif (j, i) in costs and ((j in adj_g[i] and i not in temp_adj_h[j]) or (i in adj_g[j] and j not in temp_adj_h[i])):\n                            current_cost += costs[j, i]\n            min_cost = min(min_cost, current_cost)\n        \n        return min_cost\n    \n    return cost_to_make_isomorphic()\n\nif __name__ == \"__main__\":\n    n = int(input())\n    mg = int(input())\n    edges_g = [tuple(map(int, input().split())) for _ in range(mg)]\n    mh = int(input())\n    edges_h = [tuple(map(int, input().split())) for _ in range(mh)]\n    costs = defaultdict(int)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            costs[(i, j)] = int(input())\n    \n    print(min_cost_to_isomorphism(n, mg, edges_g, mh, edges_h, costs))"
        ]
    },
    {
        "question_id": "abc371_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Initialize the result\n    result = 0\n    \n    # Iterate over all possible subarrays\n    for i in range(N):\n        seen = set()\n        for j in range(i, N):\n            seen.add(A[j])\n            result += len(seen)\n    \n    print(result)"
        ]
    },
    {
        "question_id": "abc371_a",
        "code_list": [
            "def main():\n    S_AB, S_AC, S_BC = input().split()\n    \n    if S_AB == '<' and S_AC == '<':\n        if S_BC == '<':\n            print('C')\n        else:\n            print('B')\n    elif S_AB == '<' and S_AC == '>':\n        print('B')\n    elif S_AB == '>' and S_AC == '<':\n        print('A')\n    else:\n        if S_BC == '<':\n            print('A')\n        else:\n            print('C')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, Q = map(int, input().split())\n    graph = defaultdict(set)\n    queries = []\n    \n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        queries.append(query)\n    \n    def add_edge(u, v):\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    def get_kth_largest(v, k):\n        connected_vertices = list(graph[v])\n        if len(connected_vertices) < k:\n            return -1\n        connected_vertices.sort()\n        return connected_vertices[-k]\n    \n    for query in queries:\n        if query[0] == 1:\n            u, v = query[1], query[2]\n            add_edge(u, v)\n        elif query[0] == 2:\n            v, k = query[1], query[2]\n            print(get_kth_largest(v, k))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_c",
        "code_list": [
            "def count_substring_occurrences(s, target):\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i:i+3] == target:\n            count += 1\n    return count\n\ndef main():\n    n, q = map(int, input().split())\n    s = input().strip()\n    for _ in range(q):\n        xi, ci = input().split()\n        xi = int(xi)\n        # Replace the X_i-th character with C_i\n        s = s[:xi-1] + ci + s[xi:]\n        # Count occurrences of \"ABC\" after replacement\n        print(count_substring_occurrences(s, \"ABC\"))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_d",
        "code_list": [
            "def main():\n    import sys\n    \n    def next_tallest_index(heights):\n        stack = []\n        next_tallest = [len(heights)] * len(heights)\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] < h:\n                next_tallest[stack.pop()] = i\n            stack.append(i)\n        return next_tallest\n    \n    N = int(input())\n    H = list(map(int, input().split()))\n    \n    next_tallest = next_tallest_index(H)\n    result = [next_tallest[i] - i - 1 for i in range(N)]\n    \n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_g",
        "code_list": [
            "from math import ceil\n\ndef solve_case(N, AB):\n    count = 0\n    for i in range(N):\n        A, B, C = AB[i]\n        if C > 0:\n            # Calculate the maximum possible value of y\n            max_y = (C - 1) // B\n            # Calculate the maximum possible value of x\n            max_x = (C - 1 - max_y * B) // A\n            count += max_x\n    return count\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        AB = [list(map(int, input().split())) for _ in range(N)]\n        print(solve_case(N, AB))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc372_f",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M, K = map(int, input().split())\n    edges = defaultdict(list)\n    for _ in range(M):\n        X, Y = map(int, input().split())\n        edges[X].append(Y)\n\n    mod = 998244353\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    dp[0][1] = 1\n\n    for k in range(1, K + 1):\n        for v in range(1, N + 1):\n            # Move to next vertex in the cycle\n            dp[k][v % N] += dp[k - 1][v]\n            dp[k][v % N] %= mod\n            # Move to custom edges\n            for next_v in edges[v]:\n                dp[k][next_v - 1] += dp[k - 1][v]\n                dp[k][next_v - 1] %= mod\n\n    result = sum(dp[K]) % mod\n    print(result)"
        ]
    },
    {
        "question_id": "abc372_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = S.replace('.', '')\n    print(result)"
        ]
    },
    {
        "question_id": "abc373_a",
        "code_list": [
            "def main():\n    count = 0\n    for i in range(1, 13):\n        S_i = input()\n        if len(S_i) == i:\n            count += 1\n    print(count)"
        ]
    },
    {
        "question_id": "abc373_b",
        "code_list": [
            "def calculate_distance(S):\n    # Initial position of the finger\n    current_position = 0\n    total_distance = 0\n    \n    # Calculate the distance for each character from A to Z\n    for char in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n        # Find the index of the current character in the permutation\n        target_position = S.index(char)\n        # Add the distance to the total distance\n        total_distance += abs(current_position - target_position)\n        # Update the current position to the target position\n        current_position = target_position\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(calculate_distance(S))"
        ]
    },
    {
        "question_id": "abc373_f",
        "code_list": [
            "import heapq\n\ndef main():\n    N, W = map(int, input().split())\n    items = []\n    for _ in range(N):\n        w, v = map(int, input().split())\n        # Calculate the maximum k for each item type that fits within the weight limit\n        max_k = min(W // w, 10**10)\n        # Use a negative value for the heap to simulate a max heap\n        heapq.heappush(items, (-((max_k * v) - (max_k ** 2)), w, max_k))\n    \n    total_happiness = 0\n    knapsack = [0] * (W + 1)\n    \n    while items:\n        happiness, weight, max_k = heapq.heappop(items)\n        happiness = -happiness\n        for k in range(max_k, -1, -1):\n            if knapsack[weight * k] < W:\n                total_happiness += k * v - k ** 2\n                knapsack[weight * k] += weight\n                break\n    \n    print(total_happiness)"
        ]
    },
    {
        "question_id": "abc373_g",
        "code_list": [
            "from typing import List\n\ndef orientation(p: tuple, q: tuple, r: tuple) -> int:\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef do_segments_intersect(p1: tuple, q1: tuple, p2: tuple, q2: tuple) -> bool:\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef find_permutation(N: int, P: List[tuple], Q: List[tuple]) -> List[int]:\n    def dfs(index: int, path: List[int]):\n        if index == N:\n            return path\n        \n        for i in range(N):\n            if i not in used and not any(do_segments_intersect(P[path[j]], Q[i], P[path[j+1]], Q[path[j+1]]) for j in range(index)):\n                used.add(i)\n                result = dfs(index + 1, path + [i])\n                if result:\n                    return result\n                used.remove(i)\n        \n        return []\n    \n    used = set()\n    return dfs(0, [])\n\ndef main():\n    N = int(input())\n    P = [tuple(map(int, input().split())) for _ in range(N)]\n    Q = [tuple(map(int, input().split())) for _ in range(N)]\n\n    result = find_permutation(N, P, Q)\n    if result:\n        print(\" \".join(map(str, result)))\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc373_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    n = data[0]\n    a = data[1:n+1]\n    b = data[n+1:]\n    \n    max_a = max(a)\n    max_b = max(b)\n    \n    print(max_a + max_b)"
        ]
    },
    {
        "question_id": "abc373_e",
        "code_list": [
            "def min_votes_needed(N, M, K, A):\n    # Calculate the total number of votes already counted\n    total_counted = sum(A)\n    \n    # Calculate the maximum number of votes that can be distributed among the top (M-1) candidates\n    max_top_m_minus_one = (M - 1) * (K - total_counted + (M - 1))\n    \n    # Determine the minimum number of additional votes needed for each candidate\n    C = []\n    for i in range(N):\n        current_votes = A[i]\n        # Calculate the minimum votes needed to ensure victory\n        min_votes = max(0, (max_top_m_minus_one + M - 1) // M + 1 - current_votes)\n        # Check if the candidate can secure their victory\n        if min_votes <= K - total_counted:\n            C.append(min_votes)\n        else:\n            C.append(-1)\n    \n    return C\n\nif __name__ == \"__main__\":\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    result = min_votes_needed(N, M, K, A)\n    print(*result)"
        ]
    },
    {
        "question_id": "arc181_d",
        "code_list": [
            "from typing import List\n\ndef count_inversions(arr: List[int]) -> int:\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n\ndef perform_operations(n: int, perm: List[int], operations: List[int]) -> List[int]:\n    result = []\n    current_perm = perm.copy()\n    \n    for op in operations:\n        for k in range(2, op + 1):\n            for i in range(k - 1):\n                if current_perm[i] > current_perm[i + 1]:\n                    current_perm[i], current_perm[i + 1] = current_perm[i + 1], current_perm[i]\n        result.append(count_inversions(current_perm))\n    \n    return result\n\nif __name__ == \"__main__\":\n    n = int(input())\n    perm = list(map(int, input().split()))\n    m = int(input())\n    operations = list(map(int, input().split()))\n    \n    answers = perform_operations(n, perm, operations)\n    for ans in answers:\n        print(ans)"
        ]
    },
    {
        "question_id": "arc181_c",
        "code_list": [
            "def generate_grid(N, P, Q):\n    # Initialize the grid with zeros\n    grid = [['0' for _ in range(N)] for _ in range(N)]\n    \n    # Function to flip the value of a cell\n    def flip(i, j):\n        grid[i][j] = '1' if grid[i][j] == '0' else '0'\n    \n    # Function to check if the current grid satisfies the conditions\n    def is_valid():\n        # Check rows\n        for i in range(N):\n            for j in range(N - 1):\n                if ''.join(grid[i][j:j+2]) >= ''.join(grid[P[j]][j:j+2]):\n                    return False\n        # Check columns\n        for j in range(N):\n            for i in range(N - 1):\n                if ''.join([grid[i][j] + grid[i+1][j]]) >= ''.join([grid[Q[i]][j] + grid[Q[i+1]][j]]):\n                    return False\n        return True\n    \n    # Try to flip cells to satisfy the conditions\n    for i in range(N):\n        for j in range(N):\n            # Flip the cell and check if the conditions are satisfied\n            flip(i, j)\n            if is_valid():\n                continue\n            # If not, flip back and try the next cell\n            flip(i, j)\n            flip(i, j)\n    \n    # Convert the grid to the required format and print\n    result = [''.join(row) for row in grid]\n    return '\\n'.join(result)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    print(generate_grid(N, P, Q))"
        ]
    },
    {
        "question_id": "arc181_b",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        S = input().strip()\n        X = input().strip()\n        Y = input().strip()\n        \n        # Check if lengths of X and Y differ by a multiple of len(S)\n        if (len(X) - len(Y)) % len(S) != 0:\n            print(\"No\")\n            continue\n        \n        # If lengths are equal, check if X and Y are identical\n        if len(X) == len(Y):\n            print(\"Yes\" if X == Y else \"No\")\n            continue\n        \n        # Find the common prefix length of X and Y\n        prefix_len = 0\n        while prefix_len < min(len(X), len(Y)) and X[prefix_len] == Y[prefix_len]:\n            prefix_len += 1\n        \n        # Check if the remaining parts of X and Y match after removing the common prefix\n        if prefix_len == min(len(X), len(Y)):\n            X = X[prefix_len:]\n            Y = Y[prefix_len:]\n        \n        # Check if the lengths of the remaining parts are multiples of len(S)\n        if (len(X) - len(Y)) % len(S) != 0:\n            print(\"No\")\n            continue\n        \n        # Check if the remaining parts of X and Y can be made equal by appending T\n        if (len(X) // len(S)) == (len(Y) // len(S)):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc181_a",
        "code_list": [
            "def min_operations_to_sort(permutation):\n    n = len(permutation)\n    operations = 0\n    \n    # Find the position of the first element that is not in its correct place\n    for i in range(n):\n        if permutation[i] != i + 1:\n            break\n    \n    # If the entire array is already sorted\n    if i == n:\n        return 0\n    \n    # Perform the operations to sort the array\n    while True:\n        # Sort the elements before the first incorrect element\n        for j in range(i):\n            if permutation[j] > permutation[j + 1]:\n                permutation[j], permutation[j + 1] = permutation[j + 1], permutation[j]\n                operations += 1\n        \n        # Sort the elements after the first incorrect element\n        for j in range(i + 1, n - 1):\n            if permutation[j] > permutation[j + 1]:\n                permutation[j], permutation[j + 1] = permutation[j + 1], permutation[j]\n                operations += 1\n        \n        # Check if the array is now sorted\n        for j in range(n):\n            if permutation[j] != j + 1:\n                break\n        else:\n            return operations\n        \n        # Find the next position of the first element that is not in its correct place\n        for j in range(i + 1, n):\n            if permutation[j] != j + 1:\n                i = j\n                break\n        else:\n            return operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        permutation = list(map(int, data[index:index + n]))\n        index += n\n        results.append(min_operations_to_sort(permutation))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc182_d",
        "code_list": [
            "def min_operations_to_make_good_sequences_equal(N, M, A, B):\n    operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        # Ensure the shortest path is taken\n        if diff > M // 2:\n            diff = M - diff\n        operations += diff\n    return operations\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    result = min_operations_to_make_good_sequences_equal(N, M, A, B)\n    print(result if result != float('inf') else -1)"
        ]
    },
    {
        "question_id": "arc182_e",
        "code_list": [
            "def find_min_mod_sum(N, M, C, K, A):\n    # Find the minimum value in A modulo M\n    min_val = min(A[i] % M for i in range(N))\n    \n    # Initialize the result\n    result = min_val * K\n    \n    # If all elements in A are 0, we can return the result directly\n    if min_val == 0:\n        return result\n    \n    # Calculate the prefix sums of (C + A_i) % M\n    prefix_sums = [0] * (M + 1)\n    for a in A:\n        prefix_sums[(C + a) % M] += 1\n    \n    # Calculate the contribution of each possible minimum value\n    for k in range(K):\n        current_min = (C * k) % M\n        # Find the next occurrence of the current minimum value\n        next_index = (current_min + 1) % M\n        while prefix_sums[next_index] == 0:\n            next_index = (next_index + 1) % M\n        # Calculate the number of times the current minimum value appears\n        count = prefix_sums[current_min]\n        # Update the result\n        result += count * min_val\n        # Move to the next minimum value\n        current_min = next_index\n        min_val = (current_min - C * (k + 1) + M) % M\n    \n    return result\n\nif __name__ == \"__main__\":\n    N, M, C, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(find_min_mod_sum(N, M, C, K, A))"
        ]
    },
    {
        "question_id": "arc182_a",
        "code_list": [
            "from functools import lru_cache\n\ndef main():\n    N, Q = map(int, input().split())\n    operations = [tuple(map(int, input().split())) for _ in range(Q)]\n    \n    MOD = 998244353\n    \n    @lru_cache(None)\n    def dp(i, last):\n        if i == Q:\n            return 1\n        p, v = operations[i]\n        ways = 0\n        \n        # Option 1: Replace S_1, S_2, ..., S_{P_i} with V_i\n        if p > 1:\n            if last[p-1] <= v:\n                ways += dp(i + 1, tuple(min(v, x) for x in last[:p]))\n        \n        # Option 2: Replace S_{P_i}, S_{P_i+1}, ..., S_N with V_i\n        if last[p-1] <= v:\n            ways += dp(i + 1, tuple(min(v, x) for x in last[p-1:]))\n        \n        return ways % MOD\n    \n    print(dp(0, tuple(0 for _ in range(N))))"
        ]
    },
    {
        "question_id": "arc182_c",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\nMOD = 998244353\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef score_of_product(factors):\n    score = 1\n    for exp in factors.values():\n        score *= (exp + 1)\n        score %= MOD\n    return score\n\ndef main():\n    N, M = map(int, input().split())\n    total_score = 0\n    \n    # Generate all possible prime factor combinations up to M\n    primes = [i for i in range(2, M+1)]\n    for i in range(M):\n        if gcd(primes[i], primes[:i]) != 1:\n            continue\n        for j in range(i+1, M+1):\n            if gcd(primes[j], primes[:j]) != 1:\n                continue\n            for k in range(j+1, M+1):\n                if gcd(primes[k], primes[:k]) != 1:\n                    continue\n                for l in range(k+1, M+1):\n                    if gcd(primes[l], primes[:l]) != 1:\n                        continue\n                    for m in range(l+1, M+1):\n                        if gcd(primes[m], primes[:m]) != 1:\n                            continue\n                        for n in range(m+1, M+1):\n                            if gcd(primes[n], primes[:n]) != 1:\n                                continue\n                            for o in range(n+1, M+1):\n                                if gcd(primes[o], primes[:o]) != 1:\n                                    continue\n                                for p in range(o+1, M+1):\n                                    if gcd(primes[p], primes[:p]) != 1:\n                                        continue\n                                    for q in range(p+1, M+1):\n                                        if gcd(primes[q], primes[:q]) != 1:\n                                            continue\n                                        for r in range(q+1, M+1):\n                                            if gcd(primes[r], primes[:r]) != 1:\n                                                continue\n                                            for s in range(r+1, M+1):\n                                                if gcd(primes[s], primes[:s]) != 1:\n                                                    continue\n                                                for t in range(s+1, M+1):\n                                                    if gcd(primes[t], primes[:t]) != 1:\n                                                        continue\n                                                    for u in range(t+1, M+1):\n                                                        if gcd(primes[u], primes[:u]) != 1:\n                                                            continue\n                                                        for v in range(u+1, M+1):\n                                                            if gcd(primes[v], primes[:v]) != 1:\n                                                                continue\n                                                            for w in range(v+1, M+1):\n                                                                if gcd(primes[w], primes[:w]) != 1:\n                                                                    continue\n                                                                for x in range(w+1, M+1):\n                                                                    if gcd(primes[x], primes[:x]) != 1:\n                                                                        continue\n                                                                    for y in range(x+1, M+1):\n                                                                        if gcd(primes[y], primes[:y]) != 1:\n                                                                            continue\n                                                                        for z in range(y+1, M+1):\n                                                                            if gcd(primes[z], primes[:z]) != 1:\n                                                                                continue\n                                                                            for aa in range(z+1, M+1):\n                                                                                if gcd(primes[aa], primes[:aa]) != 1:\n                                                                                    continue\n                                                                                for bb in range(aa+1, M+1):\n                                                                                    if gcd(primes[bb], primes[:bb]) != 1:\n                                                                                        continue\n                                                                                        for cc in range(bb+1, M+1):\n                                                                                            if gcd(primes[cc], primes[:cc]) != 1:\n                                                                                                continue\n                                                                                                for dd in range(cc+1, M+1):\n                                                                                                    if gcd(primes[dd], primes[:dd]) != 1:\n                                                                                                        continue\n                                                                                                        for ee in range(dd+1, M+1):\n                                                                                                            if gcd(primes[ee], primes[:ee]) != 1:\n                                                                                                                continue\n                                                                                                                for ff in range(ee+1, M+1):\n                                                                                                                    if gcd(primes[ff], primes[:ff]) != 1:\n                                                                                                                        continue\n                                                                                                                        for gg in range(ff+1, M+1):\n                                                                                                                            if gcd(primes[gg], primes[:gg]) != 1:\n                                                                                                                                continue\n                                                                                                                                for hh in range(gg+1, M+1):\n                                                                                                                                    if gcd(primes[hh], primes[:hh]) != 1:\n                                                                                                                                        continue\n                                                                                                                                        for ii in range(hh+1, M+1):\n                                                                                                                                            if gcd(primes[ii], primes[:ii]) != 1:\n                                                                                                                                                    continue\n                                                                                                                                                    for jj in range(ii+1, M+1):\n                                                                                                                                                        if gcd(primes[jj], primes[:jj]) != 1:\n                                                                                                                                                            continue\n                                                                                                                                                            for kk in range(jj+1, M+1):\n                                                                                                                                                                if gcd(primes[kk], primes[:kk]) != 1:\n                                                                                                                                                                    continue\n                                                                                                                                                                    for ll in range(kk+1, M+1):\n                                                                                                                                                                        if gcd(primes[ll], primes[:ll]) != 1:\n                                                                                                                                                                            continue\n                                                                                                                                                                            for mm in range(ll+1, M+1):\n                                                                                                                                                                                if gcd(primes[mm], primes[:mm]) != 1:\n                                                                                                                                                                                    continue\n                                                                                                                                                                                    for nn in range(mm+1, M+1):\n                                                                                                                                                                                        if gcd(primes[nn], primes[:nn]) != 1:\n                                                                                                                                                                                            continue\n                                                                                                                                                                                            for oo in range(nn+1, M+1):\n                                                                                                                                                                                                if gcd(primes[oo], primes[:oo]) != 1:\n                                                                                                                                                                                                    continue\n                                                                                                                                                                                                    for pp in range(oo+1, M+1):\n                                                                                                                                                                                                        if gcd(primes[pp], primes[:pp]) != 1:\n                                                                                                                                                                                                            continue\n                                                                                                                                                                                                            for qq in range(pp+1, M+1):\n                                                                                                                                                                                                                if gcd(primes[qq], primes[:qq]) != 1:\n                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                    for rr in range(qq+1, M+1):\n                                                                                                                                                                                                                        if gcd(primes[rr], primes[:rr]) != 1:\n                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                            for ss in range(rr+1, M+1):\n                                                                                                                                                                                                                                if gcd(primes[ss], primes[:ss]) != 1:\n                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                    for tt in range(ss+1, M+1):\n                                                                                                                                                                                                                                        if gcd(primes[tt], primes[:tt]) != 1:\n                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                            for uu in range(tt+1, M+1):\n                                                                                                                                                                                                                                                if gcd(primes[uu], primes[:uu]) != 1:\n                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                    for vv in range(uu+1, M+1):\n                                                                                                                                                                                                                                                        if gcd(primes[vv], primes[:vv]) != 1:\n                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                            for ww in range(vv+1, M+1):\n                                                                                                                                                                                                                                                                if gcd(primes[ww], primes[:ww]) != 1:\n                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                    for xx in range(ww+1, M+1):\n                                                                                                                                                                                                                                                                        if gcd(primes[xx], primes[:xx]) != 1:\n                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                            for yy in range(xx+1, M+1):\n                                                                                                                                                                                                                                                                                if gcd(primes[yy], primes[:yy]) != 1:\n                                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                                    for zz in range(yy+1, M+1):\n                                                                                                                                                                                                                                                                                        if gcd(primes[zz], primes[:zz]) != 1:\n                                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                                            for aaa in range(zz+1, M+1):\n                                                                                                                                                                                                                                                                                                if gcd(primes[aaa], primes[:aaa]) != 1:\n                                                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                                                    for bbb in range(aaa+1, M+1):\n                                                                                                                                                                                                                                                                                                        if gcd(primes[bbb], primes[:bbb]) != 1:\n                                                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                                                            for ccc in range(bbb+1, M+1):\n                                                                                                                                                                                                                                                                                                                if gcd(primes[ccc], primes[:ccc]) != 1:\n                                                                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                                                                    for ddd in range(ccc+1, M+1):\n                                                                                                                                                                                                                                                                                                                        if gcd(primes[ddd], primes[:ddd]) != 1:\n                                                                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                                                                            for eee in range(ddd+1, M+1):\n                                                                                                                                                                                                                                                                                                                                if gcd(primes[eee], primes[:eee]) != 1:\n                                                                                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                                                                                    for fff in range(eee+1, M+1):\n                                                                                                                                                                                                                                                                                                                                        if gcd(primes[fff], primes[:fff]) != 1:\n                                                                                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                                                                                            for ggg in range(fff+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                if gcd(primes[ggg], primes[:ggg]) != 1:\n                                                                                                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                                                                                                    for hhh in range(ggg+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                        if gcd(primes[hhh], primes[:hhh]) != 1:\n                                                                                                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                                                                                                            for iii in range(hhh+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                if gcd(primes[iii], primes[:iii]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                                                                                                                    for jjj in range(iii+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                        if gcd(primes[jjj], primes[:jjj]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                                                                                                                            for kkk in range(jjj+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                if gcd(primes[kkk], primes[:kkk]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                                                                                                                                    for lll in range(kkk+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                        if gcd(primes[lll], primes[:lll]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                                                                                                                                            for mmm in range(lll+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                if gcd(primes[mmm], primes[:mmm]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                    continue\n                                                                                                                                                                                                                                                                                                                                                                                                    for nnn in range(mmm+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                        if gcd(primes[nnn], primes[:nnn]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                            continue\n                                                                                                                                                                                                                                                                                                                                                                                                            for ooo in range(nnn+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                if gcd(primes[ooo], primes[:ooo]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                        for www in range(ooo+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[www], primes[:www]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                for xxx in range(www+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[xxx], primes[:xxx]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                        for yyy in range(xxx+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[yyy], primes[:yyy]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                for zzz in range(yyy+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[zzz], primes[:zzz]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        for aaa in range(zzz+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[aaa], primes[:aaa]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                for bbb in range(aaa+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[bbb], primes[:bbb]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ccc in range(bbb+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ccc], primes[:ccc]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ddd in range(ccc+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ddd], primes[:ddd]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for eee in range(ddd+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[eee], primes[:eee]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for fff in range(eee+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[fff], primes[:fff]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ggg in range(fff+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ggg], primes[:ggg]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for hhh in range(ggg+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[hhh], primes[:hhh]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for iii in range(hhh+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[iii], primes[:iii]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for jjj in range(iii+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[jjj], primes[:jjj]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for kkk in range(jjj+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[kkk], primes[:kkk]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for lll in range(kkk+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[lll], primes[:lll]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for mmm in range(lll+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[mmm], primes[:mmm]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for nnn in range(mmm+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[nnn], primes[:nnn]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ooo in range(nnn+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ooo], primes[:ooo]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for www in range(ooo+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[www], primes[:www]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for xxx in range(www+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[xxx], primes[:xxx]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for yyy in range(xxx+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[yyy], primes[:yyy]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for zzz in range(yyy+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[zzz], primes[:zzz]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for aaa in range(zzz+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[aaa], primes[:aaa]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for bbb in range(aaa+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[bbb], primes[:bbb]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ccc in range(bbb+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ccc], primes[:ccc]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ddd in range(ccc+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ddd], primes[:ddd]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for eee in range(ddd+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[eee], primes[:eee]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for fff in range(eee+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[fff], primes[:fff]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ggg in range(fff+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ggg], primes[:ggg]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for hhh in range(ggg+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[hhh], primes[:hhh]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for iii in range(hhh+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[iii], primes[:iii]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for jjj in range(iii+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[jjj], primes[:jjj]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for kkk in range(jjj+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[kkk], primes[:kkk]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for lll in range(kkk+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[lll], primes[:lll]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for mmm in range(lll+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[mmm], primes[:mmm]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for nnn in range(mmm+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[nnn], primes[:nnn]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ooo in range(nnn+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ooo], primes[:ooo]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for www in range(ooo+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[www], primes[:www]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for xxx in range(www+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[xxx], primes[:xxx]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for yyy in range(xxx+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[yyy], primes[:yyy]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for zzz in range(yyy+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[zzz], primes[:zzz]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for aaa in range(zzz+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[aaa], primes[:aaa]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for bbb in range(aaa+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[bbb], primes[:bbb]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ccc in range(bbb+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ccc], primes[:ccc]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ddd in range(ccc+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ddd], primes[:ddd]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for eee in range(ddd+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[eee], primes[:eee]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for fff in range(eee+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[fff], primes[:fff]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ggg in range(fff+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ggg], primes[:ggg]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for hhh in range(ggg+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[hhh], primes[:hhh]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for iii in range(hhh+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[iii], primes[:iii]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for jjj in range(iii+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[jjj], primes[:jjj]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for kkk in range(jjj+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[kkk], primes[:kkk]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for lll in range(kkk+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[lll], primes[:lll]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for mmm in range(lll+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[mmm], primes[:mmm]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for nnn in range(mmm+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[nnn], primes[:nnn]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ooo in range(nnn+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ooo], primes[:ooo]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for www in range(ooo+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[www], primes[:www]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for xxx in range(www+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[xxx], primes[:xxx]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for yyy in range(xxx+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[yyy], primes[:yyy]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for zzz in range(yyy+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[zzz], primes[:zzz]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for aaa in range(zzz+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[aaa], primes[:aaa]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for bbb in range(aaa+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[bbb], primes[:bbb]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ccc in range(bbb+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ccc], primes[:ccc]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ddd in range(ccc+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ddd], primes[:ddd]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for eee in range(ddd+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[eee], primes[:eee]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for fff in range(eee+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[fff], primes[:fff]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ggg in range(fff+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ggg], primes[:ggg]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for hhh in range(ggg+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[hhh], primes[:hhh]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for iii in range(hhh+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[iii], primes[:iii]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for jjj in range(iii+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[jjj], primes[:jjj]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for kkk in range(jjj+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[kkk], primes[:kkk]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for lll in range(kkk+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[lll], primes[:lll]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for mmm in range(lll+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[mmm], primes[:mmm]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for nnn in range(mmm+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[nnn], primes[:nnn]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ooo in range(nnn+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ooo], primes[:ooo]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for www in range(ooo+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[www], primes[:www]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for xxx in range(www+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[xxx], primes[:xxx]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for yyy in range(xxx+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[yyy], primes[:yyy]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for zzz in range(yyy+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[zzz], primes[:zzz]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for aaa in range(zzz+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[aaa], primes[:aaa]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for bbb in range(aaa+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[bbb], primes[:bbb]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ccc in range(bbb+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ccc], primes[:ccc]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ddd in range(ccc+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ddd], primes[:ddd]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for eee in range(ddd+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[eee], primes[:eee]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for fff in range(eee+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[fff], primes[:fff]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ggg in range(fff+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ggg], primes[:ggg]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for hhh in range(ggg+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[hhh], primes[:hhh]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for iii in range(hhh+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[iii], primes[:iii]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for jjj in range(iii+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[jjj], primes[:jjj]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for kkk in range(jjj+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[kkk], primes[:kkk]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for lll in range(kkk+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[lll], primes[:lll]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for mmm in range(lll+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[mmm], primes[:mmm]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for nnn in range(mmm+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[nnn], primes[:nnn]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ooo in range(nnn+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ooo], primes[:ooo]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for www in range(ooo+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[www], primes[:www]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for xxx in range(www+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[xxx], primes[:xxx]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for yyy in range(xxx+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[yyy], primes[:yyy]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for zzz in range(yyy+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[zzz], primes[:zzz]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for aaa in range(zzz+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[aaa], primes[:aaa]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for bbb in range(aaa+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[bbb], primes[:bbb]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ccc in range(bbb+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ccc], primes[:ccc]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for ddd in range(ccc+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[ddd], primes[:ddd]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for eee in range(ddd+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[eee], primes[:eee]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for fff in range(eee+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[fff], primes[:fff]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for ggg in range(fff+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[ggg], primes[:ggg]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for hhh in range(ggg+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[hhh], primes[:hhh]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for iii in range(hhh+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if gcd(primes[iii], primes[:iii]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        for jjj in range(iii+1, M+1):\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if gcd(primes[jjj], primes[:jjj]) != 1:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                continue\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                for kkk in range(jjj+1"
        ]
    },
    {
        "question_id": "arc183_b",
        "code_list": [
            "def can_transform(A, B, K):\n    N = len(A)\n    # Create a dictionary to store the indices of each value in A and B\n    A_indices = {}\n    B_indices = {}\n    \n    # Populate the dictionaries\n    for i in range(N):\n        A_indices[A[i]] = A_indices.get(A[i], []) + [i]\n        B_indices[B[i]] = B_indices.get(B[i], []) + [i]\n    \n    # Check if the sets of indices for each value in A and B are the same within the allowed range\n    for value in A_indices:\n        A_val_indices = A_indices[value]\n        B_val_indices = B_indices[value]\n        \n        # If the lengths of the index lists are different, return False\n        if len(A_val_indices) != len(B_val_indices):\n            return \"No\"\n        \n        # Sort the indices\n        A_val_indices.sort()\n        B_val_indices.sort()\n        \n        # Check if the indices are within the allowed range\n        for i in range(len(A_val_indices)):\n            if abs(A_val_indices[i] - B_val_indices[i]) > K:\n                return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    T = int(input().strip())\n    for _ in range(T):\n        N, K = map(int, input().strip().split())\n        A = list(map(int, input().strip().split()))\n        B = list(map(int, input().strip().split()))\n        print(can_transform(A, B, K))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc183_c",
        "code_list": [
            "from typing import List\n\ndef count_valid_permutations(n: int, m: int, conditions: List[List[int]]) -> int:\n    MOD = 998244353\n    \n    # Initialize the DP table\n    dp = [1] + [0] * n\n    \n    for l, r, x in conditions:\n        new_dp = [0] * (n + 1)\n        for i in range(n + 1):\n            if i < x:\n                new_dp[i] = dp[i]\n            else:\n                new_dp[i] = (dp[i] - dp[i - 1]) % MOD\n        dp = new_dp\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    conditions = [list(map(int, input().split())) for _ in range(m)]\n    print(count_valid_permutations(n, m, conditions))"
        ]
    },
    {
        "question_id": "arc183_a",
        "code_list": [
            "from math import comb, floor\n\ndef find_good_sequence(N, K):\n    def generate_sequence(index):\n        sequence = []\n        for num in range(1, N + 1):\n            count = 0\n            while index >= comb(K - count, N - 1):\n                index -= comb(K - count, N - 1)\n                count += 1\n            sequence.append(num)\n            K -= 1\n        return sequence\n    \n    total_sequences = comb(N * K, N - 1)\n    target_index = floor((total_sequences + 1) / 2) - 1\n    return generate_sequence(target_index)\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    result = find_good_sequence(N, K)\n    print(' '.join(map(str, result)))"
        ]
    },
    {
        "question_id": "arc183_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    start_index = 1\n    \n    for i in range(n // 2):\n        a = int(data[start_index + 2 * i]) + 1\n        b = int(data[start_index + 2 * i + 1]) + 1\n        edges.append((a, b))\n    \n    result = []\n    for i in range(n // 2):\n        x = 2 * (i + 1)\n        y = n - x + 1\n        result.append((x, y))\n    \n    for pair in result:\n        print(pair[0], pair[1])"
        ]
    },
    {
        "question_id": "3026",
        "code_list": [
            "from typing import Set\n\nclass Solution:\n    def minimumPossibleSum(self, n: int, target: int) -> int:\n        used = set()\n        result_sum = 0\n        current_num = 1\n        \n        while len(used) < n:\n            if target - current_num not in used:\n                result_sum += current_num\n                used.add(current_num)\n            current_num += 1\n        \n        return result_sum % (10**9 + 7)"
        ]
    },
    {
        "question_id": "3543",
        "code_list": [
            "from collections import deque\n\nclass Solution:\n    def countKConstraintSubstrings(self, s: str, k: int) -> int:\n        def count_substrings(char_count):\n            count = 0\n            left = 0\n            for right in range(len(s)):\n                char_count[s[right]] += 1\n                while min(char_count['0'], char_count['1']) > k:\n                    char_count[s[left]] -= 1\n                    left += 1\n                count += right - left + 1\n            return count\n        \n        return count_substrings({'0': 0, '1': 0})"
        ]
    },
    {
        "question_id": "3525",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxEnergyBoost(self, energyDrinkA: List[int], energyDrinkB: List[int]) -> int:\n        n = len(energyDrinkA)\n        dp = [[0] * 2 for _ in range(n)]\n        \n        # Initialize the first hour\n        dp[0][0] = energyDrinkA[0]\n        dp[0][1] = energyDrinkB[0]\n        \n        # Fill the DP table\n        for i in range(1, n):\n            dp[i][0] = max(dp[i-1][1], dp[i-1][0]) + energyDrinkA[i]\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0]) + energyDrinkB[i]\n        \n        # The result will be the maximum value in the last hour of both choices\n        return max(dp[n-1][0], dp[n-1][1])"
        ]
    },
    {
        "question_id": "3552",
        "code_list": [
            "class Solution:\n    def largestPalindrome(self, n: int, k: int) -> str:\n        if n == 1:\n            return '9' if k != 1 else '8'\n        max_num = 10**n - 1\n        for i in range(max_num, 10**(n-1)-1, -1):\n            palindrome = int(str(i) + str(i)[::-1])\n            if palindrome % k == 0:\n                return str(palindrome)"
        ]
    },
    {
        "question_id": "3555",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getFinalState(self, nums: List[int], k: int, multiplier: int) -> List[int]:\n        n = len(nums)\n        result = [0] * k\n        \n        for i in range(k):\n            min_val_index = nums.index(min(nums))\n            result[i] = nums[min_val_index] * multiplier\n            nums.pop(min_val_index)\n        \n        return result"
        ]
    },
    {
        "question_id": "3534",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPairs(self, nums: List[int]) -> int:\n        def is_almost_equal(num1: int, num2: int) -> bool:\n            str_num1, str_num2 = str(num1), str(num2)\n            if len(str_num1) != len(str_num2):\n                return False\n            diff_count = 0\n            for c1, c2 in zip(str_num1, str_num2):\n                if c1 != c2:\n                    diff_count += 1\n                    if diff_count > 2:\n                        return False\n            return True\n        \n        count = 0\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_almost_equal(nums[i], nums[j]):\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3553",
        "code_list": [
            "class Solution:\n    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:\n        # Convert letters to 0-based indices\n        col1, col2 = ord(coordinate1[0]) - ord('a'), ord(coordinate2[0]) - ord('a')\n        # Convert rows to 0-based indices\n        row1, row2 = int(coordinate1[1]) - 1, int(coordinate2[1]) - 1\n        \n        # Determine the color of each square (0 for black, 1 for white)\n        color1 = (col1 + row1) % 2\n        color2 = (col2 + row2) % 2\n        \n        # Check if both squares have the same color\n        return color1 == color2"
        ]
    },
    {
        "question_id": "3495",
        "code_list": [
            "import heapq\n\nclass Solution:\n    def resultsArray(self, queries: List[List[int]], k: int) -> List[int]:\n        result = []\n        obstacles = []\n        \n        for x, y in queries:\n            # Calculate the distance of the new obstacle from the origin\n            distance = abs(x) + abs(y)\n            heapq.heappush(obstacles, (distance, x, y))\n            \n            # Maintain only the k nearest obstacles\n            if len(obstacles) > k:\n                heapq.heappop(obstacles)\n            \n            # Check if there are enough obstacles to determine the k-th nearest\n            if len(obstacles) == k:\n                _, _, _ = obstacles[0]  # Ignore the values, we only care about the distance\n                result.append(distance)\n            else:\n                result.append(-1)\n        \n        return result"
        ]
    },
    {
        "question_id": "3563",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, grid: List[List[int]]) -> int:\n        row_max_scores = [set() for _ in range(len(grid))]\n        max_score = 0\n        \n        for col in range(len(grid[0])):\n            current_col_values = set()\n            for row in range(len(grid)):\n                if grid[row][col] in current_col_values or grid[row][col] in row_max_scores[row]:\n                    continue\n                current_col_values.add(grid[row][col])\n                row_max_scores[row].add(grid[row][col])\n            \n            max_score += max(current_col_values)\n        \n        return max_score"
        ]
    },
    {
        "question_id": "3551",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumSubarrayXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        from functools import reduce\n        from operator import xor\n        \n        def max_xor_in_range(start, end):\n            trie = {}\n            max_xor = 0\n            current_xor = 0\n            \n            for i in range(start, end + 1):\n                num = nums[i]\n                node = trie\n                for j in reversed(range(32)):\n                    bit = (num >> j) & 1\n                    if 1 - bit in node:\n                        current_xor ^= (1 << j)\n                        node = node[1 - bit]\n                    else:\n                        node = node[bit]\n                for j in reversed(range(32)):\n                    bit = (num >> j) & 1\n                    if 1 - bit in node:\n                        max_xor = max(max_xor, current_xor ^ (1 << j))\n                        node = node[1 - bit]\n                    else:\n                        node = node[bit]\n                node = trie if not node else node[bit]\n                current_xor ^= num\n            \n            return max_xor\n        \n        return [max_xor_in_range(l, r) for l, r in queries]"
        ]
    },
    {
        "question_id": "3567",
        "code_list": [
            "class Solution:\n    def convertDateToBinary(self, date: str) -> str:\n        year, month, day = date.split('-')\n        binary_year = bin(int(year))[2:]\n        binary_month = bin(int(month))[2:]\n        binary_day = bin(int(day))[2:]\n        \n        # Ensure each part has enough digits by padding with leading zeros\n        binary_year = binary_year.zfill(15)\n        binary_month = binary_month.zfill(4)\n        binary_day = binary_day.zfill(5)\n        \n        return f\"{binary_year}-{binary_month}-{binary_day}\""
        ]
    },
    {
        "question_id": "3485",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxPossibleScore(self, start: List[int], d: int) -> int:\n        n = len(start)\n        sorted_start = sorted(start)\n        \n        # Check if starting from the smallest number in the first interval is valid\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = abs(sorted_start[j] - sorted_start[i])\n                if diff % (j - i) == 0 and diff // (j - i) <= d:\n                    min_diff = min(min_diff, diff)\n        \n        return min_diff if min_diff != float('inf') else d"
        ]
    },
    {
        "question_id": "3528",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def findMaximumScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_heap = []\n        left = [0] * n\n        right = [0] * n\n        \n        # Calculate left max values\n        max_val = 0\n        for i in range(n):\n            max_val = max(max_val, nums[i])\n            left[i] = max_val\n        \n        # Calculate right max values using a max heap\n        max_val = 0\n        for i in range(n-1, -1, -1):\n            max_val = max(max_val, nums[i])\n            heapq.heappush(max_heap, (-max_val, i))\n        \n        score = 0\n        for i in range(n-1):\n            while max_heap and max_heap[0][1] <= i:\n                heapq.heappop(max_heap)\n            if max_heap:\n                score = max(score, (i + 1) * (-max_heap[0][0]) + left[i])\n        \n        return score"
        ]
    },
    {
        "question_id": "3560",
        "code_list": [
            "import heapq\n\nclass Solution:\n    def maxMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:\n        # Calculate the minimum moves from knight to each pawn\n        min_moves = []\n        for x, y in positions:\n            moves = abs(x - kx) + abs(y - ky) - (abs(x - kx) % 2 != abs(y - ky) % 2)\n            if moves > 0:\n                min_moves.append((moves, x, y))\n        \n        # Sort pawns based on the minimum moves required to capture them\n        min_moves.sort()\n        \n        # Initialize dp table\n        dp = [0] * len(positions)\n        \n        # Fill dp table\n        for i in range(len(positions)):\n            for j in range(i):\n                if abs(positions[i][0] - positions[j][0]) + abs(positions[i][1] - positions[j][1]) <= min_moves[i][0]:\n                    dp[i] = max(dp[i], dp[j] + min_moves[i][0])\n        \n        # Return the maximum total moves Alice can achieve\n        return max(dp)"
        ]
    },
    {
        "question_id": "3518",
        "code_list": [
            "from heapq import nlargest\n\nclass Solution:\n    def maxScore(self, a: List[int], b: List[int]) -> int:\n        # Find the 4 largest values in b and their indices\n        largest_b_values = nlargest(4, b)\n        corresponding_indices = [b.index(val) for val in largest_b_values]\n        \n        # Sort the indices to ensure they are in increasing order\n        sorted_indices = sorted(corresponding_indices)\n        \n        # Calculate the score using the corresponding values from a and b\n        score = sum(a[i] * b[j] for i, j in zip(range(4), sorted_indices))\n        \n        return score"
        ]
    },
    {
        "question_id": "3559",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minValidStrings(self, words: List[str], target: str) -> int:\n        word_set = set(words)\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        \n        for i in range(1, len(target) + 1):\n            if target[:i] in word_set:\n                dp[i] = 1\n            else:\n                for j in range(i):\n                    if target[j:i] in word_set:\n                        dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[len(target)] if dp[len(target)] != float('inf') else -1"
        ]
    },
    {
        "question_id": "3522",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def resultsArray(self, nums: List[int], k: int) -> List[int]:\n        results = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i+k]\n            if subarray == sorted(subarray) and all(subarray[j] + 1 == subarray[j+1] for j in range(len(subarray)-1)):\n                results.append(subarray[-1])\n            else:\n                results.append(-1)\n        return results"
        ]
    },
    {
        "question_id": "3550",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumValueSum(self, board: List[List[int]]) -> int:\n        m, n = len(board), len(board[0])\n        row_sums = [sum(row) for row in board]\n        col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n        \n        max_sum = float('-inf')\n        for i in range(m):\n            for j in range(n):\n                for k in range(m):\n                    if k != i:\n                        for l in range(n):\n                            if l != j and col_sums[l] > 0 and row_sums[k] > 0:\n                                current_sum = board[i][j] + board[k][l]\n                                max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3568",
        "code_list": [
            "class Solution:\n    def generateKey(self, num1: int, num2: int, num3: int) -> int:\n        # Convert numbers to strings and pad with leading zeros to ensure they are 4 digits long\n        num1_str = f\"{num1:04d}\"\n        num2_str = f\"{num2:04d}\"\n        num3_str = f\"{num3:04d}\"\n        \n        key_str = \"\"\n        for i in range(4):\n            # Find the minimum digit at the current position\n            min_digit = min(int(num1_str[i]), int(num2_str[i]), int(num3_str[i]))\n            key_str += str(min_digit)\n        \n        # Convert the key string back to an integer and remove leading zeros\n        key = int(key_str.lstrip('0'))\n        \n        return key"
        ]
    },
    {
        "question_id": "3540",
        "code_list": [
            "class Solution:\n    def stringHash(self, s: str, k: int) -> str:\n        result = \"\"\n        for i in range(0, len(s), k):\n            substring = s[i:i + k]\n            hash_sum = sum((ord(char) - ord('a')) for char in substring)\n            hashedChar = hash_sum % 26\n            result += chr(hashedChar + ord('a'))\n        return result"
        ]
    },
    {
        "question_id": "3548",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def countGoodIntegers(self, n: int, k: int) -> int:\n        if n == 1:\n            return 1 if k < 10 else 0\n        \n        def count_ways(digit_count, k):\n            if digit_count == 1:\n                return 1 if k < 10 else 0\n            ways = 0\n            for i in range(1, 10):\n                if i % k == 0:\n                    ways += comb(digit_count - 1, digit_count // 2) * (10 ** (digit_count // 2))\n                    if digit_count % 2 == 0:\n                        ways -= comb(digit_count // 2, digit_count // 4) * (10 ** (digit_count // 4))\n            return ways\n        \n        total_ways = 0\n        for mid_digit_count in range(1, n + 1, 2):\n            left_digit_count = (n - mid_digit_count) // 2\n            right_digit_count = n - left_digit_count - mid_digit_count\n            if left_digit_count >= 0 and right_digit_count >= 0:\n                ways = count_ways(mid_digit_count, k)\n                total_ways += ways * (10 ** left_digit_count) * (10 ** right_digit_count)\n        \n        return total_ways"
        ]
    },
    {
        "question_id": "3531",
        "code_list": [
            "from heapq import heapify, heappop, heappush\n\nclass Solution:\n    def minDamage(self, power: int, damage: List[int], health: List[int]) -> int:\n        # Calculate the total health of all enemies\n        total_health = sum(health)\n        \n        # Create a max heap based on the effective damage each enemy can do\n        # Effective damage is calculated as (health[i] // damage[i]) * damage[i] + max(0, health[i] % damage[i])\n        max_heap = [-(health[i] - (health[i] // damage[i]) * damage[i]) for i in range(len(damage))]\n        heapify(max_heap)\n        \n        damage_dealt = 0\n        \n        while max_heap:\n            effective_damage = -heappop(max_heap)\n            if effective_damage <= 0:\n                break\n            \n            # Calculate the time needed to kill the current enemy\n            time_to_kill = (effective_damage + power - 1) // power\n            \n            # Add the damage dealt to Bob during this time\n            damage_dealt += time_to_kill * power\n            \n            # Update the remaining health of the enemy\n            effective_damage -= power * time_to_kill\n            \n            # If the enemy is still alive, push the updated effective damage back into the heap\n            if effective_damage > 0:\n                heappush(max_heap, -effective_damage)\n        \n        return total_health - damage_dealt"
        ]
    },
    {
        "question_id": "3558",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findSafeWalk(self, grid: List[List[int]], health: int) -> bool:\n        m, n = len(grid), len(grid[0])\n        \n        def is_safe(x, y, h):\n            if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == -1:\n                return False\n            return h > 0\n        \n        def dfs(x, y, h):\n            if not is_safe(x, y, h):\n                return False\n            if (x, y) == (m - 1, n - 1):\n                return h >= 1\n            temp = grid[x][y]\n            grid[x][y] = -1\n            result = (dfs(x + 1, y, max(h - temp, 1)) or\n                      dfs(x - 1, y, max(h - temp, 1)) or\n                      dfs(x, y + 1, max(h - temp, 1)) or\n                      dfs(x, y - 1, max(h - temp, 1)))\n            grid[x][y] = temp\n            return result\n        \n        return dfs(0, 0, health)"
        ]
    },
    {
        "question_id": "3575",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxValue(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[-float('inf')] * (2 * k + 1) for _ in range(n)]\n        dp[0][1] = nums[0]\n        \n        for i in range(1, n):\n            for j in range(min(i + 1, 2 * k), 0, -1):\n                for l in range(i):\n                    or_left = dp[l][j - 1] if j > 1 else 0\n                    or_right = dp[l + 1][j - 1] if j > 1 else nums[i]\n                    xor_value = (or_left | nums[i]) ^ or_right\n                    dp[i][j] = max(dp[i][j], xor_value)\n        \n        return max(dp[n - 1])"
        ]
    },
    {
        "question_id": "3571",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def maxPathLength(self, coordinates: List[List[int]], k: int) -> int:\n        @lru_cache(None)\n        def dfs(index):\n            if index in memo:\n                return memo[index]\n            max_length = 1\n            for next_index in range(len(coordinates)):\n                if next_index != index and coordinates[next_index][0] > coordinates[index][0] and coordinates[next_index][1] > coordinates[index][1]:\n                    length = dfs(next_index) + 1\n                    max_length = max(max_length, length)\n            memo[index] = max_length\n            return max_length\n        \n        memo = {}\n        max_length = 1\n        for i in range(len(coordinates)):\n            if i == k:\n                max_length = max(max_length, dfs(i))\n            else:\n                max_length = max(max_length, dfs(i))\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3541",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def reportSpam(self, message: List[str], bannedWords: List[str]) -> bool:\n        banned_set = set(bannedWords)\n        seen_banned = set()\n        for word in message:\n            if word in banned_set:\n                seen_banned.add(word)\n                if len(seen_banned) >= 2:\n                    return True\n        return False"
        ]
    },
    {
        "question_id": "3496",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def minNumberOfSeconds(self, mountainHeight: int, workerTimes: List[int]) -> int:\n        # Calculate the maximum time each worker can spend reducing the mountain height\n        max_times = []\n        for time in workerTimes:\n            total_time = 0\n            x = 1\n            while total_time < mountainHeight:\n                total_time += time * x\n                x += 1\n            heapq.heappush(max_times, -total_time)\n        \n        # The minimum time required is the maximum of these times\n        return -max_times[0]"
        ]
    },
    {
        "question_id": "3573",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def validSubstringCount(self, word1: str, word2: str) -> int:\n        len1, len2 = len(word1), len(word2)\n        count_word2 = Counter(word2)\n        valid_count = 0\n        \n        for i in range(len1 - len2 + 1):\n            if word1[i] == word2[0]:\n                temp_count = count_word2.copy()\n                for j in range(len2):\n                    if word1[i + j] != word2[j]:\n                        break\n                    temp_count[word1[i + j]] -= 1\n                    if all(v <= 0 for v in temp_count.values()):\n                        valid_count += 1\n                        break\n        \n        return valid_count"
        ]
    },
    {
        "question_id": "3600",
        "code_list": [
            "class Solution:\n    def kthCharacter(self, k: int) -> str:\n        word = \"a\"\n        while len(word) < k:\n            word += chr((ord(word[-1]) - ord('a') + 1) % 26 + ord('a'))\n        return word[k-1]"
        ]
    },
    {
        "question_id": "3570",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def countOfSubstrings(self, word: str, k: int) -> int:\n        vowels = set('aeiou')\n        n = len(word)\n        total_vowels = sum(1 for char in word if char in vowels)\n        if total_vowels < 5 or total_vowels - 5 * (total_vowels >= 5) < k:\n            return 0\n        \n        def has_all_vowels(sub):\n            return all(v in sub for v in vowels)\n        \n        count = 0\n        for i in range(n):\n            for j in range(i + 5 - k, n + 1):\n                sub = word[i:j]\n                if has_all_vowels(sub) and len(set(sub)) - 1 == k:\n                    count += 1\n        return count"
        ]
    },
    {
        "question_id": "3579",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxGoodNumber(self, nums: List[int]) -> int:\n        return int(''.join(map(lambda x: bin(x)[2:], sorted(nums, reverse=True))), 2)"
        ]
    },
    {
        "question_id": "3583",
        "code_list": [
            "from typing import List\nfrom math import gcd\nfrom collections import Counter\nimport bisect\n\nclass Solution:\n    def gcdValues(self, nums: List[int], queries: List[int]) -> List[int]:\n        n = len(nums)\n        gcd_pairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                gcd_pairs.append(gcd(nums[i], nums[j]))\n        gcd_pairs.sort()\n        \n        count = Counter(gcd_pairs)\n        prefix_sum = [0]\n        for val in gcd_pairs:\n            prefix_sum.append(prefix_sum[-1] + count[val])\n        \n        result = []\n        for q in queries:\n            idx = bisect.bisect_left(gcd_pairs, gcd_pairs[q])\n            result.append(gcd_pairs[idx])\n        return result"
        ]
    },
    {
        "question_id": "3606",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minElement(self, nums: List[int]) -> int:\n        def sum_of_digits(n: int) -> int:\n            return sum(int(digit) for digit in str(n))\n        \n        nums = [sum_of_digits(num) for num in nums]\n        return min(nums)"
        ]
    },
    {
        "question_id": "3510",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumTotalSum(self, maximumHeight: List[int]) -> int:\n        n = len(maximumHeight)\n        if len(set(maximumHeight)) < n:\n            return -1\n        \n        total_sum = sum(maximumHeight)\n        max_height = max(maximumHeight)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + maximumHeight[i]\n        \n        def calculate_sum(target_height):\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if (mid + 1) * (maximumHeight[mid] - target_height + 1) / 2 <= prefix_sum[mid + 1]:\n                    right = mid\n                else:\n                    left = mid + 1\n            return (left + 1) * (target_height - 1) + prefix_sum[left + 1] - (left + 1) * target_height // 2\n        \n        max_sum = 0\n        for i in range(1, max_height + 1):\n            current_sum = total_sum - calculate_sum(i)\n            max_sum = max(max_sum, current_sum)\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3584",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def validSequence(self, word1: str, word2: str) -> List[int]:\n        n, m = len(word1), len(word2)\n        i, j, changes = 0, 0, 0\n        result = []\n        \n        while i < n and j < m:\n            if word1[i] == word2[j]:\n                result.append(i)\n                i += 1\n                j += 1\n            else:\n                if changes == 0:\n                    # Try to find a match for word2[j] in word1 starting from i\n                    k = i\n                    while k < n and (word1[k] != word2[j] or (changes == 1 and word1[k] == word2[j])):\n                        if word1[k] == word2[j]:\n                            changes = 1\n                        k += 1\n                    if k < n:\n                        i = k\n                        result.append(i)\n                        i += 1\n                        j += 1\n                    else:\n                        i += 1\n                else:\n                    i += 1\n        \n        return result"
        ]
    },
    {
        "question_id": "3580",
        "code_list": [
            "class Solution:\n    def minStartingIndex(self, s: str, pattern: str) -> int:\n        len_s, len_p = len(s), len(pattern)\n        diff_count = 0\n        \n        for i in range(len_s - len_p + 1):\n            diff_count = sum(1 for j in range(len_p) if s[i + j] != pattern[j])\n            if diff_count <= 1:\n                return i\n        return -1"
        ]
    },
    {
        "question_id": "abc374_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    k = data[1:]\n    total_people = sum(k)\n    half_total = total_people // 2\n\n    dp = [False] * (half_total + 1)\n    dp[0] = True\n\n    for people in k:\n        for j in range(half_total, people - 1, -1):\n            dp[j] = dp[j] or dp[j - people]\n\n    max_people = 0\n    for j in range(half_total + 1):\n        if dp[j]:\n            max_people = max(max_people, j, total_people - j)\n\n    print(max_people)"
        ]
    },
    {
        "question_id": "abc374_f",
        "code_list": [
            "from heapq import heappush, heappop\n\ndef min_dissatisfaction(N, K, X, T):\n    # Initialize variables\n    day = 0\n    heap = []\n    dissatisfied = 0\n    \n    for t in T:\n        # Move to the next available day for shipping\n        while heap and heap[0] < t:\n            heappop(heap)\n            day += X\n        \n        # Add current order to the heap\n        heappush(heap, t)\n        \n        # If the heap size exceeds K, ship K orders\n        if len(heap) > K:\n            dissatisfied += t - day\n            day += X\n            heappop(heap)\n    \n    return dissatisfied\n\nif __name__ == \"__main__\":\n    N, K, X = map(int, input().split())\n    T = list(map(int, input().split()))\n    print(min_dissatisfaction(N, K, X, T))"
        ]
    },
    {
        "question_id": "abc374_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    T = input().strip()\n    \n    len_S, len_T = len(S), len(T)\n    min_len = min(len_S, len_T)\n    \n    for i in range(min_len):\n        if S[i] != T[i]:\n            print(i + 1)\n            return\n    \n    if len_S != len_T:\n        if len_S < len_T:\n            print(len_S + 1)\n        else:\n            print(len_T + 1)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc374_d",
        "code_list": [
            "import math\n\ndef calculate_distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\ndef min_time_to_print_line_segments(N, S, T, line_segments):\n    def optimal_path(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        \n        # Calculate distances\n        d1 = calculate_distance(x1, y1, x3, y3)\n        d2 = calculate_distance(x1, y1, x4, y4)\n        d3 = calculate_distance(x2, y2, x3, y3)\n        d4 = calculate_distance(x2, y2, x4, y4)\n        \n        # Determine the optimal path\n        if d1 + d4 <= d2 + d3:\n            return d1 + d4, True\n        else:\n            return d2 + d3, False\n    \n    total_time = 0.0\n    remaining_lines = line_segments[:]\n    \n    while len(remaining_lines) > 1:\n        min_time = float('inf')\n        best_pair = None\n        \n        for i in range(len(remaining_lines)):\n            for j in range(i + 1, len(remaining_lines)):\n                time, start_with_first = optimal_path(remaining_lines[i], remaining_lines[j])\n                if time < min_time:\n                    min_time = time\n                    best_pair = (i, j, start_with_first)\n        \n        i, j, start_with_first = best_pair\n        line1, line2 = remaining_lines[i], remaining_lines[j]\n        \n        if start_with_first:\n            total_time += min_time / T\n        else:\n            total_time += min_time / T\n            total_time += (calculate_distance(*line1) - min_time) / S\n        \n        if start_with_first:\n            remaining_lines.pop(j)\n            remaining_lines.pop(i)\n        else:\n            remaining_lines.pop(i)\n            remaining_lines.pop(j)\n    \n    # Print the last remaining line segment\n    total_time += calculate_distance(*remaining_lines[0]) / T\n    \n    return total_time\n\ndef main():\n    N, S, T = map(int, input().split())\n    line_segments = [tuple(map(int, input().split())) for _ in range(N)]\n    print(min_time_to_print_line_segments(N, S, T, line_segments))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc374_g",
        "code_list": [
            "def main():\n    from collections import defaultdict\n\n    def build_suffix_array(s):\n        n = len(s)\n        sa = [i for i in range(n)]\n        sa.sort(key=lambda x: s[x:])\n        return sa\n\n    def lcp_array(s, sa):\n        n = len(s)\n        rank = [0] * n\n        for i in range(n):\n            rank[sa[i]] = i\n        k = 0\n        lcp = [0] * n\n        for i in range(n):\n            if rank[i] == n - 1:\n                k = 0\n                continue\n            j = sa[rank[i] + 1]\n            while i + k < n and j + k < n and s[i + k] == s[j + k]:\n                k += 1\n            lcp[rank[i]] = k\n            if k:\n                k -= 1\n        return lcp\n\n    def find_min_strings(products):\n        n = len(products)\n        suffixes = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                suffixes.add(products[i] + products[j])\n                suffixes.add(products[j] + products[i])\n\n        sa = build_suffix_array(''.join(products))\n        lcp = lcp_array(''.join(products), sa)\n\n        min_strings = []\n        current_string = ''\n        for i in range(n):\n            if not current_string or products[i] not in current_string:\n                current_string += products[i]\n                min_strings.append(current_string)\n            else:\n                pos = sa.index(i)\n                while pos > 0 and lcp[pos - 1] >= len(current_string):\n                    pos -= 1\n                current_string = ''.join(products[i - len(min_strings[-1]):i + 1])\n                min_strings.append(current_string)\n\n        return len(min_strings)\n\n    N = int(input())\n    products = [input().strip() for _ in range(N)]\n    print(find_min_strings(products))"
        ]
    },
    {
        "question_id": "abc374_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if S.endswith('san'):\n        print('Yes')\n    else:\n        print('No')\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc374_e",
        "code_list": [
            "import sys\nfrom bisect import bisect_right\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    X = int(data[1])\n    index = 2\n    \n    processes = []\n    for _ in range(N):\n        A = int(data[index])\n        P = int(data[index + 1])\n        B = int(data[index + 2])\n        Q = int(data[index + 3])\n        processes.append((A, P, B, Q))\n        index += 4\n    \n    # Calculate the production capacity for each machine type\n    def calculate_capacity(A, P, B, Q, X):\n        max_capacity = 0\n        for i in range(X // P + 1):\n            remaining_budget = X - i * P\n            if remaining_budget >= 0:\n                num_B = remaining_budget // Q\n                capacity = min(A * i + B * num_B, (A + B) * (X // (P + Q)))\n                max_capacity = max(max_capacity, capacity)\n        return max_capacity\n    \n    capacities = []\n    for A, P, B, Q in processes:\n        capacities.append(calculate_capacity(A, P, B, Q, X))\n    \n    # Binary search for the maximum achievable production capacity\n    left, right = 0, min(capacities)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if any(mid <= cap for cap in capacities):\n            left = mid\n        else:\n            right = mid - 1\n    \n    print(left)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc375_e",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    N = int(input())\n    people = []\n    for _ in range(N):\n        A, B = map(int, input().split())\n        people.append((A, B))\n    \n    total_strength = sum(B for _, B in people)\n    if total_strength % 3 != 0:\n        print(-1)\n        return\n    \n    target_strength = total_strength // 3\n    team_strengths = [0] * 3\n    valid_combinations = []\n\n    # Generate all possible ways to split the people into three teams\n    for i in range(1, N):\n        for comb in combinations(range(N), i):\n            teams = [[], [], []]\n            for j in range(N):\n                if j in comb:\n                    teams[0].append(j)\n                else:\n                    teams[1].append(j)\n            teams[2] = list(set(range(N)) - set(comb))\n            valid_combinations.append(teams)\n\n    min_switches = float('inf')\n\n    for teams in valid_combinations:\n        for perm in permutations([0, 1, 2]):\n            new_teams = [0] * 3\n            for i, team in enumerate(teams):\n                for person in team:\n                    new_teams[perm[i]] += people[person][1]\n            if new_teams[0] == new_teams[1] == new_teams[2] == target_strength:\n                switches = sum(len(team) for team in teams if team)\n                min_switches = min(min_switches, switches)\n                break\n\n    print(min_switches if min_switches != float('inf') else -1)\n\nfrom itertools import permutations"
        ]
    },
    {
        "question_id": "abc375_b",
        "code_list": [
            "import math\n\ndef calculate_total_cost():\n    N = int(input())\n    points = [(0, 0)] + [tuple(map(int, input().split())) for _ in range(N)] + [(0, 0)]\n    total_cost = 0.0\n    \n    for i in range(1, N + 2):\n        x1, y1 = points[i - 1]\n        x2, y2 = points[i]\n        total_cost += math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    calculate_total_cost()"
        ]
    },
    {
        "question_id": "abc375_c",
        "code_list": [
            "def main():\n    import sys\n    \n    def process_grid(N, grid):\n        for i in range(N // 2):\n            for x in range(i + 1, N - i):\n                y = N + 1 - x\n                grid[x][N - 1 - i], grid[y][i] = grid[y][i], grid[x][N - 1 - i]\n        \n        return grid\n    \n    N = int(input())\n    grid = [list(input().strip()) for _ in range(N)]\n    \n    processed_grid = process_grid(N, grid)\n    \n    for row in processed_grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc375_a",
        "code_list": [
            "def main():\n    N = int(input())\n    S = input()\n    count = 0\n    for i in range(N - 2):\n        if S[i] == '#' and S[i + 1] == '.' and S[i + 2] == '#':\n            count += 1\n    print(count)"
        ]
    },
    {
        "question_id": "abc375_d",
        "code_list": [
            "def count_palindrome_triples(S):\n    n = len(S)\n    count = 0\n    \n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            if S[i] == S[j]:\n                for k in range(j + 1, n):\n                    if S[j] == S[k] and S[i] == S[k]:\n                        count += 1\n                        \n    return count\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(count_palindrome_triples(S))"
        ]
    },
    {
        "question_id": "abc375_g",
        "code_list": [
            "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\ndef solve(N, M, roads):\n    # Build the graph for all roads\n    graph_all = defaultdict(list)\n    for a, b, c in roads:\n        graph_all[a-1].append((b-1, c))\n        graph_all[b-1].append((a-1, c))\n    \n    # Calculate the shortest path from city 1 to city N with all roads\n    dist_all = dijkstra(N, graph_all, 0)\n    if dist_all[N-1] == float('inf'):\n        raise ValueError(\"City N cannot be reached from city 1 with all roads\")\n    \n    # Check each road\n    results = []\n    for i in range(M):\n        a, b, c = roads[i]\n        # Remove the current road from the graph\n        graph = graph_all.copy()\n        graph[a-1].remove((b-1, c))\n        graph[b-1].remove((a-1, c))\n        \n        # Calculate the shortest path from city 1 to city N without the current road\n        dist_no_i = dijkstra(N, graph, 0)\n        if dist_no_i[N-1] == float('inf'):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\" if dist_no_i[N-1] == dist_all[N-1] else \"Yes\")\n    \n    return results\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(M)]\n    results = solve(N, M, roads)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc375_f",
        "code_list": [
            "from collections import defaultdict\nimport heapq\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef main():\n    n, m, q = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        graph[a-1].append((b-1, c))\n        graph[b-1].append((a-1, c))\n    \n    closed_roads = set()\n    results = {}\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            i = query[1] - 1\n            closed_roads.add(i)\n            # Update the graph by removing the closed road\n            a, b, c = i // 2 + 1, i % 2 + 1, 1\n            graph[a-1].remove((b-1, c))\n            graph[b-1].remove((a-1, c))\n        else:\n            x, y = query[1] - 1, query[2] - 1\n            if (x, y) in results:\n                print(results[(x, y)])\n            else:\n                # Rebuild the graph with open roads\n                new_graph = defaultdict(list)\n                for u in range(n):\n                    for v, w in graph[u]:\n                        if (u, v) not in closed_roads and (v, u) not in closed_roads:\n                            new_graph[u].append((v, w))\n                \n                dist = dijkstra(new_graph, x)\n                result = dist[y] if dist[y] != float('inf') else -1\n                results[(x, y)] = result\n                print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_b",
        "code_list": [
            "def min_operations_to_follow_instructions():\n    # Read input\n    N, Q = map(int, input().split())\n    \n    # Initialize the positions of the left and right hands\n    l_pos = 1\n    r_pos = 2\n    \n    # Dictionary to store the minimum operations needed to reach each position\n    min_ops = {1: 0, 2: 0}\n    \n    # Process each instruction\n    total_ops = 0\n    for _ in range(Q):\n        H, T = input().split()\n        T = int(T)\n        \n        # Calculate the current positions of the hands\n        if H == 'L':\n            current_pos = l_pos\n            other_pos = r_pos\n        else:\n            current_pos = r_pos\n            other_pos = l_pos\n        \n        # Determine the target position and calculate the minimum operations\n        if H == 'L':\n            if T < current_pos:\n                ops = abs(current_pos - T) + 1\n            else:\n                ops = abs(current_pos - T) + (N - 1)\n        else:\n            if T < current_pos:\n                ops = abs(current_pos - T) + 1\n            else:\n                ops = abs(current_pos - T) + (N - 1)\n        \n        # Update the positions and total operations\n        if H == 'L':\n            l_pos = T\n        else:\n            r_pos = T\n        total_ops += ops\n    \n    print(total_ops)\n\nif __name__ == \"__main__\":\n    min_operations_to_follow_instructions()"
        ]
    },
    {
        "question_id": "abc376_d",
        "code_list": [
            "from collections import defaultdict, deque\n\ndef find_min_cycle_length():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n\n    # Initialize distances and parent arrays\n    dist = [float('inf')] * (n + 1)\n    parent = [-1] * (n + 1)\n    dist[1] = 0\n\n    # BFS to find the shortest cycle containing vertex 1\n    queue = deque([1])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if dist[neighbor] == float('inf'):\n                dist[neighbor] = dist[node] + 1\n                parent[neighbor] = node\n                queue.append(neighbor)\n            elif parent[node] != neighbor and parent[neighbor] != node:\n                # Found a cycle\n                cycle_length = dist[node] + dist[neighbor] + 1\n                print(cycle_length)\n                return\n    print(-1)\n\nif __name__ == \"__main__\":\n    find_min_cycle_length()"
        ]
    },
    {
        "question_id": "abc376_g",
        "code_list": [
            "from collections import defaultdict\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve_case():\n    n = int(input())\n    parents = list(map(int, input().split()))\n    probabilities = list(map(int, input().split()))\n    \n    # Calculate total probability\n    total_prob = sum(probabilities)\n    \n    # Initialize dp array where dp[i] will store the expected number of operations to search vertex i\n    dp = [0] * (n + 1)\n    \n    # Function to calculate the expected number of operations using dynamic programming\n    def dfs(node):\n        if node == 0:\n            return 0\n        parent = parents[node]\n        if dp[parent] == 0:\n            dfs(parent)\n        prob_sum = sum(probabilities[child] for child in children if dp[child] != 0)\n        dp[node] = dp[parent] + (probabilities[node] * total_prob) // prob_sum\n    \n    # Build the adjacency list for the tree\n    children = defaultdict(list)\n    for i in range(1, n):\n        children[parents[i]].append(i)\n    \n    # Start DFS from the root\n    dfs(0)\n    \n    # Return the expected number of operations for the root (vertex 0)\n    return dp[0] % 998244353\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        print(solve_case())\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc376_a",
        "code_list": [
            "def main():\n    N, C = map(int, input().split())\n    T = list(map(int, input().split()))\n    last_candy_time = -C\n    candies_received = 0\n    \n    for t in T:\n        if t - last_candy_time >= C:\n            candies_received += 1\n            last_candy_time = t\n    \n    print(candies_received)"
        ]
    },
    {
        "question_id": "abc376_f",
        "code_list": [
            "def min_operations_to_follow_instructions(N, Q):\n    # Initialize the positions of the left and right hands\n    left_hand_pos = 1\n    right_hand_pos = 2\n    \n    # Dictionary to store the minimum operations needed to reach each part\n    min_ops = {1: 0, 2: 0}\n    \n    for _ in range(Q):\n        H, T = input().split()\n        T = int(T)\n        \n        # Calculate the current position of the hand to move\n        if H == 'L':\n            current_hand_pos = left_hand_pos\n            target_hand_pos = right_hand_pos\n            opposite_hand_pos = left_hand_pos\n        else:\n            current_hand_pos = right_hand_pos\n            target_hand_pos = left_hand_pos\n            opposite_hand_pos = right_hand_pos\n        \n        # Calculate the minimum operations needed to move to the target part\n        if current_hand_pos < target_hand_pos:\n            min_ops[target_hand_pos] = min(min_ops[target_hand_pos], min_ops[current_hand_pos] + abs(target_hand_pos - current_hand_pos))\n        else:\n            min_ops[target_hand_pos] = min(min_ops[target_hand_pos], min_ops[current_hand_pos] + N - abs(target_hand_pos - current_hand_pos))\n        \n        # Update the position of the hand to move\n        if H == 'L':\n            left_hand_pos = T\n        else:\n            right_hand_pos = T\n    \n    # Return the sum of the minimum operations needed to reach each target part\n    return sum(min_ops.values())\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    print(min_operations_to_follow_instructions(N, Q))"
        ]
    },
    {
        "question_id": "abc376_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def find_min_box(N, A, B):\n        left, right = 1, max(A)\n        while left < right:\n            mid = (left + right) // 2\n            placed_toys = [0] * N\n            for i in range(N - 1):\n                if B[i] >= mid:\n                    placed_toys[i] = 1\n            count = sum(placed_toys)\n            for i in range(N - 1):\n                if B[i] >= mid:\n                    continue\n                for j in range(i + 1, N - 1):\n                    if B[j] >= mid - A[i]:\n                        placed_toys[j] = 1\n                        count += 1\n                        break\n            if count >= N:\n                right = mid\n            else:\n                left = mid + 1\n        return left if left <= max(A) else -1\n\n    N = data[0]\n    A = data[1:N + 1]\n    B = data[N + 1:2 * N]\n\n    print(find_min_box(N, A, B))"
        ]
    },
    {
        "question_id": "abc376_e",
        "code_list": [
            "from heapq import heappush, heappop\n\ndef min_expression_value():\n    T = int(input())\n    \n    results = []\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        # Create a min heap to keep track of the smallest elements in S\n        min_heap = []\n        total_B = 0\n        max_A = float('-inf')\n        \n        # Initialize the heap with the first K elements\n        for i in range(K):\n            heappush(min_heap, (B[i], A[i]))\n            total_B += B[i]\n            max_A = max(max_A, A[i])\n        \n        # Calculate the initial value of the expression\n        current_value = max_A * total_B\n        \n        # Process the remaining elements\n        for i in range(K, N):\n            B_i, A_i = min_heap[0]\n            if B[i] > B_i:\n                total_B -= B_i\n                total_B += B[i]\n                heappop(min_heap)\n                heappush(min_heap, (B[i], A[i]))\n                max_A = max(max_A, A[i])\n                current_value = min(current_value, max_A * total_B)\n        \n        results.append(current_value)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    min_expression_value()"
        ]
    },
    {
        "question_id": "abc377_c",
        "code_list": [
            "def count_safe_squares(N, M, positions):\n    # Initialize a set to keep track of all squares that can be captured\n    captured_squares = set()\n    \n    # Add all possible capturing squares for each existing piece\n    for a, b in positions:\n        if a + 2 <= N and b + 1 <= N:\n            captured_squares.add((a + 2, b + 1))\n        if a + 1 <= N and b + 2 <= N:\n            captured_squares.add((a + 1, b + 2))\n        if a - 1 >= 1 and b + 2 <= N:\n            captured_squares.add((a - 1, b + 2))\n        if a - 2 >= 1 and b + 1 <= N:\n            captured_squares.add((a - 2, b + 1))\n        if a - 2 >= 1 and b - 1 >= 1:\n            captured_squares.add((a - 2, b - 1))\n        if a - 1 >= 1 and b - 2 >= 1:\n            captured_squares.add((a - 1, b - 2))\n        if a + 1 <= N and b - 2 >= 1:\n            captured_squares.add((a + 1, b - 2))\n        if a + 2 <= N and b - 1 >= 1:\n            captured_squares.add((a + 2, b - 1))\n    \n    # Calculate the total number of empty squares\n    total_squares = N * N\n    \n    # Subtract the number of captured squares from the total\n    safe_squares = total_squares - len(captured_squares)\n    \n    return safe_squares\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    positions = [tuple(map(int, input().split())) for _ in range(M)]\n    print(count_safe_squares(N, M, positions))"
        ]
    },
    {
        "question_id": "abc377_b",
        "code_list": [
            "def main():\n    # Initialize sets to store rows and columns with pieces\n    rows_with_pieces = set()\n    cols_with_pieces = set()\n    \n    # Read the grid input\n    grid = [input().strip() for _ in range(8)]\n    \n    # Identify rows and columns with pieces\n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '#':\n                rows_with_pieces.add(i)\n                cols_with_pieces.add(j)\n    \n    # Calculate the number of valid empty squares\n    valid_squares = 0\n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '.' and i not in rows_with_pieces and j not in cols_with_pieces:\n                valid_squares += 1\n    \n    print(valid_squares)"
        ]
    },
    {
        "question_id": "abc377_a",
        "code_list": [
            "def main():\n    S = input().strip()\n    if set(S) == {'A', 'B', 'C'}:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_g",
        "code_list": [
            "from collections import defaultdict\n\ndef lcs(s1, s2):\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[len(s1)][len(s2)]\n\ndef main():\n    N = int(input())\n    strings = [input() for _ in range(N)]\n    \n    # Compute the longest common subsequence lengths between all pairs\n    lcs_lengths = defaultdict(int)\n    for i in range(N):\n        for j in range(i):\n            lcs_lengths[(i, j)] = lcs(strings[i], strings[j])\n            lcs_lengths[(j, i)] = lcs(strings[j], strings[i])\n    \n    # Precompute the minimum cost to make a string empty or match another string\n    min_costs = [0] * N\n    for i in range(N):\n        min_costs[i] = len(strings[i])\n        for j in range(i):\n            min_costs[i] = min(min_costs[i], len(strings[i]) - lcs_lengths[(i, j)])\n    \n    # Process each query\n    for i in range(N):\n        print(min_costs[i])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_f",
        "code_list": [
            "def count_safe_squares(N, M, pieces):\n    # Initialize sets to keep track of rows, columns, and diagonals\n    rows = set()\n    cols = set()\n    diag1 = set()  # i + j = constant\n    diag2 = set()  # i - j = constant\n    \n    # Populate the sets with occupied rows, columns, and diagonals\n    for a, b in pieces:\n        rows.add(a)\n        cols.add(b)\n        diag1.add(a + b)\n        diag2.add(a - b)\n    \n    # Calculate the number of safe squares\n    total_squares = N * N\n    occupied_squares = len(rows) + len(cols) + len(diag1) + len(diag2) - 3 * M\n    return total_squares - occupied_squares\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    pieces = [tuple(map(int, input().split())) for _ in range(M)]\n    print(count_safe_squares(N, M, pieces))"
        ]
    },
    {
        "question_id": "abc377_e",
        "code_list": [
            "def find_cycle_length(n, k, permutation):\n    visited = [False] * n\n    cycle_lengths = []\n    \n    for i in range(n):\n        if not visited[i]:\n            cycle_start = i\n            current = i\n            cycle_length = 0\n            \n            while not visited[current]:\n                visited[current] = True\n                current = permutation[current] - 1\n                cycle_length += 1\n            \n            cycle_lengths.append((cycle_start, cycle_length))\n    \n    result = list(permutation)\n    for start, length in cycle_lengths:\n        if k >= length:\n            k %= length\n            if k == 0:\n                k = length\n        \n        current = start\n        for _ in range(k):\n            result[start], result[current] = result[current], result[start]\n            start = current\n            current = permutation[current] - 1\n    \n    return result\n\ndef main():\n    n, k = map(int, input().split())\n    permutation = list(map(int, input().split()))\n    \n    result = find_cycle_length(n, k, permutation)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc377_d",
        "code_list": [
            "from typing import List\n\ndef count_valid_pairs(N: int, M: int, intervals: List[List[int]]) -> int:\n    events = []\n    for L, R in intervals:\n        events.append((L, -1))  # Start of interval\n        events.append((R + 1, 1))  # End of interval\n    \n    events.sort()\n    \n    active_intervals = 0\n    total_pairs = 0\n    last_end = 0\n    \n    for pos, change in events:\n        if active_intervals > 0:\n            total_pairs += (pos - last_end) * (M - pos + 1)\n        \n        active_intervals += change\n        last_end = pos\n    \n    valid_pairs = (M + 1) * M // 2 - total_pairs\n    return valid_pairs\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    intervals = [list(map(int, input().split())) for _ in range(N)]\n    print(count_valid_pairs(N, M, intervals))"
        ]
    },
    {
        "question_id": "abc378_e",
        "code_list": [
            "from itertools import accumulate\nfrom collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    \n    # Calculate prefix sums and their remainders when divided by M\n    prefix_sums = [0] + list(accumulate(A))\n    remainder_counts = defaultdict(int)\n    total_sum = 0\n    \n    for r in range(N + 1):\n        current_sum = prefix_sums[r]\n        remainder = current_sum % M\n        \n        # Add the contribution of this remainder to the total sum\n        total_sum += remainder * (remainder_counts[(M - remainder) % M] + 1)\n        \n        # Update the count of this remainder\n        remainder_counts[remainder] += 1\n    \n    print(total_sum)"
        ]
    },
    {
        "question_id": "abc378_d",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, start, K):\n    H, W = len(grid), len(grid[0])\n    visited = set([start])\n    queue = deque([(start, 1)])\n    count = 0\n    \n    while queue:\n        (x, y), steps = queue.popleft()\n        if steps == K + 1:\n            count += 1\n            continue\n        \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '.' and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append(((nx, ny), steps + 1))\n                visited.remove((nx, ny))\n    \n    return count\n\ndef count_paths(H, W, K, grid):\n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                count += bfs(grid, (i, j), K)\n    return count\n\nif __name__ == \"__main__\":\n    H, W, K = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    print(count_paths(H, W, K, grid))"
        ]
    },
    {
        "question_id": "abc378_b",
        "code_list": [
            "def lcm(a, b):\n    from math import gcd\n    return a * b // gcd(a, b)\n\ndef find_next_collection_day(q, r, d):\n    while d % q != r:\n        d += 1\n    return d\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    qs = list(map(int, data[1:N+1:2]))\n    rs = list(map(int, data[2:N+2:2]))\n    Q = int(data[N+2])\n    ts = list(map(int, data[N+3:N+3+Q]))\n    ds = list(map(int, data[N+3+Q::]))\n    \n    results = []\n    for i in range(Q):\n        t = ts[i]\n        d = ds[i]\n        q = qs[t-1]\n        r = rs[t-1]\n        results.append(find_next_collection_day(q, r, d))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_f",
        "code_list": [
            "from collections import defaultdict\n\ndef find_root_and_degrees(edges):\n    degree = defaultdict(int)\n    for u, v in edges:\n        degree[u] += 1\n        degree[v] += 1\n    root = next(node for node, d in degree.items() if d > 1)\n    return root, degree\n\ndef dfs(node, parent, edges, degree, visited, cycle_nodes):\n    visited[node] = True\n    if degree[node] == 3:\n        cycle_nodes.add(node)\n    for neighbor in edges[node]:\n        if neighbor != parent and not visited[neighbor]:\n            dfs(neighbor, node, edges, degree, visited, cycle_nodes)\n\ndef count_valid_graphs(n, edges):\n    root, degree = find_root_and_degrees(edges)\n    edges_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        edges_list[u].append(v)\n        edges_list[v].append(u)\n    \n    visited = [False] * (n + 1)\n    cycle_nodes = set()\n    dfs(root, -1, edges_list, degree, visited, cycle_nodes)\n    \n    valid_count = 0\n    for node in cycle_nodes:\n        neighbors = edges_list[node]\n        if len(neighbors) == 3:\n            valid_count += 1\n    \n    # If there's more than one node in the cycle, we can add edges between any two nodes in the cycle\n    if len(cycle_nodes) > 1:\n        valid_count = max(0, valid_count - 1)  # Subtract one because adding an edge between two nodes in the cycle is counted twice\n    \n    return valid_count\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    print(count_valid_graphs(n, edges))"
        ]
    },
    {
        "question_id": "abc378_g",
        "code_list": [
            "from math import comb\n\ndef main():\n    A, B, M = map(int, input().split())\n    if A > B:\n        A, B = B, A\n\n    def count_permutations(A, B, M):\n        if A == 1 or B == 1:\n            return 0\n        if A == B:\n            return comb((A-1)*(B-1), A-1) % M\n        else:\n            return 0\n\n    result = count_permutations(A, B, M)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc378_a",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    # Read input\n    A = list(map(int, input().split()))\n    \n    # Count the occurrences of each color\n    color_counts = Counter(A)\n    \n    # Calculate the maximum number of operations\n    max_operations = sum(count // 2 for count in color_counts.values())\n    \n    # Print the result\n    print(max_operations)"
        ]
    },
    {
        "question_id": "abc378_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    last_seen = {}\n    result = []\n    \n    for i in range(n):\n        if a[i] in last_seen:\n            result.append(last_seen[a[i]])\n        else:\n            result.append(-1)\n        last_seen[a[i]] = i\n    \n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_b",
        "code_list": [
            "def main():\n    N, K = map(int, input().split())\n    S = input()\n    max_strawberries = 0\n    i = 0\n    while i <= N - K:\n        count = 0\n        for j in range(i, i + K):\n            if S[j] == 'O':\n                count += 1\n            else:\n                break\n        if count == K:\n            max_strawberries += 1\n            i += K\n        else:\n            i += count\n    print(max_strawberries)"
        ]
    },
    {
        "question_id": "abc379_e",
        "code_list": [
            "def main():\n    import sys\n    \n    def f(i, j):\n        return int(S[i-1:j])\n    \n    N = int(input())\n    S = input()\n    \n    total_sum = 0\n    for i in range(1, N+1):\n        for j in range(i, N+1):\n            total_sum += f(i, j+1)\n    \n    print(total_sum)"
        ]
    },
    {
        "question_id": "abc379_c",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    X = list(map(int, data[2:2*M:2]))\n    A = list(map(int, data[3:2*M:2]))\n    \n    total_stones = sum(A)\n    if total_stones != N:\n        print(-1)\n        return\n    \n    positions = [0] * (N + 1)\n    for i in range(M):\n        positions[X[i]] += A[i]\n    \n    current_position = 1\n    operations = 0\n    for i in range(1, N + 1):\n        if positions[i] > 0:\n            required_stones = positions[i]\n            while required_stones > 0:\n                if current_position < i:\n                    operations += i - current_position\n                    current_position = i\n                required_stones -= 1\n                if current_position < N:\n                    current_position += 1\n    \n    print(operations)"
        ]
    },
    {
        "question_id": "abc379_d",
        "code_list": [
            "from collections import deque\n\ndef main():\n    Q = int(input())\n    events = []\n    for _ in range(Q):\n        events.append(list(map(int, input().split())))\n    \n    # Process events\n    plants = deque()\n    for event in events:\n        if event[0] == 1:\n            plants.append((0, 0))  # (height, day)\n        elif event[0] == 2:\n            day_increase = event[1]\n            while plants and plants[0][1] < day_increase:\n                plants[0] = (plants[0][0] + day_increase, day_increase)\n                day_increase = max(day_increase - 1, 0)\n            if day_increase > 0:\n                plants.appendleft((day_increase, day_increase))\n        else:\n            harvest_height = event[1]\n            harvested_count = 0\n            while plants and plants[0][0] >= harvest_height:\n                harvested_count += 1\n                plants.popleft()\n            print(harvested_count)"
        ]
    },
    {
        "question_id": "abc379_g",
        "code_list": [
            "from functools import lru_cache\n\ndef main():\n    H, W = map(int, input().split())\n    S = [input() for _ in range(H)]\n    \n    MOD = 998244353\n    \n    @lru_cache(None)\n    def dfs(i, j, prev):\n        if i == H:\n            return 1\n        res = 0\n        if j == W:\n            return dfs(i + 1, 0, -1)\n        if S[i][j] == '?':\n            for d in [1, 2, 3]:\n                if d != prev:\n                    res += dfs(i, j + 1, d)\n                    res %= MOD\n        else:\n            if S[i][j] != str(prev):\n                res += dfs(i, j + 1, int(S[i][j]))\n                res %= MOD\n        return res\n    \n    print(dfs(0, 0, -1))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc379_f",
        "code_list": [
            "from typing import List\n\ndef find_visible_buildings(N: int, heights: List[int], queries: List[List[int]]) -> List[int]:\n    def get_visible_buildings(building: int) -> List[int]:\n        visible = []\n        stack = []\n        for i, h in enumerate(heights[building:], building):\n            while stack and heights[stack[-1]] <= h:\n                stack.pop()\n            if stack:\n                visible.append(i - stack[-1] - 1)\n            stack.append(i)\n        return visible\n    \n    results = []\n    for l, r in queries:\n        visible_l = get_visible_buildings(l - 1)\n        visible_r = get_visible_buildings(r - 1)[::-1]\n        \n        count = 0\n        for i in range(len(visible_l)):\n            if i >= len(visible_r):\n                break\n            if visible_l[i] == visible_r[i]:\n                count += 1\n            else:\n                break\n        \n        results.append(count)\n    \n    return results\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    heights = list(map(int, input().split()))\n    queries = [list(map(int, input().split())) for _ in range(Q)]\n    \n    results = find_visible_buildings(N, heights, queries)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc379_a",
        "code_list": [
            "def main():\n    N = int(input())\n    a = N // 100\n    b = (N // 10) % 10\n    c = N % 10\n    print(b * 100 + c * 10 + a, c * 100 + a * 10 + b)"
        ]
    },
    {
        "question_id": "abc380_e",
        "code_list": [
            "from collections import defaultdict, deque\n\ndef main():\n    N, Q = map(int, input().split())\n    \n    # Initialize the graph and color counts\n    graph = defaultdict(list)\n    color_counts = [0] * (N + 1)\n    for i in range(1, N + 1):\n        color_counts[i] = 1\n    \n    # Process queries\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n        if query[0] == 1:\n            x, c = query[1], query[2]\n            queue = deque([x])\n            while queue:\n                current = queue.popleft()\n                if color_counts[current] != c:\n                    continue\n                color_counts[current] = c\n                for neighbor in graph[current]:\n                    if color_counts[neighbor] == c:\n                        queue.append(neighbor)\n        elif query[0] == 2:\n            c = query[1]\n            print(sum(color_counts[i] == c for i in range(1, N + 1)))\n    \n    # Build the graph based on initial colors\n    for i in range(1, N):\n        if color_counts[i] == color_counts[i + 1]:\n            graph[i].append(i + 1)\n            graph[i + 1].append(i)"
        ]
    },
    {
        "question_id": "abc380_f",
        "code_list": [
            "def determine_winner(N, M, L, A, B, C):\n    # Combine all cards into a single sorted list\n    all_cards = sorted(A + B + C)\n    \n    # Function to count the number of valid moves for a player\n    def count_valid_moves(cards, table):\n        return sum(1 for card in cards if any(table_card < card for table_card in table))\n    \n    # Initialize the table with the initial cards on the table\n    table = []\n    \n    # Determine the winner based on the parity of the number of valid moves\n    while True:\n        # Takahashi's turn\n        if count_valid_moves(A, table) > 0:\n            # Take the smallest card from A that has a valid move\n            A.sort(reverse=True)\n            card = A.pop()\n            table.append(card)\n            A.remove(card)\n            # Update the table and check for valid moves\n            table = sorted(table)\n            if count_valid_moves(B, table) == 0:\n                return \"Takahashi\"\n        else:\n            break\n        \n        # Aoki's turn\n        if count_valid_moves(B, table) > 0:\n            # Take the smallest card from B that has a valid move\n            B.sort(reverse=True)\n            card = B.pop()\n            table.append(card)\n            B.remove(card)\n            # Update the table and check for valid moves\n            table = sorted(table)\n            if count_valid_moves(A, table) == 0:\n                return \"Aoki\"\n        else:\n            break\n    \n    # If no more valid moves for either player, the player whose turn it is loses\n    if len(A) == 0:\n        return \"Aoki\"\n    else:\n        return \"Takahashi\"\n\nif __name__ == \"__main__\":\n    N, M, L = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    print(determine_winner(N, M, L, A, B, C))"
        ]
    },
    {
        "question_id": "abc380_c",
        "code_list": [
            "def main():\n    # Read input\n    N, K = map(int, input().split())\n    S = input()\n\n    # Find the positions of all 1-blocks\n    block_positions = []\n    l = None\n    for i in range(N):\n        if S[i] == '1':\n            if l is None:\n                l = i\n        elif l is not None:\n            block_positions.append((l, i - 1))\n            l = None\n    \n    # Handle the last 1-block\n    if l is not None:\n        block_positions.append((l, N - 1))\n\n    # Extract the positions of the (K-1)-th and K-th 1-blocks\n    r_k_minus_1, r_k = block_positions[K - 1][1], block_positions[K][1]\n\n    # Construct the resulting string T\n    T = list(S)\n    T[r_k_minus_1 + 1:r_k_minus_1 + 1 + (r_k - r_k_minus_1)] = ['1'] * (r_k - r_k_minus_1)\n    del T[r_k:r_k + 1 + (r_k - r_k_minus_1)]\n\n    # Join the list into a string and print\n    print(''.join(T))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_d",
        "code_list": [
            "def main():\n    def transform(s):\n        return s.swapcase()\n\n    def get_final_string_length(s):\n        n = len(s)\n        return n * (2 ** (100 + 1) - 2) // 2\n\n    def find_kth_char(s, k):\n        final_len = get_final_string_length(s)\n        if k <= len(s):\n            return s[k - 1]\n        else:\n            k -= len(s)\n            period = 2 ** (100 + 1) - 2\n            offset = (k - 1) % period\n            return transform(s)[offset]\n\n    s = input().strip()\n    q = int(input().strip())\n    k_values = list(map(int, input().strip().split()))\n\n    result = [find_kth_char(s, k) for k in k_values]\n    print(' '.join(result))"
        ]
    },
    {
        "question_id": "abc380_a",
        "code_list": [
            "def main():\n    N = int(input())\n    count_1 = str(N).count('1')\n    count_2 = str(N).count('2')\n    count_3 = str(N).count('3')\n    \n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_g",
        "code_list": [
            "from math import comb\n\ndef main():\n    N, K = map(int, input().split())\n    P = list(map(int, input().split()))\n    \n    # Calculate the initial inversion number\n    inv = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if P[i] > P[j]:\n                inv += 1\n    \n    # Calculate the expected change in inversion number\n    exp_change = 0\n    for i in range(1, K + 1):\n        exp_change += (comb(K, i) * comb(N - K, i) * i * (i - 1) // 2) % 998244353\n        exp_change -= (comb(K, i) * comb(N - K, i) * i) % 998244353\n        exp_change += 998244353\n    \n    exp_change %= 998244353\n    \n    # Expected value of the inversion number\n    exp_inv = (inv + exp_change) % 998244353\n    \n    # Since we need the result modulo 998244353, the result is already in the required form\n    print(exp_inv)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc380_b",
        "code_list": [
            "def main():\n    S = input().strip()\n    result = []\n    i = 1\n    while i < len(S):\n        count = 0\n        while i < len(S) and S[i] != '|':\n            count += 1\n            i += 1\n        result.append(count)\n        i += 1\n    print(*result)"
        ]
    },
    {
        "question_id": "abc381_a",
        "code_list": [
            "def is_11_22_string(N, S):\n    # Check if the length of the string is odd\n    if N % 2 == 0:\n        return \"No\"\n    \n    # Calculate the middle index\n    mid_index = N // 2\n    \n    # Check the first half of the string\n    for i in range(mid_index):\n        if S[i] != '1':\n            return \"No\"\n    \n    # Check the middle character\n    if S[mid_index] != '/':\n        return \"No\"\n    \n    # Check the second half of the string\n    for i in range(mid_index + 1, N):\n        if S[i] != '2':\n            return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input().strip()\n    print(is_11_22_string(N, S))"
        ]
    },
    {
        "question_id": "abc381_e",
        "code_list": [
            "def find_max_1122_subsequence_length(N, S, queries):\n    def is_1122_subsequence(subseq):\n        mid = len(subseq) // 2\n        if subseq[:mid].count('1') != mid - 1 or subseq[mid] != '/' or subseq[mid+1:].count('2') != mid:\n            return False\n        return True\n\n    def max_1122_length(L, R):\n        substring = S[L-1:R]\n        max_len = 0\n        for i in range(len(substring)):\n            for j in range(i, len(substring)):\n                if is_1122_subsequence(substring[i:j+1]):\n                    max_len = max(max_len, j - i + 1)\n        return max_len\n\n    results = []\n    for L, R in queries:\n        results.append(max_1122_length(L, R))\n    return results\n\nif __name__ == \"__main__\":\n    N, Q = map(int, input().split())\n    S = input().strip()\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n    results = find_max_1122_subsequence_length(N, S, queries)\n    for result in results:\n        print(result)"
        ]
    },
    {
        "question_id": "abc381_b",
        "code_list": [
            "from collections import Counter\n\ndef is_1122_string(S):\n    # Check if the length of S is even\n    if len(S) % 2 != 0:\n        return \"No\"\n    \n    # Count the occurrences of each character\n    char_count = Counter(S)\n    \n    # Check if each character appears exactly zero or two times\n    for count in char_count.values():\n        if count not in [0, 2]:\n            return \"No\"\n    \n    # Check if the string satisfies the second condition\n    for i in range(1, len(S) // 2 + 1):\n        if S[2 * i - 2] != S[2 * i - 1]:\n            return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(is_1122_string(S))"
        ]
    },
    {
        "question_id": "abc381_c",
        "code_list": [
            "def find_max_1122_substring_length(N, S):\n    max_length = 0\n    current_length = 0\n    found_slash = False\n    \n    for i in range(N):\n        if S[i] == '1':\n            current_length += 1\n        elif S[i] == '/':\n            if current_length % 2 == 0 or current_length == 0:\n                current_length = 0\n                found_slash = True\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 1\n                found_slash = True\n        else:  # S[i] == '2'\n            if current_length % 2 == 1 and found_slash:\n                max_length = max(max_length, current_length)\n                current_length = 0\n                found_slash = False\n            else:\n                current_length = 0\n        \n        if i == N - 1 and current_length > 0 and found_slash:\n            max_length = max(max_length, current_length)\n    \n    return max_length * 2 - 1\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = input().strip()\n    print(find_max_1122_substring_length(N, S))"
        ]
    },
    {
        "question_id": "abc381_d",
        "code_list": [
            "from collections import defaultdict\n\ndef find_max_length_subarray(A):\n    n = len(A)\n    index_map = defaultdict(lambda: [-1, -1])\n    max_length = 0\n    \n    for i, num in enumerate(A):\n        if index_map[num][0] == -1:\n            index_map[num][0] = i\n        else:\n            index_map[num][1] = i\n            current_length = index_map[num][1] - index_map[num][0]\n            max_length = max(max_length, current_length)\n    \n    return max_length if max_length % 2 == 0 else max_length - 1\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(find_max_length_subarray(A))"
        ]
    },
    {
        "question_id": "abc382_d",
        "code_list": [
            "def generate_sequences(N, M):\n    def backtrack(start, path):\n        if len(path) == N:\n            if path[-1] <= M:\n                result.append(path[:])\n            return\n        for next_val in range(start, min(M - N + len(path) + 1, start + 10) + 1):\n            path.append(next_val)\n            backtrack(next_val + 1, path)\n            path.pop()\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef main():\n    N, M = map(int, input().split())\n    sequences = generate_sequences(N, M)\n    print(len(sequences))\n    for seq in sequences:\n        print(\" \".join(map(str, seq)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_a",
        "code_list": [
            "def main():\n    N, D = map(int, input().split())\n    S = input()\n    # Count the number of cookies\n    cookies = S.count('@')\n    # The number of empty boxes will be the total boxes minus the number of cookies\n    empty_boxes = N - min(cookies, D)\n    print(empty_boxes)"
        ]
    },
    {
        "question_id": "abc382_b",
        "code_list": [
            "def main():\n    N, D = map(int, input().split())\n    S = input()\n    \n    # Find the positions of all cookies\n    cookies = [i for i, char in enumerate(S) if char == '@']\n    \n    # Determine which cookies will be eaten\n    eaten_cookies = set(cookies[:D])\n    \n    # Create the result string\n    result = ['.' if i not in eaten_cookies else '@' for i in range(N)]\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_f",
        "code_list": [
            "def main():\n    H, W, N = map(int, input().split())\n    bars = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    # Determine the final row for each bar\n    for r, c, l in bars:\n        # Calculate how many steps it takes for the bar to reach the bottom\n        steps_to_bottom = H - r\n        # Since we only care about the final position, we can ignore the exact timing\n        # and just calculate the final row based on the steps\n        final_row = r + min(steps_to_bottom, 2)\n        print(final_row)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_g",
        "code_list": [
            "def calculate_min_moves(K, S_x, S_y, T_x, T_y):\n    # Calculate the tile indices for the start and target points\n    S_i, S_j = S_x // K, S_y // K\n    T_i, T_j = T_x // K, T_y // K\n    \n    # Determine the parity of the start and target points\n    S_parity = (S_i + S_j) % 2\n    T_parity = (T_i + T_j) % 2\n    \n    # Check if the start and target points are in the same parity\n    if S_parity == T_parity:\n        # Calculate the distance in terms of tiles\n        dist_i = abs(S_i - T_i)\n        dist_j = abs(S_j - T_j)\n        dist_k = min(abs(S_j - T_j), abs(S_i - T_i))\n        \n        # The minimum number of moves is the sum of distances in i and j directions minus the overlap in k direction\n        return dist_i + dist_j - dist_k\n    else:\n        # If the parities are different, we need to move to an adjacent parity tile first\n        # Calculate the distance to the nearest tile with the opposite parity\n        dist_i = abs(S_i - T_i)\n        dist_j = abs(S_j - T_j)\n        dist_k = min(abs(S_j - T_j), abs(S_i - T_i))\n        \n        # Move to the nearest tile with the opposite parity and then to the target tile\n        return dist_i + dist_j - dist_k + 2\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        K = int(data[index])\n        S_x = int(data[index + 1])\n        S_y = int(data[index + 2])\n        T_x = int(data[index + 3])\n        T_y = int(data[index + 4])\n        index += 5\n        \n        result = calculate_min_moves(K, S_x, S_y, T_x, T_y)\n        results.append(str(result))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc382_c",
        "code_list": [
            "def main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Initialize the result list with -1 for each sushi\n    result = [-1] * M\n\n    # Process each sushi\n    for j, b in enumerate(B):\n        # Find the first person who can eat the sushi\n        for i in range(N):\n            if A[i] >= b:\n                # Update the result and break the loop\n                result[j] = i + 1\n                # Mark the person as taken\n                A[i] = 0\n                break\n\n    # Print the result for each sushi\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc383_c",
        "code_list": [
            "from collections import deque\n\ndef bfs(grid, h, w, d):\n    visited = [[False] * w for _ in range(h)]\n    humidifiers = []\n    \n    # Find all humidifiers\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'H':\n                humidifiers.append((i, j))\n    \n    # Perform BFS from each humidifier\n    for x, y in humidifiers:\n        queue = deque([(x, y, 0)])\n        visited[x][y] = True\n        \n        while queue:\n            x, y, dist = queue.popleft()\n            \n            if dist > d:\n                break\n            \n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < h and 0 <= ny < w and not visited[nx][ny] and grid[nx][ny] != '#':\n                    visited[nx][ny] = True\n                    queue.append((nx, ny, dist + 1))\n    \n    # Count the number of humidified floor cells\n    count = 0\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '.' and visited[i][j]:\n                count += 1\n    \n    return count\n\ndef main():\n    h, w, d = map(int, input().split())\n    grid = [input().strip() for _ in range(h)]\n    print(bfs(grid, h, w, d))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc383_a",
        "code_list": [
            "def main():\n    N = int(input())\n    water_level = 0\n    for _ in range(N):\n        T, V = map(int, input().split())\n        water_level += V\n        water_level -= T - (T if water_level == 0 else max(T - 1, 0))\n    print(water_level)"
        ]
    },
    {
        "question_id": "abc383_e",
        "code_list": [
            "import sys\nfrom heapq import heappush, heappop\n\ndef dijkstra(n, graph, start):\n    dist = [float('inf')] * n\n    dist[start - 1] = 0\n    pq = [(0, start - 1)]\n    while pq:\n        d, u = heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > max(d, w):\n                dist[v] = max(d, w)\n                heappush(pq, (dist[v], v))\n    return dist\n\ndef solve(N, M, K, edges, A, B):\n    # Build the graph\n    graph = [[] for _ in range(N)]\n    for u, v, w in edges:\n        graph[u - 1].append((v - 1, w))\n        graph[v - 1].append((u - 1, w))\n    \n    # Compute the shortest path weights from each A_i to all other vertices\n    dists = []\n    for a in A:\n        dists.append(dijkstra(N, graph, a))\n    \n    # Sort B in descending order of the maximum path weight from A_i to B_i\n    B_sorted = sorted([(b, max(dists[i][b - 1] for i in range(K))) for b in B], key=lambda x: -x[1])\n    \n    # Permute B to minimize the sum of path weights\n    result = 0\n    for i, b in enumerate(B_sorted):\n        result += dists[i][b[0] - 1]\n    \n    return result\n\nif __name__ == \"__main__\":\n    N, M, K = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        u, v, w = map(int, input().split())\n        edges.append((u, v, w))\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    print(solve(N, M, K, edges, A, B))"
        ]
    },
    {
        "question_id": "abc383_b",
        "code_list": [
            "def find_max_humidified_cells(H, W, D, grid):\n    def is_floor(x, y):\n        return grid[x][y] == '.'\n\n    def count_humidified_cells(x1, y1, x2, y2):\n        count = 0\n        for i in range(H):\n            for j in range(W):\n                if is_floor(i, j) and (abs(i - x1) + abs(j - y1) <= D or abs(i - x2) + abs(j - y2) <= D):\n                    count += 1\n        return count\n\n    max_count = 0\n    for i in range(H):\n        for j in range(W):\n            if is_floor(i, j):\n                for k in range(i + 1, H):\n                    for l in range(k + 1, H):\n                        if is_floor(k, l):\n                            for m in range(W):\n                                if is_floor(m, l) and (abs(m - i) + abs(l - j) > D and abs(m - k) + abs(l - l) > D):\n                                    continue\n                                for n in range(W):\n                                    if is_floor(i, n) and (abs(n - j) + abs(i - k) > D and abs(n - l) + abs(i - l) > D):\n                                        continue\n                                    humidified_count = count_humidified_cells(i, j, k, l)\n                                    max_count = max(max_count, humidified_count)\n\n    return max_count\n\nif __name__ == \"__main__\":\n    H, W, D = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    print(find_max_humidified_cells(H, W, D, grid))"
        ]
    },
    {
        "question_id": "abc383_d",
        "code_list": [
            "import math\n\ndef count_numbers_with_nine_divisors(N):\n    count = 0\n    # Iterate through possible base values\n    for base in range(2, int(math.pow(N, 1/8)) + 2):\n        # Check if base^8 is within the limit\n        if base**8 <= N:\n            count += 1\n        # Check if base^4 * p is within the limit, where p is a prime number\n        for p in [2, 3, 5, 7]:\n            if (base**4) * p <= N:\n                count += 1\n            if (base**4) * (p**2) <= N:\n                count += 1\n            if (base**4) * (p**3) <= N:\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(count_numbers_with_nine_divisors(N))"
        ]
    },
    {
        "question_id": "abc384_b",
        "code_list": [
            "def calculate_rating():\n    N, R = map(int, input().split())\n    for _ in range(N):\n        D, A = map(int, input().split())\n        if (1600 <= R + A <= 2799) and D == 1:\n            R += A\n        elif (1200 <= R + A <= 2399) and D == 2:\n            R += A\n    print(R)\n\nif __name__ == \"__main__\":\n    calculate_rating()"
        ]
    },
    {
        "question_id": "abc384_d",
        "code_list": [
            "from itertools import accumulate\n\ndef find_subsequence(N, S, A):\n    # Calculate prefix sums\n    prefix_sums = [0] + list(accumulate(A))\n    \n    # Create a set to store prefix sums modulo N\n    mod_set = set()\n    \n    # Iterate through the prefix sums\n    for i in range(1, N + 1):\n        mod_val = prefix_sums[i] % N\n        mod_set.add(mod_val)\n        \n        # Check if there exists a previous prefix sum such that the difference is S modulo N\n        if (prefix_sums[i] - S) % N in mod_set:\n            return \"Yes\"\n    \n    # Check for the case where the entire sequence sums up to S\n    total_sum = prefix_sums[N]\n    if total_sum == S or (total_sum - S) % N == 0:\n        return \"Yes\"\n    \n    return \"No\"\n\nif __name__ == \"__main__\":\n    N, S = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(find_subsequence(N, S, A))"
        ]
    },
    {
        "question_id": "abc384_g",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def get_prefix_sum(arr):\n        prefix_sum = [0]\n        for num in arr:\n            prefix_sum.append(prefix_sum[-1] + num)\n        return prefix_sum\n\n    N = data[0]\n    A = data[1:N+1]\n    B = data[N+1:2*N+1]\n    prefix_A = get_prefix_sum(A)\n    prefix_B = get_prefix_sum(B)\n\n    K = data[2*N+1]\n    queries = [(data[2*N+2+i*2], data[2*N+2+i*2+1]) for i in range(K)]\n\n    for X, Y in queries:\n        result = prefix_A[X] + prefix_B[Y] - 2 * sum(min(A[i], B[j]) for i in range(X) for j in range(Y))\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_a",
        "code_list": [
            "def main():\n    N, c1, c2 = input().split()\n    S = input().strip()\n    result = ''.join(c2 if char != c1 else char for char in S)\n    print(result)"
        ]
    },
    {
        "question_id": "abc384_e",
        "code_list": [
            "from heapq import heappush, heappop\nfrom collections import deque\n\ndef main():\n    H, W, X = map(int, input().split())\n    P, Q = map(int, input().split())\n    S = [list(map(int, input().split())) for _ in range(H)]\n\n    # Initialize the priority queue with the starting position\n    pq = [(S[P-1][Q-1], P-1, Q-1)]\n    visited = set([(P-1, Q-1)])\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\n    max_strength = S[P-1][Q-1]\n\n    while pq:\n        current_strength, r, c = heappop(pq)\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in visited:\n                new_strength = current_strength + S[nr][nc]\n                if S[nr][nc] < current_strength / X:\n                    visited.add((nr, nc))\n                    heappush(pq, (new_strength, nr, nc))\n                    max_strength = max(max_strength, new_strength)\n\n    print(max_strength)"
        ]
    },
    {
        "question_id": "abc384_f",
        "code_list": [
            "def f(x):\n    while x % 2 == 0:\n        x //= 2\n    return x\n\ndef main():\n    import collections\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Count occurrences of each number\n    count = collections.Counter(A)\n    \n    total_sum = 0\n    \n    # Calculate the contribution of each pair (i, j)\n    for i in range(N):\n        for j in range(i, N):\n            total_sum += f(A[i] + A[j])\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc384_c",
        "code_list": [
            "from itertools import combinations\n\ndef main():\n    # Read input scores\n    a, b, c, d, e = map(int, input().split())\n    \n    # Generate all possible participant names\n    participants = []\n    for r in range(1, 6):\n        for combo in combinations('ABCDE', r):\n            name = ''.join(combo)\n            score = sum([locals()[char] for char in name])\n            participants.append((name, score))\n    \n    # Sort participants by score and then lexicographically\n    participants.sort(key=lambda x: (-x[1], x[0]))\n    \n    # Print the names of the participants\n    for name, _ in participants:\n        print(name)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_f",
        "code_list": [
            "from bisect import bisect_left\n\ndef main():\n    N = int(input())\n    buildings = []\n    for _ in range(N):\n        X, H = map(int, input().split())\n        buildings.append((X, H))\n    \n    # Sort buildings based on their X coordinates\n    buildings.sort()\n    \n    # Calculate the slope for each pair of consecutive buildings\n    slopes = []\n    for i in range(1, N):\n        X1, H1 = buildings[i-1]\n        X2, H2 = buildings[i]\n        if H2 > H1:\n            slopes.append((H2 - H1) / (X2 - X1))\n    \n    # Find the maximum height from which it is not possible to see all buildings\n    max_height = -1\n    for i in range(N-1):\n        X1, H1 = buildings[i]\n        X2, H2 = buildings[i+1]\n        if H2 > H1:\n            # Binary search to find the maximum height\n            left, right = 0, H2 - H1\n            while left + 1e-9 < right:\n                mid = (left + right) / 2\n                pos = X1 + mid / (H2 - H1)\n                idx = bisect_left(slopes, mid / (X2 - X1))\n                if idx == 0 or slopes[idx-1] < mid / (X2 - X1):\n                    left = mid\n                else:\n                    right = mid\n            max_height = max(max_height, left)\n    \n    print(max_height)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_a",
        "code_list": [
            "def main():\n    A, B, C = map(int, input().split())\n    total_sum = A + B + C\n    if total_sum % 2 == 1 or max(A, B, C) > total_sum // 2:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_c",
        "code_list": [
            "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    N = int(input())\n    H = list(map(int, input().split()))\n    \n    max_buildings = 1\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            if H[i] == H[j]:\n                interval = j - i\n                k = j + interval\n                while k < N and H[k] == H[i]:\n                    max_buildings = max(max_buildings, j - i + 1)\n                    k += interval\n    \n    print(max_buildings)"
        ]
    },
    {
        "question_id": "abc385_d",
        "code_list": [
            "def main():\n    # Read input\n    N, M, S_x, S_y = map(int, input().split())\n    houses = [tuple(map(int, input().split())) for _ in range(N)]\n    moves = [input().split() for _ in range(M)]\n\n    # Initialize current position\n    x, y = S_x, S_y\n    visited_houses = set()\n\n    # Process each move\n    for direction, distance in moves:\n        if direction == 'U':\n            y += int(distance)\n        elif direction == 'D':\n            y -= int(distance)\n        elif direction == 'L':\n            x -= int(distance)\n        elif direction == 'R':\n            x += int(distance)\n\n        # Check if any house was passed through or arrived at\n        for house in houses:\n            if (x, y) == house:\n                visited_houses.add(house)\n\n    # Output the final position and number of distinct houses visited\n    print(x, y, len(visited_houses))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc385_e",
        "code_list": [
            "import sys\n\ndef dfs(node, parent, graph):\n    children = []\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            children.append(dfs(neighbor, node, graph))\n    if len(children) == 0:\n        return 0, 0, True\n    elif len(children) == 1:\n        x, y, is_leaf = children[0]\n        if is_leaf:\n            return 0, 0, False\n        else:\n            return x, y, True\n    else:\n        x_sum = sum(x for x, _, _ in children)\n        y_sum = sum(y for _, y, _ in children)\n        if x_sum == 0:\n            return 0, 0, False\n        else:\n            return x_sum, y_sum, True\n\ndef find_min_deletions(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    root = 0\n    for i in range(n):\n        if len(graph[i]) > 1:\n            root = i\n            break\n    \n    x, y, _ = dfs(root, -1, graph)\n    return n - (x + y + 1)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    edges = [tuple(map(int, line.split())) for line in sys.stdin.readlines()]\n    print(find_min_deletions(n, edges))"
        ]
    },
    {
        "question_id": "abc385_b",
        "code_list": [
            "def main():\n    H, W, X, Y = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    T = input().strip()\n    \n    houses_passed = set()\n    x, y = X - 1, Y - 1\n    \n    for direction in T:\n        if direction == 'U' and x > 0 and grid[x-1][y] != '#':\n            x -= 1\n        elif direction == 'D' and x < H - 1 and grid[x+1][y] != '#':\n            x += 1\n        elif direction == 'L' and y > 0 and grid[x][y-1] != '#':\n            y -= 1\n        elif direction == 'R' and y < W - 1 and grid[x][y+1] != '#':\n            y += 1\n        \n        if grid[x][y] == '@':\n            houses_passed.add((x, y))\n    \n    final_x, final_y = x + 1, y + 1\n    num_houses_passed = len(houses_passed)\n    \n    print(final_x, final_y, num_houses_passed)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc386_e",
        "code_list": [
            "from typing import List\n\ndef max_xor_subset(A: List[int], K: int) -> int:\n    N = len(A)\n    max_xor = 0\n    \n    # Create a list to store the number of times each bit pattern appears\n    bit_counts = [0] * 60\n    \n    # Count the number of times each bit pattern appears in the array\n    for num in A:\n        for bit in range(60):\n            if num & (1 << bit):\n                bit_counts[bit] += 1\n    \n    # Construct the maximum XOR subset\n    for num in A:\n        xor_val = 0\n        for bit in range(60):\n            if bit_counts[bit] > 0 and (num & (1 << bit)) == 0:\n                xor_val |= (1 << bit)\n                bit_counts[bit] -= 1\n            elif bit_counts[bit] > K // 2 and (num & (1 << bit)) != 0:\n                xor_val |= (1 << bit)\n                bit_counts[bit] -= 1\n        max_xor = max(max_xor, xor_val)\n    \n    return max_xor\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(max_xor_subset(A, K))"
        ]
    },
    {
        "question_id": "abc386_a",
        "code_list": [
            "from collections import Counter\n\ndef main():\n    A, B, C, D = map(int, input().split())\n    cards = [A, B, C, D]\n    count = Counter(cards)\n    \n    # Check if any number already has 3 cards\n    for num, freq in count.items():\n        if freq == 3:\n            # Check if we can add a card to make another number appear 2 times\n            for other_num in count:\n                if other_num != num and (count[other_num] == 1 or count[other_num] == 0):\n                    print(\"Yes\")\n                    return\n            # If no such number exists, check if we can add a new pair\n            if len(count) < 3:\n                print(\"Yes\")\n                return\n    \n    # Check if we can add a card to form a full house\n    for i in range(1, 14):\n        if i not in count:\n            if (count.most_common(1)[0][1] == 2 and count.most_common(2)[1][1] == 2) or \\\n               (count.most_common(1)[0][1] == 3 and count.most_common(2)[1][1] == 1):\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "abc386_d",
        "code_list": [
            "def can_color_grid(N, M, colored_cells):\n    # Initialize sets to keep track of the minimum and maximum black cells required for each row and column\n    min_black_rows = [N] * N\n    max_black_cols = [N] * N\n    \n    # Process the pre-colored cells\n    for x, y, color in colored_cells:\n        x -= 1\n        y -= 1\n        if color == 'B':\n            min_black_rows[x] = min(min_black_rows[x], y + 1)\n            max_black_cols[y] = min(max_black_cols[y], x + 1)\n        else:\n            min_black_rows[x] = min(min_black_rows[x], y)\n            max_black_cols[y] = min(max_black_cols[y], x)\n\n    # Check if the conditions can be satisfied\n    for x in range(N):\n        if min_black_rows[x] > N or (max_black_cols[x] < N and min_black_rows[x] > max_black_cols[x]):\n            return \"No\"\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    colored_cells = [tuple(input().split())[:2] + (input().strip(),) for _ in range(M)]\n    for i in range(M):\n        colored_cells[i] = (int(colored_cells[i][0]) - 1, int(colored_cells[i][1]) - 1, colored_cells[i][2])\n    print(can_color_grid(N, M, colored_cells))"
        ]
    },
    {
        "question_id": "abc386_c",
        "code_list": [
            "def can_transform(K, S, T):\n    if len(S) > len(T):\n        # If S is longer than T, we need deletions which are not allowed in K=1\n        return False\n    elif len(S) < len(T):\n        # If S is shorter than T, we need insertions which are not allowed in K=1\n        return False\n    else:\n        # If lengths are equal, check if we can replace characters\n        diff_count = sum(1 for s_char, t_char in zip(S, T) if s_char != t_char)\n        return diff_count <= K\n\nif __name__ == \"__main__\":\n    K = int(input().strip())\n    S = input().strip()\n    T = input().strip()\n    if can_transform(K, S, T):\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        ]
    },
    {
        "question_id": "abc386_b",
        "code_list": [
            "def min_button_presses(S):\n    # Initialize the result with the length of the string\n    result = len(S)\n    # Iterate through the string to find the minimum number of button presses\n    for i in range(len(S)):\n        # Calculate the cost of pressing the current segment as \"00\" or single digits\n        if S[i] == '0':\n            result = min(result, i + 1)\n        else:\n            result = min(result, i + 2)\n    return result\n\nif __name__ == \"__main__\":\n    S = input().strip()\n    print(min_button_presses(S))"
        ]
    },
    {
        "question_id": "abc386_f",
        "code_list": [
            "def can_transform(k, s, t):\n    m, n = len(s), len(t)\n    i, j = 0, 0\n    \n    # Find the longest common subsequence of s and t\n    lcs = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                lcs[i][j] = lcs[i - 1][j - 1] + 1\n            else:\n                lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1])\n    \n    # Calculate the number of insertions and deletions needed\n    insertions = m - lcs[m][n]\n    deletions = n - lcs[m][n]\n    \n    # Total operations needed\n    total_operations = insertions + deletions\n    \n    # Check if we can achieve the transformation within K operations\n    return total_operations <= k\n\nif __name__ == \"__main__\":\n    k = int(input().strip())\n    s = input().strip()\n    t = input().strip()\n    if can_transform(k, s, t):\n        print(\"Yes\")\n    else:\n        print(\"No\")"
        ]
    },
    {
        "question_id": "arc184_d",
        "code_list": [
            "from itertools import permutations\n\ndef main():\n    N = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    def valid_set(perm):\n        removed = set()\n        for i in perm:\n            if i in removed:\n                continue\n            xk, yk = points[i-1]\n            new_removed = set()\n            for j in perm:\n                if j == i:\n                    continue\n                xi, yi = points[j-1]\n                if (xi < xk and yi < yk) or (xi > xk and yi > yk):\n                    new_removed.add(j)\n            removed.update(new_removed)\n        return len(set(range(1, N+1)) - removed)\n    \n    count = 0\n    for perm in permutations(range(1, N+1)):\n        count += valid_set(perm)\n    \n    print(count % 998244353)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc184_c",
        "code_list": [
            "def count_mountain_folds(N, A):\n    # Initialize variables\n    max_count = 0\n    current_count = 0\n    A.append(2**100)  # Append the total number of creases to simplify the loop\n    \n    for i in range(len(A) - 1):\n        # Calculate the difference between consecutive elements\n        diff = A[i + 1] - A[i]\n        \n        # Update the count of mountain folds\n        current_count += diff // 2\n        \n        # Update the maximum count of mountain folds\n        max_count = max(max_count, current_count)\n        \n        # If the difference is even, we can have a full pair of mountain and valley folds\n        if diff % 2 == 0:\n            current_count -= diff // 2\n    \n    return max_count\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(count_mountain_folds(N, A))"
        ]
    },
    {
        "question_id": "arc184_e",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, M = map(int, input().split())\n    sequences = [list(map(int, input().split())) for _ in range(N)]\n    \n    def transform(seq):\n        return [(sum(seq[:i+1]) % 2) for i in range(M)]\n    \n    def find_min_operations(seq1, seq2):\n        for x in range(M + 1):\n            if seq1 == seq2:\n                return x\n            seq1 = transform(seq1)\n        return 0\n    \n    total_operations = 0\n    mod = 998244353\n    \n    for i in range(N):\n        transformed_sequences = defaultdict(int)\n        current_seq = sequences[i]\n        transformed_sequences[tuple(current_seq)] += 1\n        \n        for j in range(i, N):\n            current_seq = sequences[j]\n            min_ops = find_min_operations(current_seq, current_seq)\n            total_operations += min_ops * transformed_sequences[tuple(current_seq)]\n            total_operations %= mod\n            \n            for k in range(M):\n                current_seq[k] = (current_seq[k] + 1) % 2\n                transformed_sequences[tuple(current_seq)] += 1\n    \n    print(total_operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc185_c",
        "code_list": [
            "def find_triple(N, X, A):\n    # Create a dictionary to store the possible pairs that sum up to X - A[i]\n    pair_sum_dict = {}\n    \n    for j in range(1, N):\n        for k in range(j + 1, N):\n            pair_sum = A[j] + A[k]\n            if X - pair_sum in pair_sum_dict:\n                return pair_sum_dict[X - pair_sum], j, k\n        pair_sum_dict[A[j]] = (j, j)\n    \n    return -1\n\nif __name__ == \"__main__\":\n    N, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    result = find_triple(N, X, A)\n    if result == -1:\n        print(result)\n    else:\n        i, j, k = result\n        print(i, j, k)"
        ]
    },
    {
        "question_id": "arc185_e",
        "code_list": [
            "from math import gcd\nfrom collections import defaultdict\nfrom typing import List\n\ndef main():\n    def solve(N: int, A: List[int]) -> List[int]:\n        MOD = 998244353\n        prefix_gcd = [0] * (N + 1)\n        suffix_gcd = [0] * (N + 1)\n        \n        # Compute prefix GCDs\n        for i in range(N):\n            prefix_gcd[i + 1] = gcd(prefix_gcd[i], A[i])\n        \n        # Compute suffix GCDs\n        for i in range(N - 1, -1, -1):\n            suffix_gcd[i] = gcd(suffix_gcd[i + 1], A[i])\n        \n        ans = [0] * N\n        \n        # Calculate the contribution of each element\n        for i in range(N):\n            left = prefix_gcd[i]\n            right = suffix_gcd[i + 1]\n            count_left = 1\n            count_right = 1\n            \n            # Count how many times the current gcd appears to the left and right\n            for j in range(i + 1, N):\n                if prefix_gcd[j] == left:\n                    count_left += 1\n                else:\n                    break\n            for j in range(i - 1, -1, -1):\n                if suffix_gcd[j] == right:\n                    count_right += 1\n                else:\n                    break\n            \n            # Calculate the contribution\n            ans[N - 1 - i] = (ans[N - 1 - i] + (count_left * count_right * gcd(left, right)) % MOD) % MOD\n        \n        return ans\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    result = solve(N, A)\n    for r in result:\n        print(r)"
        ]
    },
    {
        "question_id": "arc185_b",
        "code_list": [
            "def can_make_non_decreasing(N, A):\n    # Check if the sequence can be made non-decreasing\n    for i in range(1, N):\n        if A[i] < A[i-1]:\n            return \"No\"\n    return \"Yes\"\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        A = list(map(int, input().split()))\n        print(can_make_non_decreasing(N, A))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc185_d",
        "code_list": [
            "from math import gcd\n\ndef main():\n    N, M = map(int, input().split())\n    MOD = 998244353\n\n    # Function to calculate modular inverse\n    def modinv(a, mod):\n        return pow(a, mod - 2, mod)\n\n    # Calculate the expected value\n    expected_value = 0\n    for i in range(1, N * M + 1):\n        if i % N == 0:\n            expected_value += 2\n        else:\n            expected_value += 1\n        expected_value %= MOD\n\n    # Simplify the fraction and get the result\n    numerator = expected_value\n    denominator = 2\n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n\n    result = (numerator * modinv(denominator, MOD)) % MOD\n    print(result)"
        ]
    },
    {
        "question_id": "arc186_a",
        "code_list": [
            "def is_possible(N, K):\n    total_elements = N * N\n    # Check if K is within the possible range\n    if K > total_elements or K % N != 0 and K % (N - 1) != 0:\n        return False\n    return True\n\ndef main():\n    N, Q = map(int, input().split())\n    results = []\n    for _ in range(Q):\n        K = int(input())\n        results.append('Yes' if is_possible(N, K) else 'No')\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_d",
        "code_list": [
            "from functools import lru_cache\n\nMOD = 998244353\n\n@lru_cache(None)\ndef count_polish_sequences(n):\n    if n == 0:\n        return 1\n    result = 0\n    for i in range(n + 1):\n        result += count_polish_sequences(i) * count_polish_sequences(n - i)\n        result %= MOD\n    return result\n\ndef main():\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    \n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    for i in range(N):\n        for j in range(A[i], -1, -1):\n            dp[j + 1] += dp[j]\n            dp[j + 1] %= MOD\n    \n    print(dp[A[-1]])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_b",
        "code_list": [
            "from typing import List\n\ndef count_valid_permutations(N: int, A: List[int]) -> int:\n    MOD = 998244353\n    dp = [1] * (N + 1)\n    \n    for i in range(1, N):\n        if A[i] == 0:\n            continue\n        for j in range(A[i], i):\n            dp[i] += dp[j]\n            dp[i] %= MOD\n    \n    return dp[N]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(count_valid_permutations(N, A))"
        ]
    },
    {
        "question_id": "arc186_e",
        "code_list": [
            "from collections import defaultdict\nfrom math import comb\n\nMOD = 998244353\n\ndef main():\n    N, M, K = map(int, input().split())\n    X = list(map(int, input().split()))\n\n    # Build the suffix array for X\n    suffixes = [(X[i:], i) for i in range(M)]\n    suffixes.sort()\n\n    # Build the LCP array\n    lcp = [0] * (M - 1)\n    prev_suffix = suffixes[0]\n    for i in range(1, M):\n        j, start = prev_suffix\n        k, start2 = suffixes[i]\n        while j < M and k < M and X[j] == X[k]:\n            j += 1\n            k += 1\n        lcp[i - 1] = j\n        prev_suffix = suffixes[i]\n\n    # Find the longest common prefix between consecutive suffixes\n    max_lcp = max(lcp)\n\n    # Calculate the number of valid sequences\n    if max_lcp >= N - M + 1:\n        print(0)\n    else:\n        ans = pow(K, N, MOD)\n        for i in range(K):\n            if i + 1 not in X:\n                continue\n            count = 0\n            for j in range(M):\n                if X[j] == i + 1:\n                    count += 1\n            if count > 1:\n                ans -= pow(K - 1, N - count + 1, MOD) * comb(count - 1, max_lcp) % MOD\n                ans %= MOD\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc186_c",
        "code_list": [
            "from typing import List\n\ndef optimal_game(N: int, M: int, V: List[int], P: List[int]) -> int:\n    # Sort boxes based on their cost per unit capacity\n    boxes = sorted([(V[i], P[i]) for i in range(N)], key=lambda x: x[1] / x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    box_types = [0] * M\n    \n    for v, p in boxes:\n        # Determine the type of ball that can be stored in this box\n        ball_type = min(range(M), key=lambda t: box_types[t])\n        \n        # Calculate the maximum number of balls of this type that can be stored in the box\n        max_balls = v - box_types[ball_type]\n        \n        # Calculate the cost to store these balls\n        cost = max_balls * (p / v)\n        \n        # Update the total cost and the number of balls stored in the box\n        total_cost += cost\n        box_types[ball_type] += max_balls\n        \n        # Check if the game can continue\n        if any(t < v for t in box_types):\n            break\n    \n    return int(total_cost)\n\ndef main():\n    T = int(input())\n    results = []\n    for _ in range(T):\n        N, M = map(int, input().split())\n        V = list(map(int, input().split()))\n        P = list(map(int, input().split()))\n        result = optimal_game(N, M, V, P)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc187_b",
        "code_list": [
            "from collections import defaultdict\n\ndef count_connected_components(n, m, b):\n    mod = 998244353\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(n):\n        if b[i] != -1:\n            dp[i + 1] = dp[i]\n        else:\n            for j in range(1, m + 1):\n                dp[i + 1] += dp[i]\n                dp[i + 1] %= mod\n    \n    result = 0\n    for i in range(n):\n        if b[i] != -1:\n            result += dp[i] * (m ** (n - i - 1))\n            result %= mod\n        else:\n            for j in range(1, m + 1):\n                result += dp[i] * (m ** (n - i - 1))\n                result %= mod\n    \n    return result\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    b = list(map(int, input().split()))\n    print(count_connected_components(n, m, b))"
        ]
    },
    {
        "question_id": "arc188_c",
        "code_list": [
            "from typing import List\n\ndef find_confused_villagers(N: int, M: int, testimonies: List[List[int]]) -> str:\n    def check(confused):\n        honest = [not c for c in confused]\n        liar = [c for c in confused]\n        \n        # Check if the current configuration satisfies all testimonies\n        for A, B, C in testimonies:\n            if confused[A-1] == 0:  # A is confused honest\n                if C == 0:  # A says B is honest, but A is lying\n                    if honest[B-1]: return False\n            elif confused[A-1] == 1:  # A is confused liar\n                if C == 0:  # A says B is honest, but A is telling the truth\n                    if not honest[B-1]: return False\n            else:  # A is not confused\n                if C == 0:  # A says B is honest, and A is telling the truth\n                    if not honest[B-1]: return False\n                else:  # A says B is a liar, and A is telling the truth\n                    if honest[B-1]: return False\n        \n        return True\n    \n    # Try all possible configurations of confused villagers\n    for i in range(2**N):\n        confused = [bool((i >> j) & 1) for j in range(N)]\n        if check(confused):\n            return ''.join('1' if c else '0' for c in confused)\n    \n    return '-1'\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    testimonies = [list(map(int, input().split())) for _ in range(M)]\n    print(find_confused_villagers(N, M, testimonies))"
        ]
    },
    {
        "question_id": "arc188_b",
        "code_list": [
            "def can_color_all_points(T):\n    def can_color(N, K):\n        # If K is 1 or N-1, Alice can always color all points black\n        if K == 1 or K == N - 1:\n            return \"Yes\"\n        \n        # If N is even and K is half of N, Alice can always color all points black\n        if N % 2 == 0 and K == N // 2:\n            return \"Yes\"\n        \n        # If N is odd and K is (N+1)/2, Alice can always color all points black\n        if N % 2 != 0 and K == (N + 1) // 2:\n            return \"Yes\"\n        \n        # For other cases, it's impossible to color all points black\n        return \"No\"\n\n    results = []\n    for _ in range(T):\n        N, K = map(int, input().split())\n        results.append(can_color(N, K))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    can_color_all_points()"
        ]
    },
    {
        "question_id": "arc188_d",
        "code_list": [
            "from itertools import permutations\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    # Create a set of unique elements from A and B excluding -1\n    unique_elements = set(A + [x for x in B if x != -1])\n    N_unique = len(unique_elements)\n\n    # If the number of unique elements is less than 2N, return 0\n    if N_unique < 2 * N:\n        print(0)\n        return\n\n    # Calculate the number of valid permutations\n    def count_valid_permutations():\n        count = 0\n        for perm in permutations(range(1, N_unique + 1)):\n            a = list(perm[:N])\n            b = list(perm[N:])\n            if a == A and all(x == y or y == -1 for x, y in zip(b, B)):\n                count += 1\n        return count\n\n    result = count_valid_permutations() % 998244353\n    print(result)"
        ]
    },
    {
        "question_id": "arc188_a",
        "code_list": [
            "from itertools import product\n\nMOD = 998244353\n\ndef is_good_string(s):\n    stack = []\n    for char in s:\n        if char == 'A':\n            if len(stack) >= 2 and stack[-1] == 'B' and stack[-2] == 'C':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == 'B':\n            if len(stack) >= 2 and stack[-1] == 'C' and stack[-2] == 'A':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char == 'C':\n            if len(stack) >= 2 and stack[-1] == 'A' and stack[-2] == 'B':\n                stack.pop()\n                stack.pop()\n            else:\n                stack.append(char)\n        else:\n            stack.append(char)\n    return len(stack) == 0\n\ndef count_good_substrings(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_good_string(s[i:j]):\n                count += 1\n    return count\n\ndef solve(n, k, s):\n    dp = [[[0] * (k + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n    for i in range(n):\n        for j in range(i + 1):\n            for m in range(k + 1):\n                if dp[i][j][m] > 0:\n                    for c in ['A', 'B', 'C', '?']:\n                        new_s = s[:i] + c + s[i:]\n                        new_j = j + (c != '?')\n                        new_m = m + (is_good_string(new_s[i:i+new_j]) if c != '?' else 0)\n                        if new_m <= k:\n                            dp[i + 1][new_j][new_m] = (dp[i + 1][new_j][new_m] + dp[i][j][m]) % MOD\n    return sum(dp[n][j][k] for j in range(n + 1)) % MOD\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    s = input().strip()\n    print(solve(n, k, s))"
        ]
    },
    {
        "question_id": "arc189_a",
        "code_list": [
            "from math import comb\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    # Calculate the number of 0s and 1s\n    count_0 = A.count(0)\n    count_1 = A.count(1)\n\n    # If the counts of 0s and 1s are not equal, it's impossible to achieve the target configuration\n    if count_0 != count_1:\n        print(0)\n        return\n\n    # Calculate the number of ways to arrange the 0s and 1s\n    # We need to choose positions for 0s out of N positions\n    mod = 998244353\n    ways = pow(2, N // 2, mod) * comb(N // 2, count_0, exact=True) % mod\n\n    print(ways)"
        ]
    },
    {
        "question_id": "arc189_c",
        "code_list": [
            "from collections import defaultdict\n\ndef main():\n    N, X = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n\n    # Create inverse permutations\n    inv_P = [0] * (N + 1)\n    inv_Q = [0] * (N + 1)\n    for i in range(1, N + 1):\n        inv_P[P[i - 1]] = i\n        inv_Q[Q[i - 1]] = i\n\n    # Initialize counts\n    red_count = [0] * (N + 1)\n    blue_count = [0] * (N + 1)\n\n    # Count initial red and blue balls in each box\n    for i in range(N):\n        red_count[i + 1] += A[i]\n        blue_count[i + 1] += B[i]\n\n    # Process each box\n    operations = 0\n    for i in range(1, N + 1):\n        # If the current box is the target box, skip it\n        if i == X:\n            continue\n\n        # If there are no balls in the current box, continue\n        if red_count[i] == 0 and blue_count[i] == 0:\n            continue\n\n        # Determine the target box for red and blue balls\n        target_red = P[i - 1]\n        target_blue = Q[i - 1]\n\n        # If the target box for red and blue balls is the same, we need one operation\n        if target_red == target_blue:\n            red_count[target_red] += red_count[i]\n            blue_count[target_red] += blue_count[i]\n            operations += 1\n        else:\n            # If the target boxes are different, we need two operations\n            red_count[target_red] += red_count[i]\n            blue_count[target_blue] += blue_count[i]\n            operations += 2\n\n    # Check if all boxes except the target box are empty\n    for i in range(1, N + 1):\n        if i != X and (red_count[i] > 0 or blue_count[i] > 0):\n            print(-1)\n            return\n\n    print(operations)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc189_d",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    def process_slimes(n, slimes):\n        stack = []\n        result = [0] * n\n        for i, size in enumerate(slimes):\n            while stack and slimes[stack[-1]] < size:\n                mid = stack.pop()\n                if stack:\n                    left = stack[-1]\n                    result[left] += size - slimes[mid]\n                else:\n                    result[i] += size - slimes[mid]\n            stack.append(i)\n        \n        return result\n\n    n = data[0]\n    slimes = data[1:]\n    results = process_slimes(n, slimes)\n    \n    print(*results)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_id": "arc189_b",
        "code_list": [
            "def main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    x = data[1:]\n\n    # Calculate the median of the first three elements\n    median = x[(n-1)//2]\n\n    # Calculate the sum of the coordinates after minimizing it\n    min_sum = sum(x[i] - median for i in range(n))\n\n    print(min_sum)"
        ]
    },
    {
        "question_id": "3610",
        "code_list": [
            "from collections import Counter\nfrom heapq import nlargest\n\nclass Solution:\n    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:\n        result = []\n        for i in range(len(nums) - k + 1):\n            subarray = nums[i:i + k]\n            freq_counter = Counter(subarray)\n            top_x_elements = nlargest(x, freq_counter.items(), key=lambda item: (item[1], item[0]))\n            top_x_values = [item[0] for item in top_x_elements]\n            filtered_subarray = [num for num in subarray if num in top_x_values]\n            result.append(sum(filtered_subarray))\n        return result"
        ]
    },
    {
        "question_id": "3588",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countWinningSequences(self, s: str) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(i, prev):\n            if i == len(s):\n                return 1\n            count = 0\n            for next_move in 'FEW':\n                if next_move != prev:\n                    if (s[i] == 'F' and next_move == 'E') or \\\n                       (s[i] == 'W' and next_move == 'F') or \\\n                       (s[i] == 'E' and next_move == 'W'):\n                        count += dp(i + 1, next_move)\n            return count % MOD\n        \n        return dp(0, '')"
        ]
    },
    {
        "question_id": "3566",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def stringSequence(self, target: str) -> List[str]:\n        result = [\"a\"]\n        for char in target:\n            if char == 'a':\n                result.append(\"aa\")\n            else:\n                steps = ord(char) - ord('a')\n                while steps > 0:\n                    result.append(result[-1][:-1] + chr(ord(result[-1][-1]) + 1))\n                    steps -= 1\n                result.append(result[-1] + char)\n        return result"
        ]
    },
    {
        "question_id": "3502",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def numberOfSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        result = 0\n        \n        for start in range(n):\n            counter = Counter()\n            for end in range(start, n):\n                counter[s[end]] += 1\n                if all(count >= k for count in counter.values()):\n                    result += 1\n                    \n        return result"
        ]
    },
    {
        "question_id": "3607",
        "code_list": [
            "from math import sqrt\nfrom typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        def find_greatest_proper_divisor(n):\n            for i in range(int(sqrt(n)), 1, -1):\n                if n % i == 0:\n                    return n // i\n            return 1\n        \n        operations = 0\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                current = nums[i]\n                while current > nums[i + 1]:\n                    current //= find_greatest_proper_divisor(current)\n                    operations += 1\n                if current < nums[i + 1]:\n                    return -1\n        return operations"
        ]
    },
    {
        "question_id": "3603",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def findAnswer(self, parent: List[int], s: str) -> List[bool]:\n        # Build the tree using adjacency list representation\n        tree = defaultdict(list)\n        for i in range(1, len(parent)):\n            tree[parent[i]].append(i)\n        \n        # Function to check if a string is a palindrome\n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        # Recursive DFS function\n        def dfs(x):\n            nonlocal dfsStr\n            for y in sorted(tree[x]):\n                dfs(y)\n            dfsStr += s[x]\n        \n        # Main logic to determine if each subtree forms a palindrome\n        answer = []\n        for i in range(len(parent)):\n            dfsStr = \"\"\n            dfs(i)\n            answer.append(is_palindrome(dfsStr))\n        \n        return answer"
        ]
    },
    {
        "question_id": "3593",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\nclass Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0] * nums[0]\n        \n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        \n        def max_factor_score(nums):\n            max_score = 0\n            for i in range(n):\n                current_gcd = nums[i]\n                current_lcm = nums[i]\n                for j in range(i + 1, n):\n                    current_gcd = gcd(current_gcd, nums[j])\n                    current_lcm = lcm(current_lcm, nums[j])\n                max_score = max(max_score, current_gcd * current_lcm)\n            return max_score\n        \n        initial_max_score = max_factor_score(nums)\n        \n        for num in nums:\n            new_nums = [n for n in nums if n != num]\n            max_score_without_num = max_factor_score(new_nums)\n            initial_max_score = max(initial_max_score, max_score_without_num)\n        \n        return initial_max_score"
        ]
    },
    {
        "question_id": "3629",
        "code_list": [
            "class Solution:\n    def lengthAfterTransformations(self, s: str, t: int) -> int:\n        MOD = 10**9 + 7\n        \n        def transform(c):\n            if c == 'z':\n                return 'ab'\n            return chr(ord(c) + 1)\n        \n        initial_length = len(s)\n        transformed_length = 0\n        \n        for char in s:\n            if char == 'z':\n                transformed_length += 2\n            else:\n                transformed_length += 1\n        \n        for _ in range(t):\n            if transformed_length > 0 and transformed_length < 26:\n                transformed_length = (transformed_length - 1) * 2 % MOD\n            else:\n                transformed_length = (initial_length - 1) * 2 % MOD\n        \n        return transformed_length % MOD"
        ]
    },
    {
        "question_id": "3608",
        "code_list": [
            "from typing import List\nfrom math import gcd\nfrom itertools import combinations\n\nclass Solution:\n    def subsequencePairCount(self, nums: List[int]) -> int:\n        MOD = 10**9 + 7\n        \n        def count_subsequences_with_gcd(g: int) -> int:\n            count = 0\n            for comb in combinations(nums, 1):\n                if gcd(comb[0], g) == g:\n                    count += 1\n            return count\n        \n        total_pairs = 0\n        unique_gcds = set()\n        for i in range(1, 201):\n            for j in range(i, 201):\n                if gcd(i, j) not in unique_gcds:\n                    unique_gcds.add(gcd(i, j))\n                    count_i = count_subsequences_with_gcd(i)\n                    count_j = count_subsequences_with_gcd(j)\n                    total_pairs += count_i * count_j\n        \n        return total_pairs % MOD"
        ]
    },
    {
        "question_id": "3636",
        "code_list": [
            "class Solution:\n    def isBalanced(self, num: str) -> bool:\n        even_sum = sum(int(num[i]) for i in range(0, len(num), 2))\n        odd_sum = sum(int(num[i]) for i in range(1, len(num), 2))\n        return even_sum == odd_sum"
        ]
    },
    {
        "question_id": "3627",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def minTimeToReach(self, moveTime: List[List[int]]) -> int:\n        n, m = len(moveTime), len(moveTime[0])\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n        visited = set()\n        pq = [(moveTime[0][0], 0, 0)]  # (time, row, col)\n        \n        while pq:\n            time, row, col = heapq.heappop(pq)\n            if (row, col) == (n - 1, m - 1):\n                return time\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n            \n            for dr, dc in directions:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited:\n                    new_time = max(time, moveTime[new_row][new_col]) + 1\n                    heapq.heappush(pq, (new_time, new_row, new_col))\n        \n        return -1"
        ]
    },
    {
        "question_id": "3637",
        "code_list": [
            "from math import factorial\n\nclass Solution:\n    def countBalancedPermutations(self, num: str) -> int:\n        from collections import Counter\n        \n        velunexorai = num\n        count = Counter(num)\n        even_sum = sum(count[str(i)] for i in range(1, 10, 2))\n        odd_sum = sum(count[str(i)] for i in range(2, 10, 2))\n        \n        if even_sum != odd_sum:\n            return 0\n        \n        total_length = len(num)\n        even_length = total_length // 2\n        odd_length = total_length - even_length\n        \n        even_factorial = factorial(even_length)\n        odd_factorial = factorial(odd_length)\n        \n        result = factorial(total_length) // (even_factorial * odd_factorial)\n        \n        for digit, freq in count.items():\n            if freq % 2 == 1:\n                result //= 2\n        \n        return result % (10**9 + 7)"
        ]
    },
    {
        "question_id": "3612",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:\n        for i in range(len(nums) - k * 2):\n            if all(nums[i + j] < nums[i + j + 1] for j in range(k)) and \\\n               all(nums[i + k + j] < nums[i + k + j + 1] for j in range(k)):\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3646",
        "code_list": [
            "from typing import List\nfrom collections import defaultdict\nfrom functools import lru_cache\n\nclass Solution:\n    def sumOfGoodSubsequences(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        dp = defaultdict(lambda: [0, 0])\n        nums_set = set(nums)\n        for num in sorted(nums):\n            if num - 1 in nums_set:\n                dp[num][0] += dp[num - 1][0] + dp[num - 1][1]\n            if num + 1 in nums_set:\n                dp[num][1] += dp[num + 1][0] + dp[num + 1][1]\n            dp[num][0] += num\n            dp[num][1] += num\n        return (sum(dp[num][0] + dp[num][1] for num in nums_set) + len(nums_set)) % mod"
        ]
    },
    {
        "question_id": "3631",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def countKReducibleNumbers(self, s: str, k: int) -> int:\n        MOD = 10**9 + 7\n        \n        def count_set_bits(n: int) -> int:\n            return bin(n).count('1')\n        \n        def is_k_reducible(x: int, k: int) -> bool:\n            while x > 1 and k > 0:\n                x = count_set_bits(x)\n                k -= 1\n            return x == 1\n        \n        n = int(s, 2)\n        count = 0\n        \n        for i in range(1, n):\n            if is_k_reducible(i, k):\n                count = (count + 1) % MOD\n        \n        return count"
        ]
    },
    {
        "question_id": "3616",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countValidSelections(self, nums: List[int]) -> int:\n        n = len(nums)\n        zeros = [i for i, num in enumerate(nums) if num == 0]\n        count = 0\n        \n        for start in zeros:\n            direction = 1\n            steps = [0] * n\n            curr = start\n            while True:\n                if curr < 0 or curr >= n:\n                    break\n                if nums[curr] == 0:\n                    curr += direction\n                elif nums[curr] > 0:\n                    nums[curr] -= 1\n                    if direction == 1:\n                        direction = -1\n                    else:\n                        direction = 1\n                    curr += direction\n                steps[curr] += 1\n                if all(num == 0 for num in nums):\n                    count += 1\n                    break\n            nums[start:] = [num + steps[i] for i, num in enumerate(nums[start:])]\n        \n        return count"
        ]
    },
    {
        "question_id": "3639",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def isZeroArray(self, nums: List[int], queries: List[List[int]]) -> bool:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        \n        for l, r in queries:\n            prefix_sum[l] += 1\n            prefix_sum[r + 1] -= 1\n        \n        for i in range(n):\n            prefix_sum[i + 1] += prefix_sum[i]\n            if prefix_sum[i + 1] > nums[i]:\n                return False\n            nums[i] -= prefix_sum[i + 1]\n        \n        return all(num == 0 for num in nums)"
        ]
    },
    {
        "question_id": "3658",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minDifference(self, nums: List[int]) -> int:\n        # Filter out the -1 positions and sort the numbers\n        gaps = sorted((i for i, num in enumerate(nums) if num != -1))\n        n = len(gaps)\n        min_diff = float('inf')\n        \n        # If there are less than 4 non-missing values, we can fill all -1s\n        if n < 4:\n            return max(gaps) - min(gaps) if n else 0\n        \n        # Calculate the maximum difference after replacing 2 missing values\n        for i in range(n - 3):\n            max_diff = max(gaps[i], gaps[n-1] - gaps[i+2], gaps[n-2] - gaps[i+1], gaps[n-3] - gaps[i])\n            min_diff = min(min_diff, max_diff)\n        \n        return min_diff"
        ]
    },
    {
        "question_id": "3644",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumSumSubarray(self, nums: List[int], l: int, r: int) -> int:\n        n = len(nums)\n        min_sum = float('inf')\n        for length in range(l, r + 1):\n            current_sum = 0\n            for i in range(n - length + 1):\n                current_sum = sum(nums[i:i + length])\n                if current_sum > 0:\n                    min_sum = min(min_sum, current_sum)\n                    break  # Found the first valid subarray, no need to check further for this length\n        return min_sum if min_sum != float('inf') else -1"
        ]
    },
    {
        "question_id": "3654",
        "code_list": [
            "import heapq\n\nclass Solution:\n    def minArraySum(self, nums: List[int], k: int, op1: int, op2: int) -> int:\n        # Convert nums to a max heap by negating the values\n        nums = [-num for num in nums]\n        heapq.heapify(nums)\n        ops1, ops2 = op1, op2\n        \n        while ops1 > 0 or ops2 > 0:\n            if nums[0] < -k and ops2 > 0:\n                # Perform Operation 2\n                heapq.heappush(nums, heapq.heappop(nums) - k)\n                ops2 -= 1\n            elif nums[0] > -1:\n                # Perform Operation 1\n                heapq.heappush(nums, (heapq.heappop(nums) + 1) // 2)\n                ops1 -= 1\n            else:\n                break\n        \n        return -sum(nums)"
        ]
    },
    {
        "question_id": "3675",
        "code_list": [
            "from typing import List\nimport heapq\n\nclass Solution:\n    def maximizeSumOfWeights(self, edges: List[List[int]], k: int) -> int:\n        n = len(edges) + 1\n        graph = [[] for _ in range(n)]\n        \n        # Build the graph\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        \n        # Priority queue to store edges to be removed\n        pq = []\n        visited = [False] * n\n        \n        # Start DFS from node 0\n        def dfs(node):\n            visited[node] = True\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n                    # Push the negative weight to simulate max heap\n                    heapq.heappush(pq, (-weight, node, neighbor))\n        \n        dfs(0)\n        \n        total_weight = 0\n        while pq and len(graph[0]) > k:\n            weight, u, v = heapq.heappop(pq)\n            weight = -weight\n            # Remove the edge with the smallest weight that exceeds the limit\n            if len(graph[u]) > k and len(graph[v]) > k:\n                graph[u].remove((v, weight))\n                graph[v].remove((u, weight))\n                total_weight += weight\n                visited = [False] * n\n                dfs(0)\n        \n        return total_weight"
        ]
    },
    {
        "question_id": "3605",
        "code_list": [
            "class Solution:\n    def minBitwiseArray(self, nums: List[int]) -> List[int]:\n        ans = []\n        for num in nums:\n            found = False\n            for candidate in range(num):\n                if candidate | (candidate + 1) == num:\n                    ans.append(candidate)\n                    found = True\n                    break\n            if not found:\n                ans.append(-1)\n        return ans"
        ]
    },
    {
        "question_id": "3487",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:\n        i, j, n, m = 0, 0, len(source), len(pattern)\n        count = 0\n        \n        while i < n and j < m:\n            if i in targetIndices:\n                count += 1\n                i += 1\n                continue\n            if source[i] == pattern[j]:\n                j += 1\n            i += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3604",
        "code_list": [
            "from math import comb\n\nclass Solution:\n    def numberOfWays(self, n: int, x: int, y: int) -> int:\n        MOD = 10**9 + 7\n        \n        def power(a, b):\n            result = 1\n            while b > 0:\n                if b % 2 == 1:\n                    result = (result * a) % MOD\n                a = (a * a) % MOD\n                b //= 2\n            return result\n        \n        total_ways = 0\n        for i in range(1, n + 1):\n            ways_to_assign_stages = comb(n, i) * power(x, i)\n            remaining_performers = n - i\n            ways_to_score_bands = power(y, i)\n            total_ways += ways_to_assign_stages * ways_to_score_bands * power(power(x, remaining_performers), y)\n        \n        return total_ways % MOD"
        ]
    },
    {
        "question_id": "3617",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def possibleStringCount(self, word: str) -> int:\n        count = Counter(word)\n        n = len(word)\n        dp = [1] + [0] * n\n        \n        for i in range(1, n + 1):\n            if count[word[i-1]] == 1:\n                dp[i] = dp[i-1]\n            else:\n                for j in range(i - 1, -1, -1):\n                    if word[j] == word[i-1]:\n                        break\n                dp[i] = dp[j] + dp[j-1] if j > 0 else 1\n        \n        return dp[n]"
        ]
    },
    {
        "question_id": "3587",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:\n        # Initialize DP table\n        dp = [[0 for _ in range(n)] for _ in range(k + 1)]\n        \n        # Fill DP table\n        for day in range(1, k + 1):\n            for curr_city in range(n):\n                # Option 1: Stay in the current city\n                stay_points = stayScore[day - 1][curr_city]\n                max_points_stay = stay_points + dp[day - 1][curr_city]\n                \n                # Option 2: Move to another city\n                move_points = 0\n                for dest_city in range(n):\n                    if dest_city != curr_city:\n                        move_points = travelScore[curr_city][dest_city] + dp[day - 1][dest_city]\n                        max_points_stay = max(max_points_stay, move_points)\n                \n                # Choose the maximum points between staying and moving\n                dp[day][curr_city] = max_points_stay\n        \n        # Return the maximum points among all cities on the last day\n        return max(dp[k])"
        ]
    },
    {
        "question_id": "3626",
        "code_list": [
            "class Solution:\n    def smallestNumber(self, n: int, t: int) -> int:\n        def digit_product(num):\n            product = 1\n            while num > 0:\n                product *= num % 10\n                num //= 10\n            return product\n        \n        num = n\n        while True:\n            if digit_product(num) % t == 0:\n                return num\n            num += 1"
        ]
    },
    {
        "question_id": "3622",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:\n        nums.sort()\n        n = len(nums)\n        left, right, total = 0, 0, 0\n        max_freq = 1\n        \n        while right < n:\n            total += nums[right]\n            while nums[right] * (right - left + 1) > total + k:\n                total -= nums[left]\n                left += 1\n            max_freq = max(max_freq, right - left + 1)\n            right += 1\n        \n        return max_freq"
        ]
    },
    {
        "question_id": "3625",
        "code_list": [
            "class Solution:\n    def canAliceWin(self, n: int) -> bool:\n        # If n is less than 10, Alice cannot win as she needs at least 10 stones to make her first move.\n        if n < 10:\n            return False\n        # If n is 10 or greater, Alice can always win by removing 10 stones on her first turn,\n        # leaving a number of stones that will force Bob into a losing position.\n        return True"
        ]
    },
    {
        "question_id": "3591",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:\n        distance = 0\n        for char_s, char_t in zip(s, t):\n            index_s, index_t = ord(char_s) - ord('a'), ord(char_t) - ord('a')\n            # Calculate the cost to go from s to t directly\n            direct_cost = abs(index_s - index_t)\n            # Calculate the cost to go from s to 'a' or 'z' and then to t\n            cost_to_a = (25 - direct_cost) if index_s > index_t else direct_cost + 25\n            cost_to_z = (25 - direct_cost) if index_s < index_t else direct_cost + 25\n            # Choose the minimum cost\n            min_cost = min(direct_cost * nextCost[index_s] + previousCost[index_t],\n                           cost_to_a * nextCost[index_s] + previousCost[0],\n                           cost_to_z * previousCost[index_s] + nextCost[25])\n            distance += min_cost\n        return distance"
        ]
    },
    {
        "question_id": "3647",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:\n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        \n        query_count = len(queries)\n        dp = [0] * (query_count + 1)\n        dp[query_count] = prefix_sum[-1]\n        \n        for i in range(query_count - 1, -1, -1):\n            l, r = queries[i]\n            total = prefix_sum[r + 1] - prefix_sum[l]\n            dp[i] = min(total, dp[i + 1])\n        \n        max_removal = 0\n        for i in range(query_count):\n            if dp[i + 1] >= dp[i]:\n                max_removal += 1\n            else:\n                break\n        \n        if dp[0] == 0:\n            return max_removal\n        else:\n            return -1"
        ]
    },
    {
        "question_id": "3648",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:\n        n = len(fruits)\n        dp = [[[0] * n for _ in range(n)] for _ in range(3)]\n        \n        # Initialize the starting positions\n        dp[0][0][0] = fruits[0][0]\n        dp[1][0][n-1] = fruits[0][n-1]\n        dp[2][n-1][0] = fruits[n-1][0]\n        \n        # Directions for each child\n        directions = {\n            0: [(1, 1), (1, 0), (0, 1)],  # Child starting from (0, 0)\n            1: [(1, -1), (1, 0), (0, 1)], # Child starting from (0, n-1)\n            2: [(-1, 1), (0, 1), (1, 1)]  # Child starting from (n-1, 0)\n        }\n        \n        # Fill the DP table\n        for step in range(1, n):\n            for child in range(3):\n                for i in range(n):\n                    for j in range(n):\n                        if dp[child][i][j] > 0:\n                            for di, dj in directions[child]:\n                                ni, nj = i + di, j + dj\n                                if 0 <= ni < n and 0 <= nj < n:\n                                    dp[(child + 1) % 3][ni][nj] = max(dp[(child + 1) % 3][ni][nj], dp[child][i][j] + fruits[ni][nj])\n        \n        # The result is the maximum value in the last step for any child\n        return max(max(row) for row in dp[0][-1]) + max(max(row) for row in dp[1][-1]) + max(max(row) for row in dp[2][-1])"
        ]
    },
    {
        "question_id": "3676",
        "code_list": [
            "class Solution:\n    def smallestNumber(self, n: int) -> int:\n        x = n\n        set_bit = n & -n\n        while set_bit:\n            x |= set_bit\n            set_bit >>= 1\n        return x"
        ]
    },
    {
        "question_id": "3594",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def getLargestOutlier(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        sum_val = nums[0] + nums[1]\n        outlier = max(nums[2], nums[-1])\n        for i in range(2, n):\n            if nums[i] != sum_val and nums[i] != nums[i-1]:\n                outlier = max(outlier, nums[i])\n        return outlier"
        ]
    },
    {
        "question_id": "3651",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def constructTransformedArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        result = [0] * n\n        \n        for i in range(n):\n            if nums[i] > 0:\n                new_index = (i + nums[i]) % n\n                result[i] = nums[new_index]\n            elif nums[i] < 0:\n                new_index = (i + nums[i] + n) % n\n                result[i] = nums[new_index]\n            else:\n                result[i] = nums[i]\n        \n        return result"
        ]
    },
    {
        "question_id": "3681",
        "code_list": [
            "from itertools import combinations\n\nclass Solution:\n    def maxRectangleArea(self, points: List[List[int]]) -> int:\n        point_set = {(x, y) for x, y in points}\n        max_area = -1\n        \n        for (x1, y1), (x2, y2) in combinations(points, 2):\n            if (x1, y2) in point_set and (x2, y1) in point_set:\n                width = abs(x2 - x1)\n                height = abs(y2 - y1)\n                area = width * height\n                max_area = max(max_area, area)\n        \n        return max_area"
        ]
    },
    {
        "question_id": "3653",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maxSubarraySum(self, nums: List[int], k: int) -> int:\n        prefix_sum = 0\n        max_sum = float('-inf')\n        remainder_map = {0: 0}\n        current_sum = 0\n        \n        for i, num in enumerate(nums):\n            current_sum += num\n            remainder = current_sum % k\n            \n            if remainder in remainder_map:\n                subarray_length = (i + 1 - remainder_map[remainder]) % k\n                if subarray_length == 0 or subarray_length == k:\n                    max_sum = max(max_sum, current_sum)\n            else:\n                remainder_map[remainder] = i + 1\n            \n            max_sum = max(max_sum, current_sum - remainder_map.get(remainder, current_sum))\n        \n        return max_sum"
        ]
    },
    {
        "question_id": "3621",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        operations = 0\n        while any(num > k for num in nums):\n            valid_h = max(num for num in nums if num < k)\n            operations += 1\n            nums = [valid_h if num > valid_h else num for num in nums]\n        if min(nums) != k:\n            return -1\n        return operations"
        ]
    },
    {
        "question_id": "3649",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def findMinimumTime(self, strength: List[int], K: int) -> int:\n        n = len(strength)\n        dp = [float('inf')] * (1 << n)\n        dp[0] = 0\n        \n        for mask in range(1 << n):\n            time = 0\n            x = 1\n            energy = 0\n            for i in range(n):\n                if mask & (1 << i):\n                    while energy < strength[i]:\n                        time += 1\n                        energy += x\n                        if time >= dp[mask ^ (1 << i)]:\n                            break\n                    energy = 0\n                    x += K\n            dp[mask] = min(dp[mask], time)\n        \n        return dp[(1 << n) - 1]"
        ]
    },
    {
        "question_id": "3655",
        "code_list": [
            "from math import inf\n\nclass Solution:\n    def minOperations(self, n: int, m: int) -> int:\n        if n == m:\n            return 0\n        \n        def is_prime(num):\n            if num < 2:\n                return False\n            for i in range(2, int(num**0.5) + 1):\n                if num % i == 0:\n                    return False\n            return True\n        \n        if is_prime(m):\n            return -1\n        \n        digits_n = [int(d) for d in str(n)]\n        digits_m = [int(d) for d in str(m)]\n        cost = 0\n        \n        for i in range(len(digits_n)):\n            if digits_n[i] == digits_m[i]:\n                continue\n            elif digits_n[i] > digits_m[i]:\n                while digits_n[i] > digits_m[i]:\n                    if digits_n[i] != 9:\n                        digits_n[i] -= 1\n                        cost += 1\n                    else:\n                        j = i - 1\n                        while j >= 0 and digits_n[j] == 9:\n                            digits_n[j] = 0\n                            cost += 9\n                            j -= 1\n                        if j >= 0:\n                            digits_n[j] += 1\n                            cost += 1\n            else:\n                while digits_n[i] < digits_m[i]:\n                    if digits_n[i] != 0:\n                        digits_n[i] += 1\n                        cost += 1\n                    else:\n                        j = i - 1\n                        while j >= 0 and digits_n[j] == 0:\n                            digits_n[j] = 9\n                            cost += 9\n                            j -= 1\n                        if j >= 0:\n                            digits_n[j] -= 1\n                            cost += 1\n            if is_prime(int(''.join(map(str, digits_n)))):\n                return -1\n        \n        return cost + int(''.join(map(str, digits_n)))"
        ]
    },
    {
        "question_id": "3680",
        "code_list": [
            "from math import gcd\nfrom typing import List\n\nclass Solution:\n    def countComponents(self, nums: List[int], threshold: int) -> int:\n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        \n        parent = list(range(len(nums)))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootY] = rootX\n        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if lcm(nums[i], nums[j]) <= threshold:\n                    union(i, j)\n        \n        components = set()\n        for i in range(len(nums)):\n            components.add(find(i))\n        \n        return len(components)"
        ]
    },
    {
        "question_id": "3632",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def buttonWithLongestTime(self, events: List[List[int]]) -> int:\n        max_time, result_button = 0, events[0][0]\n        prev_time = events[0][1]\n        \n        for index, time in events:\n            time_taken = time - prev_time\n            if time_taken > max_time or (time_taken == max_time and index < result_button):\n                max_time = time_taken\n                result_button = index\n            prev_time = time\n        \n        return result_button"
        ]
    },
    {
        "question_id": "3613",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def maxAmount(self, initialCurrency: str, pairs1: List[List[str]], rates1: List[float], pairs2: List[List[str]], rates2: List[float]) -> float:\n        # Build the graph for day 1\n        graph1 = defaultdict(dict)\n        for pair, rate in zip(pairs1, rates1):\n            start, end = pair\n            graph1[start][end] = rate\n        \n        # Build the graph for day 2\n        graph2 = defaultdict(dict)\n        for pair, rate in zip(pairs2, rates2):\n            start, end = pair\n            graph2[start][end] = rate\n        \n        # Function to find the maximum amount using DFS\n        def dfs(graph, start, end, rate, visited):\n            if start not in graph or end not in graph[start]:\n                return 1.0\n            if (start, end) in visited:\n                return visited[(start, end)]\n            \n            max_rate = 1.0 / graph[start][end]\n            for neighbor in graph[start]:\n                if neighbor == end:\n                    continue\n                new_rate = dfs(graph, neighbor, end, rate, visited) * graph[start][neighbor]\n                max_rate = max(max_rate, new_rate)\n            \n            visited[(start, end)] = max_rate\n            return max_rate\n        \n        # Calculate the maximum amount for day 1\n        max_amount_day1 = dfs(graph1, initialCurrency, initialCurrency, 1.0, {})\n        \n        # Calculate the maximum amount for day 2\n        max_amount_day2 = dfs(graph2, initialCurrency, initialCurrency, 1.0, {})\n        \n        # Return the product of the two maximum amounts\n        return max_amount_day1 * max_amount_day2"
        ]
    },
    {
        "question_id": "3686",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def beautifulSplits(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        count = 0\n        for i in range(1, n - 1):\n            left_sum = prefix_sum[i]\n            right_sum = prefix_sum[n] - prefix_sum[i + 1]\n            mid_sum = prefix_sum[i + 1] - prefix_sum[0]\n            if (left_sum == mid_sum or mid_sum == right_sum):\n                count += 1\n        \n        return count"
        ]
    },
    {
        "question_id": "3638",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def makeStringGood(self, s: str) -> int:\n        char_counts = Counter(s)\n        min_operations = 0\n        \n        for count in char_counts.values():\n            while count > 1:\n                found_match = False\n                for i in range(1, 26):\n                    if count - i in char_counts:\n                        found_match = True\n                        min_operations += abs(count - (count - i))\n                        count -= i\n                        break\n                if not found_match:\n                    min_operations += count - 1\n                    count = 1\n        return min_operations"
        ]
    },
    {
        "question_id": "3656",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        operations = 0\n        while len(nums) >= 3:\n            for i in range(3):\n                if i < len(nums):\n                    nums.pop(0)\n            operations += 1\n        return operations"
        ]
    },
    {
        "question_id": "3620",
        "code_list": [
            "from collections import Counter\n\nclass Solution:\n    def maxDistinctElements(self, nums: List[int], k: int) -> int:\n        count = Counter(nums)\n        min_count = min(count.values())\n        \n        # If all numbers are the same, we can make at most (len(nums) + 1) distinct elements\n        if min_count == len(nums):\n            return len(nums) + 1\n        \n        # Count how many groups of numbers can be made equal within the range [-k, k]\n        groups = sum(1 for v in count.values() if v - min_count > k)\n        \n        # The maximum possible number of distinct elements is the original number of distinct elements plus the number of groups\n        return len(count) + groups"
        ]
    },
    {
        "question_id": "3690",
        "code_list": [
            "class Solution:\n    def minLength(self, s: str, numOps: int) -> int:\n        n = len(s)\n        max_gap = 0\n        \n        # Find the maximum gap between two same characters\n        for i in range(1, n):\n            if s[i] == s[i - 1]:\n                max_gap = max(max_gap, i - (i - 1))\n        \n        # If the entire string is already uniform, no operations are needed\n        if max_gap == 0:\n            return 1\n        \n        # Calculate the minimum length of the longest substring\n        min_length = n\n        for i in range(n):\n            left = i\n            right = i + 1\n            while right < n and (s[left] != s[right] or (right - left - 1) > numOps * 2):\n                right += 1\n            \n            if right - left - 1 <= numOps * 2:\n                min_length = min(min_length, right - left)\n        \n        return n - min_length"
        ]
    },
    {
        "question_id": "3683",
        "code_list": [
            "from itertools import combinations\n\nclass Solution:\n    def answerString(self, word: str, numFriends: int) -> str:\n        n = len(word)\n        if numFriends == 1:\n            return word\n        \n        # Generate all possible splits\n        splits = []\n        for i in range(1, n):\n            for combo in combinations(range(1, n), i):\n                parts = [word[:combo[0]]]\n                for j in range(len(combo) - 1):\n                    parts.append(word[combo[j]:combo[j + 1]])\n                parts.append(word[combo[-1]:])\n                if len(parts) == numFriends:\n                    splits.append(parts)\n        \n        # Find the lexicographically largest string from the box\n        max_string = \"\"\n        for split in splits:\n            box = set()\n            for perm in permutations(split):\n                box.add(\"\".join(perm))\n            max_string = max(max_string, max(box))\n        \n        return max_string"
        ]
    },
    {
        "question_id": "3699",
        "code_list": [
            "from collections import defaultdict\n\nclass Solution:\n    def numberOfSubsequences(self, nums: List[int]) -> int:\n        count_map = defaultdict(int)\n        result = 0\n        \n        for i in range(1, len(nums) - 1):\n            for j in range(i + 2, len(nums)):\n                product = nums[i] * nums[j]\n                if product in count_map:\n                    count_map[product] += 1\n                else:\n                    count_map[product] = 1\n        \n        for k in range(1, len(nums) - 2):\n            if nums[k] in count_map:\n                result += count_map[nums[k]]\n        \n        return result"
        ]
    },
    {
        "question_id": "3682",
        "code_list": [
            "from functools import lru_cache\n\nclass Solution:\n    def countGoodArrays(self, n: int, m: int, k: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(length, prev, consecutive):\n            if length == n:\n                return 1 if consecutive == k else 0\n            count = 0\n            for num in range(1, m + 1):\n                if num == prev:\n                    count += dp(length + 1, num, consecutive)\n                else:\n                    count += dp(length + 1, num, consecutive + 1)\n            return count % MOD\n        \n        return dp(1, 0, 0)"
        ]
    },
    {
        "question_id": "3685",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        n = len(nums)\n        for i in range(n - 2):\n            if nums[i] + nums[i + 2] == nums[i + 1] / 2:\n                count += 1\n        return count"
        ]
    },
    {
        "question_id": "3659",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def countPathsWithXorValue(self, grid: List[List[int]], k: int) -> int:\n        m, n = len(grid), len(grid[0])\n        MOD = 10**9 + 7\n        \n        # Initialize dp table\n        dp = [[[0 for _ in range(k)] for _ in range(n)] for _ in range(m)]\n        dp[0][0][grid[0][0]] = 1\n        \n        # Fill dp table\n        for i in range(m):\n            for j in range(n):\n                for val in range(k):\n                    if i > 0:\n                        dp[i][j][(grid[i][j] ^ val)] += dp[i-1][j][val]\n                        dp[i][j][(grid[i][j] ^ val)] %= MOD\n                    if j > 0:\n                        dp[i][j][(grid[i][j] ^ val)] += dp[i][j-1][val]\n                        dp[i][j][(grid[i][j] ^ val)] %= MOD\n        \n        return dp[m-1][n-1][k]"
        ]
    },
    {
        "question_id": "3657",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def checkValidCuts(self, n: int, rectangles: List[List[int]]) -> bool:\n        # Extract unique x and y boundaries from rectangles\n        x_boundaries = set()\n        y_boundaries = set()\n        for start_x, start_y, end_x, end_y in rectangles:\n            x_boundaries.update([start_x, end_x])\n            y_boundaries.update([start_y, end_y])\n        \n        # Sort boundaries to facilitate cut evaluation\n        x_boundaries = sorted(x_boundaries)\n        y_boundaries = sorted(y_boundaries)\n        \n        # Check for possible horizontal cuts\n        horizontal_cuts = []\n        for i in range(len(y_boundaries) - 1):\n            if y_boundaries[i + 1] - y_boundaries[i] > 1:\n                horizontal_cuts.append((y_boundaries[i] + y_boundaries[i + 1]) // 2)\n        \n        # Check for possible vertical cuts\n        vertical_cuts = []\n        for i in range(len(x_boundaries) - 1):\n            if x_boundaries[i + 1] - x_boundaries[i] > 1:\n                vertical_cuts.append((x_boundaries[i] + x_boundaries[i + 1]) // 2)\n        \n        # Function to check if a set of cuts satisfies the condition\n        def valid_cuts(cuts):\n            if len(cuts) < 2:\n                return False\n            sections = []\n            prev = None\n            for rect in rectangles:\n                x1, y1, x2, y2 = rect\n                if prev is None:\n                    prev = (y1, y2)\n                    continue\n                if prev[1] < y1:\n                    sections.append(prev)\n                    prev = (y1, y2)\n                else:\n                    prev = (min(prev[0], y1), max(prev[1], y2))\n            sections.append(prev)\n            for section in sections:\n                if all(section[0] >= cut or section[1] <= cut for cut in cuts):\n                    return False\n            return True\n        \n        # Check both horizontal and vertical cuts\n        return valid_cuts(horizontal_cuts) or valid_cuts(vertical_cuts)"
        ]
    },
    {
        "question_id": "3700",
        "code_list": [
            "from collections import Counter\nfrom math import comb\n\nclass Solution:\n    def subsequencesWithMiddleMode(self, nums: List[int]) -> int:\n        mod = 10**9 + 7\n        count = Counter(nums)\n        max_count = max(count.values())\n        result = 0\n        \n        for num, freq in count.items():\n            if freq == max_count:\n                # Calculate the number of ways to choose the remaining 2 elements from the rest\n                remaining_count = sum(v for k, v in count.items() if k != num)\n                ways_to_choose_remaining = comb(remaining_count, 2)\n                # Calculate the number of ways to arrange the chosen elements\n                result += ways_to_choose_remaining * (freq ** 2)\n        \n        return result % mod"
        ]
    },
    {
        "question_id": "3702",
        "code_list": [
            "from math import gcd\nfrom functools import reduce\n\nclass Solution:\n    def maxLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_len = 0\n        \n        def lcm(a, b):\n            return a * b // gcd(a, b)\n        \n        def lcm_of_list(lst):\n            return reduce(lcm, lst)\n        \n        for i in range(n):\n            for j in range(i, n):\n                subarray = nums[i:j+1]\n                prod = 1\n                for num in subarray:\n                    prod *= num\n                sub_lcm = lcm_of_list(subarray)\n                sub_gcd = reduce(gcd, subarray)\n                if prod == sub_lcm * sub_gcd:\n                    max_len = max(max_len, j - i + 1)\n        \n        return max_len"
        ]
    },
    {
        "question_id": "3634",
        "code_list": [
            "class Solution:\n    def calculateScore(self, s: str) -> int:\n        mirror_map = {chr(i): chr(219 - i) for i in range(ord('a'), ord('z') + 1)}\n        marked = set()\n        score = 0\n        \n        for i, char in enumerate(s):\n            if i in marked:\n                continue\n            mirror_char = mirror_map[char]\n            j = i - 1\n            while j >= 0:\n                if j in marked:\n                    j -= 1\n                    continue\n                if s[j] == mirror_char:\n                    marked.add(i)\n                    marked.add(j)\n                    score += i - j\n                    break\n                j -= 1\n        \n        return score"
        ]
    },
    {
        "question_id": "3715",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def maximumCoins(self, coins: List[List[int]], k: int) -> int:\n        n = len(coins)\n        prefix_sum = [0]\n        for l, r, c in coins:\n            prefix_sum.append(prefix_sum[-1] + c)\n        \n        dp = [0] * (n + 1)\n        result = 0\n        \n        for i in range(n):\n            l, r, c = coins[i]\n            if r - l + 1 >= k:\n                dp[i + 1] = max(dp[i + 1], dp[i])\n                result = max(result, dp[i + 1] + prefix_sum[min(r + 1, n)] - prefix_sum[max(l, 1)])\n            else:\n                for j in range(i - 1, -1, -1):\n                    l_j, r_j, c_j = coins[j]\n                    if r_j < l:\n                        break\n                    if r_j - l_j + 1 >= k:\n                        dp[i + 1] = max(dp[i + 1], dp[j] + prefix_sum[min(r + 1, n)] - prefix_sum[max(l, 1)] - prefix_sum[min(r_j + 1, n)] + prefix_sum[max(l_j, 1)])\n        \n        return result"
        ]
    },
    {
        "question_id": "3562",
        "code_list": [
            "from typing import List\nfrom functools import lru_cache\n\nclass Solution:\n    def maximumWeight(self, intervals: List[List[int]]) -> List[int]:\n        # Sort intervals based on starting point, and then by weight in descending order\n        intervals.sort(key=lambda x: (x[0], -x[2]))\n        \n        @lru_cache(None)\n        def dp(index, mask):\n            if index >= len(intervals):\n                return 0, []\n            max_score = 0\n            best_indices = []\n            for i in range(index, len(intervals)):\n                if mask & (1 << i):\n                    continue\n                if intervals[i][0] > intervals[index][1]:  # Check if intervals overlap\n                    new_mask = mask | (1 << i)\n                    score, indices = dp(i + 1, new_mask)\n                    if score + intervals[i][2] > max_score:\n                        max_score = score + intervals[i][2]\n                        best_indices = [i] + indices\n            return max_score, best_indices\n        \n        max_score, best_indices = dp(0, 0)\n        return sorted(best_indices[:4])"
        ]
    },
    {
        "question_id": "3684",
        "code_list": [
            "class Solution:\n    def hasMatch(self, s: str, p: str) -> bool:\n        star_index = p.find('*')\n        if star_index == -1:\n            return s == p\n        \n        prefix = p[:star_index]\n        suffix = p[star_index + 1:]\n        \n        for i in range(len(s) - len(suffix) + 1):\n            if s[i:i+len(prefix)] == prefix and (suffix == '' or s[i+len(prefix):i+len(prefix)+len(suffix)] == suffix):\n                return True\n        return False"
        ]
    },
    {
        "question_id": "3716",
        "code_list": [
            "from typing import List\n\nclass Solution:\n    def longestSubsequence(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        \n        # dp[i][j] represents the length of the longest subsequence ending at index i with the last difference j\n        dp = [[0] * 301 for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][0] = 1  # Base case: any single number is a valid subsequence\n        \n        max_length = 1\n        for i in range(1, n):\n            for j in range(i):\n                diff = abs(nums[i] - nums[j])\n                dp[i][diff] = max(dp[i][diff], dp[j][diff] + 1)\n                max_length = max(max_length, dp[i][diff])\n        \n        return max_length"
        ]
    },
    {
        "question_id": "3688",
        "code_list": [
            "from typing import List\nfrom collections import Counter\n\nclass Solution:\n    def maxSubarraySum(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        num_count = Counter(nums)\n        max_sum = float('-inf')\n        zero_count = prefix_sum[-1]\n        \n        for num, count in num_count.items():\n            if count == 1:\n                max_sum = max(max_sum, prefix_sum[-1])\n            else:\n                left_sum = prefix_sum[nums.index(num)] - prefix_sum[0]\n                right_sum = prefix_sum[-1] - prefix_sum[nums.index(num) + 1]\n                max_sum = max(max_sum, max(left_sum, right_sum))\n        \n        return max_sum"
        ]
    }
]